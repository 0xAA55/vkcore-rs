
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]

use std::{
	collections::BTreeSet,
	ffi::{c_void, CStr},
	fmt::{self, Debug, Formatter},
	mem::transmute,
	ptr::{null, null_mut},
};

pub fn vk_make_version(major: u32, minor: u32, patch: u32) -> u32 {
	(major << 22) | (minor << 12) | patch
}
pub fn vk_make_api_version(variant: u32, major: u32, minor: u32, patch: u32) -> u32 {
	(variant << 29) | (major << 22) | (minor << 12) | patch
}
pub fn vk_make_video_std_version(major: u32, minor: u32, patch: u32) -> u32 {
	(major << 22) | (minor << 12) | patch
}

pub const VK_USE_64_BIT_PTR_DEFINES: u32 = 0;
pub const VK_NULL_HANDLE: u32 = 0;
pub const VK_API_VERSION_1_0: u32 = 0x400000;
pub const VK_HEADER_VERSION: u32 = 324;
pub const VK_HEADER_VERSION_COMPLETE: u32 = 0x404144;
pub const VK_ATTACHMENT_UNUSED: u32 = !0u32;
pub const VK_FALSE: u32 = 0u32;
pub const VK_LOD_CLAMP_NONE: f32 = 1000.0f32;
pub const VK_QUEUE_FAMILY_IGNORED: u32 = !0u32;
pub const VK_REMAINING_ARRAY_LAYERS: u32 = !0u32;
pub const VK_REMAINING_MIP_LEVELS: u32 = !0u32;
pub const VK_SUBPASS_EXTERNAL: u32 = !0u32;
pub const VK_TRUE: u32 = 1u32;
pub const VK_WHOLE_SIZE: u64 = !0u64;
pub const VK_MAX_MEMORY_TYPES: u32 = 32u32;
pub const VK_MAX_PHYSICAL_DEVICE_NAME_SIZE: u32 = 256u32;
pub const VK_UUID_SIZE: u32 = 16u32;
pub const VK_MAX_EXTENSION_NAME_SIZE: u32 = 256u32;
pub const VK_MAX_DESCRIPTION_SIZE: u32 = 256u32;
pub const VK_MAX_MEMORY_HEAPS: u32 = 16u32;
pub type int8_t = i8;
pub type int16_t = i16;
pub type int32_t = i32;
pub type int64_t = i64;
pub type uint8_t = u8;
pub type uint16_t = u16;
pub type uint32_t = u32;
pub type uint64_t = u64;
pub type size_t = usize;
pub type char = i8;
pub type short = i16;
pub type int = i32;
pub type unsigned = u32;
pub type long = i64;
pub type float = f32;
pub type double = f64;
pub type VkBool32 = u32;
pub type VkDeviceAddress = u64;
pub type VkDeviceSize = u64;
pub type VkFlags = u32;
pub type VkSampleMask = u32;
pub type VkAccessFlags = VkFlags;
pub type VkImageAspectFlags = VkFlags;
pub type VkFormatFeatureFlags = VkFlags;
pub type VkImageCreateFlags = VkFlags;
pub type VkSampleCountFlags = VkFlags;
pub type VkImageUsageFlags = VkFlags;
pub type VkInstanceCreateFlags = VkFlags;
pub type VkMemoryHeapFlags = VkFlags;
pub type VkMemoryPropertyFlags = VkFlags;
pub type VkQueueFlags = VkFlags;
pub type VkDeviceCreateFlags = VkFlags;
pub type VkDeviceQueueCreateFlags = VkFlags;
pub type VkPipelineStageFlags = VkFlags;
pub type VkMemoryMapFlags = VkFlags;
pub type VkSparseMemoryBindFlags = VkFlags;
pub type VkSparseImageFormatFlags = VkFlags;
pub type VkFenceCreateFlags = VkFlags;
pub type VkSemaphoreCreateFlags = VkFlags;
pub type VkEventCreateFlags = VkFlags;
pub type VkQueryPipelineStatisticFlags = VkFlags;
pub type VkQueryPoolCreateFlags = VkFlags;
pub type VkQueryResultFlags = VkFlags;
pub type VkBufferCreateFlags = VkFlags;
pub type VkBufferUsageFlags = VkFlags;
pub type VkBufferViewCreateFlags = VkFlags;
pub type VkImageViewCreateFlags = VkFlags;
pub type VkShaderModuleCreateFlags = VkFlags;
pub type VkPipelineCacheCreateFlags = VkFlags;
pub type VkColorComponentFlags = VkFlags;
pub type VkPipelineCreateFlags = VkFlags;
pub type VkPipelineShaderStageCreateFlags = VkFlags;
pub type VkCullModeFlags = VkFlags;
pub type VkPipelineVertexInputStateCreateFlags = VkFlags;
pub type VkPipelineInputAssemblyStateCreateFlags = VkFlags;
pub type VkPipelineTessellationStateCreateFlags = VkFlags;
pub type VkPipelineViewportStateCreateFlags = VkFlags;
pub type VkPipelineRasterizationStateCreateFlags = VkFlags;
pub type VkPipelineMultisampleStateCreateFlags = VkFlags;
pub type VkPipelineDepthStencilStateCreateFlags = VkFlags;
pub type VkPipelineColorBlendStateCreateFlags = VkFlags;
pub type VkPipelineDynamicStateCreateFlags = VkFlags;
pub type VkPipelineLayoutCreateFlags = VkFlags;
pub type VkShaderStageFlags = VkFlags;
pub type VkSamplerCreateFlags = VkFlags;
pub type VkDescriptorPoolCreateFlags = VkFlags;
pub type VkDescriptorPoolResetFlags = VkFlags;
pub type VkDescriptorSetLayoutCreateFlags = VkFlags;
pub type VkAttachmentDescriptionFlags = VkFlags;
pub type VkDependencyFlags = VkFlags;
pub type VkFramebufferCreateFlags = VkFlags;
pub type VkRenderPassCreateFlags = VkFlags;
pub type VkSubpassDescriptionFlags = VkFlags;
pub type VkCommandPoolCreateFlags = VkFlags;
pub type VkCommandPoolResetFlags = VkFlags;
pub type VkCommandBufferUsageFlags = VkFlags;
pub type VkQueryControlFlags = VkFlags;
pub type VkCommandBufferResetFlags = VkFlags;
pub type VkStencilFaceFlags = VkFlags;
// Define handle `VkInstance`
#[derive(Debug, Clone, Copy)] pub struct VkInstance_T {}
pub type VkInstance = *const VkInstance_T;
// Define handle `VkPhysicalDevice`
#[derive(Debug, Clone, Copy)] pub struct VkPhysicalDevice_T {}
pub type VkPhysicalDevice = *const VkPhysicalDevice_T;
// Define handle `VkDevice`
#[derive(Debug, Clone, Copy)] pub struct VkDevice_T {}
pub type VkDevice = *const VkDevice_T;
// Define handle `VkQueue`
#[derive(Debug, Clone, Copy)] pub struct VkQueue_T {}
pub type VkQueue = *const VkQueue_T;
// Define handle `VkCommandBuffer`
#[derive(Debug, Clone, Copy)] pub struct VkCommandBuffer_T {}
pub type VkCommandBuffer = *const VkCommandBuffer_T;
// Define non-dispatchable handle `VkBuffer`
#[cfg(target_pointer_width = "32")] pub type VkBuffer = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkBuffer_T {}
#[cfg(target_pointer_width = "64")] pub type VkBuffer = *const VkBuffer_T;
// Define non-dispatchable handle `VkImage`
#[cfg(target_pointer_width = "32")] pub type VkImage = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkImage_T {}
#[cfg(target_pointer_width = "64")] pub type VkImage = *const VkImage_T;
// Define non-dispatchable handle `VkSemaphore`
#[cfg(target_pointer_width = "32")] pub type VkSemaphore = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkSemaphore_T {}
#[cfg(target_pointer_width = "64")] pub type VkSemaphore = *const VkSemaphore_T;
// Define non-dispatchable handle `VkFence`
#[cfg(target_pointer_width = "32")] pub type VkFence = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkFence_T {}
#[cfg(target_pointer_width = "64")] pub type VkFence = *const VkFence_T;
// Define non-dispatchable handle `VkDeviceMemory`
#[cfg(target_pointer_width = "32")] pub type VkDeviceMemory = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkDeviceMemory_T {}
#[cfg(target_pointer_width = "64")] pub type VkDeviceMemory = *const VkDeviceMemory_T;
// Define non-dispatchable handle `VkEvent`
#[cfg(target_pointer_width = "32")] pub type VkEvent = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkEvent_T {}
#[cfg(target_pointer_width = "64")] pub type VkEvent = *const VkEvent_T;
// Define non-dispatchable handle `VkQueryPool`
#[cfg(target_pointer_width = "32")] pub type VkQueryPool = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkQueryPool_T {}
#[cfg(target_pointer_width = "64")] pub type VkQueryPool = *const VkQueryPool_T;
// Define non-dispatchable handle `VkBufferView`
#[cfg(target_pointer_width = "32")] pub type VkBufferView = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkBufferView_T {}
#[cfg(target_pointer_width = "64")] pub type VkBufferView = *const VkBufferView_T;
// Define non-dispatchable handle `VkImageView`
#[cfg(target_pointer_width = "32")] pub type VkImageView = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkImageView_T {}
#[cfg(target_pointer_width = "64")] pub type VkImageView = *const VkImageView_T;
// Define non-dispatchable handle `VkShaderModule`
#[cfg(target_pointer_width = "32")] pub type VkShaderModule = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkShaderModule_T {}
#[cfg(target_pointer_width = "64")] pub type VkShaderModule = *const VkShaderModule_T;
// Define non-dispatchable handle `VkPipelineCache`
#[cfg(target_pointer_width = "32")] pub type VkPipelineCache = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkPipelineCache_T {}
#[cfg(target_pointer_width = "64")] pub type VkPipelineCache = *const VkPipelineCache_T;
// Define non-dispatchable handle `VkPipelineLayout`
#[cfg(target_pointer_width = "32")] pub type VkPipelineLayout = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkPipelineLayout_T {}
#[cfg(target_pointer_width = "64")] pub type VkPipelineLayout = *const VkPipelineLayout_T;
// Define non-dispatchable handle `VkPipeline`
#[cfg(target_pointer_width = "32")] pub type VkPipeline = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkPipeline_T {}
#[cfg(target_pointer_width = "64")] pub type VkPipeline = *const VkPipeline_T;
// Define non-dispatchable handle `VkRenderPass`
#[cfg(target_pointer_width = "32")] pub type VkRenderPass = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkRenderPass_T {}
#[cfg(target_pointer_width = "64")] pub type VkRenderPass = *const VkRenderPass_T;
// Define non-dispatchable handle `VkDescriptorSetLayout`
#[cfg(target_pointer_width = "32")] pub type VkDescriptorSetLayout = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkDescriptorSetLayout_T {}
#[cfg(target_pointer_width = "64")] pub type VkDescriptorSetLayout = *const VkDescriptorSetLayout_T;
// Define non-dispatchable handle `VkSampler`
#[cfg(target_pointer_width = "32")] pub type VkSampler = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkSampler_T {}
#[cfg(target_pointer_width = "64")] pub type VkSampler = *const VkSampler_T;
// Define non-dispatchable handle `VkDescriptorSet`
#[cfg(target_pointer_width = "32")] pub type VkDescriptorSet = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkDescriptorSet_T {}
#[cfg(target_pointer_width = "64")] pub type VkDescriptorSet = *const VkDescriptorSet_T;
// Define non-dispatchable handle `VkDescriptorPool`
#[cfg(target_pointer_width = "32")] pub type VkDescriptorPool = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkDescriptorPool_T {}
#[cfg(target_pointer_width = "64")] pub type VkDescriptorPool = *const VkDescriptorPool_T;
// Define non-dispatchable handle `VkFramebuffer`
#[cfg(target_pointer_width = "32")] pub type VkFramebuffer = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkFramebuffer_T {}
#[cfg(target_pointer_width = "64")] pub type VkFramebuffer = *const VkFramebuffer_T;
// Define non-dispatchable handle `VkCommandPool`
#[cfg(target_pointer_width = "32")] pub type VkCommandPool = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkCommandPool_T {}
#[cfg(target_pointer_width = "64")] pub type VkCommandPool = *const VkCommandPool_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkResult {
	VK_SUCCESS = 0,
	VK_NOT_READY = 1,
	VK_TIMEOUT = 2,
	VK_EVENT_SET = 3,
	VK_EVENT_RESET = 4,
	VK_INCOMPLETE = 5,
	VK_ERROR_OUT_OF_HOST_MEMORY = -1,
	VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
	VK_ERROR_INITIALIZATION_FAILED = -3,
	VK_ERROR_DEVICE_LOST = -4,
	VK_ERROR_MEMORY_MAP_FAILED = -5,
	VK_ERROR_LAYER_NOT_PRESENT = -6,
	VK_ERROR_EXTENSION_NOT_PRESENT = -7,
	VK_ERROR_FEATURE_NOT_PRESENT = -8,
	VK_ERROR_INCOMPATIBLE_DRIVER = -9,
	VK_ERROR_TOO_MANY_OBJECTS = -10,
	VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
	VK_ERROR_FRAGMENTED_POOL = -12,
	VK_ERROR_UNKNOWN = -13,
	VK_ERROR_VALIDATION_FAILED = -1000011001,
	VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
	VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
	VK_ERROR_FRAGMENTATION = -1000161000,
	VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
	VK_PIPELINE_COMPILE_REQUIRED = 1000297000,
	VK_ERROR_NOT_PERMITTED = -1000174001,
	VK_ERROR_SURFACE_LOST_KHR = -1000000000,
	VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
	VK_SUBOPTIMAL_KHR = 1000001003,
	VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
	VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
	VK_ERROR_INVALID_SHADER_NV = -1000012000,
	VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR = -1000023000,
	VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR = -1000023001,
	VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR = -1000023002,
	VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR = -1000023003,
	VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR = -1000023004,
	VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = -1000023005,
	VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
	VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
	VK_THREAD_IDLE_KHR = 1000268000,
	VK_THREAD_DONE_KHR = 1000268001,
	VK_OPERATION_DEFERRED_KHR = 1000268002,
	VK_OPERATION_NOT_DEFERRED_KHR = 1000268003,
	VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR = -1000299000,
	VK_ERROR_COMPRESSION_EXHAUSTED_EXT = -1000338000,
	VK_INCOMPATIBLE_SHADER_BINARY_EXT = 1000482000,
	VK_PIPELINE_BINARY_MISSING_KHR = 1000483000,
	VK_ERROR_NOT_ENOUGH_SPACE_KHR = -1000483000,
	VK_RESULT_MAX_ENUM = 0x7fffffff,
}
impl VkResult {
	pub const VK_ERROR_VALIDATION_FAILED_EXT: VkResult = VkResult::VK_ERROR_VALIDATION_FAILED;
	pub const VK_ERROR_OUT_OF_POOL_MEMORY_KHR: VkResult = VkResult::VK_ERROR_OUT_OF_POOL_MEMORY;
	pub const VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR: VkResult = VkResult::VK_ERROR_INVALID_EXTERNAL_HANDLE;
	pub const VK_ERROR_FRAGMENTATION_EXT: VkResult = VkResult::VK_ERROR_FRAGMENTATION;
	pub const VK_ERROR_NOT_PERMITTED_EXT: VkResult = VkResult::VK_ERROR_NOT_PERMITTED;
	pub const VK_ERROR_NOT_PERMITTED_KHR: VkResult = VkResult::VK_ERROR_NOT_PERMITTED;
	pub const VK_ERROR_INVALID_DEVICE_ADDRESS_EXT: VkResult = VkResult::VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
	pub const VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR: VkResult = VkResult::VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
	pub const VK_PIPELINE_COMPILE_REQUIRED_EXT: VkResult = VkResult::VK_PIPELINE_COMPILE_REQUIRED;
	pub const VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT: VkResult = VkResult::VK_PIPELINE_COMPILE_REQUIRED;
	pub const VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT: VkResult = VkResult::VK_INCOMPATIBLE_SHADER_BINARY_EXT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkStructureType {
	VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
	VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
	VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
	VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
	VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
	VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
	VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
	VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
	VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
	VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
	VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
	VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
	VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
	VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
	VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
	VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
	VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
	VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
	VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
	VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
	VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
	VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
	VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
	VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
	VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
	VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
	VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
	VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
	VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
	VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
	VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
	VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
	VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
	VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
	VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
	VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
	VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
	VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
	VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
	VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 49,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 50,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 51,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 52,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000,
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 1000109000,
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 1000109001,
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 1000109002,
	VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 1000109003,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 1000109004,
	VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 1000109005,
	VK_STRUCTURE_TYPE_SUBPASS_END_INFO = 1000109006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000,
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000,
	VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000,
	VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002,
	VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000,
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001,
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001,
	VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 1000207002,
	VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003,
	VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 1000207004,
	VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 1000207005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000,
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001,
	VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002,
	VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES = 53,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES = 54,
	VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO = 1000192000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES = 1000215000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES = 1000245000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES = 1000276000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES = 1000295000,
	VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO = 1000295001,
	VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO = 1000295002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES = 1000297000,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 = 1000314000,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 = 1000314001,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 = 1000314002,
	VK_STRUCTURE_TYPE_DEPENDENCY_INFO = 1000314003,
	VK_STRUCTURE_TYPE_SUBMIT_INFO_2 = 1000314004,
	VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO = 1000314005,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO = 1000314006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES = 1000314007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES = 1000325000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES = 1000335000,
	VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 = 1000337000,
	VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 = 1000337001,
	VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 = 1000337002,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 = 1000337003,
	VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 = 1000337004,
	VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 = 1000337005,
	VK_STRUCTURE_TYPE_BUFFER_COPY_2 = 1000337006,
	VK_STRUCTURE_TYPE_IMAGE_COPY_2 = 1000337007,
	VK_STRUCTURE_TYPE_IMAGE_BLIT_2 = 1000337008,
	VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 = 1000337009,
	VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 = 1000337010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES = 1000225000,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO = 1000225001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES = 1000225002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES = 1000138000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES = 1000138001,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK = 1000138002,
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO = 1000138003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES = 1000066000,
	VK_STRUCTURE_TYPE_RENDERING_INFO = 1000044000,
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO = 1000044001,
	VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO = 1000044002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES = 1000044003,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO = 1000044004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES = 1000280000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES = 1000280001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES = 1000281001,
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 = 1000360000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES = 1000413000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES = 1000413001,
	VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS = 1000413002,
	VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS = 1000413003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES = 55,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES = 56,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO = 1000174000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES = 1000388000,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES = 1000388001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES = 1000416000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES = 1000528000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES = 1000544000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES = 1000259000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO = 1000259001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES = 1000259002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES = 1000525000,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO = 1000190001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES = 1000190002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES = 1000265000,
	VK_STRUCTURE_TYPE_MEMORY_MAP_INFO = 1000271000,
	VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO = 1000271001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES = 1000470000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES = 1000470001,
	VK_STRUCTURE_TYPE_RENDERING_AREA_INFO = 1000470003,
	VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO = 1000470004,
	VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2 = 1000338002,
	VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2 = 1000338003,
	VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO = 1000470005,
	VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO = 1000470006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES = 1000080000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES = 1000232000,
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO = 1000232001,
	VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO = 1000232002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES = 1000545000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES = 1000545001,
	VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS = 1000545002,
	VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO = 1000545003,
	VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO = 1000545004,
	VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO = 1000545005,
	VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO = 1000545006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES = 1000466000,
	VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO = 1000068000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES = 1000068001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES = 1000068002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES = 1000270000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES = 1000270001,
	VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY = 1000270002,
	VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY = 1000270003,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO = 1000270004,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO = 1000270005,
	VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO = 1000270006,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO = 1000270007,
	VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE = 1000270008,
	VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY = 1000270009,
	VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
	VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
	VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
	VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
	VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
	VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
	VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
	VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
	VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
	VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
	VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
	VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
	VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
	VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
	VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
	VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
	VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR = 1000023000,
	VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR = 1000023001,
	VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR = 1000023002,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR = 1000023003,
	VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR = 1000023004,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR = 1000023005,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000023006,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR = 1000023007,
	VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR = 1000023008,
	VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR = 1000023009,
	VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR = 1000023010,
	VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR = 1000023011,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR = 1000023012,
	VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR = 1000023013,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR = 1000023014,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR = 1000023015,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR = 1000023016,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR = 1000024000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR = 1000024001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR = 1000024002,
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
	VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX = 1000029000,
	VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX = 1000029001,
	VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX = 1000029002,
	VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX = 1000029004,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR = 1000038000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000038001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000038002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR = 1000038003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR = 1000038004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR = 1000038005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR = 1000038006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR = 1000038007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR = 1000038008,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR = 1000038009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR = 1000038010,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR = 1000038011,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR = 1000038012,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000038013,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR = 1000039000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000039001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000039002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR = 1000039003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR = 1000039004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR = 1000039005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR = 1000039006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR = 1000039007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR = 1000039009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR = 1000039010,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR = 1000039011,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR = 1000039012,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR = 1000039013,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000039014,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR = 1000040000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR = 1000040001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR = 1000040003,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000040004,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000040005,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR = 1000040006,
	VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
	VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
	VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
	VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
	VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
	VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
	VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
	VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
	VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
	VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
	VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
	VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
	VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
	VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
	VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
	VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
	VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
	VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
	VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
	VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
	VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG = 1000110000,
	VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
	VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
	VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
	VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
	VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
	VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
	VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
	VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003,
	VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004,
	VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 1000116005,
	VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
	VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
	VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000,
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
	VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003,
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
	VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
	VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
	VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
	VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
	VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID = 1000129006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX = 1000134000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX = 1000134001,
	VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX = 1000134002,
	VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX = 1000134003,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX = 1000134004,
	VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR = 1000141000,
	VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
	VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
	VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
	VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 1000150007,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 1000150000,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 1000150002,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 1000150003,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 1000150004,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 1000150005,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR = 1000150006,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR = 1000150009,
	VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR = 1000150010,
	VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 1000150011,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 1000150012,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR = 1000150013,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR = 1000150014,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 1000150017,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR = 1000150020,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR = 1000347000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR = 1000347001,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015,
	VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR = 1000348013,
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001,
	VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
	VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
	VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
	VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR = 1000163000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR = 1000163001,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
	VK_STRUCTURE_TYPE_GEOMETRY_NV = 1000165003,
	VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004,
	VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005,
	VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
	VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
	VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
	VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
	VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000,
	VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR = 1000187000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000187001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000187002,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR = 1000187003,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR = 1000187004,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR = 1000187005,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
	VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
	VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008,
	VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
	VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000,
	VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
	VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002,
	VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003,
	VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004,
	VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
	VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
	VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
	VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
	VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
	VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
	VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007,
	VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000,
	VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004,
	VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 1000234000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR = 1000235000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
	VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
	VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
	VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR = 1000248000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
	VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000,
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT = 1000254000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT = 1000254001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT = 1000254002,
	VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
	VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
	VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000,
	VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT = 1000272000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT = 1000272001,
	VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT = 1000272002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 1000273000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 1000277000,
	VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 1000277001,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 1000277002,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV = 1000277003,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV = 1000277004,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV = 1000277005,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV = 1000277006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV = 1000277007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 1000278000,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 1000278001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 1000282000,
	VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 1000282001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT = 1000283000,
	VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT = 1000283001,
	VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT = 1000283002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 1000284000,
	VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT = 1000284001,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT = 1000284002,
	VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002,
	VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV = 1000292000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV = 1000292001,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV = 1000292002,
	VK_STRUCTURE_TYPE_PRESENT_ID_KHR = 1000294000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR = 1000294001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR = 1000299000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR = 1000299001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR = 1000299002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR = 1000299003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR = 1000299004,
	VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR = 1000299005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR = 1000299007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299008,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR = 1000299009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000299010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 1000300000,
	VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 1000300001,
	VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV = 1000307000,
	VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV = 1000307001,
	VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV = 1000307002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV = 1000307003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV = 1000307004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM = 1000309000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM = 1000309001,
	VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM = 1000309002,
	VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM = 1000309003,
	VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM = 1000309004,
	VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM = 1000309005,
	VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV = 1000310000,
	VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT = 1000311000,
	VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT = 1000311001,
	VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT = 1000311002,
	VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT = 1000311003,
	VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT = 1000311004,
	VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT = 1000311005,
	VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT = 1000311006,
	VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT = 1000311007,
	VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT = 1000311008,
	VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT = 1000311009,
	VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311010,
	VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311011,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT = 1000316000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT = 1000316001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT = 1000316002,
	VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT = 1000316003,
	VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT = 1000316004,
	VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316005,
	VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316006,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316007,
	VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316008,
	VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT = 1000316010,
	VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT = 1000316011,
	VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT = 1000316012,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT = 1000320000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT = 1000320001,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT = 1000320002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD = 1000321000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR = 1000203000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR = 1000322000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR = 1000323000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 1000326000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 1000326001,
	VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 1000326002,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV = 1000327000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV = 1000327001,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV = 1000327002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT = 1000328000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT = 1000328001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 1000330000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001,
	VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM = 1000333000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 1000336000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT = 1000338000,
	VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT = 1000338001,
	VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT = 1000338004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT = 1000339000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT = 1000341000,
	VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT = 1000341001,
	VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT = 1000341002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT = 1000344000,
	VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 1000352000,
	VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 1000352001,
	VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 1000352002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT = 1000353000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT = 1000354000,
	VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT = 1000354001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000,
	VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001,
	VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002,
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365000,
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365001,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA = 1000366000,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA = 1000366001,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA = 1000366002,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA = 1000366003,
	VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA = 1000366004,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA = 1000366005,
	VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA = 1000366006,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA = 1000366007,
	VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA = 1000366008,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA = 1000366009,
	VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI = 1000369000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI = 1000369001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI = 1000369002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI = 1000370000,
	VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV = 1000371000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV = 1000371001,
	VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT = 1000372000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT = 1000372001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT = 1000375000,
	VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT = 1000375001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT = 1000376000,
	VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT = 1000376001,
	VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT = 1000376002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 1000377000,
	VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX = 1000378000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 1000381000,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 1000381001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT = 1000382000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR = 1000386000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT = 1000391000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT = 1000391001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT = 1000392000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT = 1000392001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT = 1000393000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT = 1000395000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT = 1000395001,
	VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT = 1000396000,
	VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT = 1000396001,
	VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT = 1000396002,
	VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT = 1000396003,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT = 1000396004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT = 1000396005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT = 1000396006,
	VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT = 1000396007,
	VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT = 1000396008,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT = 1000396009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV = 1000397000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV = 1000397001,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV = 1000397002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI = 1000404000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI = 1000404001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI = 1000404002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 1000411000,
	VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM = 1000415000,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM = 1000417000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM = 1000417001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM = 1000417002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT = 1000418000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT = 1000418001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE = 1000420000,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE = 1000420001,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE = 1000420002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT = 1000422000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM = 1000424000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM = 1000424001,
	VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM = 1000424002,
	VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM = 1000424003,
	VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM = 1000424004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV = 1000426000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV = 1000426001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV = 1000427000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV = 1000427001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV = 1000428000,
	VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV = 1000428001,
	VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV = 1000428002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV = 1000429008,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV = 1000429009,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV = 1000429010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV = 1000430000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR = 1000434000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT = 1000437000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM = 1000440000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM = 1000440001,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM = 1000440002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT = 1000451000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT = 1000451001,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT = 1000453000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT = 1000455000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT = 1000455001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT = 1000458000,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT = 1000458001,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000458002,
	VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT = 1000458003,
	VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG = 1000459000,
	VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG = 1000459001,
	VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM = 1000460000,
	VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM = 1000460001,
	VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM = 1000460002,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM = 1000460003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM = 1000460004,
	VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM = 1000460005,
	VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM = 1000460006,
	VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM = 1000460007,
	VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM = 1000460008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM = 1000460009,
	VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM = 1000460010,
	VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM = 1000460011,
	VK_STRUCTURE_TYPE_TENSOR_COPY_ARM = 1000460012,
	VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM = 1000460013,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM = 1000460014,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM = 1000460015,
	VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM = 1000460016,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM = 1000460017,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM = 1000460018,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM = 1000460019,
	VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM = 1000460020,
	VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM = 1000460021,
	VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM = 1000460022,
	VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM = 1000460023,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT = 1000462000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT = 1000462001,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT = 1000462002,
	VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT = 1000462003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT = 1000342000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV = 1000464000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV = 1000464001,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV = 1000464002,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV = 1000464003,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV = 1000464004,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV = 1000464005,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV = 1000464010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT = 1000465000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID = 1000468000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID = 1000468001,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID = 1000468002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD = 1000476000,
	VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD = 1000476001,
	VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD = 1000476002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DENSE_GEOMETRY_FORMAT_FEATURES_AMDX = 1000478000,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DENSE_GEOMETRY_FORMAT_TRIANGLES_DATA_AMDX = 1000478001,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR = 1000479000,
	VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR = 1000479001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR = 1000479002,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR = 1000480000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR = 1000480001,
	VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR = 1000480002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR = 1000481000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT = 1000482000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT = 1000482001,
	VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT = 1000482002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR = 1000483000,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR = 1000483001,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR = 1000483002,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR = 1000483003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR = 1000483004,
	VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR = 1000483005,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR = 1000483006,
	VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR = 1000483007,
	VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR = 1000483008,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR = 1000483009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM = 1000484000,
	VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM = 1000484001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC = 1000485000,
	VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC = 1000485001,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR = 1000274000,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR = 1000274001,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR = 1000274002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR = 1000275000,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR = 1000275001,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR = 1000275002,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR = 1000275003,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR = 1000275004,
	VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR = 1000275005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM = 1000488000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV = 1000490000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV = 1000490001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV = 1000491000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV = 1000491001,
	VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV = 1000491002,
	VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV = 1000491004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV = 1000492000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV = 1000492001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT = 1000351000,
	VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT = 1000351002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT = 1000495000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT = 1000495001,
	VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT = 1000496000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM = 1000497000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM = 1000497001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT = 1000498000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT = 1000499000,
	VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV = 1000505000,
	VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV = 1000505001,
	VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV = 1000505002,
	VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV = 1000505003,
	VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV = 1000505004,
	VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV = 1000505005,
	VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV = 1000505006,
	VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV = 1000505007,
	VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV = 1000505008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR = 1000506000,
	VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506002,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM = 1000507000,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM = 1000507001,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM = 1000507002,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM = 1000507003,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM = 1000507004,
	VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM = 1000507005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM = 1000507006,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM = 1000507007,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM = 1000507008,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM = 1000507009,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM = 1000507010,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM = 1000507011,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM = 1000507012,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM = 1000507013,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM = 1000507014,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM = 1000507016,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM = 1000507017,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM = 1000507018,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM = 1000507019,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM = 1000507015,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM = 1000510000,
	VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM = 1000510001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR = 1000201000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR = 1000511000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR = 1000512000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR = 1000512001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR = 1000512003,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000512004,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR = 1000512005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR = 1000513000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000513001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR = 1000513002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR = 1000513003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR = 1000513004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR = 1000513005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR = 1000513006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR = 1000513007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR = 1000513008,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR = 1000513009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR = 1000513010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR = 1000514000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR = 1000514001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR = 1000514002,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR = 1000514003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR = 1000515000,
	VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR = 1000515001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV = 1000516000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM = 1000518000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM = 1000518001,
	VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM = 1000518002,
	VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM = 1000519000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM = 1000519001,
	VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM = 1000519002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM = 1000520000,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM = 1000520001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM = 1000521000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT = 1000524000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR = 1000527000,
	VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT = 1000527001,
	VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX = 1000529000,
	VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX = 1000529001,
	VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX = 1000529002,
	VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX = 1000529003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX = 1000529004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT = 1000530000,
	VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR = 1000184000,
	VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT = 1000545007,
	VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT = 1000545008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV = 1000546000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM = 1000547000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM = 1000547001,
	VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM = 1000547002,
	VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM = 1000547003,
	VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM = 1000547004,
	VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV = 1000551000,
	VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV = 1000551001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR = 1000552000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR = 1000552001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR = 1000552002,
	VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR = 1000552003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR = 1000552004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553000,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR = 1000553002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000553005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR = 1000553009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553004,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553007,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV = 1000555000,
	VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV = 1000556000,
	VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV = 1000556001,
	VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV = 1000556002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV = 1000556003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR = 1000558000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV = 1000559000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR = 1000562000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR = 1000562001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR = 1000562002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR = 1000562003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR = 1000562004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV = 1000563000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT = 1000564000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT = 1000567000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV = 1000568000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV = 1000569000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV = 1000569001,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV = 1000569002,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV = 1000569003,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV = 1000569004,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV = 1000569005,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV = 1000569006,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000569007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV = 1000570000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV = 1000570001,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV = 1000570002,
	VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV = 1000570003,
	VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV = 1000570004,
	VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV = 1000570005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT = 1000572000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT = 1000572001,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT = 1000572002,
	VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT = 1000572003,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT = 1000572004,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT = 1000572006,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT = 1000572007,
	VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT = 1000572008,
	VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT = 1000572009,
	VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT = 1000572010,
	VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT = 1000572011,
	VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT = 1000572012,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT = 1000572013,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT = 1000572014,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR = 1000574000,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR = 1000574002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA = 1000575000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA = 1000575001,
	VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA = 1000575002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT = 1000582000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT = 1000582001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR = 1000584000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR = 1000584001,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR = 1000584002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR = 1000586000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586002,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586003,
	VK_STRUCTURE_TYPE_OH_SURFACE_CREATE_INFO_OHOS = 1000587000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI = 1000590000,
	VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI = 1000590001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV = 1000593000,
	VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV = 1000593001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV = 1000593002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM = 1000596000,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT = 1000602000,
	VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT = 1000602001,
	VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT = 1000602002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR = 1000421000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT = 1000608000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM = 1000609000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE = 1000611000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE = 1000611001,
	VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE = 1000611002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR = 1000286000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR = 1000286001,
	VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV = 1000613000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV = 1000613001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT = 1000425000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT = 1000425001,
	VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT = 1000425002,
	VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT = 1000619003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT = 1000620000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR = 1000361000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC = 1000637000,
	VK_STRUCTURE_TYPE_MAX_ENUM = 0x7fffffff,
}
impl VkStructureType {
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
	pub const VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
	pub const VK_STRUCTURE_TYPE_RENDERING_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDERING_INFO;
	pub const VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO;
	pub const VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
	pub const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO;
	pub const VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
	pub const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
	pub const VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
	pub const VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
	pub const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
	pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
	pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
	pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
	pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
	pub const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
	pub const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
	pub const VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
	pub const VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
	pub const VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
	pub const VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
	pub const VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
	pub const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO;
	pub const VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO;
	pub const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;
	pub const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2;
	pub const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2;
	pub const VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2;
	pub const VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2;
	pub const VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO;
	pub const VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_END_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
	pub const VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR;
	pub const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
	pub const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK;
	pub const VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
	pub const VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;
	pub const VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
	pub const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
	pub const VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
	pub const VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
	pub const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO;
	pub const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
	pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO;
	pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT;
	pub const VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
	pub const VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR;
	pub const VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES;
	pub const VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
	pub const VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
	pub const VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;
	pub const VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO;
	pub const VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES;
	pub const VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO;
	pub const VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
	pub const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT;
	pub const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
	pub const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
	pub const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
	pub const VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
	pub const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES;
	pub const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY;
	pub const VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY;
	pub const VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO;
	pub const VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO;
	pub const VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO;
	pub const VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO;
	pub const VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE;
	pub const VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY;
	pub const VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_MAP_INFO;
	pub const VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO;
	pub const VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR;
	pub const VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR;
	pub const VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR;
	pub const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR;
	pub const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR;
	pub const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR;
	pub const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR;
	pub const VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
	pub const VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
	pub const VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_BARRIER_2;
	pub const VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2;
	pub const VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEPENDENCY_INFO;
	pub const VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBMIT_INFO_2;
	pub const VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO;
	pub const VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
	pub const VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2;
	pub const VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2;
	pub const VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2;
	pub const VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2;
	pub const VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2;
	pub const VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2;
	pub const VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_COPY_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_COPY_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_BLIT_2;
	pub const VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2;
	pub const VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
	pub const VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT;
	pub const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR;
	pub const VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES;
	pub const VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS;
	pub const VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT;
	pub const VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDERING_AREA_INFO;
	pub const VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO;
	pub const VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2;
	pub const VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES;
	pub const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS;
	pub const VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO;
	pub const VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO;
	pub const VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO;
	pub const VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineCacheHeaderVersion {
	VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
	VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageLayout {
	VK_IMAGE_LAYOUT_UNDEFINED = 0,
	VK_IMAGE_LAYOUT_GENERAL = 1,
	VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
	VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
	VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
	VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
	VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001,
	VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
	VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003,
	VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = 1000314000,
	VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = 1000314001,
	VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ = 1000232000,
	VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
	VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = 1000024000,
	VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = 1000024001,
	VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = 1000024002,
	VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
	VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
	VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = 1000299000,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = 1000299001,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = 1000299002,
	VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = 1000339000,
	VK_IMAGE_LAYOUT_TENSOR_ALIASING_ARM = 1000460000,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR = 1000553000,
	VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT = 1000620000,
	VK_IMAGE_LAYOUT_MAX_ENUM = 0x7fffffff,
}
impl VkImageLayout {
	pub const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL;
	pub const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL;
	pub const VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR;
	pub const VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ;
	pub const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL;
	pub const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL;
	pub const VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL;
	pub const VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL;
	pub const VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL;
	pub const VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkObjectType {
	VK_OBJECT_TYPE_UNKNOWN = 0,
	VK_OBJECT_TYPE_INSTANCE = 1,
	VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
	VK_OBJECT_TYPE_DEVICE = 3,
	VK_OBJECT_TYPE_QUEUE = 4,
	VK_OBJECT_TYPE_SEMAPHORE = 5,
	VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
	VK_OBJECT_TYPE_FENCE = 7,
	VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
	VK_OBJECT_TYPE_BUFFER = 9,
	VK_OBJECT_TYPE_IMAGE = 10,
	VK_OBJECT_TYPE_EVENT = 11,
	VK_OBJECT_TYPE_QUERY_POOL = 12,
	VK_OBJECT_TYPE_BUFFER_VIEW = 13,
	VK_OBJECT_TYPE_IMAGE_VIEW = 14,
	VK_OBJECT_TYPE_SHADER_MODULE = 15,
	VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
	VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
	VK_OBJECT_TYPE_RENDER_PASS = 18,
	VK_OBJECT_TYPE_PIPELINE = 19,
	VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
	VK_OBJECT_TYPE_SAMPLER = 21,
	VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
	VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
	VK_OBJECT_TYPE_FRAMEBUFFER = 24,
	VK_OBJECT_TYPE_COMMAND_POOL = 25,
	VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000,
	VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
	VK_OBJECT_TYPE_PRIVATE_DATA_SLOT = 1000295000,
	VK_OBJECT_TYPE_SURFACE_KHR = 1000000000,
	VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
	VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000,
	VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
	VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
	VK_OBJECT_TYPE_VIDEO_SESSION_KHR = 1000023000,
	VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR = 1000023001,
	VK_OBJECT_TYPE_CU_MODULE_NVX = 1000029000,
	VK_OBJECT_TYPE_CU_FUNCTION_NVX = 1000029001,
	VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000,
	VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
	VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000,
	VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
	VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL = 1000210000,
	VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR = 1000268000,
	VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV = 1000277000,
	VK_OBJECT_TYPE_CUDA_MODULE_NV = 1000307000,
	VK_OBJECT_TYPE_CUDA_FUNCTION_NV = 1000307001,
	VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA = 1000366000,
	VK_OBJECT_TYPE_MICROMAP_EXT = 1000396000,
	VK_OBJECT_TYPE_TENSOR_ARM = 1000460000,
	VK_OBJECT_TYPE_TENSOR_VIEW_ARM = 1000460001,
	VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV = 1000464000,
	VK_OBJECT_TYPE_SHADER_EXT = 1000482000,
	VK_OBJECT_TYPE_PIPELINE_BINARY_KHR = 1000483000,
	VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM = 1000507000,
	VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV = 1000556000,
	VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT = 1000572000,
	VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT = 1000572001,
	VK_OBJECT_TYPE_MAX_ENUM = 0x7fffffff,
}
impl VkObjectType {
	pub const VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR: VkObjectType = VkObjectType::VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE;
	pub const VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR: VkObjectType = VkObjectType::VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION;
	pub const VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT: VkObjectType = VkObjectType::VK_OBJECT_TYPE_PRIVATE_DATA_SLOT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVendorId {
	VK_VENDOR_ID_KHRONOS = 0x10000,
	VK_VENDOR_ID_VIV = 0x10001,
	VK_VENDOR_ID_VSI = 0x10002,
	VK_VENDOR_ID_KAZAN = 0x10003,
	VK_VENDOR_ID_CODEPLAY = 0x10004,
	VK_VENDOR_ID_MESA = 0x10005,
	VK_VENDOR_ID_POCL = 0x10006,
	VK_VENDOR_ID_MOBILEYE = 0x10007,
	VK_VENDOR_ID_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSystemAllocationScope {
	VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
	VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
	VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
	VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
	VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
	VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkInternalAllocationType {
	VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
	VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFormat {
	VK_FORMAT_UNDEFINED = 0,
	VK_FORMAT_R4G4_UNORM_PACK8 = 1,
	VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
	VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
	VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
	VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
	VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
	VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
	VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
	VK_FORMAT_R8_UNORM = 9,
	VK_FORMAT_R8_SNORM = 10,
	VK_FORMAT_R8_USCALED = 11,
	VK_FORMAT_R8_SSCALED = 12,
	VK_FORMAT_R8_UINT = 13,
	VK_FORMAT_R8_SINT = 14,
	VK_FORMAT_R8_SRGB = 15,
	VK_FORMAT_R8G8_UNORM = 16,
	VK_FORMAT_R8G8_SNORM = 17,
	VK_FORMAT_R8G8_USCALED = 18,
	VK_FORMAT_R8G8_SSCALED = 19,
	VK_FORMAT_R8G8_UINT = 20,
	VK_FORMAT_R8G8_SINT = 21,
	VK_FORMAT_R8G8_SRGB = 22,
	VK_FORMAT_R8G8B8_UNORM = 23,
	VK_FORMAT_R8G8B8_SNORM = 24,
	VK_FORMAT_R8G8B8_USCALED = 25,
	VK_FORMAT_R8G8B8_SSCALED = 26,
	VK_FORMAT_R8G8B8_UINT = 27,
	VK_FORMAT_R8G8B8_SINT = 28,
	VK_FORMAT_R8G8B8_SRGB = 29,
	VK_FORMAT_B8G8R8_UNORM = 30,
	VK_FORMAT_B8G8R8_SNORM = 31,
	VK_FORMAT_B8G8R8_USCALED = 32,
	VK_FORMAT_B8G8R8_SSCALED = 33,
	VK_FORMAT_B8G8R8_UINT = 34,
	VK_FORMAT_B8G8R8_SINT = 35,
	VK_FORMAT_B8G8R8_SRGB = 36,
	VK_FORMAT_R8G8B8A8_UNORM = 37,
	VK_FORMAT_R8G8B8A8_SNORM = 38,
	VK_FORMAT_R8G8B8A8_USCALED = 39,
	VK_FORMAT_R8G8B8A8_SSCALED = 40,
	VK_FORMAT_R8G8B8A8_UINT = 41,
	VK_FORMAT_R8G8B8A8_SINT = 42,
	VK_FORMAT_R8G8B8A8_SRGB = 43,
	VK_FORMAT_B8G8R8A8_UNORM = 44,
	VK_FORMAT_B8G8R8A8_SNORM = 45,
	VK_FORMAT_B8G8R8A8_USCALED = 46,
	VK_FORMAT_B8G8R8A8_SSCALED = 47,
	VK_FORMAT_B8G8R8A8_UINT = 48,
	VK_FORMAT_B8G8R8A8_SINT = 49,
	VK_FORMAT_B8G8R8A8_SRGB = 50,
	VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
	VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
	VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
	VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
	VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
	VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
	VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
	VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
	VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
	VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
	VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
	VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
	VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
	VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
	VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
	VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
	VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
	VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
	VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
	VK_FORMAT_R16_UNORM = 70,
	VK_FORMAT_R16_SNORM = 71,
	VK_FORMAT_R16_USCALED = 72,
	VK_FORMAT_R16_SSCALED = 73,
	VK_FORMAT_R16_UINT = 74,
	VK_FORMAT_R16_SINT = 75,
	VK_FORMAT_R16_SFLOAT = 76,
	VK_FORMAT_R16G16_UNORM = 77,
	VK_FORMAT_R16G16_SNORM = 78,
	VK_FORMAT_R16G16_USCALED = 79,
	VK_FORMAT_R16G16_SSCALED = 80,
	VK_FORMAT_R16G16_UINT = 81,
	VK_FORMAT_R16G16_SINT = 82,
	VK_FORMAT_R16G16_SFLOAT = 83,
	VK_FORMAT_R16G16B16_UNORM = 84,
	VK_FORMAT_R16G16B16_SNORM = 85,
	VK_FORMAT_R16G16B16_USCALED = 86,
	VK_FORMAT_R16G16B16_SSCALED = 87,
	VK_FORMAT_R16G16B16_UINT = 88,
	VK_FORMAT_R16G16B16_SINT = 89,
	VK_FORMAT_R16G16B16_SFLOAT = 90,
	VK_FORMAT_R16G16B16A16_UNORM = 91,
	VK_FORMAT_R16G16B16A16_SNORM = 92,
	VK_FORMAT_R16G16B16A16_USCALED = 93,
	VK_FORMAT_R16G16B16A16_SSCALED = 94,
	VK_FORMAT_R16G16B16A16_UINT = 95,
	VK_FORMAT_R16G16B16A16_SINT = 96,
	VK_FORMAT_R16G16B16A16_SFLOAT = 97,
	VK_FORMAT_R32_UINT = 98,
	VK_FORMAT_R32_SINT = 99,
	VK_FORMAT_R32_SFLOAT = 100,
	VK_FORMAT_R32G32_UINT = 101,
	VK_FORMAT_R32G32_SINT = 102,
	VK_FORMAT_R32G32_SFLOAT = 103,
	VK_FORMAT_R32G32B32_UINT = 104,
	VK_FORMAT_R32G32B32_SINT = 105,
	VK_FORMAT_R32G32B32_SFLOAT = 106,
	VK_FORMAT_R32G32B32A32_UINT = 107,
	VK_FORMAT_R32G32B32A32_SINT = 108,
	VK_FORMAT_R32G32B32A32_SFLOAT = 109,
	VK_FORMAT_R64_UINT = 110,
	VK_FORMAT_R64_SINT = 111,
	VK_FORMAT_R64_SFLOAT = 112,
	VK_FORMAT_R64G64_UINT = 113,
	VK_FORMAT_R64G64_SINT = 114,
	VK_FORMAT_R64G64_SFLOAT = 115,
	VK_FORMAT_R64G64B64_UINT = 116,
	VK_FORMAT_R64G64B64_SINT = 117,
	VK_FORMAT_R64G64B64_SFLOAT = 118,
	VK_FORMAT_R64G64B64A64_UINT = 119,
	VK_FORMAT_R64G64B64A64_SINT = 120,
	VK_FORMAT_R64G64B64A64_SFLOAT = 121,
	VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
	VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
	VK_FORMAT_D16_UNORM = 124,
	VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
	VK_FORMAT_D32_SFLOAT = 126,
	VK_FORMAT_S8_UINT = 127,
	VK_FORMAT_D16_UNORM_S8_UINT = 128,
	VK_FORMAT_D24_UNORM_S8_UINT = 129,
	VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
	VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
	VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
	VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
	VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
	VK_FORMAT_BC2_UNORM_BLOCK = 135,
	VK_FORMAT_BC2_SRGB_BLOCK = 136,
	VK_FORMAT_BC3_UNORM_BLOCK = 137,
	VK_FORMAT_BC3_SRGB_BLOCK = 138,
	VK_FORMAT_BC4_UNORM_BLOCK = 139,
	VK_FORMAT_BC4_SNORM_BLOCK = 140,
	VK_FORMAT_BC5_UNORM_BLOCK = 141,
	VK_FORMAT_BC5_SNORM_BLOCK = 142,
	VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
	VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
	VK_FORMAT_BC7_UNORM_BLOCK = 145,
	VK_FORMAT_BC7_SRGB_BLOCK = 146,
	VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
	VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
	VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
	VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
	VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
	VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
	VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
	VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
	VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
	VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
	VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
	VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
	VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
	VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
	VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
	VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
	VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
	VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
	VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
	VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
	VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
	VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
	VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
	VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
	VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
	VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
	VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
	VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
	VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
	VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
	VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
	VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
	VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
	VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
	VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
	VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
	VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
	VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
	VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
	VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
	VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
	VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
	VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
	VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
	VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
	VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
	VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
	VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
	VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
	VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
	VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
	VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
	VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
	VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
	VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
	VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
	VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
	VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
	VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
	VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
	VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
	VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
	VK_FORMAT_G8_B8R8_2PLANE_444_UNORM = 1000330000,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002,
	VK_FORMAT_G16_B16R16_2PLANE_444_UNORM = 1000330003,
	VK_FORMAT_A4R4G4B4_UNORM_PACK16 = 1000340000,
	VK_FORMAT_A4B4G4R4_UNORM_PACK16 = 1000340001,
	VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK = 1000066000,
	VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK = 1000066001,
	VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK = 1000066002,
	VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK = 1000066003,
	VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK = 1000066004,
	VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK = 1000066005,
	VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK = 1000066006,
	VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK = 1000066007,
	VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK = 1000066008,
	VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK = 1000066009,
	VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK = 1000066010,
	VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK = 1000066011,
	VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK = 1000066012,
	VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK = 1000066013,
	VK_FORMAT_A1B5G5R5_UNORM_PACK16 = 1000470000,
	VK_FORMAT_A8_UNORM = 1000470001,
	VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
	VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
	VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
	VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
	VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
	VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
	VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
	VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
	VK_FORMAT_R8_BOOL_ARM = 1000460000,
	VK_FORMAT_R16G16_SFIXED5_NV = 1000464000,
	VK_FORMAT_R10X6_UINT_PACK16_ARM = 1000609000,
	VK_FORMAT_R10X6G10X6_UINT_2PACK16_ARM = 1000609001,
	VK_FORMAT_R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM = 1000609002,
	VK_FORMAT_R12X4_UINT_PACK16_ARM = 1000609003,
	VK_FORMAT_R12X4G12X4_UINT_2PACK16_ARM = 1000609004,
	VK_FORMAT_R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM = 1000609005,
	VK_FORMAT_R14X2_UINT_PACK16_ARM = 1000609006,
	VK_FORMAT_R14X2G14X2_UINT_2PACK16_ARM = 1000609007,
	VK_FORMAT_R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM = 1000609008,
	VK_FORMAT_R14X2_UNORM_PACK16_ARM = 1000609009,
	VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM = 1000609010,
	VK_FORMAT_R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM = 1000609011,
	VK_FORMAT_G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM = 1000609012,
	VK_FORMAT_G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM = 1000609013,
	VK_FORMAT_MAX_ENUM = 0x7fffffff,
}
impl VkFormat {
	pub const VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK;
	pub const VK_FORMAT_G8B8G8R8_422_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G8B8G8R8_422_UNORM;
	pub const VK_FORMAT_B8G8R8G8_422_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_B8G8R8G8_422_UNORM;
	pub const VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM;
	pub const VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G8_B8R8_2PLANE_420_UNORM;
	pub const VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM;
	pub const VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G8_B8R8_2PLANE_422_UNORM;
	pub const VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM;
	pub const VK_FORMAT_R10X6_UNORM_PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_R10X6_UNORM_PACK16;
	pub const VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_R10X6G10X6_UNORM_2PACK16;
	pub const VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16;
	pub const VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16;
	pub const VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16;
	pub const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16;
	pub const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16;
	pub const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16;
	pub const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16;
	pub const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16;
	pub const VK_FORMAT_R12X4_UNORM_PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_R12X4_UNORM_PACK16;
	pub const VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_R12X4G12X4_UNORM_2PACK16;
	pub const VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16;
	pub const VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16;
	pub const VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16;
	pub const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16;
	pub const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16;
	pub const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16;
	pub const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16;
	pub const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16;
	pub const VK_FORMAT_G16B16G16R16_422_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G16B16G16R16_422_UNORM;
	pub const VK_FORMAT_B16G16R16G16_422_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_B16G16R16G16_422_UNORM;
	pub const VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM;
	pub const VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G16_B16R16_2PLANE_420_UNORM;
	pub const VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM;
	pub const VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G16_B16R16_2PLANE_422_UNORM;
	pub const VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM;
	pub const VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT: VkFormat = VkFormat::VK_FORMAT_G8_B8R8_2PLANE_444_UNORM;
	pub const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT: VkFormat = VkFormat::VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16;
	pub const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT: VkFormat = VkFormat::VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16;
	pub const VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT: VkFormat = VkFormat::VK_FORMAT_G16_B16R16_2PLANE_444_UNORM;
	pub const VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT: VkFormat = VkFormat::VK_FORMAT_A4R4G4B4_UNORM_PACK16;
	pub const VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT: VkFormat = VkFormat::VK_FORMAT_A4B4G4R4_UNORM_PACK16;
	pub const VK_FORMAT_R16G16_S10_5_NV: VkFormat = VkFormat::VK_FORMAT_R16G16_SFIXED5_NV;
	pub const VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_A1B5G5R5_UNORM_PACK16;
	pub const VK_FORMAT_A8_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_A8_UNORM;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageTiling {
	VK_IMAGE_TILING_OPTIMAL = 0,
	VK_IMAGE_TILING_LINEAR = 1,
	VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
	VK_IMAGE_TILING_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageType {
	VK_IMAGE_TYPE_1D = 0,
	VK_IMAGE_TYPE_2D = 1,
	VK_IMAGE_TYPE_3D = 2,
	VK_IMAGE_TYPE_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPhysicalDeviceType {
	VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
	VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
	VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
	VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
	VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
	VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueryType {
	VK_QUERY_TYPE_OCCLUSION = 0,
	VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
	VK_QUERY_TYPE_TIMESTAMP = 2,
	VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR = 1000023000,
	VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
	VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR = 1000116000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR = 1000150000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR = 1000150001,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000,
	VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL = 1000210000,
	VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR = 1000299000,
	VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT = 1000328000,
	VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT = 1000382000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR = 1000386000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR = 1000386001,
	VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT = 1000396000,
	VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT = 1000396001,
	VK_QUERY_TYPE_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSharingMode {
	VK_SHARING_MODE_EXCLUSIVE = 0,
	VK_SHARING_MODE_CONCURRENT = 1,
	VK_SHARING_MODE_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkComponentSwizzle {
	VK_COMPONENT_SWIZZLE_IDENTITY = 0,
	VK_COMPONENT_SWIZZLE_ZERO = 1,
	VK_COMPONENT_SWIZZLE_ONE = 2,
	VK_COMPONENT_SWIZZLE_R = 3,
	VK_COMPONENT_SWIZZLE_G = 4,
	VK_COMPONENT_SWIZZLE_B = 5,
	VK_COMPONENT_SWIZZLE_A = 6,
	VK_COMPONENT_SWIZZLE_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageViewType {
	VK_IMAGE_VIEW_TYPE_1D = 0,
	VK_IMAGE_VIEW_TYPE_2D = 1,
	VK_IMAGE_VIEW_TYPE_3D = 2,
	VK_IMAGE_VIEW_TYPE_CUBE = 3,
	VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
	VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
	VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
	VK_IMAGE_VIEW_TYPE_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBlendFactor {
	VK_BLEND_FACTOR_ZERO = 0,
	VK_BLEND_FACTOR_ONE = 1,
	VK_BLEND_FACTOR_SRC_COLOR = 2,
	VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
	VK_BLEND_FACTOR_DST_COLOR = 4,
	VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
	VK_BLEND_FACTOR_SRC_ALPHA = 6,
	VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
	VK_BLEND_FACTOR_DST_ALPHA = 8,
	VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
	VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
	VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
	VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
	VK_BLEND_FACTOR_SRC1_COLOR = 15,
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
	VK_BLEND_FACTOR_SRC1_ALPHA = 17,
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
	VK_BLEND_FACTOR_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBlendOp {
	VK_BLEND_OP_ADD = 0,
	VK_BLEND_OP_SUBTRACT = 1,
	VK_BLEND_OP_REVERSE_SUBTRACT = 2,
	VK_BLEND_OP_MIN = 3,
	VK_BLEND_OP_MAX = 4,
	VK_BLEND_OP_ZERO_EXT = 1000148000,
	VK_BLEND_OP_SRC_EXT = 1000148001,
	VK_BLEND_OP_DST_EXT = 1000148002,
	VK_BLEND_OP_SRC_OVER_EXT = 1000148003,
	VK_BLEND_OP_DST_OVER_EXT = 1000148004,
	VK_BLEND_OP_SRC_IN_EXT = 1000148005,
	VK_BLEND_OP_DST_IN_EXT = 1000148006,
	VK_BLEND_OP_SRC_OUT_EXT = 1000148007,
	VK_BLEND_OP_DST_OUT_EXT = 1000148008,
	VK_BLEND_OP_SRC_ATOP_EXT = 1000148009,
	VK_BLEND_OP_DST_ATOP_EXT = 1000148010,
	VK_BLEND_OP_XOR_EXT = 1000148011,
	VK_BLEND_OP_MULTIPLY_EXT = 1000148012,
	VK_BLEND_OP_SCREEN_EXT = 1000148013,
	VK_BLEND_OP_OVERLAY_EXT = 1000148014,
	VK_BLEND_OP_DARKEN_EXT = 1000148015,
	VK_BLEND_OP_LIGHTEN_EXT = 1000148016,
	VK_BLEND_OP_COLORDODGE_EXT = 1000148017,
	VK_BLEND_OP_COLORBURN_EXT = 1000148018,
	VK_BLEND_OP_HARDLIGHT_EXT = 1000148019,
	VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020,
	VK_BLEND_OP_DIFFERENCE_EXT = 1000148021,
	VK_BLEND_OP_EXCLUSION_EXT = 1000148022,
	VK_BLEND_OP_INVERT_EXT = 1000148023,
	VK_BLEND_OP_INVERT_RGB_EXT = 1000148024,
	VK_BLEND_OP_LINEARDODGE_EXT = 1000148025,
	VK_BLEND_OP_LINEARBURN_EXT = 1000148026,
	VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
	VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028,
	VK_BLEND_OP_PINLIGHT_EXT = 1000148029,
	VK_BLEND_OP_HARDMIX_EXT = 1000148030,
	VK_BLEND_OP_HSL_HUE_EXT = 1000148031,
	VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032,
	VK_BLEND_OP_HSL_COLOR_EXT = 1000148033,
	VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
	VK_BLEND_OP_PLUS_EXT = 1000148035,
	VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
	VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
	VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038,
	VK_BLEND_OP_MINUS_EXT = 1000148039,
	VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
	VK_BLEND_OP_CONTRAST_EXT = 1000148041,
	VK_BLEND_OP_INVERT_OVG_EXT = 1000148042,
	VK_BLEND_OP_RED_EXT = 1000148043,
	VK_BLEND_OP_GREEN_EXT = 1000148044,
	VK_BLEND_OP_BLUE_EXT = 1000148045,
	VK_BLEND_OP_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCompareOp {
	VK_COMPARE_OP_NEVER = 0,
	VK_COMPARE_OP_LESS = 1,
	VK_COMPARE_OP_EQUAL = 2,
	VK_COMPARE_OP_LESS_OR_EQUAL = 3,
	VK_COMPARE_OP_GREATER = 4,
	VK_COMPARE_OP_NOT_EQUAL = 5,
	VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
	VK_COMPARE_OP_ALWAYS = 7,
	VK_COMPARE_OP_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDynamicState {
	VK_DYNAMIC_STATE_VIEWPORT = 0,
	VK_DYNAMIC_STATE_SCISSOR = 1,
	VK_DYNAMIC_STATE_LINE_WIDTH = 2,
	VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
	VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
	VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
	VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
	VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
	VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
	VK_DYNAMIC_STATE_CULL_MODE = 1000267000,
	VK_DYNAMIC_STATE_FRONT_FACE = 1000267001,
	VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY = 1000267002,
	VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT = 1000267003,
	VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT = 1000267004,
	VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE = 1000267005,
	VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE = 1000267006,
	VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE = 1000267007,
	VK_DYNAMIC_STATE_DEPTH_COMPARE_OP = 1000267008,
	VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE = 1000267009,
	VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE = 1000267010,
	VK_DYNAMIC_STATE_STENCIL_OP = 1000267011,
	VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE = 1000377001,
	VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE = 1000377002,
	VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE = 1000377004,
	VK_DYNAMIC_STATE_LINE_STIPPLE = 1000259000,
	VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
	VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
	VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT = 1000099001,
	VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT = 1000099002,
	VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000,
	VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR = 1000347000,
	VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
	VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
	VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV = 1000205000,
	VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001,
	VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR = 1000226000,
	VK_DYNAMIC_STATE_VERTEX_INPUT_EXT = 1000352000,
	VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT = 1000377000,
	VK_DYNAMIC_STATE_LOGIC_OP_EXT = 1000377003,
	VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT = 1000381000,
	VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT = 1000455003,
	VK_DYNAMIC_STATE_POLYGON_MODE_EXT = 1000455004,
	VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT = 1000455005,
	VK_DYNAMIC_STATE_SAMPLE_MASK_EXT = 1000455006,
	VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT = 1000455007,
	VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT = 1000455008,
	VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT = 1000455009,
	VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT = 1000455010,
	VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT = 1000455011,
	VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT = 1000455012,
	VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT = 1000455002,
	VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT = 1000455013,
	VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT = 1000455014,
	VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT = 1000455015,
	VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT = 1000455016,
	VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT = 1000455017,
	VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT = 1000455018,
	VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT = 1000455019,
	VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT = 1000455020,
	VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT = 1000455021,
	VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT = 1000455022,
	VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV = 1000455023,
	VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV = 1000455024,
	VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV = 1000455025,
	VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV = 1000455026,
	VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV = 1000455027,
	VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV = 1000455028,
	VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV = 1000455029,
	VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV = 1000455030,
	VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV = 1000455031,
	VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV = 1000455032,
	VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT = 1000524000,
	VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT = 1000582000,
	VK_DYNAMIC_STATE_MAX_ENUM = 0x7fffffff,
}
impl VkDynamicState {
	pub const VK_DYNAMIC_STATE_LINE_STIPPLE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_LINE_STIPPLE;
	pub const VK_DYNAMIC_STATE_CULL_MODE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_CULL_MODE;
	pub const VK_DYNAMIC_STATE_FRONT_FACE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_FRONT_FACE;
	pub const VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY;
	pub const VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT;
	pub const VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT;
	pub const VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE;
	pub const VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE;
	pub const VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE;
	pub const VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_DEPTH_COMPARE_OP;
	pub const VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE;
	pub const VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE;
	pub const VK_DYNAMIC_STATE_STENCIL_OP_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_STENCIL_OP;
	pub const VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE;
	pub const VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE;
	pub const VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE;
	pub const VK_DYNAMIC_STATE_LINE_STIPPLE_KHR: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_LINE_STIPPLE;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFrontFace {
	VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
	VK_FRONT_FACE_CLOCKWISE = 1,
	VK_FRONT_FACE_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVertexInputRate {
	VK_VERTEX_INPUT_RATE_VERTEX = 0,
	VK_VERTEX_INPUT_RATE_INSTANCE = 1,
	VK_VERTEX_INPUT_RATE_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPrimitiveTopology {
	VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
	VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
	VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPolygonMode {
	VK_POLYGON_MODE_FILL = 0,
	VK_POLYGON_MODE_LINE = 1,
	VK_POLYGON_MODE_POINT = 2,
	VK_POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000,
	VK_POLYGON_MODE_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkStencilOp {
	VK_STENCIL_OP_KEEP = 0,
	VK_STENCIL_OP_ZERO = 1,
	VK_STENCIL_OP_REPLACE = 2,
	VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
	VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
	VK_STENCIL_OP_INVERT = 5,
	VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
	VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
	VK_STENCIL_OP_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkLogicOp {
	VK_LOGIC_OP_CLEAR = 0,
	VK_LOGIC_OP_AND = 1,
	VK_LOGIC_OP_AND_REVERSE = 2,
	VK_LOGIC_OP_COPY = 3,
	VK_LOGIC_OP_AND_INVERTED = 4,
	VK_LOGIC_OP_NO_OP = 5,
	VK_LOGIC_OP_XOR = 6,
	VK_LOGIC_OP_OR = 7,
	VK_LOGIC_OP_NOR = 8,
	VK_LOGIC_OP_EQUIVALENT = 9,
	VK_LOGIC_OP_INVERT = 10,
	VK_LOGIC_OP_OR_REVERSE = 11,
	VK_LOGIC_OP_COPY_INVERTED = 12,
	VK_LOGIC_OP_OR_INVERTED = 13,
	VK_LOGIC_OP_NAND = 14,
	VK_LOGIC_OP_SET = 15,
	VK_LOGIC_OP_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBorderColor {
	VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
	VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
	VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
	VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
	VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
	VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
	VK_BORDER_COLOR_FLOAT_CUSTOM_EXT = 1000287003,
	VK_BORDER_COLOR_INT_CUSTOM_EXT = 1000287004,
	VK_BORDER_COLOR_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFilter {
	VK_FILTER_NEAREST = 0,
	VK_FILTER_LINEAR = 1,
	VK_FILTER_CUBIC_EXT = 1000015000,
	VK_FILTER_MAX_ENUM = 0x7fffffff,
}
impl VkFilter {
	pub const VK_FILTER_CUBIC_IMG: VkFilter = VkFilter::VK_FILTER_CUBIC_EXT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSamplerAddressMode {
	VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
	VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
	VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
	VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7fffffff,
}
impl VkSamplerAddressMode {
	pub const VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR: VkSamplerAddressMode = VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSamplerMipmapMode {
	VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
	VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
	VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDescriptorType {
	VK_DESCRIPTOR_TYPE_SAMPLER = 0,
	VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
	VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
	VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
	VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
	VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
	VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
	VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK = 1000138000,
	VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
	VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
	VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM = 1000440000,
	VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM = 1000440001,
	VK_DESCRIPTOR_TYPE_TENSOR_ARM = 1000460000,
	VK_DESCRIPTOR_TYPE_MUTABLE_EXT = 1000351000,
	VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV = 1000570000,
	VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7fffffff,
}
impl VkDescriptorType {
	pub const VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT: VkDescriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK;
	pub const VK_DESCRIPTOR_TYPE_MUTABLE_VALVE: VkDescriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_MUTABLE_EXT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAttachmentLoadOp {
	VK_ATTACHMENT_LOAD_OP_LOAD = 0,
	VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
	VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
	VK_ATTACHMENT_LOAD_OP_NONE = 1000400000,
	VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7fffffff,
}
impl VkAttachmentLoadOp {
	pub const VK_ATTACHMENT_LOAD_OP_NONE_EXT: VkAttachmentLoadOp = VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_NONE;
	pub const VK_ATTACHMENT_LOAD_OP_NONE_KHR: VkAttachmentLoadOp = VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_NONE;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAttachmentStoreOp {
	VK_ATTACHMENT_STORE_OP_STORE = 0,
	VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
	VK_ATTACHMENT_STORE_OP_NONE = 1000301000,
	VK_ATTACHMENT_STORE_OP_MAX_ENUM = 0x7fffffff,
}
impl VkAttachmentStoreOp {
	pub const VK_ATTACHMENT_STORE_OP_NONE_KHR: VkAttachmentStoreOp = VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_NONE;
	pub const VK_ATTACHMENT_STORE_OP_NONE_QCOM: VkAttachmentStoreOp = VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_NONE;
	pub const VK_ATTACHMENT_STORE_OP_NONE_EXT: VkAttachmentStoreOp = VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_NONE;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineBindPoint {
	VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
	VK_PIPELINE_BIND_POINT_COMPUTE = 1,
	VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX = 1000134000,
	VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR = 1000165000,
	VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI = 1000369003,
	VK_PIPELINE_BIND_POINT_DATA_GRAPH_ARM = 1000507000,
	VK_PIPELINE_BIND_POINT_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineBindPoint {
	pub const VK_PIPELINE_BIND_POINT_RAY_TRACING_NV: VkPipelineBindPoint = VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCommandBufferLevel {
	VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
	VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
	VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkIndexType {
	VK_INDEX_TYPE_UINT16 = 0,
	VK_INDEX_TYPE_UINT32 = 1,
	VK_INDEX_TYPE_UINT8 = 1000265000,
	VK_INDEX_TYPE_NONE_KHR = 1000165000,
	VK_INDEX_TYPE_MAX_ENUM = 0x7fffffff,
}
impl VkIndexType {
	pub const VK_INDEX_TYPE_NONE_NV: VkIndexType = VkIndexType::VK_INDEX_TYPE_NONE_KHR;
	pub const VK_INDEX_TYPE_UINT8_EXT: VkIndexType = VkIndexType::VK_INDEX_TYPE_UINT8;
	pub const VK_INDEX_TYPE_UINT8_KHR: VkIndexType = VkIndexType::VK_INDEX_TYPE_UINT8;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSubpassContents {
	VK_SUBPASS_CONTENTS_INLINE = 0,
	VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
	VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR = 1000451000,
	VK_SUBPASS_CONTENTS_MAX_ENUM = 0x7fffffff,
}
impl VkSubpassContents {
	pub const VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT: VkSubpassContents = VkSubpassContents::VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAccessFlagBits {
	VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
	VK_ACCESS_INDEX_READ_BIT = 0x00000002,
	VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
	VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
	VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
	VK_ACCESS_SHADER_READ_BIT = 0x00000020,
	VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
	VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
	VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
	VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
	VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
	VK_ACCESS_HOST_READ_BIT = 0x00002000,
	VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
	VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
	VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
	VK_ACCESS_NONE = 0,
	VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000,
	VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000,
	VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000,
	VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000,
	VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000,
	VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000,
	VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000,
	VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000,
	VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x00800000,
	VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT = 0x00020000,
	VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT = 0x00040000,
	VK_ACCESS_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkAccessFlagBits {
	pub const VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV: VkAccessFlagBits = VkAccessFlagBits::VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR;
	pub const VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV: VkAccessFlagBits = VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR;
	pub const VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV: VkAccessFlagBits = VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR;
	pub const VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV: VkAccessFlagBits = VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT;
	pub const VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV: VkAccessFlagBits = VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT;
	pub const VK_ACCESS_NONE_KHR: VkAccessFlagBits = VkAccessFlagBits::VK_ACCESS_NONE;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageAspectFlagBits {
	VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
	VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
	VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
	VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
	VK_IMAGE_ASPECT_PLANE_0_BIT = 0x00000010,
	VK_IMAGE_ASPECT_PLANE_1_BIT = 0x00000020,
	VK_IMAGE_ASPECT_PLANE_2_BIT = 0x00000040,
	VK_IMAGE_ASPECT_NONE = 0,
	VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080,
	VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100,
	VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200,
	VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400,
	VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkImageAspectFlagBits {
	pub const VK_IMAGE_ASPECT_PLANE_0_BIT_KHR: VkImageAspectFlagBits = VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_0_BIT;
	pub const VK_IMAGE_ASPECT_PLANE_1_BIT_KHR: VkImageAspectFlagBits = VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_1_BIT;
	pub const VK_IMAGE_ASPECT_PLANE_2_BIT_KHR: VkImageAspectFlagBits = VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_2_BIT;
	pub const VK_IMAGE_ASPECT_NONE_KHR: VkImageAspectFlagBits = VkImageAspectFlagBits::VK_IMAGE_ASPECT_NONE;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFormatFeatureFlagBits {
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
	VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
	VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
	VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
	VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
	VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
	VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
	VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
	VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 0x00004000,
	VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 0x00008000,
	VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 0x00020000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x00080000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x00100000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x00200000,
	VK_FORMAT_FEATURE_DISJOINT_BIT = 0x00400000,
	VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 0x00800000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 0x00010000,
	VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR = 0x02000000,
	VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR = 0x04000000,
	VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x20000000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 0x00002000,
	VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x01000000,
	VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x40000000,
	VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR = 0x08000000,
	VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR = 0x10000000,
	VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkFormatFeatureFlagBits {
	pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT;
	pub const VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_SRC_BIT;
	pub const VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_DST_BIT;
	pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT;
	pub const VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT;
	pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT;
	pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT;
	pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT;
	pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT;
	pub const VK_FORMAT_FEATURE_DISJOINT_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_DISJOINT_BIT;
	pub const VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageCreateFlagBits {
	VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
	VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
	VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
	VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
	VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
	VK_IMAGE_CREATE_ALIAS_BIT = 0x00000400,
	VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 0x00000040,
	VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 0x00000020,
	VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 0x00000080,
	VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 0x00000100,
	VK_IMAGE_CREATE_PROTECTED_BIT = 0x00000800,
	VK_IMAGE_CREATE_DISJOINT_BIT = 0x00000200,
	VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 0x00002000,
	VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x00001000,
	VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 0x00004000,
	VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00010000,
	VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT = 0x00040000,
	VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT = 0x00020000,
	VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR = 0x00100000,
	VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT = 0x00008000,
	VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkImageCreateFlagBits {
	pub const VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR: VkImageCreateFlagBits = VkImageCreateFlagBits::VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT;
	pub const VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR: VkImageCreateFlagBits = VkImageCreateFlagBits::VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT;
	pub const VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR: VkImageCreateFlagBits = VkImageCreateFlagBits::VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT;
	pub const VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR: VkImageCreateFlagBits = VkImageCreateFlagBits::VK_IMAGE_CREATE_EXTENDED_USAGE_BIT;
	pub const VK_IMAGE_CREATE_DISJOINT_BIT_KHR: VkImageCreateFlagBits = VkImageCreateFlagBits::VK_IMAGE_CREATE_DISJOINT_BIT;
	pub const VK_IMAGE_CREATE_ALIAS_BIT_KHR: VkImageCreateFlagBits = VkImageCreateFlagBits::VK_IMAGE_CREATE_ALIAS_BIT;
	pub const VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM: VkImageCreateFlagBits = VkImageCreateFlagBits::VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSampleCountFlagBits {
	VK_SAMPLE_COUNT_1_BIT = 0x00000001,
	VK_SAMPLE_COUNT_2_BIT = 0x00000002,
	VK_SAMPLE_COUNT_4_BIT = 0x00000004,
	VK_SAMPLE_COUNT_8_BIT = 0x00000008,
	VK_SAMPLE_COUNT_16_BIT = 0x00000010,
	VK_SAMPLE_COUNT_32_BIT = 0x00000020,
	VK_SAMPLE_COUNT_64_BIT = 0x00000040,
	VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageUsageFlagBits {
	VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
	VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
	VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
	VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
	VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
	VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
	VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
	VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
	VK_IMAGE_USAGE_HOST_TRANSFER_BIT = 0x00400000,
	VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00000400,
	VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00000800,
	VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR = 0x00001000,
	VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x00000200,
	VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00000100,
	VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00002000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00004000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR = 0x00008000,
	VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x00080000,
	VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI = 0x00040000,
	VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM = 0x00100000,
	VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM = 0x00200000,
	VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM = 0x00800000,
	VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM = 0x08000000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x02000000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR = 0x04000000,
	VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkImageUsageFlagBits {
	pub const VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV: VkImageUsageFlagBits = VkImageUsageFlagBits::VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
	pub const VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT: VkImageUsageFlagBits = VkImageUsageFlagBits::VK_IMAGE_USAGE_HOST_TRANSFER_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkInstanceCreateFlagBits {
	VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR = 0x00000001,
	VK_INSTANCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkMemoryHeapFlagBits {
	VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
	VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 0x00000002,
	VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM = 0x00000008,
	VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkMemoryHeapFlagBits {
	pub const VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR: VkMemoryHeapFlagBits = VkMemoryHeapFlagBits::VK_MEMORY_HEAP_MULTI_INSTANCE_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkMemoryPropertyFlagBits {
	VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
	VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
	VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
	VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
	VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
	VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x00000020,
	VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x00000040,
	VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x00000080,
	VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 0x00000100,
	VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueueFlagBits {
	VK_QUEUE_GRAPHICS_BIT = 0x00000001,
	VK_QUEUE_COMPUTE_BIT = 0x00000002,
	VK_QUEUE_TRANSFER_BIT = 0x00000004,
	VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
	VK_QUEUE_PROTECTED_BIT = 0x00000010,
	VK_QUEUE_VIDEO_DECODE_BIT_KHR = 0x00000020,
	VK_QUEUE_VIDEO_ENCODE_BIT_KHR = 0x00000040,
	VK_QUEUE_OPTICAL_FLOW_BIT_NV = 0x00000100,
	VK_QUEUE_DATA_GRAPH_BIT_ARM = 0x00000400,
	VK_QUEUE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceQueueCreateFlagBits {
	VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x00000001,
	VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineStageFlagBits {
	VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
	VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
	VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
	VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
	VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
	VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
	VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
	VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
	VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
	VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
	VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
	VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
	VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
	VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
	VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
	VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
	VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
	VK_PIPELINE_STAGE_NONE = 0,
	VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000,
	VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000,
	VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000,
	VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 0x00200000,
	VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000,
	VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000,
	VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT = 0x00080000,
	VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT = 0x00100000,
	VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT = 0x00020000,
	VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineStageFlagBits {
	pub const VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV: VkPipelineStageFlagBits = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
	pub const VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV: VkPipelineStageFlagBits = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR;
	pub const VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV: VkPipelineStageFlagBits = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
	pub const VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV: VkPipelineStageFlagBits = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT;
	pub const VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV: VkPipelineStageFlagBits = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT;
	pub const VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV: VkPipelineStageFlagBits = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT;
	pub const VK_PIPELINE_STAGE_NONE_KHR: VkPipelineStageFlagBits = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_NONE;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkMemoryMapFlagBits {
	VK_MEMORY_MAP_PLACED_BIT_EXT = 0x00000001,
	VK_MEMORY_MAP_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSparseMemoryBindFlagBits {
	VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
	VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSparseImageFormatFlagBits {
	VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
	VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
	VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
	VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFenceCreateFlagBits {
	VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
	VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkEventCreateFlagBits {
	VK_EVENT_CREATE_DEVICE_ONLY_BIT = 0x00000001,
	VK_EVENT_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkEventCreateFlagBits {
	pub const VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR: VkEventCreateFlagBits = VkEventCreateFlagBits::VK_EVENT_CREATE_DEVICE_ONLY_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueryPipelineStatisticFlagBits {
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
	VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
	VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
	VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
	VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT = 0x00000800,
	VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT = 0x00001000,
	VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI = 0x00002000,
	VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueryPoolCreateFlagBits {
	VK_QUERY_POOL_CREATE_RESET_BIT_KHR = 0x00000001,
	VK_QUERY_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueryResultFlagBits {
	VK_QUERY_RESULT_64_BIT = 0x00000001,
	VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
	VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
	VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
	VK_QUERY_RESULT_WITH_STATUS_BIT_KHR = 0x00000010,
	VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBufferCreateFlagBits {
	VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
	VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
	VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
	VK_BUFFER_CREATE_PROTECTED_BIT = 0x00000008,
	VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x00000010,
	VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000020,
	VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR = 0x00000040,
	VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkBufferCreateFlagBits {
	pub const VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT: VkBufferCreateFlagBits = VkBufferCreateFlagBits::VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT;
	pub const VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR: VkBufferCreateFlagBits = VkBufferCreateFlagBits::VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBufferUsageFlagBits {
	VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
	VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
	VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
	VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
	VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
	VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
	VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
	VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
	VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
	VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 0x00020000,
	VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00002000,
	VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00004000,
	VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800,
	VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000,
	VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200,
	VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX = 0x02000000,
	VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 0x00080000,
	VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 0x00100000,
	VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = 0x00000400,
	VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00008000,
	VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00010000,
	VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = 0x00200000,
	VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = 0x00400000,
	VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 0x04000000,
	VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 0x00800000,
	VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT = 0x01000000,
	VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM = 0x08000000,
	VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkBufferUsageFlagBits {
	pub const VK_BUFFER_USAGE_RAY_TRACING_BIT_NV: VkBufferUsageFlagBits = VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR;
	pub const VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT: VkBufferUsageFlagBits = VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;
	pub const VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR: VkBufferUsageFlagBits = VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageViewCreateFlagBits {
	VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 0x00000001,
	VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000004,
	VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = 0x00000002,
	VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineCacheCreateFlagBits {
	VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT = 0x00000001,
	VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR = 0x00000008,
	VK_PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineCacheCreateFlagBits {
	pub const VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT: VkPipelineCacheCreateFlagBits = VkPipelineCacheCreateFlagBits::VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkColorComponentFlagBits {
	VK_COLOR_COMPONENT_R_BIT = 0x00000001,
	VK_COLOR_COMPONENT_G_BIT = 0x00000002,
	VK_COLOR_COMPONENT_B_BIT = 0x00000004,
	VK_COLOR_COMPONENT_A_BIT = 0x00000008,
	VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineCreateFlagBits {
	VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
	VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
	VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
	VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x00000008,
	VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = 0x00000010,
	VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 0x00000100,
	VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT = 0x00000200,
	VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT = 0x08000000,
	VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT = 0x40000000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x00004000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x00008000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x00010000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 0x00020000,
	VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 0x00001000,
	VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x00002000,
	VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x00080000,
	VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 0x00000020,
	VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000,
	VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000,
	VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 0x00000040,
	VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080,
	VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x00040000,
	VK_PIPELINE_CREATE_LIBRARY_BIT_KHR = 0x00000800,
	VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 0x20000000,
	VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = 0x00800000,
	VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT = 0x00000400,
	VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV = 0x00100000,
	VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x02000000,
	VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x04000000,
	VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = 0x01000000,
	VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV = 0x10000000,
	VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineCreateFlagBits {
	pub const VK_PIPELINE_CREATE_DISPATCH_BASE: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_BIT;
	pub const VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT;
	pub const VK_PIPELINE_CREATE_DISPATCH_BASE_BIT_KHR: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_BIT;
	pub const VK_PIPELINE_CREATE_DISPATCH_BASE_KHR: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_BIT;
	pub const VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT;
	pub const VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
	pub const VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT;
	pub const VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT;
	pub const VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT;
	pub const VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineShaderStageCreateFlagBits {
	VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = 0x00000001,
	VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = 0x00000002,
	VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineShaderStageCreateFlagBits {
	pub const VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT: VkPipelineShaderStageCreateFlagBits = VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT;
	pub const VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT: VkPipelineShaderStageCreateFlagBits = VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkShaderStageFlagBits {
	VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
	VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
	VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
	VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
	VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
	VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
	VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001f,
	VK_SHADER_STAGE_ALL = 0x7fffffff,
	VK_SHADER_STAGE_RAYGEN_BIT_KHR = 0x00000100,
	VK_SHADER_STAGE_ANY_HIT_BIT_KHR = 0x00000200,
	VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR = 0x00000400,
	VK_SHADER_STAGE_MISS_BIT_KHR = 0x00000800,
	VK_SHADER_STAGE_INTERSECTION_BIT_KHR = 0x00001000,
	VK_SHADER_STAGE_CALLABLE_BIT_KHR = 0x00002000,
	VK_SHADER_STAGE_TASK_BIT_EXT = 0x00000040,
	VK_SHADER_STAGE_MESH_BIT_EXT = 0x00000080,
	VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI = 0x00004000,
	VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI = 0x00080000,
}
impl VkShaderStageFlagBits {
	pub const VK_SHADER_STAGE_RAYGEN_BIT_NV: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_RAYGEN_BIT_KHR;
	pub const VK_SHADER_STAGE_ANY_HIT_BIT_NV: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_ANY_HIT_BIT_KHR;
	pub const VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR;
	pub const VK_SHADER_STAGE_MISS_BIT_NV: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_MISS_BIT_KHR;
	pub const VK_SHADER_STAGE_INTERSECTION_BIT_NV: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_INTERSECTION_BIT_KHR;
	pub const VK_SHADER_STAGE_CALLABLE_BIT_NV: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_CALLABLE_BIT_KHR;
	pub const VK_SHADER_STAGE_TASK_BIT_NV: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_TASK_BIT_EXT;
	pub const VK_SHADER_STAGE_MESH_BIT_NV: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_MESH_BIT_EXT;
	pub const VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_ALL;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCullModeFlagBits {
	VK_CULL_MODE_NONE = 0,
	VK_CULL_MODE_FRONT_BIT = 0x00000001,
	VK_CULL_MODE_BACK_BIT = 0x00000002,
	VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
	VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineDepthStencilStateCreateFlagBits {
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 0x00000001,
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 0x00000002,
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineDepthStencilStateCreateFlagBits {
	pub const VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM: VkPipelineDepthStencilStateCreateFlagBits = VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT;
	pub const VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM: VkPipelineDepthStencilStateCreateFlagBits = VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineColorBlendStateCreateFlagBits {
	VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT = 0x00000001,
	VK_PIPELINE_COLOR_BLEND_STATE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineColorBlendStateCreateFlagBits {
	pub const VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM: VkPipelineColorBlendStateCreateFlagBits = VkPipelineColorBlendStateCreateFlagBits::VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineLayoutCreateFlagBits {
	VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT = 0x00000002,
	VK_PIPELINE_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSamplerCreateFlagBits {
	VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 0x00000001,
	VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 0x00000002,
	VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000008,
	VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT = 0x00000004,
	VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM = 0x00000010,
	VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDescriptorPoolCreateFlagBits {
	VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
	VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = 0x00000002,
	VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT = 0x00000004,
	VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV = 0x00000008,
	VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV = 0x00000010,
	VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkDescriptorPoolCreateFlagBits {
	pub const VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT: VkDescriptorPoolCreateFlagBits = VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT;
	pub const VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE: VkDescriptorPoolCreateFlagBits = VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDescriptorSetLayoutCreateFlagBits {
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 0x00000002,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT = 0x00000001,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 0x00000010,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT = 0x00000020,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x00000080,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT = 0x00000004,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV = 0x00000040,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkDescriptorSetLayoutCreateFlagBits {
	pub const VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR: VkDescriptorSetLayoutCreateFlagBits = VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT;
	pub const VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT: VkDescriptorSetLayoutCreateFlagBits = VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT;
	pub const VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE: VkDescriptorSetLayoutCreateFlagBits = VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAttachmentDescriptionFlagBits {
	VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
	VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDependencyFlagBits {
	VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
	VK_DEPENDENCY_DEVICE_GROUP_BIT = 0x00000004,
	VK_DEPENDENCY_VIEW_LOCAL_BIT = 0x00000002,
	VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = 0x00000008,
	VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR = 0x00000020,
	VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR = 0x00000040,
	VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkDependencyFlagBits {
	pub const VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR: VkDependencyFlagBits = VkDependencyFlagBits::VK_DEPENDENCY_VIEW_LOCAL_BIT;
	pub const VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR: VkDependencyFlagBits = VkDependencyFlagBits::VK_DEPENDENCY_DEVICE_GROUP_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFramebufferCreateFlagBits {
	VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = 0x00000001,
	VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkFramebufferCreateFlagBits {
	pub const VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR: VkFramebufferCreateFlagBits = VkFramebufferCreateFlagBits::VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkRenderPassCreateFlagBits {
	VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = 0x00000002,
	VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE = 0x00000004,
	VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSubpassDescriptionFlagBits {
	VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 0x00000001,
	VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 0x00000002,
	VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM = 0x00000004,
	VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM = 0x00000008,
	VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM = 0x00000100,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT = 0x00000010,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 0x00000020,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 0x00000040,
	VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x00000080,
	VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkSubpassDescriptionFlagBits {
	pub const VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM: VkSubpassDescriptionFlagBits = VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT;
	pub const VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM: VkSubpassDescriptionFlagBits = VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT;
	pub const VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM: VkSubpassDescriptionFlagBits = VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCommandPoolCreateFlagBits {
	VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
	VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
	VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 0x00000004,
	VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCommandPoolResetFlagBits {
	VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
	VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCommandBufferUsageFlagBits {
	VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
	VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
	VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
	VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueryControlFlagBits {
	VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
	VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCommandBufferResetFlagBits {
	VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
	VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkStencilFaceFlagBits {
	VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
	VK_STENCIL_FACE_BACK_BIT = 0x00000002,
	VK_STENCIL_FACE_FRONT_AND_BACK = 0x00000003,
	VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkStencilFaceFlagBits {
	pub const VK_STENCIL_FRONT_AND_BACK: VkStencilFaceFlagBits = VkStencilFaceFlagBits::VK_STENCIL_FACE_FRONT_AND_BACK;
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkClearColorValue {
	pub float32: [f32; 4 as usize],
	pub int32: [i32; 4 as usize],
	pub uint32: [u32; 4 as usize],
}
impl Debug for VkClearColorValue {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClearColorValue")
		.field("float32", unsafe {&self.float32})
		.field("int32", unsafe {&self.int32})
		.field("uint32", unsafe {&self.uint32})
		.finish()
	}
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkClearValue {
	pub color: VkClearColorValue,
	pub depthStencil: VkClearDepthStencilValue,
}
impl Debug for VkClearValue {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClearValue")
		.field("color", unsafe {&self.color})
		.field("depthStencil", unsafe {&self.depthStencil})
		.finish()
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExtent2D {
	pub width: u32,
	pub height: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExtent3D {
	pub width: u32,
	pub height: u32,
	pub depth: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkOffset2D {
	pub x: i32,
	pub y: i32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkOffset3D {
	pub x: i32,
	pub y: i32,
	pub z: i32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRect2D {
	pub offset: VkOffset2D,
	pub extent: VkExtent2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBaseInStructure {
	pub sType: VkStructureType,
	pub pNext: *const VkBaseInStructure,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBaseOutStructure {
	pub sType: VkStructureType,
	pub pNext: *mut VkBaseOutStructure,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBufferMemoryBarrier {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcAccessMask: VkAccessFlags,
	pub dstAccessMask: VkAccessFlags,
	pub srcQueueFamilyIndex: u32,
	pub dstQueueFamilyIndex: u32,
	pub buffer: VkBuffer,
	pub offset: VkDeviceSize,
	pub size: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDispatchIndirectCommand {
	pub x: u32,
	pub y: u32,
	pub z: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDrawIndexedIndirectCommand {
	pub indexCount: u32,
	pub instanceCount: u32,
	pub firstIndex: u32,
	pub vertexOffset: i32,
	pub firstInstance: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDrawIndirectCommand {
	pub vertexCount: u32,
	pub instanceCount: u32,
	pub firstVertex: u32,
	pub firstInstance: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageSubresourceRange {
	pub aspectMask: VkImageAspectFlags,
	pub baseMipLevel: u32,
	pub levelCount: u32,
	pub baseArrayLayer: u32,
	pub layerCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageMemoryBarrier {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcAccessMask: VkAccessFlags,
	pub dstAccessMask: VkAccessFlags,
	pub oldLayout: VkImageLayout,
	pub newLayout: VkImageLayout,
	pub srcQueueFamilyIndex: u32,
	pub dstQueueFamilyIndex: u32,
	pub image: VkImage,
	pub subresourceRange: VkImageSubresourceRange,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryBarrier {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcAccessMask: VkAccessFlags,
	pub dstAccessMask: VkAccessFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineCacheHeaderVersionOne {
	pub headerSize: u32,
	pub headerVersion: VkPipelineCacheHeaderVersion,
	pub vendorID: u32,
	pub deviceID: u32,
	pub pipelineCacheUUID: [u8; VK_UUID_SIZE as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAllocationCallbacks {
	pub pUserData: *mut c_void,
	pub pfnAllocation: PFN_vkAllocationFunction,
	pub pfnReallocation: PFN_vkReallocationFunction,
	pub pfnFree: PFN_vkFreeFunction,
	pub pfnInternalAllocation: PFN_vkInternalAllocationNotification,
	pub pfnInternalFree: PFN_vkInternalFreeNotification,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkApplicationInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pApplicationName: *const i8,
	pub applicationVersion: u32,
	pub pEngineName: *const i8,
	pub engineVersion: u32,
	pub apiVersion: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkFormatProperties {
	pub linearTilingFeatures: VkFormatFeatureFlags,
	pub optimalTilingFeatures: VkFormatFeatureFlags,
	pub bufferFeatures: VkFormatFeatureFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageFormatProperties {
	pub maxExtent: VkExtent3D,
	pub maxMipLevels: u32,
	pub maxArrayLayers: u32,
	pub sampleCounts: VkSampleCountFlags,
	pub maxResourceSize: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkInstanceCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkInstanceCreateFlags,
	pub pApplicationInfo: *const VkApplicationInfo,
	pub enabledLayerCount: u32,
	pub ppEnabledLayerNames: *const *const char,
	pub enabledExtensionCount: u32,
	pub ppEnabledExtensionNames: *const *const char,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryHeap {
	pub size: VkDeviceSize,
	pub flags: VkMemoryHeapFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryType {
	pub propertyFlags: VkMemoryPropertyFlags,
	pub heapIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFeatures {
	pub robustBufferAccess: VkBool32,
	pub fullDrawIndexUint32: VkBool32,
	pub imageCubeArray: VkBool32,
	pub independentBlend: VkBool32,
	pub geometryShader: VkBool32,
	pub tessellationShader: VkBool32,
	pub sampleRateShading: VkBool32,
	pub dualSrcBlend: VkBool32,
	pub logicOp: VkBool32,
	pub multiDrawIndirect: VkBool32,
	pub drawIndirectFirstInstance: VkBool32,
	pub depthClamp: VkBool32,
	pub depthBiasClamp: VkBool32,
	pub fillModeNonSolid: VkBool32,
	pub depthBounds: VkBool32,
	pub wideLines: VkBool32,
	pub largePoints: VkBool32,
	pub alphaToOne: VkBool32,
	pub multiViewport: VkBool32,
	pub samplerAnisotropy: VkBool32,
	pub textureCompressionETC2: VkBool32,
	pub textureCompressionASTC_LDR: VkBool32,
	pub textureCompressionBC: VkBool32,
	pub occlusionQueryPrecise: VkBool32,
	pub pipelineStatisticsQuery: VkBool32,
	pub vertexPipelineStoresAndAtomics: VkBool32,
	pub fragmentStoresAndAtomics: VkBool32,
	pub shaderTessellationAndGeometryPointSize: VkBool32,
	pub shaderImageGatherExtended: VkBool32,
	pub shaderStorageImageExtendedFormats: VkBool32,
	pub shaderStorageImageMultisample: VkBool32,
	pub shaderStorageImageReadWithoutFormat: VkBool32,
	pub shaderStorageImageWriteWithoutFormat: VkBool32,
	pub shaderUniformBufferArrayDynamicIndexing: VkBool32,
	pub shaderSampledImageArrayDynamicIndexing: VkBool32,
	pub shaderStorageBufferArrayDynamicIndexing: VkBool32,
	pub shaderStorageImageArrayDynamicIndexing: VkBool32,
	pub shaderClipDistance: VkBool32,
	pub shaderCullDistance: VkBool32,
	pub shaderFloat64: VkBool32,
	pub shaderInt64: VkBool32,
	pub shaderInt16: VkBool32,
	pub shaderResourceResidency: VkBool32,
	pub shaderResourceMinLod: VkBool32,
	pub sparseBinding: VkBool32,
	pub sparseResidencyBuffer: VkBool32,
	pub sparseResidencyImage2D: VkBool32,
	pub sparseResidencyImage3D: VkBool32,
	pub sparseResidency2Samples: VkBool32,
	pub sparseResidency4Samples: VkBool32,
	pub sparseResidency8Samples: VkBool32,
	pub sparseResidency16Samples: VkBool32,
	pub sparseResidencyAliased: VkBool32,
	pub variableMultisampleRate: VkBool32,
	pub inheritedQueries: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceLimits {
	pub maxImageDimension1D: u32,
	pub maxImageDimension2D: u32,
	pub maxImageDimension3D: u32,
	pub maxImageDimensionCube: u32,
	pub maxImageArrayLayers: u32,
	pub maxTexelBufferElements: u32,
	pub maxUniformBufferRange: u32,
	pub maxStorageBufferRange: u32,
	pub maxPushConstantsSize: u32,
	pub maxMemoryAllocationCount: u32,
	pub maxSamplerAllocationCount: u32,
	pub bufferImageGranularity: VkDeviceSize,
	pub sparseAddressSpaceSize: VkDeviceSize,
	pub maxBoundDescriptorSets: u32,
	pub maxPerStageDescriptorSamplers: u32,
	pub maxPerStageDescriptorUniformBuffers: u32,
	pub maxPerStageDescriptorStorageBuffers: u32,
	pub maxPerStageDescriptorSampledImages: u32,
	pub maxPerStageDescriptorStorageImages: u32,
	pub maxPerStageDescriptorInputAttachments: u32,
	pub maxPerStageResources: u32,
	pub maxDescriptorSetSamplers: u32,
	pub maxDescriptorSetUniformBuffers: u32,
	pub maxDescriptorSetUniformBuffersDynamic: u32,
	pub maxDescriptorSetStorageBuffers: u32,
	pub maxDescriptorSetStorageBuffersDynamic: u32,
	pub maxDescriptorSetSampledImages: u32,
	pub maxDescriptorSetStorageImages: u32,
	pub maxDescriptorSetInputAttachments: u32,
	pub maxVertexInputAttributes: u32,
	pub maxVertexInputBindings: u32,
	pub maxVertexInputAttributeOffset: u32,
	pub maxVertexInputBindingStride: u32,
	pub maxVertexOutputComponents: u32,
	pub maxTessellationGenerationLevel: u32,
	pub maxTessellationPatchSize: u32,
	pub maxTessellationControlPerVertexInputComponents: u32,
	pub maxTessellationControlPerVertexOutputComponents: u32,
	pub maxTessellationControlPerPatchOutputComponents: u32,
	pub maxTessellationControlTotalOutputComponents: u32,
	pub maxTessellationEvaluationInputComponents: u32,
	pub maxTessellationEvaluationOutputComponents: u32,
	pub maxGeometryShaderInvocations: u32,
	pub maxGeometryInputComponents: u32,
	pub maxGeometryOutputComponents: u32,
	pub maxGeometryOutputVertices: u32,
	pub maxGeometryTotalOutputComponents: u32,
	pub maxFragmentInputComponents: u32,
	pub maxFragmentOutputAttachments: u32,
	pub maxFragmentDualSrcAttachments: u32,
	pub maxFragmentCombinedOutputResources: u32,
	pub maxComputeSharedMemorySize: u32,
	pub maxComputeWorkGroupCount: [u32; 3 as usize],
	pub maxComputeWorkGroupInvocations: u32,
	pub maxComputeWorkGroupSize: [u32; 3 as usize],
	pub subPixelPrecisionBits: u32,
	pub subTexelPrecisionBits: u32,
	pub mipmapPrecisionBits: u32,
	pub maxDrawIndexedIndexValue: u32,
	pub maxDrawIndirectCount: u32,
	pub maxSamplerLodBias: f32,
	pub maxSamplerAnisotropy: f32,
	pub maxViewports: u32,
	pub maxViewportDimensions: [u32; 2 as usize],
	pub viewportBoundsRange: [f32; 2 as usize],
	pub viewportSubPixelBits: u32,
	pub minMemoryMapAlignment: usize,
	pub minTexelBufferOffsetAlignment: VkDeviceSize,
	pub minUniformBufferOffsetAlignment: VkDeviceSize,
	pub minStorageBufferOffsetAlignment: VkDeviceSize,
	pub minTexelOffset: i32,
	pub maxTexelOffset: u32,
	pub minTexelGatherOffset: i32,
	pub maxTexelGatherOffset: u32,
	pub minInterpolationOffset: f32,
	pub maxInterpolationOffset: f32,
	pub subPixelInterpolationOffsetBits: u32,
	pub maxFramebufferWidth: u32,
	pub maxFramebufferHeight: u32,
	pub maxFramebufferLayers: u32,
	pub framebufferColorSampleCounts: VkSampleCountFlags,
	pub framebufferDepthSampleCounts: VkSampleCountFlags,
	pub framebufferStencilSampleCounts: VkSampleCountFlags,
	pub framebufferNoAttachmentsSampleCounts: VkSampleCountFlags,
	pub maxColorAttachments: u32,
	pub sampledImageColorSampleCounts: VkSampleCountFlags,
	pub sampledImageIntegerSampleCounts: VkSampleCountFlags,
	pub sampledImageDepthSampleCounts: VkSampleCountFlags,
	pub sampledImageStencilSampleCounts: VkSampleCountFlags,
	pub storageImageSampleCounts: VkSampleCountFlags,
	pub maxSampleMaskWords: u32,
	pub timestampComputeAndGraphics: VkBool32,
	pub timestampPeriod: f32,
	pub maxClipDistances: u32,
	pub maxCullDistances: u32,
	pub maxCombinedClipAndCullDistances: u32,
	pub discreteQueuePriorities: u32,
	pub pointSizeRange: [f32; 2 as usize],
	pub lineWidthRange: [f32; 2 as usize],
	pub pointSizeGranularity: f32,
	pub lineWidthGranularity: f32,
	pub strictLines: VkBool32,
	pub standardSampleLocations: VkBool32,
	pub optimalBufferCopyOffsetAlignment: VkDeviceSize,
	pub optimalBufferCopyRowPitchAlignment: VkDeviceSize,
	pub nonCoherentAtomSize: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMemoryProperties {
	pub memoryTypeCount: u32,
	pub memoryTypes: [VkMemoryType; VK_MAX_MEMORY_TYPES as usize],
	pub memoryHeapCount: u32,
	pub memoryHeaps: [VkMemoryHeap; VK_MAX_MEMORY_HEAPS as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSparseProperties {
	pub residencyStandard2DBlockShape: VkBool32,
	pub residencyStandard2DMultisampleBlockShape: VkBool32,
	pub residencyStandard3DBlockShape: VkBool32,
	pub residencyAlignedMipSize: VkBool32,
	pub residencyNonResidentStrict: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceProperties {
	pub apiVersion: u32,
	pub driverVersion: u32,
	pub vendorID: u32,
	pub deviceID: u32,
	pub deviceType: VkPhysicalDeviceType,
	pub deviceName: [i8; VK_MAX_PHYSICAL_DEVICE_NAME_SIZE as usize],
	pub pipelineCacheUUID: [u8; VK_UUID_SIZE as usize],
	pub limits: VkPhysicalDeviceLimits,
	pub sparseProperties: VkPhysicalDeviceSparseProperties,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkQueueFamilyProperties {
	pub queueFlags: VkQueueFlags,
	pub queueCount: u32,
	pub timestampValidBits: u32,
	pub minImageTransferGranularity: VkExtent3D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceQueueCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDeviceQueueCreateFlags,
	pub queueFamilyIndex: u32,
	pub queueCount: u32,
	pub pQueuePriorities: *const float,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDeviceCreateFlags,
	pub queueCreateInfoCount: u32,
	pub pQueueCreateInfos: *const VkDeviceQueueCreateInfo,
	pub enabledLayerCount: u32,
	pub ppEnabledLayerNames: *const *const char,
	pub enabledExtensionCount: u32,
	pub ppEnabledExtensionNames: *const *const char,
	pub pEnabledFeatures: *const VkPhysicalDeviceFeatures,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExtensionProperties {
	pub extensionName: [i8; VK_MAX_EXTENSION_NAME_SIZE as usize],
	pub specVersion: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkLayerProperties {
	pub layerName: [i8; VK_MAX_EXTENSION_NAME_SIZE as usize],
	pub specVersion: u32,
	pub implementationVersion: u32,
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSubmitInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub waitSemaphoreCount: u32,
	pub pWaitSemaphores: *const VkSemaphore,
	pub pWaitDstStageMask: *const VkPipelineStageFlags,
	pub commandBufferCount: u32,
	pub pCommandBuffers: *const VkCommandBuffer,
	pub signalSemaphoreCount: u32,
	pub pSignalSemaphores: *const VkSemaphore,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMappedMemoryRange {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub memory: VkDeviceMemory,
	pub offset: VkDeviceSize,
	pub size: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryAllocateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub allocationSize: VkDeviceSize,
	pub memoryTypeIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryRequirements {
	pub size: VkDeviceSize,
	pub alignment: VkDeviceSize,
	pub memoryTypeBits: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSparseMemoryBind {
	pub resourceOffset: VkDeviceSize,
	pub size: VkDeviceSize,
	pub memory: VkDeviceMemory,
	pub memoryOffset: VkDeviceSize,
	pub flags: VkSparseMemoryBindFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSparseBufferMemoryBindInfo {
	pub buffer: VkBuffer,
	pub bindCount: u32,
	pub pBinds: *const VkSparseMemoryBind,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSparseImageOpaqueMemoryBindInfo {
	pub image: VkImage,
	pub bindCount: u32,
	pub pBinds: *const VkSparseMemoryBind,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageSubresource {
	pub aspectMask: VkImageAspectFlags,
	pub mipLevel: u32,
	pub arrayLayer: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSparseImageMemoryBind {
	pub subresource: VkImageSubresource,
	pub offset: VkOffset3D,
	pub extent: VkExtent3D,
	pub memory: VkDeviceMemory,
	pub memoryOffset: VkDeviceSize,
	pub flags: VkSparseMemoryBindFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSparseImageMemoryBindInfo {
	pub image: VkImage,
	pub bindCount: u32,
	pub pBinds: *const VkSparseImageMemoryBind,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindSparseInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub waitSemaphoreCount: u32,
	pub pWaitSemaphores: *const VkSemaphore,
	pub bufferBindCount: u32,
	pub pBufferBinds: *const VkSparseBufferMemoryBindInfo,
	pub imageOpaqueBindCount: u32,
	pub pImageOpaqueBinds: *const VkSparseImageOpaqueMemoryBindInfo,
	pub imageBindCount: u32,
	pub pImageBinds: *const VkSparseImageMemoryBindInfo,
	pub signalSemaphoreCount: u32,
	pub pSignalSemaphores: *const VkSemaphore,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSparseImageFormatProperties {
	pub aspectMask: VkImageAspectFlags,
	pub imageGranularity: VkExtent3D,
	pub flags: VkSparseImageFormatFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSparseImageMemoryRequirements {
	pub formatProperties: VkSparseImageFormatProperties,
	pub imageMipTailFirstLod: u32,
	pub imageMipTailSize: VkDeviceSize,
	pub imageMipTailOffset: VkDeviceSize,
	pub imageMipTailStride: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkFenceCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkFenceCreateFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSemaphoreCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkSemaphoreCreateFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkEventCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkEventCreateFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkQueryPoolCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkQueryPoolCreateFlags,
	pub queryType: VkQueryType,
	pub queryCount: u32,
	pub pipelineStatistics: VkQueryPipelineStatisticFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBufferCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkBufferCreateFlags,
	pub size: VkDeviceSize,
	pub usage: VkBufferUsageFlags,
	pub sharingMode: VkSharingMode,
	pub queueFamilyIndexCount: u32,
	pub pQueueFamilyIndices: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBufferViewCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkBufferViewCreateFlags,
	pub buffer: VkBuffer,
	pub format: VkFormat,
	pub offset: VkDeviceSize,
	pub range: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkImageCreateFlags,
	pub imageType: VkImageType,
	pub format: VkFormat,
	pub extent: VkExtent3D,
	pub mipLevels: u32,
	pub arrayLayers: u32,
	pub samples: VkSampleCountFlagBits,
	pub tiling: VkImageTiling,
	pub usage: VkImageUsageFlags,
	pub sharingMode: VkSharingMode,
	pub queueFamilyIndexCount: u32,
	pub pQueueFamilyIndices: *const uint32_t,
	pub initialLayout: VkImageLayout,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSubresourceLayout {
	pub offset: VkDeviceSize,
	pub size: VkDeviceSize,
	pub rowPitch: VkDeviceSize,
	pub arrayPitch: VkDeviceSize,
	pub depthPitch: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkComponentMapping {
	pub r: VkComponentSwizzle,
	pub g: VkComponentSwizzle,
	pub b: VkComponentSwizzle,
	pub a: VkComponentSwizzle,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageViewCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkImageViewCreateFlags,
	pub image: VkImage,
	pub viewType: VkImageViewType,
	pub format: VkFormat,
	pub components: VkComponentMapping,
	pub subresourceRange: VkImageSubresourceRange,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkShaderModuleCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkShaderModuleCreateFlags,
	pub codeSize: usize,
	pub pCode: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineCacheCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCacheCreateFlags,
	pub initialDataSize: usize,
	pub pInitialData: *const c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSpecializationMapEntry {
	pub constantID: u32,
	pub offset: u32,
	pub size: usize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSpecializationInfo {
	pub mapEntryCount: u32,
	pub pMapEntries: *const VkSpecializationMapEntry,
	pub dataSize: usize,
	pub pData: *const c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineShaderStageCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineShaderStageCreateFlags,
	pub stage: VkShaderStageFlagBits,
	pub module: VkShaderModule,
	pub pName: *const i8,
	pub pSpecializationInfo: *const VkSpecializationInfo,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkComputePipelineCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCreateFlags,
	pub stage: VkPipelineShaderStageCreateInfo,
	pub layout: VkPipelineLayout,
	pub basePipelineHandle: VkPipeline,
	pub basePipelineIndex: i32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVertexInputBindingDescription {
	pub binding: u32,
	pub stride: u32,
	pub inputRate: VkVertexInputRate,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVertexInputAttributeDescription {
	pub location: u32,
	pub binding: u32,
	pub format: VkFormat,
	pub offset: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineVertexInputStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineVertexInputStateCreateFlags,
	pub vertexBindingDescriptionCount: u32,
	pub pVertexBindingDescriptions: *const VkVertexInputBindingDescription,
	pub vertexAttributeDescriptionCount: u32,
	pub pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineInputAssemblyStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineInputAssemblyStateCreateFlags,
	pub topology: VkPrimitiveTopology,
	pub primitiveRestartEnable: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineTessellationStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineTessellationStateCreateFlags,
	pub patchControlPoints: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkViewport {
	pub x: f32,
	pub y: f32,
	pub width: f32,
	pub height: f32,
	pub minDepth: f32,
	pub maxDepth: f32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineViewportStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineViewportStateCreateFlags,
	pub viewportCount: u32,
	pub pViewports: *const VkViewport,
	pub scissorCount: u32,
	pub pScissors: *const VkRect2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineRasterizationStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineRasterizationStateCreateFlags,
	pub depthClampEnable: VkBool32,
	pub rasterizerDiscardEnable: VkBool32,
	pub polygonMode: VkPolygonMode,
	pub cullMode: VkCullModeFlags,
	pub frontFace: VkFrontFace,
	pub depthBiasEnable: VkBool32,
	pub depthBiasConstantFactor: f32,
	pub depthBiasClamp: f32,
	pub depthBiasSlopeFactor: f32,
	pub lineWidth: f32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineMultisampleStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineMultisampleStateCreateFlags,
	pub rasterizationSamples: VkSampleCountFlagBits,
	pub sampleShadingEnable: VkBool32,
	pub minSampleShading: f32,
	pub pSampleMask: *const VkSampleMask,
	pub alphaToCoverageEnable: VkBool32,
	pub alphaToOneEnable: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkStencilOpState {
	pub failOp: VkStencilOp,
	pub passOp: VkStencilOp,
	pub depthFailOp: VkStencilOp,
	pub compareOp: VkCompareOp,
	pub compareMask: u32,
	pub writeMask: u32,
	pub reference: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineDepthStencilStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineDepthStencilStateCreateFlags,
	pub depthTestEnable: VkBool32,
	pub depthWriteEnable: VkBool32,
	pub depthCompareOp: VkCompareOp,
	pub depthBoundsTestEnable: VkBool32,
	pub stencilTestEnable: VkBool32,
	pub front: VkStencilOpState,
	pub back: VkStencilOpState,
	pub minDepthBounds: f32,
	pub maxDepthBounds: f32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineColorBlendAttachmentState {
	pub blendEnable: VkBool32,
	pub srcColorBlendFactor: VkBlendFactor,
	pub dstColorBlendFactor: VkBlendFactor,
	pub colorBlendOp: VkBlendOp,
	pub srcAlphaBlendFactor: VkBlendFactor,
	pub dstAlphaBlendFactor: VkBlendFactor,
	pub alphaBlendOp: VkBlendOp,
	pub colorWriteMask: VkColorComponentFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineColorBlendStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineColorBlendStateCreateFlags,
	pub logicOpEnable: VkBool32,
	pub logicOp: VkLogicOp,
	pub attachmentCount: u32,
	pub pAttachments: *const VkPipelineColorBlendAttachmentState,
	pub blendConstants: [f32; 4 as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineDynamicStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineDynamicStateCreateFlags,
	pub dynamicStateCount: u32,
	pub pDynamicStates: *const VkDynamicState,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkGraphicsPipelineCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCreateFlags,
	pub stageCount: u32,
	pub pStages: *const VkPipelineShaderStageCreateInfo,
	pub pVertexInputState: *const VkPipelineVertexInputStateCreateInfo,
	pub pInputAssemblyState: *const VkPipelineInputAssemblyStateCreateInfo,
	pub pTessellationState: *const VkPipelineTessellationStateCreateInfo,
	pub pViewportState: *const VkPipelineViewportStateCreateInfo,
	pub pRasterizationState: *const VkPipelineRasterizationStateCreateInfo,
	pub pMultisampleState: *const VkPipelineMultisampleStateCreateInfo,
	pub pDepthStencilState: *const VkPipelineDepthStencilStateCreateInfo,
	pub pColorBlendState: *const VkPipelineColorBlendStateCreateInfo,
	pub pDynamicState: *const VkPipelineDynamicStateCreateInfo,
	pub layout: VkPipelineLayout,
	pub renderPass: VkRenderPass,
	pub subpass: u32,
	pub basePipelineHandle: VkPipeline,
	pub basePipelineIndex: i32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPushConstantRange {
	pub stageFlags: VkShaderStageFlags,
	pub offset: u32,
	pub size: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineLayoutCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineLayoutCreateFlags,
	pub setLayoutCount: u32,
	pub pSetLayouts: *const VkDescriptorSetLayout,
	pub pushConstantRangeCount: u32,
	pub pPushConstantRanges: *const VkPushConstantRange,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSamplerCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkSamplerCreateFlags,
	pub magFilter: VkFilter,
	pub minFilter: VkFilter,
	pub mipmapMode: VkSamplerMipmapMode,
	pub addressModeU: VkSamplerAddressMode,
	pub addressModeV: VkSamplerAddressMode,
	pub addressModeW: VkSamplerAddressMode,
	pub mipLodBias: f32,
	pub anisotropyEnable: VkBool32,
	pub maxAnisotropy: f32,
	pub compareEnable: VkBool32,
	pub compareOp: VkCompareOp,
	pub minLod: f32,
	pub maxLod: f32,
	pub borderColor: VkBorderColor,
	pub unnormalizedCoordinates: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyDescriptorSet {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcSet: VkDescriptorSet,
	pub srcBinding: u32,
	pub srcArrayElement: u32,
	pub dstSet: VkDescriptorSet,
	pub dstBinding: u32,
	pub dstArrayElement: u32,
	pub descriptorCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorBufferInfo {
	pub buffer: VkBuffer,
	pub offset: VkDeviceSize,
	pub range: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorImageInfo {
	pub sampler: VkSampler,
	pub imageView: VkImageView,
	pub imageLayout: VkImageLayout,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorPoolSize {
	pub type_: VkDescriptorType,
	pub descriptorCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorPoolCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDescriptorPoolCreateFlags,
	pub maxSets: u32,
	pub poolSizeCount: u32,
	pub pPoolSizes: *const VkDescriptorPoolSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorSetAllocateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub descriptorPool: VkDescriptorPool,
	pub descriptorSetCount: u32,
	pub pSetLayouts: *const VkDescriptorSetLayout,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorSetLayoutBinding {
	pub binding: u32,
	pub descriptorType: VkDescriptorType,
	pub descriptorCount: u32,
	pub stageFlags: VkShaderStageFlags,
	pub pImmutableSamplers: *const VkSampler,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorSetLayoutCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDescriptorSetLayoutCreateFlags,
	pub bindingCount: u32,
	pub pBindings: *const VkDescriptorSetLayoutBinding,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkWriteDescriptorSet {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dstSet: VkDescriptorSet,
	pub dstBinding: u32,
	pub dstArrayElement: u32,
	pub descriptorCount: u32,
	pub descriptorType: VkDescriptorType,
	pub pImageInfo: *const VkDescriptorImageInfo,
	pub pBufferInfo: *const VkDescriptorBufferInfo,
	pub pTexelBufferView: *const VkBufferView,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAttachmentDescription {
	pub flags: VkAttachmentDescriptionFlags,
	pub format: VkFormat,
	pub samples: VkSampleCountFlagBits,
	pub loadOp: VkAttachmentLoadOp,
	pub storeOp: VkAttachmentStoreOp,
	pub stencilLoadOp: VkAttachmentLoadOp,
	pub stencilStoreOp: VkAttachmentStoreOp,
	pub initialLayout: VkImageLayout,
	pub finalLayout: VkImageLayout,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAttachmentReference {
	pub attachment: u32,
	pub layout: VkImageLayout,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkFramebufferCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkFramebufferCreateFlags,
	pub renderPass: VkRenderPass,
	pub attachmentCount: u32,
	pub pAttachments: *const VkImageView,
	pub width: u32,
	pub height: u32,
	pub layers: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSubpassDescription {
	pub flags: VkSubpassDescriptionFlags,
	pub pipelineBindPoint: VkPipelineBindPoint,
	pub inputAttachmentCount: u32,
	pub pInputAttachments: *const VkAttachmentReference,
	pub colorAttachmentCount: u32,
	pub pColorAttachments: *const VkAttachmentReference,
	pub pResolveAttachments: *const VkAttachmentReference,
	pub pDepthStencilAttachment: *const VkAttachmentReference,
	pub preserveAttachmentCount: u32,
	pub pPreserveAttachments: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSubpassDependency {
	pub srcSubpass: u32,
	pub dstSubpass: u32,
	pub srcStageMask: VkPipelineStageFlags,
	pub dstStageMask: VkPipelineStageFlags,
	pub srcAccessMask: VkAccessFlags,
	pub dstAccessMask: VkAccessFlags,
	pub dependencyFlags: VkDependencyFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkRenderPassCreateFlags,
	pub attachmentCount: u32,
	pub pAttachments: *const VkAttachmentDescription,
	pub subpassCount: u32,
	pub pSubpasses: *const VkSubpassDescription,
	pub dependencyCount: u32,
	pub pDependencies: *const VkSubpassDependency,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCommandPoolCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkCommandPoolCreateFlags,
	pub queueFamilyIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCommandBufferAllocateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub commandPool: VkCommandPool,
	pub level: VkCommandBufferLevel,
	pub commandBufferCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCommandBufferInheritanceInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub renderPass: VkRenderPass,
	pub subpass: u32,
	pub framebuffer: VkFramebuffer,
	pub occlusionQueryEnable: VkBool32,
	pub queryFlags: VkQueryControlFlags,
	pub pipelineStatistics: VkQueryPipelineStatisticFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCommandBufferBeginInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkCommandBufferUsageFlags,
	pub pInheritanceInfo: *const VkCommandBufferInheritanceInfo,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBufferCopy {
	pub srcOffset: VkDeviceSize,
	pub dstOffset: VkDeviceSize,
	pub size: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageSubresourceLayers {
	pub aspectMask: VkImageAspectFlags,
	pub mipLevel: u32,
	pub baseArrayLayer: u32,
	pub layerCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBufferImageCopy {
	pub bufferOffset: VkDeviceSize,
	pub bufferRowLength: u32,
	pub bufferImageHeight: u32,
	pub imageSubresource: VkImageSubresourceLayers,
	pub imageOffset: VkOffset3D,
	pub imageExtent: VkExtent3D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkClearDepthStencilValue {
	pub depth: f32,
	pub stencil: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkClearAttachment {
	pub aspectMask: VkImageAspectFlags,
	pub colorAttachment: u32,
	pub clearValue: VkClearValue,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkClearRect {
	pub rect: VkRect2D,
	pub baseArrayLayer: u32,
	pub layerCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageBlit {
	pub srcSubresource: VkImageSubresourceLayers,
	pub srcOffsets: [VkOffset3D; 2 as usize],
	pub dstSubresource: VkImageSubresourceLayers,
	pub dstOffsets: [VkOffset3D; 2 as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageCopy {
	pub srcSubresource: VkImageSubresourceLayers,
	pub srcOffset: VkOffset3D,
	pub dstSubresource: VkImageSubresourceLayers,
	pub dstOffset: VkOffset3D,
	pub extent: VkExtent3D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageResolve {
	pub srcSubresource: VkImageSubresourceLayers,
	pub srcOffset: VkOffset3D,
	pub dstSubresource: VkImageSubresourceLayers,
	pub dstOffset: VkOffset3D,
	pub extent: VkExtent3D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassBeginInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub renderPass: VkRenderPass,
	pub framebuffer: VkFramebuffer,
	pub renderArea: VkRect2D,
	pub clearValueCount: u32,
	pub pClearValues: *const VkClearValue,
}
type PFN_vkAllocationFunction = extern "system" fn(pUserData: *mut c_void, size: usize, alignment: usize, allocationScope: VkSystemAllocationScope) -> *mut c_void;
type PFN_vkFreeFunction = extern "system" fn(pUserData: *mut c_void, pMemory: *mut c_void);
type PFN_vkInternalAllocationNotification = extern "system" fn(pUserData: *mut c_void, size: usize, allocationType: VkInternalAllocationType, allocationScope: VkSystemAllocationScope);
type PFN_vkInternalFreeNotification = extern "system" fn(pUserData: *mut c_void, size: usize, allocationType: VkInternalAllocationType, allocationScope: VkSystemAllocationScope);
type PFN_vkReallocationFunction = extern "system" fn(pUserData: *mut c_void, pOriginal: *mut c_void, size: usize, alignment: usize, allocationScope: VkSystemAllocationScope) -> *mut c_void;
type PFN_vkVoidFunction = extern "system" fn();
type PFN_vkCreateInstance = extern "system" fn(pCreateInfo: *const VkInstanceCreateInfo, pAllocator: *const VkAllocationCallbacks, pInstance: *mut VkInstance) -> VkResult;
type PFN_vkDestroyInstance = extern "system" fn(instance: VkInstance, pAllocator: *const VkAllocationCallbacks);
type PFN_vkEnumeratePhysicalDevices = extern "system" fn(instance: VkInstance, pPhysicalDeviceCount: *mut uint32_t, pPhysicalDevices: *mut VkPhysicalDevice) -> VkResult;
type PFN_vkGetPhysicalDeviceFeatures = extern "system" fn(physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures);
type PFN_vkGetPhysicalDeviceFormatProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties);
type PFN_vkGetPhysicalDeviceImageFormatProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, pImageFormatProperties: *mut VkImageFormatProperties) -> VkResult;
type PFN_vkGetPhysicalDeviceProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties);
type PFN_vkGetPhysicalDeviceQueueFamilyProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties);
type PFN_vkGetPhysicalDeviceMemoryProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties);
type PFN_vkGetInstanceProcAddr = extern "system" fn(instance: VkInstance, pName: *const i8) -> PFN_vkVoidFunction;
type PFN_vkGetDeviceProcAddr = extern "system" fn(device: VkDevice, pName: *const i8) -> PFN_vkVoidFunction;
type PFN_vkCreateDevice = extern "system" fn(physicalDevice: VkPhysicalDevice, pCreateInfo: *const VkDeviceCreateInfo, pAllocator: *const VkAllocationCallbacks, pDevice: *mut VkDevice) -> VkResult;
type PFN_vkDestroyDevice = extern "system" fn(device: VkDevice, pAllocator: *const VkAllocationCallbacks);
type PFN_vkEnumerateInstanceExtensionProperties = extern "system" fn(pLayerName: *const i8, pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> VkResult;
type PFN_vkEnumerateDeviceExtensionProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pLayerName: *const i8, pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> VkResult;
type PFN_vkEnumerateInstanceLayerProperties = extern "system" fn(pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> VkResult;
type PFN_vkEnumerateDeviceLayerProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> VkResult;
type PFN_vkGetDeviceQueue = extern "system" fn(device: VkDevice, queueFamilyIndex: u32, queueIndex: u32, pQueue: *mut VkQueue);
type PFN_vkQueueSubmit = extern "system" fn(queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo, fence: VkFence) -> VkResult;
type PFN_vkQueueWaitIdle = extern "system" fn(queue: VkQueue) -> VkResult;
type PFN_vkDeviceWaitIdle = extern "system" fn(device: VkDevice) -> VkResult;
type PFN_vkAllocateMemory = extern "system" fn(device: VkDevice, pAllocateInfo: *const VkMemoryAllocateInfo, pAllocator: *const VkAllocationCallbacks, pMemory: *mut VkDeviceMemory) -> VkResult;
type PFN_vkFreeMemory = extern "system" fn(device: VkDevice, memory: VkDeviceMemory, pAllocator: *const VkAllocationCallbacks);
type PFN_vkMapMemory = extern "system" fn(device: VkDevice, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize, flags: VkMemoryMapFlags, ppData: *mut *mut c_void) -> VkResult;
type PFN_vkUnmapMemory = extern "system" fn(device: VkDevice, memory: VkDeviceMemory);
type PFN_vkFlushMappedMemoryRanges = extern "system" fn(device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *const VkMappedMemoryRange) -> VkResult;
type PFN_vkInvalidateMappedMemoryRanges = extern "system" fn(device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *const VkMappedMemoryRange) -> VkResult;
type PFN_vkGetDeviceMemoryCommitment = extern "system" fn(device: VkDevice, memory: VkDeviceMemory, pCommittedMemoryInBytes: *mut VkDeviceSize);
type PFN_vkBindBufferMemory = extern "system" fn(device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> VkResult;
type PFN_vkBindImageMemory = extern "system" fn(device: VkDevice, image: VkImage, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> VkResult;
type PFN_vkGetBufferMemoryRequirements = extern "system" fn(device: VkDevice, buffer: VkBuffer, pMemoryRequirements: *mut VkMemoryRequirements);
type PFN_vkGetImageMemoryRequirements = extern "system" fn(device: VkDevice, image: VkImage, pMemoryRequirements: *mut VkMemoryRequirements);
type PFN_vkGetImageSparseMemoryRequirements = extern "system" fn(device: VkDevice, image: VkImage, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements);
type PFN_vkGetPhysicalDeviceSparseImageFormatProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties);
type PFN_vkQueueBindSparse = extern "system" fn(queue: VkQueue, bindInfoCount: u32, pBindInfo: *const VkBindSparseInfo, fence: VkFence) -> VkResult;
type PFN_vkCreateFence = extern "system" fn(device: VkDevice, pCreateInfo: *const VkFenceCreateInfo, pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence) -> VkResult;
type PFN_vkDestroyFence = extern "system" fn(device: VkDevice, fence: VkFence, pAllocator: *const VkAllocationCallbacks);
type PFN_vkResetFences = extern "system" fn(device: VkDevice, fenceCount: u32, pFences: *const VkFence) -> VkResult;
type PFN_vkGetFenceStatus = extern "system" fn(device: VkDevice, fence: VkFence) -> VkResult;
type PFN_vkWaitForFences = extern "system" fn(device: VkDevice, fenceCount: u32, pFences: *const VkFence, waitAll: VkBool32, timeout: u64) -> VkResult;
type PFN_vkCreateSemaphore = extern "system" fn(device: VkDevice, pCreateInfo: *const VkSemaphoreCreateInfo, pAllocator: *const VkAllocationCallbacks, pSemaphore: *mut VkSemaphore) -> VkResult;
type PFN_vkDestroySemaphore = extern "system" fn(device: VkDevice, semaphore: VkSemaphore, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCreateEvent = extern "system" fn(device: VkDevice, pCreateInfo: *const VkEventCreateInfo, pAllocator: *const VkAllocationCallbacks, pEvent: *mut VkEvent) -> VkResult;
type PFN_vkDestroyEvent = extern "system" fn(device: VkDevice, event: VkEvent, pAllocator: *const VkAllocationCallbacks);
type PFN_vkGetEventStatus = extern "system" fn(device: VkDevice, event: VkEvent) -> VkResult;
type PFN_vkSetEvent = extern "system" fn(device: VkDevice, event: VkEvent) -> VkResult;
type PFN_vkResetEvent = extern "system" fn(device: VkDevice, event: VkEvent) -> VkResult;
type PFN_vkCreateQueryPool = extern "system" fn(device: VkDevice, pCreateInfo: *const VkQueryPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pQueryPool: *mut VkQueryPool) -> VkResult;
type PFN_vkDestroyQueryPool = extern "system" fn(device: VkDevice, queryPool: VkQueryPool, pAllocator: *const VkAllocationCallbacks);
type PFN_vkGetQueryPoolResults = extern "system" fn(device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dataSize: usize, pData: *mut c_void, stride: VkDeviceSize, flags: VkQueryResultFlags) -> VkResult;
type PFN_vkCreateBuffer = extern "system" fn(device: VkDevice, pCreateInfo: *const VkBufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pBuffer: *mut VkBuffer) -> VkResult;
type PFN_vkDestroyBuffer = extern "system" fn(device: VkDevice, buffer: VkBuffer, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCreateBufferView = extern "system" fn(device: VkDevice, pCreateInfo: *const VkBufferViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkBufferView) -> VkResult;
type PFN_vkDestroyBufferView = extern "system" fn(device: VkDevice, bufferView: VkBufferView, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCreateImage = extern "system" fn(device: VkDevice, pCreateInfo: *const VkImageCreateInfo, pAllocator: *const VkAllocationCallbacks, pImage: *mut VkImage) -> VkResult;
type PFN_vkDestroyImage = extern "system" fn(device: VkDevice, image: VkImage, pAllocator: *const VkAllocationCallbacks);
type PFN_vkGetImageSubresourceLayout = extern "system" fn(device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource, pLayout: *mut VkSubresourceLayout);
type PFN_vkCreateImageView = extern "system" fn(device: VkDevice, pCreateInfo: *const VkImageViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkImageView) -> VkResult;
type PFN_vkDestroyImageView = extern "system" fn(device: VkDevice, imageView: VkImageView, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCreateShaderModule = extern "system" fn(device: VkDevice, pCreateInfo: *const VkShaderModuleCreateInfo, pAllocator: *const VkAllocationCallbacks, pShaderModule: *mut VkShaderModule) -> VkResult;
type PFN_vkDestroyShaderModule = extern "system" fn(device: VkDevice, shaderModule: VkShaderModule, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCreatePipelineCache = extern "system" fn(device: VkDevice, pCreateInfo: *const VkPipelineCacheCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineCache: *mut VkPipelineCache) -> VkResult;
type PFN_vkDestroyPipelineCache = extern "system" fn(device: VkDevice, pipelineCache: VkPipelineCache, pAllocator: *const VkAllocationCallbacks);
type PFN_vkGetPipelineCacheData = extern "system" fn(device: VkDevice, pipelineCache: VkPipelineCache, pDataSize: *mut size_t, pData: *mut c_void) -> VkResult;
type PFN_vkMergePipelineCaches = extern "system" fn(device: VkDevice, dstCache: VkPipelineCache, srcCacheCount: u32, pSrcCaches: *const VkPipelineCache) -> VkResult;
type PFN_vkCreateGraphicsPipelines = extern "system" fn(device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkGraphicsPipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult;
type PFN_vkCreateComputePipelines = extern "system" fn(device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkComputePipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult;
type PFN_vkDestroyPipeline = extern "system" fn(device: VkDevice, pipeline: VkPipeline, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCreatePipelineLayout = extern "system" fn(device: VkDevice, pCreateInfo: *const VkPipelineLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineLayout: *mut VkPipelineLayout) -> VkResult;
type PFN_vkDestroyPipelineLayout = extern "system" fn(device: VkDevice, pipelineLayout: VkPipelineLayout, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCreateSampler = extern "system" fn(device: VkDevice, pCreateInfo: *const VkSamplerCreateInfo, pAllocator: *const VkAllocationCallbacks, pSampler: *mut VkSampler) -> VkResult;
type PFN_vkDestroySampler = extern "system" fn(device: VkDevice, sampler: VkSampler, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCreateDescriptorSetLayout = extern "system" fn(device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pSetLayout: *mut VkDescriptorSetLayout) -> VkResult;
type PFN_vkDestroyDescriptorSetLayout = extern "system" fn(device: VkDevice, descriptorSetLayout: VkDescriptorSetLayout, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCreateDescriptorPool = extern "system" fn(device: VkDevice, pCreateInfo: *const VkDescriptorPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorPool: *mut VkDescriptorPool) -> VkResult;
type PFN_vkDestroyDescriptorPool = extern "system" fn(device: VkDevice, descriptorPool: VkDescriptorPool, pAllocator: *const VkAllocationCallbacks);
type PFN_vkResetDescriptorPool = extern "system" fn(device: VkDevice, descriptorPool: VkDescriptorPool, flags: VkDescriptorPoolResetFlags) -> VkResult;
type PFN_vkAllocateDescriptorSets = extern "system" fn(device: VkDevice, pAllocateInfo: *const VkDescriptorSetAllocateInfo, pDescriptorSets: *mut VkDescriptorSet) -> VkResult;
type PFN_vkFreeDescriptorSets = extern "system" fn(device: VkDevice, descriptorPool: VkDescriptorPool, descriptorSetCount: u32, pDescriptorSets: *const VkDescriptorSet) -> VkResult;
type PFN_vkUpdateDescriptorSets = extern "system" fn(device: VkDevice, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: *const VkCopyDescriptorSet);
type PFN_vkCreateFramebuffer = extern "system" fn(device: VkDevice, pCreateInfo: *const VkFramebufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pFramebuffer: *mut VkFramebuffer) -> VkResult;
type PFN_vkDestroyFramebuffer = extern "system" fn(device: VkDevice, framebuffer: VkFramebuffer, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCreateRenderPass = extern "system" fn(device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult;
type PFN_vkDestroyRenderPass = extern "system" fn(device: VkDevice, renderPass: VkRenderPass, pAllocator: *const VkAllocationCallbacks);
type PFN_vkGetRenderAreaGranularity = extern "system" fn(device: VkDevice, renderPass: VkRenderPass, pGranularity: *mut VkExtent2D);
type PFN_vkCreateCommandPool = extern "system" fn(device: VkDevice, pCreateInfo: *const VkCommandPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pCommandPool: *mut VkCommandPool) -> VkResult;
type PFN_vkDestroyCommandPool = extern "system" fn(device: VkDevice, commandPool: VkCommandPool, pAllocator: *const VkAllocationCallbacks);
type PFN_vkResetCommandPool = extern "system" fn(device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolResetFlags) -> VkResult;
type PFN_vkAllocateCommandBuffers = extern "system" fn(device: VkDevice, pAllocateInfo: *const VkCommandBufferAllocateInfo, pCommandBuffers: *mut VkCommandBuffer) -> VkResult;
type PFN_vkFreeCommandBuffers = extern "system" fn(device: VkDevice, commandPool: VkCommandPool, commandBufferCount: u32, pCommandBuffers: *const VkCommandBuffer);
type PFN_vkBeginCommandBuffer = extern "system" fn(commandBuffer: VkCommandBuffer, pBeginInfo: *const VkCommandBufferBeginInfo) -> VkResult;
type PFN_vkEndCommandBuffer = extern "system" fn(commandBuffer: VkCommandBuffer) -> VkResult;
type PFN_vkResetCommandBuffer = extern "system" fn(commandBuffer: VkCommandBuffer, flags: VkCommandBufferResetFlags) -> VkResult;
type PFN_vkCmdBindPipeline = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline);
type PFN_vkCmdSetViewport = extern "system" fn(commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: *const VkViewport);
type PFN_vkCmdSetScissor = extern "system" fn(commandBuffer: VkCommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: *const VkRect2D);
type PFN_vkCmdSetLineWidth = extern "system" fn(commandBuffer: VkCommandBuffer, lineWidth: f32);
type PFN_vkCmdSetDepthBias = extern "system" fn(commandBuffer: VkCommandBuffer, depthBiasConstantFactor: f32, depthBiasClamp: f32, depthBiasSlopeFactor: f32);
type PFN_vkCmdSetBlendConstants = extern "system" fn(commandBuffer: VkCommandBuffer, blendConstants: &[float; 4 as usize]);
type PFN_vkCmdSetDepthBounds = extern "system" fn(commandBuffer: VkCommandBuffer, minDepthBounds: f32, maxDepthBounds: f32);
type PFN_vkCmdSetStencilCompareMask = extern "system" fn(commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, compareMask: u32);
type PFN_vkCmdSetStencilWriteMask = extern "system" fn(commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, writeMask: u32);
type PFN_vkCmdSetStencilReference = extern "system" fn(commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, reference: u32);
type PFN_vkCmdBindDescriptorSets = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: *const VkDescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: *const uint32_t);
type PFN_vkCmdBindIndexBuffer = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, indexType: VkIndexType);
type PFN_vkCmdBindVertexBuffers = extern "system" fn(commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize);
type PFN_vkCmdDraw = extern "system" fn(commandBuffer: VkCommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32);
type PFN_vkCmdDrawIndexed = extern "system" fn(commandBuffer: VkCommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: i32, firstInstance: u32);
type PFN_vkCmdDrawIndirect = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32);
type PFN_vkCmdDrawIndexedIndirect = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32);
type PFN_vkCmdDispatch = extern "system" fn(commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32);
type PFN_vkCmdDispatchIndirect = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize);
type PFN_vkCmdCopyBuffer = extern "system" fn(commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstBuffer: VkBuffer, regionCount: u32, pRegions: *const VkBufferCopy);
type PFN_vkCmdCopyImage = extern "system" fn(commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageCopy);
type PFN_vkCmdBlitImage = extern "system" fn(commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageBlit, filter: VkFilter);
type PFN_vkCmdCopyBufferToImage = extern "system" fn(commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkBufferImageCopy);
type PFN_vkCmdCopyImageToBuffer = extern "system" fn(commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstBuffer: VkBuffer, regionCount: u32, pRegions: *const VkBufferImageCopy);
type PFN_vkCmdUpdateBuffer = extern "system" fn(commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, dataSize: VkDeviceSize, pData: *const c_void);
type PFN_vkCmdFillBuffer = extern "system" fn(commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, size: VkDeviceSize, data: u32);
type PFN_vkCmdClearColorImage = extern "system" fn(commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pColor: *const VkClearColorValue, rangeCount: u32, pRanges: *const VkImageSubresourceRange);
type PFN_vkCmdClearDepthStencilImage = extern "system" fn(commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pDepthStencil: *const VkClearDepthStencilValue, rangeCount: u32, pRanges: *const VkImageSubresourceRange);
type PFN_vkCmdClearAttachments = extern "system" fn(commandBuffer: VkCommandBuffer, attachmentCount: u32, pAttachments: *const VkClearAttachment, rectCount: u32, pRects: *const VkClearRect);
type PFN_vkCmdResolveImage = extern "system" fn(commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageResolve);
type PFN_vkCmdSetEvent = extern "system" fn(commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags);
type PFN_vkCmdResetEvent = extern "system" fn(commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags);
type PFN_vkCmdWaitEvents = extern "system" fn(commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const VkImageMemoryBarrier);
type PFN_vkCmdPipelineBarrier = extern "system" fn(commandBuffer: VkCommandBuffer, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, dependencyFlags: VkDependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const VkImageMemoryBarrier);
type PFN_vkCmdBeginQuery = extern "system" fn(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags);
type PFN_vkCmdEndQuery = extern "system" fn(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32);
type PFN_vkCmdResetQueryPool = extern "system" fn(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32);
type PFN_vkCmdWriteTimestamp = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, queryPool: VkQueryPool, query: u32);
type PFN_vkCmdCopyQueryPoolResults = extern "system" fn(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, stride: VkDeviceSize, flags: VkQueryResultFlags);
type PFN_vkCmdPushConstants = extern "system" fn(commandBuffer: VkCommandBuffer, layout: VkPipelineLayout, stageFlags: VkShaderStageFlags, offset: u32, size: u32, pValues: *const c_void);
type PFN_vkCmdBeginRenderPass = extern "system" fn(commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, contents: VkSubpassContents);
type PFN_vkCmdNextSubpass = extern "system" fn(commandBuffer: VkCommandBuffer, contents: VkSubpassContents);
type PFN_vkCmdEndRenderPass = extern "system" fn(commandBuffer: VkCommandBuffer);
type PFN_vkCmdExecuteCommands = extern "system" fn(commandBuffer: VkCommandBuffer, commandBufferCount: u32, pCommandBuffers: *const VkCommandBuffer);
extern "system" fn dummy_vkCreateInstance(_: *const VkInstanceCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkInstance) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateInstance()` is NULL");
}
extern "system" fn dummy_vkDestroyInstance(_: VkInstance, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyInstance()` is NULL");
}
extern "system" fn dummy_vkEnumeratePhysicalDevices(_: VkInstance, _: *mut uint32_t, _: *mut VkPhysicalDevice) -> VkResult {
	panic!("Vulkan function pointer of `vkEnumeratePhysicalDevices()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceFeatures(_: VkPhysicalDevice, _: *mut VkPhysicalDeviceFeatures) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceFeatures()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceFormatProperties(_: VkPhysicalDevice, _: VkFormat, _: *mut VkFormatProperties) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceFormatProperties()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceImageFormatProperties(_: VkPhysicalDevice, _: VkFormat, _: VkImageType, _: VkImageTiling, _: VkImageUsageFlags, _: VkImageCreateFlags, _: *mut VkImageFormatProperties) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceImageFormatProperties()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceProperties(_: VkPhysicalDevice, _: *mut VkPhysicalDeviceProperties) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceProperties()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceQueueFamilyProperties(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkQueueFamilyProperties) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceQueueFamilyProperties()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceMemoryProperties(_: VkPhysicalDevice, _: *mut VkPhysicalDeviceMemoryProperties) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceMemoryProperties()` is NULL");
}
extern "system" fn dummy_vkGetInstanceProcAddr(_: VkInstance, _: *const i8) -> PFN_vkVoidFunction {
	panic!("Vulkan function pointer of `vkGetInstanceProcAddr()` is NULL");
}
extern "system" fn dummy_vkGetDeviceProcAddr(_: VkDevice, _: *const i8) -> PFN_vkVoidFunction {
	panic!("Vulkan function pointer of `vkGetDeviceProcAddr()` is NULL");
}
extern "system" fn dummy_vkCreateDevice(_: VkPhysicalDevice, _: *const VkDeviceCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkDevice) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateDevice()` is NULL");
}
extern "system" fn dummy_vkDestroyDevice(_: VkDevice, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyDevice()` is NULL");
}
extern "system" fn dummy_vkEnumerateInstanceExtensionProperties(_: *const i8, _: *mut uint32_t, _: *mut VkExtensionProperties) -> VkResult {
	panic!("Vulkan function pointer of `vkEnumerateInstanceExtensionProperties()` is NULL");
}
extern "system" fn dummy_vkEnumerateDeviceExtensionProperties(_: VkPhysicalDevice, _: *const i8, _: *mut uint32_t, _: *mut VkExtensionProperties) -> VkResult {
	panic!("Vulkan function pointer of `vkEnumerateDeviceExtensionProperties()` is NULL");
}
extern "system" fn dummy_vkEnumerateInstanceLayerProperties(_: *mut uint32_t, _: *mut VkLayerProperties) -> VkResult {
	panic!("Vulkan function pointer of `vkEnumerateInstanceLayerProperties()` is NULL");
}
extern "system" fn dummy_vkEnumerateDeviceLayerProperties(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkLayerProperties) -> VkResult {
	panic!("Vulkan function pointer of `vkEnumerateDeviceLayerProperties()` is NULL");
}
extern "system" fn dummy_vkGetDeviceQueue(_: VkDevice, _: u32, _: u32, _: *mut VkQueue) {
	panic!("Vulkan function pointer of `vkGetDeviceQueue()` is NULL");
}
extern "system" fn dummy_vkQueueSubmit(_: VkQueue, _: u32, _: *const VkSubmitInfo, _: VkFence) -> VkResult {
	panic!("Vulkan function pointer of `vkQueueSubmit()` is NULL");
}
extern "system" fn dummy_vkQueueWaitIdle(_: VkQueue) -> VkResult {
	panic!("Vulkan function pointer of `vkQueueWaitIdle()` is NULL");
}
extern "system" fn dummy_vkDeviceWaitIdle(_: VkDevice) -> VkResult {
	panic!("Vulkan function pointer of `vkDeviceWaitIdle()` is NULL");
}
extern "system" fn dummy_vkAllocateMemory(_: VkDevice, _: *const VkMemoryAllocateInfo, _: *const VkAllocationCallbacks, _: *mut VkDeviceMemory) -> VkResult {
	panic!("Vulkan function pointer of `vkAllocateMemory()` is NULL");
}
extern "system" fn dummy_vkFreeMemory(_: VkDevice, _: VkDeviceMemory, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkFreeMemory()` is NULL");
}
extern "system" fn dummy_vkMapMemory(_: VkDevice, _: VkDeviceMemory, _: VkDeviceSize, _: VkDeviceSize, _: VkMemoryMapFlags, _: *mut *mut c_void) -> VkResult {
	panic!("Vulkan function pointer of `vkMapMemory()` is NULL");
}
extern "system" fn dummy_vkUnmapMemory(_: VkDevice, _: VkDeviceMemory) {
	panic!("Vulkan function pointer of `vkUnmapMemory()` is NULL");
}
extern "system" fn dummy_vkFlushMappedMemoryRanges(_: VkDevice, _: u32, _: *const VkMappedMemoryRange) -> VkResult {
	panic!("Vulkan function pointer of `vkFlushMappedMemoryRanges()` is NULL");
}
extern "system" fn dummy_vkInvalidateMappedMemoryRanges(_: VkDevice, _: u32, _: *const VkMappedMemoryRange) -> VkResult {
	panic!("Vulkan function pointer of `vkInvalidateMappedMemoryRanges()` is NULL");
}
extern "system" fn dummy_vkGetDeviceMemoryCommitment(_: VkDevice, _: VkDeviceMemory, _: *mut VkDeviceSize) {
	panic!("Vulkan function pointer of `vkGetDeviceMemoryCommitment()` is NULL");
}
extern "system" fn dummy_vkBindBufferMemory(_: VkDevice, _: VkBuffer, _: VkDeviceMemory, _: VkDeviceSize) -> VkResult {
	panic!("Vulkan function pointer of `vkBindBufferMemory()` is NULL");
}
extern "system" fn dummy_vkBindImageMemory(_: VkDevice, _: VkImage, _: VkDeviceMemory, _: VkDeviceSize) -> VkResult {
	panic!("Vulkan function pointer of `vkBindImageMemory()` is NULL");
}
extern "system" fn dummy_vkGetBufferMemoryRequirements(_: VkDevice, _: VkBuffer, _: *mut VkMemoryRequirements) {
	panic!("Vulkan function pointer of `vkGetBufferMemoryRequirements()` is NULL");
}
extern "system" fn dummy_vkGetImageMemoryRequirements(_: VkDevice, _: VkImage, _: *mut VkMemoryRequirements) {
	panic!("Vulkan function pointer of `vkGetImageMemoryRequirements()` is NULL");
}
extern "system" fn dummy_vkGetImageSparseMemoryRequirements(_: VkDevice, _: VkImage, _: *mut uint32_t, _: *mut VkSparseImageMemoryRequirements) {
	panic!("Vulkan function pointer of `vkGetImageSparseMemoryRequirements()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceSparseImageFormatProperties(_: VkPhysicalDevice, _: VkFormat, _: VkImageType, _: VkSampleCountFlagBits, _: VkImageUsageFlags, _: VkImageTiling, _: *mut uint32_t, _: *mut VkSparseImageFormatProperties) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceSparseImageFormatProperties()` is NULL");
}
extern "system" fn dummy_vkQueueBindSparse(_: VkQueue, _: u32, _: *const VkBindSparseInfo, _: VkFence) -> VkResult {
	panic!("Vulkan function pointer of `vkQueueBindSparse()` is NULL");
}
extern "system" fn dummy_vkCreateFence(_: VkDevice, _: *const VkFenceCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkFence) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateFence()` is NULL");
}
extern "system" fn dummy_vkDestroyFence(_: VkDevice, _: VkFence, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyFence()` is NULL");
}
extern "system" fn dummy_vkResetFences(_: VkDevice, _: u32, _: *const VkFence) -> VkResult {
	panic!("Vulkan function pointer of `vkResetFences()` is NULL");
}
extern "system" fn dummy_vkGetFenceStatus(_: VkDevice, _: VkFence) -> VkResult {
	panic!("Vulkan function pointer of `vkGetFenceStatus()` is NULL");
}
extern "system" fn dummy_vkWaitForFences(_: VkDevice, _: u32, _: *const VkFence, _: VkBool32, _: u64) -> VkResult {
	panic!("Vulkan function pointer of `vkWaitForFences()` is NULL");
}
extern "system" fn dummy_vkCreateSemaphore(_: VkDevice, _: *const VkSemaphoreCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkSemaphore) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateSemaphore()` is NULL");
}
extern "system" fn dummy_vkDestroySemaphore(_: VkDevice, _: VkSemaphore, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroySemaphore()` is NULL");
}
extern "system" fn dummy_vkCreateEvent(_: VkDevice, _: *const VkEventCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkEvent) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateEvent()` is NULL");
}
extern "system" fn dummy_vkDestroyEvent(_: VkDevice, _: VkEvent, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyEvent()` is NULL");
}
extern "system" fn dummy_vkGetEventStatus(_: VkDevice, _: VkEvent) -> VkResult {
	panic!("Vulkan function pointer of `vkGetEventStatus()` is NULL");
}
extern "system" fn dummy_vkSetEvent(_: VkDevice, _: VkEvent) -> VkResult {
	panic!("Vulkan function pointer of `vkSetEvent()` is NULL");
}
extern "system" fn dummy_vkResetEvent(_: VkDevice, _: VkEvent) -> VkResult {
	panic!("Vulkan function pointer of `vkResetEvent()` is NULL");
}
extern "system" fn dummy_vkCreateQueryPool(_: VkDevice, _: *const VkQueryPoolCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkQueryPool) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateQueryPool()` is NULL");
}
extern "system" fn dummy_vkDestroyQueryPool(_: VkDevice, _: VkQueryPool, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyQueryPool()` is NULL");
}
extern "system" fn dummy_vkGetQueryPoolResults(_: VkDevice, _: VkQueryPool, _: u32, _: u32, _: usize, _: *mut c_void, _: VkDeviceSize, _: VkQueryResultFlags) -> VkResult {
	panic!("Vulkan function pointer of `vkGetQueryPoolResults()` is NULL");
}
extern "system" fn dummy_vkCreateBuffer(_: VkDevice, _: *const VkBufferCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkBuffer) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateBuffer()` is NULL");
}
extern "system" fn dummy_vkDestroyBuffer(_: VkDevice, _: VkBuffer, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyBuffer()` is NULL");
}
extern "system" fn dummy_vkCreateBufferView(_: VkDevice, _: *const VkBufferViewCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkBufferView) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateBufferView()` is NULL");
}
extern "system" fn dummy_vkDestroyBufferView(_: VkDevice, _: VkBufferView, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyBufferView()` is NULL");
}
extern "system" fn dummy_vkCreateImage(_: VkDevice, _: *const VkImageCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkImage) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateImage()` is NULL");
}
extern "system" fn dummy_vkDestroyImage(_: VkDevice, _: VkImage, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyImage()` is NULL");
}
extern "system" fn dummy_vkGetImageSubresourceLayout(_: VkDevice, _: VkImage, _: *const VkImageSubresource, _: *mut VkSubresourceLayout) {
	panic!("Vulkan function pointer of `vkGetImageSubresourceLayout()` is NULL");
}
extern "system" fn dummy_vkCreateImageView(_: VkDevice, _: *const VkImageViewCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkImageView) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateImageView()` is NULL");
}
extern "system" fn dummy_vkDestroyImageView(_: VkDevice, _: VkImageView, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyImageView()` is NULL");
}
extern "system" fn dummy_vkCreateShaderModule(_: VkDevice, _: *const VkShaderModuleCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkShaderModule) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateShaderModule()` is NULL");
}
extern "system" fn dummy_vkDestroyShaderModule(_: VkDevice, _: VkShaderModule, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyShaderModule()` is NULL");
}
extern "system" fn dummy_vkCreatePipelineCache(_: VkDevice, _: *const VkPipelineCacheCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkPipelineCache) -> VkResult {
	panic!("Vulkan function pointer of `vkCreatePipelineCache()` is NULL");
}
extern "system" fn dummy_vkDestroyPipelineCache(_: VkDevice, _: VkPipelineCache, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyPipelineCache()` is NULL");
}
extern "system" fn dummy_vkGetPipelineCacheData(_: VkDevice, _: VkPipelineCache, _: *mut size_t, _: *mut c_void) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPipelineCacheData()` is NULL");
}
extern "system" fn dummy_vkMergePipelineCaches(_: VkDevice, _: VkPipelineCache, _: u32, _: *const VkPipelineCache) -> VkResult {
	panic!("Vulkan function pointer of `vkMergePipelineCaches()` is NULL");
}
extern "system" fn dummy_vkCreateGraphicsPipelines(_: VkDevice, _: VkPipelineCache, _: u32, _: *const VkGraphicsPipelineCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkPipeline) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateGraphicsPipelines()` is NULL");
}
extern "system" fn dummy_vkCreateComputePipelines(_: VkDevice, _: VkPipelineCache, _: u32, _: *const VkComputePipelineCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkPipeline) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateComputePipelines()` is NULL");
}
extern "system" fn dummy_vkDestroyPipeline(_: VkDevice, _: VkPipeline, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyPipeline()` is NULL");
}
extern "system" fn dummy_vkCreatePipelineLayout(_: VkDevice, _: *const VkPipelineLayoutCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkPipelineLayout) -> VkResult {
	panic!("Vulkan function pointer of `vkCreatePipelineLayout()` is NULL");
}
extern "system" fn dummy_vkDestroyPipelineLayout(_: VkDevice, _: VkPipelineLayout, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyPipelineLayout()` is NULL");
}
extern "system" fn dummy_vkCreateSampler(_: VkDevice, _: *const VkSamplerCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkSampler) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateSampler()` is NULL");
}
extern "system" fn dummy_vkDestroySampler(_: VkDevice, _: VkSampler, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroySampler()` is NULL");
}
extern "system" fn dummy_vkCreateDescriptorSetLayout(_: VkDevice, _: *const VkDescriptorSetLayoutCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkDescriptorSetLayout) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateDescriptorSetLayout()` is NULL");
}
extern "system" fn dummy_vkDestroyDescriptorSetLayout(_: VkDevice, _: VkDescriptorSetLayout, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyDescriptorSetLayout()` is NULL");
}
extern "system" fn dummy_vkCreateDescriptorPool(_: VkDevice, _: *const VkDescriptorPoolCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkDescriptorPool) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateDescriptorPool()` is NULL");
}
extern "system" fn dummy_vkDestroyDescriptorPool(_: VkDevice, _: VkDescriptorPool, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyDescriptorPool()` is NULL");
}
extern "system" fn dummy_vkResetDescriptorPool(_: VkDevice, _: VkDescriptorPool, _: VkDescriptorPoolResetFlags) -> VkResult {
	panic!("Vulkan function pointer of `vkResetDescriptorPool()` is NULL");
}
extern "system" fn dummy_vkAllocateDescriptorSets(_: VkDevice, _: *const VkDescriptorSetAllocateInfo, _: *mut VkDescriptorSet) -> VkResult {
	panic!("Vulkan function pointer of `vkAllocateDescriptorSets()` is NULL");
}
extern "system" fn dummy_vkFreeDescriptorSets(_: VkDevice, _: VkDescriptorPool, _: u32, _: *const VkDescriptorSet) -> VkResult {
	panic!("Vulkan function pointer of `vkFreeDescriptorSets()` is NULL");
}
extern "system" fn dummy_vkUpdateDescriptorSets(_: VkDevice, _: u32, _: *const VkWriteDescriptorSet, _: u32, _: *const VkCopyDescriptorSet) {
	panic!("Vulkan function pointer of `vkUpdateDescriptorSets()` is NULL");
}
extern "system" fn dummy_vkCreateFramebuffer(_: VkDevice, _: *const VkFramebufferCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkFramebuffer) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateFramebuffer()` is NULL");
}
extern "system" fn dummy_vkDestroyFramebuffer(_: VkDevice, _: VkFramebuffer, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyFramebuffer()` is NULL");
}
extern "system" fn dummy_vkCreateRenderPass(_: VkDevice, _: *const VkRenderPassCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkRenderPass) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateRenderPass()` is NULL");
}
extern "system" fn dummy_vkDestroyRenderPass(_: VkDevice, _: VkRenderPass, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyRenderPass()` is NULL");
}
extern "system" fn dummy_vkGetRenderAreaGranularity(_: VkDevice, _: VkRenderPass, _: *mut VkExtent2D) {
	panic!("Vulkan function pointer of `vkGetRenderAreaGranularity()` is NULL");
}
extern "system" fn dummy_vkCreateCommandPool(_: VkDevice, _: *const VkCommandPoolCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkCommandPool) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateCommandPool()` is NULL");
}
extern "system" fn dummy_vkDestroyCommandPool(_: VkDevice, _: VkCommandPool, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyCommandPool()` is NULL");
}
extern "system" fn dummy_vkResetCommandPool(_: VkDevice, _: VkCommandPool, _: VkCommandPoolResetFlags) -> VkResult {
	panic!("Vulkan function pointer of `vkResetCommandPool()` is NULL");
}
extern "system" fn dummy_vkAllocateCommandBuffers(_: VkDevice, _: *const VkCommandBufferAllocateInfo, _: *mut VkCommandBuffer) -> VkResult {
	panic!("Vulkan function pointer of `vkAllocateCommandBuffers()` is NULL");
}
extern "system" fn dummy_vkFreeCommandBuffers(_: VkDevice, _: VkCommandPool, _: u32, _: *const VkCommandBuffer) {
	panic!("Vulkan function pointer of `vkFreeCommandBuffers()` is NULL");
}
extern "system" fn dummy_vkBeginCommandBuffer(_: VkCommandBuffer, _: *const VkCommandBufferBeginInfo) -> VkResult {
	panic!("Vulkan function pointer of `vkBeginCommandBuffer()` is NULL");
}
extern "system" fn dummy_vkEndCommandBuffer(_: VkCommandBuffer) -> VkResult {
	panic!("Vulkan function pointer of `vkEndCommandBuffer()` is NULL");
}
extern "system" fn dummy_vkResetCommandBuffer(_: VkCommandBuffer, _: VkCommandBufferResetFlags) -> VkResult {
	panic!("Vulkan function pointer of `vkResetCommandBuffer()` is NULL");
}
extern "system" fn dummy_vkCmdBindPipeline(_: VkCommandBuffer, _: VkPipelineBindPoint, _: VkPipeline) {
	panic!("Vulkan function pointer of `vkCmdBindPipeline()` is NULL");
}
extern "system" fn dummy_vkCmdSetViewport(_: VkCommandBuffer, _: u32, _: u32, _: *const VkViewport) {
	panic!("Vulkan function pointer of `vkCmdSetViewport()` is NULL");
}
extern "system" fn dummy_vkCmdSetScissor(_: VkCommandBuffer, _: u32, _: u32, _: *const VkRect2D) {
	panic!("Vulkan function pointer of `vkCmdSetScissor()` is NULL");
}
extern "system" fn dummy_vkCmdSetLineWidth(_: VkCommandBuffer, _: f32) {
	panic!("Vulkan function pointer of `vkCmdSetLineWidth()` is NULL");
}
extern "system" fn dummy_vkCmdSetDepthBias(_: VkCommandBuffer, _: f32, _: f32, _: f32) {
	panic!("Vulkan function pointer of `vkCmdSetDepthBias()` is NULL");
}
extern "system" fn dummy_vkCmdSetBlendConstants(_: VkCommandBuffer, _: &[float; 4 as usize]) {
	panic!("Vulkan function pointer of `vkCmdSetBlendConstants()` is NULL");
}
extern "system" fn dummy_vkCmdSetDepthBounds(_: VkCommandBuffer, _: f32, _: f32) {
	panic!("Vulkan function pointer of `vkCmdSetDepthBounds()` is NULL");
}
extern "system" fn dummy_vkCmdSetStencilCompareMask(_: VkCommandBuffer, _: VkStencilFaceFlags, _: u32) {
	panic!("Vulkan function pointer of `vkCmdSetStencilCompareMask()` is NULL");
}
extern "system" fn dummy_vkCmdSetStencilWriteMask(_: VkCommandBuffer, _: VkStencilFaceFlags, _: u32) {
	panic!("Vulkan function pointer of `vkCmdSetStencilWriteMask()` is NULL");
}
extern "system" fn dummy_vkCmdSetStencilReference(_: VkCommandBuffer, _: VkStencilFaceFlags, _: u32) {
	panic!("Vulkan function pointer of `vkCmdSetStencilReference()` is NULL");
}
extern "system" fn dummy_vkCmdBindDescriptorSets(_: VkCommandBuffer, _: VkPipelineBindPoint, _: VkPipelineLayout, _: u32, _: u32, _: *const VkDescriptorSet, _: u32, _: *const uint32_t) {
	panic!("Vulkan function pointer of `vkCmdBindDescriptorSets()` is NULL");
}
extern "system" fn dummy_vkCmdBindIndexBuffer(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkIndexType) {
	panic!("Vulkan function pointer of `vkCmdBindIndexBuffer()` is NULL");
}
extern "system" fn dummy_vkCmdBindVertexBuffers(_: VkCommandBuffer, _: u32, _: u32, _: *const VkBuffer, _: *const VkDeviceSize) {
	panic!("Vulkan function pointer of `vkCmdBindVertexBuffers()` is NULL");
}
extern "system" fn dummy_vkCmdDraw(_: VkCommandBuffer, _: u32, _: u32, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdDraw()` is NULL");
}
extern "system" fn dummy_vkCmdDrawIndexed(_: VkCommandBuffer, _: u32, _: u32, _: u32, _: i32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdDrawIndexed()` is NULL");
}
extern "system" fn dummy_vkCmdDrawIndirect(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdDrawIndirect()` is NULL");
}
extern "system" fn dummy_vkCmdDrawIndexedIndirect(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdDrawIndexedIndirect()` is NULL");
}
extern "system" fn dummy_vkCmdDispatch(_: VkCommandBuffer, _: u32, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdDispatch()` is NULL");
}
extern "system" fn dummy_vkCmdDispatchIndirect(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize) {
	panic!("Vulkan function pointer of `vkCmdDispatchIndirect()` is NULL");
}
extern "system" fn dummy_vkCmdCopyBuffer(_: VkCommandBuffer, _: VkBuffer, _: VkBuffer, _: u32, _: *const VkBufferCopy) {
	panic!("Vulkan function pointer of `vkCmdCopyBuffer()` is NULL");
}
extern "system" fn dummy_vkCmdCopyImage(_: VkCommandBuffer, _: VkImage, _: VkImageLayout, _: VkImage, _: VkImageLayout, _: u32, _: *const VkImageCopy) {
	panic!("Vulkan function pointer of `vkCmdCopyImage()` is NULL");
}
extern "system" fn dummy_vkCmdBlitImage(_: VkCommandBuffer, _: VkImage, _: VkImageLayout, _: VkImage, _: VkImageLayout, _: u32, _: *const VkImageBlit, _: VkFilter) {
	panic!("Vulkan function pointer of `vkCmdBlitImage()` is NULL");
}
extern "system" fn dummy_vkCmdCopyBufferToImage(_: VkCommandBuffer, _: VkBuffer, _: VkImage, _: VkImageLayout, _: u32, _: *const VkBufferImageCopy) {
	panic!("Vulkan function pointer of `vkCmdCopyBufferToImage()` is NULL");
}
extern "system" fn dummy_vkCmdCopyImageToBuffer(_: VkCommandBuffer, _: VkImage, _: VkImageLayout, _: VkBuffer, _: u32, _: *const VkBufferImageCopy) {
	panic!("Vulkan function pointer of `vkCmdCopyImageToBuffer()` is NULL");
}
extern "system" fn dummy_vkCmdUpdateBuffer(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkDeviceSize, _: *const c_void) {
	panic!("Vulkan function pointer of `vkCmdUpdateBuffer()` is NULL");
}
extern "system" fn dummy_vkCmdFillBuffer(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkDeviceSize, _: u32) {
	panic!("Vulkan function pointer of `vkCmdFillBuffer()` is NULL");
}
extern "system" fn dummy_vkCmdClearColorImage(_: VkCommandBuffer, _: VkImage, _: VkImageLayout, _: *const VkClearColorValue, _: u32, _: *const VkImageSubresourceRange) {
	panic!("Vulkan function pointer of `vkCmdClearColorImage()` is NULL");
}
extern "system" fn dummy_vkCmdClearDepthStencilImage(_: VkCommandBuffer, _: VkImage, _: VkImageLayout, _: *const VkClearDepthStencilValue, _: u32, _: *const VkImageSubresourceRange) {
	panic!("Vulkan function pointer of `vkCmdClearDepthStencilImage()` is NULL");
}
extern "system" fn dummy_vkCmdClearAttachments(_: VkCommandBuffer, _: u32, _: *const VkClearAttachment, _: u32, _: *const VkClearRect) {
	panic!("Vulkan function pointer of `vkCmdClearAttachments()` is NULL");
}
extern "system" fn dummy_vkCmdResolveImage(_: VkCommandBuffer, _: VkImage, _: VkImageLayout, _: VkImage, _: VkImageLayout, _: u32, _: *const VkImageResolve) {
	panic!("Vulkan function pointer of `vkCmdResolveImage()` is NULL");
}
extern "system" fn dummy_vkCmdSetEvent(_: VkCommandBuffer, _: VkEvent, _: VkPipelineStageFlags) {
	panic!("Vulkan function pointer of `vkCmdSetEvent()` is NULL");
}
extern "system" fn dummy_vkCmdResetEvent(_: VkCommandBuffer, _: VkEvent, _: VkPipelineStageFlags) {
	panic!("Vulkan function pointer of `vkCmdResetEvent()` is NULL");
}
extern "system" fn dummy_vkCmdWaitEvents(_: VkCommandBuffer, _: u32, _: *const VkEvent, _: VkPipelineStageFlags, _: VkPipelineStageFlags, _: u32, _: *const VkMemoryBarrier, _: u32, _: *const VkBufferMemoryBarrier, _: u32, _: *const VkImageMemoryBarrier) {
	panic!("Vulkan function pointer of `vkCmdWaitEvents()` is NULL");
}
extern "system" fn dummy_vkCmdPipelineBarrier(_: VkCommandBuffer, _: VkPipelineStageFlags, _: VkPipelineStageFlags, _: VkDependencyFlags, _: u32, _: *const VkMemoryBarrier, _: u32, _: *const VkBufferMemoryBarrier, _: u32, _: *const VkImageMemoryBarrier) {
	panic!("Vulkan function pointer of `vkCmdPipelineBarrier()` is NULL");
}
extern "system" fn dummy_vkCmdBeginQuery(_: VkCommandBuffer, _: VkQueryPool, _: u32, _: VkQueryControlFlags) {
	panic!("Vulkan function pointer of `vkCmdBeginQuery()` is NULL");
}
extern "system" fn dummy_vkCmdEndQuery(_: VkCommandBuffer, _: VkQueryPool, _: u32) {
	panic!("Vulkan function pointer of `vkCmdEndQuery()` is NULL");
}
extern "system" fn dummy_vkCmdResetQueryPool(_: VkCommandBuffer, _: VkQueryPool, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdResetQueryPool()` is NULL");
}
extern "system" fn dummy_vkCmdWriteTimestamp(_: VkCommandBuffer, _: VkPipelineStageFlagBits, _: VkQueryPool, _: u32) {
	panic!("Vulkan function pointer of `vkCmdWriteTimestamp()` is NULL");
}
extern "system" fn dummy_vkCmdCopyQueryPoolResults(_: VkCommandBuffer, _: VkQueryPool, _: u32, _: u32, _: VkBuffer, _: VkDeviceSize, _: VkDeviceSize, _: VkQueryResultFlags) {
	panic!("Vulkan function pointer of `vkCmdCopyQueryPoolResults()` is NULL");
}
extern "system" fn dummy_vkCmdPushConstants(_: VkCommandBuffer, _: VkPipelineLayout, _: VkShaderStageFlags, _: u32, _: u32, _: *const c_void) {
	panic!("Vulkan function pointer of `vkCmdPushConstants()` is NULL");
}
extern "system" fn dummy_vkCmdBeginRenderPass(_: VkCommandBuffer, _: *const VkRenderPassBeginInfo, _: VkSubpassContents) {
	panic!("Vulkan function pointer of `vkCmdBeginRenderPass()` is NULL");
}
extern "system" fn dummy_vkCmdNextSubpass(_: VkCommandBuffer, _: VkSubpassContents) {
	panic!("Vulkan function pointer of `vkCmdNextSubpass()` is NULL");
}
extern "system" fn dummy_vkCmdEndRenderPass(_: VkCommandBuffer) {
	panic!("Vulkan function pointer of `vkCmdEndRenderPass()` is NULL");
}
extern "system" fn dummy_vkCmdExecuteCommands(_: VkCommandBuffer, _: u32, _: *const VkCommandBuffer) {
	panic!("Vulkan function pointer of `vkCmdExecuteCommands()` is NULL");
}
pub trait VK_VERSION_1_0: Debug {
	fn vkCreateInstance(&self, pCreateInfo: *const VkInstanceCreateInfo, pAllocator: *const VkAllocationCallbacks, pInstance: *mut VkInstance) -> VkResult;
	fn vkDestroyInstance(&self, instance: VkInstance, pAllocator: *const VkAllocationCallbacks);
	fn vkEnumeratePhysicalDevices(&self, instance: VkInstance, pPhysicalDeviceCount: *mut uint32_t, pPhysicalDevices: *mut VkPhysicalDevice) -> VkResult;
	fn vkGetPhysicalDeviceFeatures(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures);
	fn vkGetPhysicalDeviceFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties);
	fn vkGetPhysicalDeviceImageFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, pImageFormatProperties: *mut VkImageFormatProperties) -> VkResult;
	fn vkGetPhysicalDeviceProperties(&self, physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties);
	fn vkGetPhysicalDeviceQueueFamilyProperties(&self, physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties);
	fn vkGetPhysicalDeviceMemoryProperties(&self, physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties);
	fn vkGetInstanceProcAddr(&self, instance: VkInstance, pName: *const i8) -> PFN_vkVoidFunction;
	fn vkGetDeviceProcAddr(&self, device: VkDevice, pName: *const i8) -> PFN_vkVoidFunction;
	fn vkCreateDevice(&self, physicalDevice: VkPhysicalDevice, pCreateInfo: *const VkDeviceCreateInfo, pAllocator: *const VkAllocationCallbacks, pDevice: *mut VkDevice) -> VkResult;
	fn vkDestroyDevice(&self, device: VkDevice, pAllocator: *const VkAllocationCallbacks);
	fn vkEnumerateInstanceExtensionProperties(&self, pLayerName: *const i8, pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> VkResult;
	fn vkEnumerateDeviceExtensionProperties(&self, physicalDevice: VkPhysicalDevice, pLayerName: *const i8, pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> VkResult;
	fn vkEnumerateInstanceLayerProperties(&self, pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> VkResult;
	fn vkEnumerateDeviceLayerProperties(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> VkResult;
	fn vkGetDeviceQueue(&self, device: VkDevice, queueFamilyIndex: u32, queueIndex: u32, pQueue: *mut VkQueue);
	fn vkQueueSubmit(&self, queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo, fence: VkFence) -> VkResult;
	fn vkQueueWaitIdle(&self, queue: VkQueue) -> VkResult;
	fn vkDeviceWaitIdle(&self, device: VkDevice) -> VkResult;
	fn vkAllocateMemory(&self, device: VkDevice, pAllocateInfo: *const VkMemoryAllocateInfo, pAllocator: *const VkAllocationCallbacks, pMemory: *mut VkDeviceMemory) -> VkResult;
	fn vkFreeMemory(&self, device: VkDevice, memory: VkDeviceMemory, pAllocator: *const VkAllocationCallbacks);
	fn vkMapMemory(&self, device: VkDevice, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize, flags: VkMemoryMapFlags, ppData: *mut *mut c_void) -> VkResult;
	fn vkUnmapMemory(&self, device: VkDevice, memory: VkDeviceMemory);
	fn vkFlushMappedMemoryRanges(&self, device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *const VkMappedMemoryRange) -> VkResult;
	fn vkInvalidateMappedMemoryRanges(&self, device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *const VkMappedMemoryRange) -> VkResult;
	fn vkGetDeviceMemoryCommitment(&self, device: VkDevice, memory: VkDeviceMemory, pCommittedMemoryInBytes: *mut VkDeviceSize);
	fn vkBindBufferMemory(&self, device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> VkResult;
	fn vkBindImageMemory(&self, device: VkDevice, image: VkImage, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> VkResult;
	fn vkGetBufferMemoryRequirements(&self, device: VkDevice, buffer: VkBuffer, pMemoryRequirements: *mut VkMemoryRequirements);
	fn vkGetImageMemoryRequirements(&self, device: VkDevice, image: VkImage, pMemoryRequirements: *mut VkMemoryRequirements);
	fn vkGetImageSparseMemoryRequirements(&self, device: VkDevice, image: VkImage, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements);
	fn vkGetPhysicalDeviceSparseImageFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties);
	fn vkQueueBindSparse(&self, queue: VkQueue, bindInfoCount: u32, pBindInfo: *const VkBindSparseInfo, fence: VkFence) -> VkResult;
	fn vkCreateFence(&self, device: VkDevice, pCreateInfo: *const VkFenceCreateInfo, pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence) -> VkResult;
	fn vkDestroyFence(&self, device: VkDevice, fence: VkFence, pAllocator: *const VkAllocationCallbacks);
	fn vkResetFences(&self, device: VkDevice, fenceCount: u32, pFences: *const VkFence) -> VkResult;
	fn vkGetFenceStatus(&self, device: VkDevice, fence: VkFence) -> VkResult;
	fn vkWaitForFences(&self, device: VkDevice, fenceCount: u32, pFences: *const VkFence, waitAll: VkBool32, timeout: u64) -> VkResult;
	fn vkCreateSemaphore(&self, device: VkDevice, pCreateInfo: *const VkSemaphoreCreateInfo, pAllocator: *const VkAllocationCallbacks, pSemaphore: *mut VkSemaphore) -> VkResult;
	fn vkDestroySemaphore(&self, device: VkDevice, semaphore: VkSemaphore, pAllocator: *const VkAllocationCallbacks);
	fn vkCreateEvent(&self, device: VkDevice, pCreateInfo: *const VkEventCreateInfo, pAllocator: *const VkAllocationCallbacks, pEvent: *mut VkEvent) -> VkResult;
	fn vkDestroyEvent(&self, device: VkDevice, event: VkEvent, pAllocator: *const VkAllocationCallbacks);
	fn vkGetEventStatus(&self, device: VkDevice, event: VkEvent) -> VkResult;
	fn vkSetEvent(&self, device: VkDevice, event: VkEvent) -> VkResult;
	fn vkResetEvent(&self, device: VkDevice, event: VkEvent) -> VkResult;
	fn vkCreateQueryPool(&self, device: VkDevice, pCreateInfo: *const VkQueryPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pQueryPool: *mut VkQueryPool) -> VkResult;
	fn vkDestroyQueryPool(&self, device: VkDevice, queryPool: VkQueryPool, pAllocator: *const VkAllocationCallbacks);
	fn vkGetQueryPoolResults(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dataSize: usize, pData: *mut c_void, stride: VkDeviceSize, flags: VkQueryResultFlags) -> VkResult;
	fn vkCreateBuffer(&self, device: VkDevice, pCreateInfo: *const VkBufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pBuffer: *mut VkBuffer) -> VkResult;
	fn vkDestroyBuffer(&self, device: VkDevice, buffer: VkBuffer, pAllocator: *const VkAllocationCallbacks);
	fn vkCreateBufferView(&self, device: VkDevice, pCreateInfo: *const VkBufferViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkBufferView) -> VkResult;
	fn vkDestroyBufferView(&self, device: VkDevice, bufferView: VkBufferView, pAllocator: *const VkAllocationCallbacks);
	fn vkCreateImage(&self, device: VkDevice, pCreateInfo: *const VkImageCreateInfo, pAllocator: *const VkAllocationCallbacks, pImage: *mut VkImage) -> VkResult;
	fn vkDestroyImage(&self, device: VkDevice, image: VkImage, pAllocator: *const VkAllocationCallbacks);
	fn vkGetImageSubresourceLayout(&self, device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource, pLayout: *mut VkSubresourceLayout);
	fn vkCreateImageView(&self, device: VkDevice, pCreateInfo: *const VkImageViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkImageView) -> VkResult;
	fn vkDestroyImageView(&self, device: VkDevice, imageView: VkImageView, pAllocator: *const VkAllocationCallbacks);
	fn vkCreateShaderModule(&self, device: VkDevice, pCreateInfo: *const VkShaderModuleCreateInfo, pAllocator: *const VkAllocationCallbacks, pShaderModule: *mut VkShaderModule) -> VkResult;
	fn vkDestroyShaderModule(&self, device: VkDevice, shaderModule: VkShaderModule, pAllocator: *const VkAllocationCallbacks);
	fn vkCreatePipelineCache(&self, device: VkDevice, pCreateInfo: *const VkPipelineCacheCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineCache: *mut VkPipelineCache) -> VkResult;
	fn vkDestroyPipelineCache(&self, device: VkDevice, pipelineCache: VkPipelineCache, pAllocator: *const VkAllocationCallbacks);
	fn vkGetPipelineCacheData(&self, device: VkDevice, pipelineCache: VkPipelineCache, pDataSize: *mut size_t, pData: *mut c_void) -> VkResult;
	fn vkMergePipelineCaches(&self, device: VkDevice, dstCache: VkPipelineCache, srcCacheCount: u32, pSrcCaches: *const VkPipelineCache) -> VkResult;
	fn vkCreateGraphicsPipelines(&self, device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkGraphicsPipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult;
	fn vkCreateComputePipelines(&self, device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkComputePipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult;
	fn vkDestroyPipeline(&self, device: VkDevice, pipeline: VkPipeline, pAllocator: *const VkAllocationCallbacks);
	fn vkCreatePipelineLayout(&self, device: VkDevice, pCreateInfo: *const VkPipelineLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineLayout: *mut VkPipelineLayout) -> VkResult;
	fn vkDestroyPipelineLayout(&self, device: VkDevice, pipelineLayout: VkPipelineLayout, pAllocator: *const VkAllocationCallbacks);
	fn vkCreateSampler(&self, device: VkDevice, pCreateInfo: *const VkSamplerCreateInfo, pAllocator: *const VkAllocationCallbacks, pSampler: *mut VkSampler) -> VkResult;
	fn vkDestroySampler(&self, device: VkDevice, sampler: VkSampler, pAllocator: *const VkAllocationCallbacks);
	fn vkCreateDescriptorSetLayout(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pSetLayout: *mut VkDescriptorSetLayout) -> VkResult;
	fn vkDestroyDescriptorSetLayout(&self, device: VkDevice, descriptorSetLayout: VkDescriptorSetLayout, pAllocator: *const VkAllocationCallbacks);
	fn vkCreateDescriptorPool(&self, device: VkDevice, pCreateInfo: *const VkDescriptorPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorPool: *mut VkDescriptorPool) -> VkResult;
	fn vkDestroyDescriptorPool(&self, device: VkDevice, descriptorPool: VkDescriptorPool, pAllocator: *const VkAllocationCallbacks);
	fn vkResetDescriptorPool(&self, device: VkDevice, descriptorPool: VkDescriptorPool, flags: VkDescriptorPoolResetFlags) -> VkResult;
	fn vkAllocateDescriptorSets(&self, device: VkDevice, pAllocateInfo: *const VkDescriptorSetAllocateInfo, pDescriptorSets: *mut VkDescriptorSet) -> VkResult;
	fn vkFreeDescriptorSets(&self, device: VkDevice, descriptorPool: VkDescriptorPool, descriptorSetCount: u32, pDescriptorSets: *const VkDescriptorSet) -> VkResult;
	fn vkUpdateDescriptorSets(&self, device: VkDevice, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: *const VkCopyDescriptorSet);
	fn vkCreateFramebuffer(&self, device: VkDevice, pCreateInfo: *const VkFramebufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pFramebuffer: *mut VkFramebuffer) -> VkResult;
	fn vkDestroyFramebuffer(&self, device: VkDevice, framebuffer: VkFramebuffer, pAllocator: *const VkAllocationCallbacks);
	fn vkCreateRenderPass(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult;
	fn vkDestroyRenderPass(&self, device: VkDevice, renderPass: VkRenderPass, pAllocator: *const VkAllocationCallbacks);
	fn vkGetRenderAreaGranularity(&self, device: VkDevice, renderPass: VkRenderPass, pGranularity: *mut VkExtent2D);
	fn vkCreateCommandPool(&self, device: VkDevice, pCreateInfo: *const VkCommandPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pCommandPool: *mut VkCommandPool) -> VkResult;
	fn vkDestroyCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, pAllocator: *const VkAllocationCallbacks);
	fn vkResetCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolResetFlags) -> VkResult;
	fn vkAllocateCommandBuffers(&self, device: VkDevice, pAllocateInfo: *const VkCommandBufferAllocateInfo, pCommandBuffers: *mut VkCommandBuffer) -> VkResult;
	fn vkFreeCommandBuffers(&self, device: VkDevice, commandPool: VkCommandPool, commandBufferCount: u32, pCommandBuffers: *const VkCommandBuffer);
	fn vkBeginCommandBuffer(&self, commandBuffer: VkCommandBuffer, pBeginInfo: *const VkCommandBufferBeginInfo) -> VkResult;
	fn vkEndCommandBuffer(&self, commandBuffer: VkCommandBuffer) -> VkResult;
	fn vkResetCommandBuffer(&self, commandBuffer: VkCommandBuffer, flags: VkCommandBufferResetFlags) -> VkResult;
	fn vkCmdBindPipeline(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline);
	fn vkCmdSetViewport(&self, commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: *const VkViewport);
	fn vkCmdSetScissor(&self, commandBuffer: VkCommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: *const VkRect2D);
	fn vkCmdSetLineWidth(&self, commandBuffer: VkCommandBuffer, lineWidth: f32);
	fn vkCmdSetDepthBias(&self, commandBuffer: VkCommandBuffer, depthBiasConstantFactor: f32, depthBiasClamp: f32, depthBiasSlopeFactor: f32);
	fn vkCmdSetBlendConstants(&self, commandBuffer: VkCommandBuffer, blendConstants: &[float; 4 as usize]);
	fn vkCmdSetDepthBounds(&self, commandBuffer: VkCommandBuffer, minDepthBounds: f32, maxDepthBounds: f32);
	fn vkCmdSetStencilCompareMask(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, compareMask: u32);
	fn vkCmdSetStencilWriteMask(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, writeMask: u32);
	fn vkCmdSetStencilReference(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, reference: u32);
	fn vkCmdBindDescriptorSets(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: *const VkDescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: *const uint32_t);
	fn vkCmdBindIndexBuffer(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, indexType: VkIndexType);
	fn vkCmdBindVertexBuffers(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize);
	fn vkCmdDraw(&self, commandBuffer: VkCommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32);
	fn vkCmdDrawIndexed(&self, commandBuffer: VkCommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: i32, firstInstance: u32);
	fn vkCmdDrawIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32);
	fn vkCmdDrawIndexedIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32);
	fn vkCmdDispatch(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32);
	fn vkCmdDispatchIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize);
	fn vkCmdCopyBuffer(&self, commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstBuffer: VkBuffer, regionCount: u32, pRegions: *const VkBufferCopy);
	fn vkCmdCopyImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageCopy);
	fn vkCmdBlitImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageBlit, filter: VkFilter);
	fn vkCmdCopyBufferToImage(&self, commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkBufferImageCopy);
	fn vkCmdCopyImageToBuffer(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstBuffer: VkBuffer, regionCount: u32, pRegions: *const VkBufferImageCopy);
	fn vkCmdUpdateBuffer(&self, commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, dataSize: VkDeviceSize, pData: *const c_void);
	fn vkCmdFillBuffer(&self, commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, size: VkDeviceSize, data: u32);
	fn vkCmdClearColorImage(&self, commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pColor: *const VkClearColorValue, rangeCount: u32, pRanges: *const VkImageSubresourceRange);
	fn vkCmdClearDepthStencilImage(&self, commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pDepthStencil: *const VkClearDepthStencilValue, rangeCount: u32, pRanges: *const VkImageSubresourceRange);
	fn vkCmdClearAttachments(&self, commandBuffer: VkCommandBuffer, attachmentCount: u32, pAttachments: *const VkClearAttachment, rectCount: u32, pRects: *const VkClearRect);
	fn vkCmdResolveImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageResolve);
	fn vkCmdSetEvent(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags);
	fn vkCmdResetEvent(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags);
	fn vkCmdWaitEvents(&self, commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const VkImageMemoryBarrier);
	fn vkCmdPipelineBarrier(&self, commandBuffer: VkCommandBuffer, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, dependencyFlags: VkDependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const VkImageMemoryBarrier);
	fn vkCmdBeginQuery(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags);
	fn vkCmdEndQuery(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32);
	fn vkCmdResetQueryPool(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32);
	fn vkCmdWriteTimestamp(&self, commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, queryPool: VkQueryPool, query: u32);
	fn vkCmdCopyQueryPoolResults(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, stride: VkDeviceSize, flags: VkQueryResultFlags);
	fn vkCmdPushConstants(&self, commandBuffer: VkCommandBuffer, layout: VkPipelineLayout, stageFlags: VkShaderStageFlags, offset: u32, size: u32, pValues: *const c_void);
	fn vkCmdBeginRenderPass(&self, commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, contents: VkSubpassContents);
	fn vkCmdNextSubpass(&self, commandBuffer: VkCommandBuffer, contents: VkSubpassContents);
	fn vkCmdEndRenderPass(&self, commandBuffer: VkCommandBuffer);
	fn vkCmdExecuteCommands(&self, commandBuffer: VkCommandBuffer, commandBufferCount: u32, pCommandBuffers: *const VkCommandBuffer);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_VERSION_1_0 {
	vk_create_instance: PFN_vkCreateInstance,
	vk_destroy_instance: PFN_vkDestroyInstance,
	vk_enumerate_physical_devices: PFN_vkEnumeratePhysicalDevices,
	vk_get_physical_device_features: PFN_vkGetPhysicalDeviceFeatures,
	vk_get_physical_device_format_properties: PFN_vkGetPhysicalDeviceFormatProperties,
	vk_get_physical_device_image_format_properties: PFN_vkGetPhysicalDeviceImageFormatProperties,
	vk_get_physical_device_properties: PFN_vkGetPhysicalDeviceProperties,
	vk_get_physical_device_queue_family_properties: PFN_vkGetPhysicalDeviceQueueFamilyProperties,
	vk_get_physical_device_memory_properties: PFN_vkGetPhysicalDeviceMemoryProperties,
	vk_get_instance_proc_addr: PFN_vkGetInstanceProcAddr,
	vk_get_device_proc_addr: PFN_vkGetDeviceProcAddr,
	vk_create_device: PFN_vkCreateDevice,
	vk_destroy_device: PFN_vkDestroyDevice,
	vk_enumerate_instance_extension_properties: PFN_vkEnumerateInstanceExtensionProperties,
	vk_enumerate_device_extension_properties: PFN_vkEnumerateDeviceExtensionProperties,
	vk_enumerate_instance_layer_properties: PFN_vkEnumerateInstanceLayerProperties,
	vk_enumerate_device_layer_properties: PFN_vkEnumerateDeviceLayerProperties,
	vk_get_device_queue: PFN_vkGetDeviceQueue,
	vk_queue_submit: PFN_vkQueueSubmit,
	vk_queue_wait_idle: PFN_vkQueueWaitIdle,
	vk_device_wait_idle: PFN_vkDeviceWaitIdle,
	vk_allocate_memory: PFN_vkAllocateMemory,
	vk_free_memory: PFN_vkFreeMemory,
	vk_map_memory: PFN_vkMapMemory,
	vk_unmap_memory: PFN_vkUnmapMemory,
	vk_flush_mapped_memory_ranges: PFN_vkFlushMappedMemoryRanges,
	vk_invalidate_mapped_memory_ranges: PFN_vkInvalidateMappedMemoryRanges,
	vk_get_device_memory_commitment: PFN_vkGetDeviceMemoryCommitment,
	vk_bind_buffer_memory: PFN_vkBindBufferMemory,
	vk_bind_image_memory: PFN_vkBindImageMemory,
	vk_get_buffer_memory_requirements: PFN_vkGetBufferMemoryRequirements,
	vk_get_image_memory_requirements: PFN_vkGetImageMemoryRequirements,
	vk_get_image_sparse_memory_requirements: PFN_vkGetImageSparseMemoryRequirements,
	vk_get_physical_device_sparse_image_format_properties: PFN_vkGetPhysicalDeviceSparseImageFormatProperties,
	vk_queue_bind_sparse: PFN_vkQueueBindSparse,
	vk_create_fence: PFN_vkCreateFence,
	vk_destroy_fence: PFN_vkDestroyFence,
	vk_reset_fences: PFN_vkResetFences,
	vk_get_fence_status: PFN_vkGetFenceStatus,
	vk_wait_for_fences: PFN_vkWaitForFences,
	vk_create_semaphore: PFN_vkCreateSemaphore,
	vk_destroy_semaphore: PFN_vkDestroySemaphore,
	vk_create_event: PFN_vkCreateEvent,
	vk_destroy_event: PFN_vkDestroyEvent,
	vk_get_event_status: PFN_vkGetEventStatus,
	vk_set_event: PFN_vkSetEvent,
	vk_reset_event: PFN_vkResetEvent,
	vk_create_query_pool: PFN_vkCreateQueryPool,
	vk_destroy_query_pool: PFN_vkDestroyQueryPool,
	vk_get_query_pool_results: PFN_vkGetQueryPoolResults,
	vk_create_buffer: PFN_vkCreateBuffer,
	vk_destroy_buffer: PFN_vkDestroyBuffer,
	vk_create_buffer_view: PFN_vkCreateBufferView,
	vk_destroy_buffer_view: PFN_vkDestroyBufferView,
	vk_create_image: PFN_vkCreateImage,
	vk_destroy_image: PFN_vkDestroyImage,
	vk_get_image_subresource_layout: PFN_vkGetImageSubresourceLayout,
	vk_create_image_view: PFN_vkCreateImageView,
	vk_destroy_image_view: PFN_vkDestroyImageView,
	vk_create_shader_module: PFN_vkCreateShaderModule,
	vk_destroy_shader_module: PFN_vkDestroyShaderModule,
	vk_create_pipeline_cache: PFN_vkCreatePipelineCache,
	vk_destroy_pipeline_cache: PFN_vkDestroyPipelineCache,
	vk_get_pipeline_cache_data: PFN_vkGetPipelineCacheData,
	vk_merge_pipeline_caches: PFN_vkMergePipelineCaches,
	vk_create_graphics_pipelines: PFN_vkCreateGraphicsPipelines,
	vk_create_compute_pipelines: PFN_vkCreateComputePipelines,
	vk_destroy_pipeline: PFN_vkDestroyPipeline,
	vk_create_pipeline_layout: PFN_vkCreatePipelineLayout,
	vk_destroy_pipeline_layout: PFN_vkDestroyPipelineLayout,
	vk_create_sampler: PFN_vkCreateSampler,
	vk_destroy_sampler: PFN_vkDestroySampler,
	vk_create_descriptor_set_layout: PFN_vkCreateDescriptorSetLayout,
	vk_destroy_descriptor_set_layout: PFN_vkDestroyDescriptorSetLayout,
	vk_create_descriptor_pool: PFN_vkCreateDescriptorPool,
	vk_destroy_descriptor_pool: PFN_vkDestroyDescriptorPool,
	vk_reset_descriptor_pool: PFN_vkResetDescriptorPool,
	vk_allocate_descriptor_sets: PFN_vkAllocateDescriptorSets,
	vk_free_descriptor_sets: PFN_vkFreeDescriptorSets,
	vk_update_descriptor_sets: PFN_vkUpdateDescriptorSets,
	vk_create_framebuffer: PFN_vkCreateFramebuffer,
	vk_destroy_framebuffer: PFN_vkDestroyFramebuffer,
	vk_create_render_pass: PFN_vkCreateRenderPass,
	vk_destroy_render_pass: PFN_vkDestroyRenderPass,
	vk_get_render_area_granularity: PFN_vkGetRenderAreaGranularity,
	vk_create_command_pool: PFN_vkCreateCommandPool,
	vk_destroy_command_pool: PFN_vkDestroyCommandPool,
	vk_reset_command_pool: PFN_vkResetCommandPool,
	vk_allocate_command_buffers: PFN_vkAllocateCommandBuffers,
	vk_free_command_buffers: PFN_vkFreeCommandBuffers,
	vk_begin_command_buffer: PFN_vkBeginCommandBuffer,
	vk_end_command_buffer: PFN_vkEndCommandBuffer,
	vk_reset_command_buffer: PFN_vkResetCommandBuffer,
	vk_cmd_bind_pipeline: PFN_vkCmdBindPipeline,
	vk_cmd_set_viewport: PFN_vkCmdSetViewport,
	vk_cmd_set_scissor: PFN_vkCmdSetScissor,
	vk_cmd_set_line_width: PFN_vkCmdSetLineWidth,
	vk_cmd_set_depth_bias: PFN_vkCmdSetDepthBias,
	vk_cmd_set_blend_constants: PFN_vkCmdSetBlendConstants,
	vk_cmd_set_depth_bounds: PFN_vkCmdSetDepthBounds,
	vk_cmd_set_stencil_compare_mask: PFN_vkCmdSetStencilCompareMask,
	vk_cmd_set_stencil_write_mask: PFN_vkCmdSetStencilWriteMask,
	vk_cmd_set_stencil_reference: PFN_vkCmdSetStencilReference,
	vk_cmd_bind_descriptor_sets: PFN_vkCmdBindDescriptorSets,
	vk_cmd_bind_index_buffer: PFN_vkCmdBindIndexBuffer,
	vk_cmd_bind_vertex_buffers: PFN_vkCmdBindVertexBuffers,
	vk_cmd_draw: PFN_vkCmdDraw,
	vk_cmd_draw_indexed: PFN_vkCmdDrawIndexed,
	vk_cmd_draw_indirect: PFN_vkCmdDrawIndirect,
	vk_cmd_draw_indexed_indirect: PFN_vkCmdDrawIndexedIndirect,
	vk_cmd_dispatch: PFN_vkCmdDispatch,
	vk_cmd_dispatch_indirect: PFN_vkCmdDispatchIndirect,
	vk_cmd_copy_buffer: PFN_vkCmdCopyBuffer,
	vk_cmd_copy_image: PFN_vkCmdCopyImage,
	vk_cmd_blit_image: PFN_vkCmdBlitImage,
	vk_cmd_copy_buffer_to_image: PFN_vkCmdCopyBufferToImage,
	vk_cmd_copy_image_to_buffer: PFN_vkCmdCopyImageToBuffer,
	vk_cmd_update_buffer: PFN_vkCmdUpdateBuffer,
	vk_cmd_fill_buffer: PFN_vkCmdFillBuffer,
	vk_cmd_clear_color_image: PFN_vkCmdClearColorImage,
	vk_cmd_clear_depth_stencil_image: PFN_vkCmdClearDepthStencilImage,
	vk_cmd_clear_attachments: PFN_vkCmdClearAttachments,
	vk_cmd_resolve_image: PFN_vkCmdResolveImage,
	vk_cmd_set_event: PFN_vkCmdSetEvent,
	vk_cmd_reset_event: PFN_vkCmdResetEvent,
	vk_cmd_wait_events: PFN_vkCmdWaitEvents,
	vk_cmd_pipeline_barrier: PFN_vkCmdPipelineBarrier,
	vk_cmd_begin_query: PFN_vkCmdBeginQuery,
	vk_cmd_end_query: PFN_vkCmdEndQuery,
	vk_cmd_reset_query_pool: PFN_vkCmdResetQueryPool,
	vk_cmd_write_timestamp: PFN_vkCmdWriteTimestamp,
	vk_cmd_copy_query_pool_results: PFN_vkCmdCopyQueryPoolResults,
	vk_cmd_push_constants: PFN_vkCmdPushConstants,
	vk_cmd_begin_render_pass: PFN_vkCmdBeginRenderPass,
	vk_cmd_next_subpass: PFN_vkCmdNextSubpass,
	vk_cmd_end_render_pass: PFN_vkCmdEndRenderPass,
	vk_cmd_execute_commands: PFN_vkCmdExecuteCommands,
}
impl VK_VERSION_1_0 for Vulkan_VERSION_1_0 {
	fn vkCreateInstance(&self, pCreateInfo: *const VkInstanceCreateInfo, pAllocator: *const VkAllocationCallbacks, pInstance: *mut VkInstance) -> VkResult {
		(self.vk_create_instance)(pCreateInfo, pAllocator, pInstance)
	}
	fn vkDestroyInstance(&self, instance: VkInstance, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_instance)(instance, pAllocator)
	}
	fn vkEnumeratePhysicalDevices(&self, instance: VkInstance, pPhysicalDeviceCount: *mut uint32_t, pPhysicalDevices: *mut VkPhysicalDevice) -> VkResult {
		(self.vk_enumerate_physical_devices)(instance, pPhysicalDeviceCount, pPhysicalDevices)
	}
	fn vkGetPhysicalDeviceFeatures(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures) {
		(self.vk_get_physical_device_features)(physicalDevice, pFeatures)
	}
	fn vkGetPhysicalDeviceFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties) {
		(self.vk_get_physical_device_format_properties)(physicalDevice, format, pFormatProperties)
	}
	fn vkGetPhysicalDeviceImageFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, pImageFormatProperties: *mut VkImageFormatProperties) -> VkResult {
		(self.vk_get_physical_device_image_format_properties)(physicalDevice, format, type_, tiling, usage, flags, pImageFormatProperties)
	}
	fn vkGetPhysicalDeviceProperties(&self, physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties) {
		(self.vk_get_physical_device_properties)(physicalDevice, pProperties)
	}
	fn vkGetPhysicalDeviceQueueFamilyProperties(&self, physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties) {
		(self.vk_get_physical_device_queue_family_properties)(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)
	}
	fn vkGetPhysicalDeviceMemoryProperties(&self, physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties) {
		(self.vk_get_physical_device_memory_properties)(physicalDevice, pMemoryProperties)
	}
	fn vkGetInstanceProcAddr(&self, instance: VkInstance, pName: *const i8) -> PFN_vkVoidFunction {
		(self.vk_get_instance_proc_addr)(instance, pName)
	}
	fn vkGetDeviceProcAddr(&self, device: VkDevice, pName: *const i8) -> PFN_vkVoidFunction {
		(self.vk_get_device_proc_addr)(device, pName)
	}
	fn vkCreateDevice(&self, physicalDevice: VkPhysicalDevice, pCreateInfo: *const VkDeviceCreateInfo, pAllocator: *const VkAllocationCallbacks, pDevice: *mut VkDevice) -> VkResult {
		(self.vk_create_device)(physicalDevice, pCreateInfo, pAllocator, pDevice)
	}
	fn vkDestroyDevice(&self, device: VkDevice, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_device)(device, pAllocator)
	}
	fn vkEnumerateInstanceExtensionProperties(&self, pLayerName: *const i8, pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> VkResult {
		(self.vk_enumerate_instance_extension_properties)(pLayerName, pPropertyCount, pProperties)
	}
	fn vkEnumerateDeviceExtensionProperties(&self, physicalDevice: VkPhysicalDevice, pLayerName: *const i8, pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> VkResult {
		(self.vk_enumerate_device_extension_properties)(physicalDevice, pLayerName, pPropertyCount, pProperties)
	}
	fn vkEnumerateInstanceLayerProperties(&self, pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> VkResult {
		(self.vk_enumerate_instance_layer_properties)(pPropertyCount, pProperties)
	}
	fn vkEnumerateDeviceLayerProperties(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> VkResult {
		(self.vk_enumerate_device_layer_properties)(physicalDevice, pPropertyCount, pProperties)
	}
	fn vkGetDeviceQueue(&self, device: VkDevice, queueFamilyIndex: u32, queueIndex: u32, pQueue: *mut VkQueue) {
		(self.vk_get_device_queue)(device, queueFamilyIndex, queueIndex, pQueue)
	}
	fn vkQueueSubmit(&self, queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo, fence: VkFence) -> VkResult {
		(self.vk_queue_submit)(queue, submitCount, pSubmits, fence)
	}
	fn vkQueueWaitIdle(&self, queue: VkQueue) -> VkResult {
		(self.vk_queue_wait_idle)(queue)
	}
	fn vkDeviceWaitIdle(&self, device: VkDevice) -> VkResult {
		(self.vk_device_wait_idle)(device)
	}
	fn vkAllocateMemory(&self, device: VkDevice, pAllocateInfo: *const VkMemoryAllocateInfo, pAllocator: *const VkAllocationCallbacks, pMemory: *mut VkDeviceMemory) -> VkResult {
		(self.vk_allocate_memory)(device, pAllocateInfo, pAllocator, pMemory)
	}
	fn vkFreeMemory(&self, device: VkDevice, memory: VkDeviceMemory, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_free_memory)(device, memory, pAllocator)
	}
	fn vkMapMemory(&self, device: VkDevice, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize, flags: VkMemoryMapFlags, ppData: *mut *mut c_void) -> VkResult {
		(self.vk_map_memory)(device, memory, offset, size, flags, ppData)
	}
	fn vkUnmapMemory(&self, device: VkDevice, memory: VkDeviceMemory) {
		(self.vk_unmap_memory)(device, memory)
	}
	fn vkFlushMappedMemoryRanges(&self, device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *const VkMappedMemoryRange) -> VkResult {
		(self.vk_flush_mapped_memory_ranges)(device, memoryRangeCount, pMemoryRanges)
	}
	fn vkInvalidateMappedMemoryRanges(&self, device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *const VkMappedMemoryRange) -> VkResult {
		(self.vk_invalidate_mapped_memory_ranges)(device, memoryRangeCount, pMemoryRanges)
	}
	fn vkGetDeviceMemoryCommitment(&self, device: VkDevice, memory: VkDeviceMemory, pCommittedMemoryInBytes: *mut VkDeviceSize) {
		(self.vk_get_device_memory_commitment)(device, memory, pCommittedMemoryInBytes)
	}
	fn vkBindBufferMemory(&self, device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> VkResult {
		(self.vk_bind_buffer_memory)(device, buffer, memory, memoryOffset)
	}
	fn vkBindImageMemory(&self, device: VkDevice, image: VkImage, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> VkResult {
		(self.vk_bind_image_memory)(device, image, memory, memoryOffset)
	}
	fn vkGetBufferMemoryRequirements(&self, device: VkDevice, buffer: VkBuffer, pMemoryRequirements: *mut VkMemoryRequirements) {
		(self.vk_get_buffer_memory_requirements)(device, buffer, pMemoryRequirements)
	}
	fn vkGetImageMemoryRequirements(&self, device: VkDevice, image: VkImage, pMemoryRequirements: *mut VkMemoryRequirements) {
		(self.vk_get_image_memory_requirements)(device, image, pMemoryRequirements)
	}
	fn vkGetImageSparseMemoryRequirements(&self, device: VkDevice, image: VkImage, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements) {
		(self.vk_get_image_sparse_memory_requirements)(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements)
	}
	fn vkGetPhysicalDeviceSparseImageFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties) {
		(self.vk_get_physical_device_sparse_image_format_properties)(physicalDevice, format, type_, samples, usage, tiling, pPropertyCount, pProperties)
	}
	fn vkQueueBindSparse(&self, queue: VkQueue, bindInfoCount: u32, pBindInfo: *const VkBindSparseInfo, fence: VkFence) -> VkResult {
		(self.vk_queue_bind_sparse)(queue, bindInfoCount, pBindInfo, fence)
	}
	fn vkCreateFence(&self, device: VkDevice, pCreateInfo: *const VkFenceCreateInfo, pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence) -> VkResult {
		(self.vk_create_fence)(device, pCreateInfo, pAllocator, pFence)
	}
	fn vkDestroyFence(&self, device: VkDevice, fence: VkFence, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_fence)(device, fence, pAllocator)
	}
	fn vkResetFences(&self, device: VkDevice, fenceCount: u32, pFences: *const VkFence) -> VkResult {
		(self.vk_reset_fences)(device, fenceCount, pFences)
	}
	fn vkGetFenceStatus(&self, device: VkDevice, fence: VkFence) -> VkResult {
		(self.vk_get_fence_status)(device, fence)
	}
	fn vkWaitForFences(&self, device: VkDevice, fenceCount: u32, pFences: *const VkFence, waitAll: VkBool32, timeout: u64) -> VkResult {
		(self.vk_wait_for_fences)(device, fenceCount, pFences, waitAll, timeout)
	}
	fn vkCreateSemaphore(&self, device: VkDevice, pCreateInfo: *const VkSemaphoreCreateInfo, pAllocator: *const VkAllocationCallbacks, pSemaphore: *mut VkSemaphore) -> VkResult {
		(self.vk_create_semaphore)(device, pCreateInfo, pAllocator, pSemaphore)
	}
	fn vkDestroySemaphore(&self, device: VkDevice, semaphore: VkSemaphore, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_semaphore)(device, semaphore, pAllocator)
	}
	fn vkCreateEvent(&self, device: VkDevice, pCreateInfo: *const VkEventCreateInfo, pAllocator: *const VkAllocationCallbacks, pEvent: *mut VkEvent) -> VkResult {
		(self.vk_create_event)(device, pCreateInfo, pAllocator, pEvent)
	}
	fn vkDestroyEvent(&self, device: VkDevice, event: VkEvent, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_event)(device, event, pAllocator)
	}
	fn vkGetEventStatus(&self, device: VkDevice, event: VkEvent) -> VkResult {
		(self.vk_get_event_status)(device, event)
	}
	fn vkSetEvent(&self, device: VkDevice, event: VkEvent) -> VkResult {
		(self.vk_set_event)(device, event)
	}
	fn vkResetEvent(&self, device: VkDevice, event: VkEvent) -> VkResult {
		(self.vk_reset_event)(device, event)
	}
	fn vkCreateQueryPool(&self, device: VkDevice, pCreateInfo: *const VkQueryPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pQueryPool: *mut VkQueryPool) -> VkResult {
		(self.vk_create_query_pool)(device, pCreateInfo, pAllocator, pQueryPool)
	}
	fn vkDestroyQueryPool(&self, device: VkDevice, queryPool: VkQueryPool, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_query_pool)(device, queryPool, pAllocator)
	}
	fn vkGetQueryPoolResults(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dataSize: usize, pData: *mut c_void, stride: VkDeviceSize, flags: VkQueryResultFlags) -> VkResult {
		(self.vk_get_query_pool_results)(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags)
	}
	fn vkCreateBuffer(&self, device: VkDevice, pCreateInfo: *const VkBufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pBuffer: *mut VkBuffer) -> VkResult {
		(self.vk_create_buffer)(device, pCreateInfo, pAllocator, pBuffer)
	}
	fn vkDestroyBuffer(&self, device: VkDevice, buffer: VkBuffer, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_buffer)(device, buffer, pAllocator)
	}
	fn vkCreateBufferView(&self, device: VkDevice, pCreateInfo: *const VkBufferViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkBufferView) -> VkResult {
		(self.vk_create_buffer_view)(device, pCreateInfo, pAllocator, pView)
	}
	fn vkDestroyBufferView(&self, device: VkDevice, bufferView: VkBufferView, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_buffer_view)(device, bufferView, pAllocator)
	}
	fn vkCreateImage(&self, device: VkDevice, pCreateInfo: *const VkImageCreateInfo, pAllocator: *const VkAllocationCallbacks, pImage: *mut VkImage) -> VkResult {
		(self.vk_create_image)(device, pCreateInfo, pAllocator, pImage)
	}
	fn vkDestroyImage(&self, device: VkDevice, image: VkImage, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_image)(device, image, pAllocator)
	}
	fn vkGetImageSubresourceLayout(&self, device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource, pLayout: *mut VkSubresourceLayout) {
		(self.vk_get_image_subresource_layout)(device, image, pSubresource, pLayout)
	}
	fn vkCreateImageView(&self, device: VkDevice, pCreateInfo: *const VkImageViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkImageView) -> VkResult {
		(self.vk_create_image_view)(device, pCreateInfo, pAllocator, pView)
	}
	fn vkDestroyImageView(&self, device: VkDevice, imageView: VkImageView, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_image_view)(device, imageView, pAllocator)
	}
	fn vkCreateShaderModule(&self, device: VkDevice, pCreateInfo: *const VkShaderModuleCreateInfo, pAllocator: *const VkAllocationCallbacks, pShaderModule: *mut VkShaderModule) -> VkResult {
		(self.vk_create_shader_module)(device, pCreateInfo, pAllocator, pShaderModule)
	}
	fn vkDestroyShaderModule(&self, device: VkDevice, shaderModule: VkShaderModule, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_shader_module)(device, shaderModule, pAllocator)
	}
	fn vkCreatePipelineCache(&self, device: VkDevice, pCreateInfo: *const VkPipelineCacheCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineCache: *mut VkPipelineCache) -> VkResult {
		(self.vk_create_pipeline_cache)(device, pCreateInfo, pAllocator, pPipelineCache)
	}
	fn vkDestroyPipelineCache(&self, device: VkDevice, pipelineCache: VkPipelineCache, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_pipeline_cache)(device, pipelineCache, pAllocator)
	}
	fn vkGetPipelineCacheData(&self, device: VkDevice, pipelineCache: VkPipelineCache, pDataSize: *mut size_t, pData: *mut c_void) -> VkResult {
		(self.vk_get_pipeline_cache_data)(device, pipelineCache, pDataSize, pData)
	}
	fn vkMergePipelineCaches(&self, device: VkDevice, dstCache: VkPipelineCache, srcCacheCount: u32, pSrcCaches: *const VkPipelineCache) -> VkResult {
		(self.vk_merge_pipeline_caches)(device, dstCache, srcCacheCount, pSrcCaches)
	}
	fn vkCreateGraphicsPipelines(&self, device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkGraphicsPipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult {
		(self.vk_create_graphics_pipelines)(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)
	}
	fn vkCreateComputePipelines(&self, device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkComputePipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult {
		(self.vk_create_compute_pipelines)(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)
	}
	fn vkDestroyPipeline(&self, device: VkDevice, pipeline: VkPipeline, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_pipeline)(device, pipeline, pAllocator)
	}
	fn vkCreatePipelineLayout(&self, device: VkDevice, pCreateInfo: *const VkPipelineLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineLayout: *mut VkPipelineLayout) -> VkResult {
		(self.vk_create_pipeline_layout)(device, pCreateInfo, pAllocator, pPipelineLayout)
	}
	fn vkDestroyPipelineLayout(&self, device: VkDevice, pipelineLayout: VkPipelineLayout, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_pipeline_layout)(device, pipelineLayout, pAllocator)
	}
	fn vkCreateSampler(&self, device: VkDevice, pCreateInfo: *const VkSamplerCreateInfo, pAllocator: *const VkAllocationCallbacks, pSampler: *mut VkSampler) -> VkResult {
		(self.vk_create_sampler)(device, pCreateInfo, pAllocator, pSampler)
	}
	fn vkDestroySampler(&self, device: VkDevice, sampler: VkSampler, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_sampler)(device, sampler, pAllocator)
	}
	fn vkCreateDescriptorSetLayout(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pSetLayout: *mut VkDescriptorSetLayout) -> VkResult {
		(self.vk_create_descriptor_set_layout)(device, pCreateInfo, pAllocator, pSetLayout)
	}
	fn vkDestroyDescriptorSetLayout(&self, device: VkDevice, descriptorSetLayout: VkDescriptorSetLayout, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_descriptor_set_layout)(device, descriptorSetLayout, pAllocator)
	}
	fn vkCreateDescriptorPool(&self, device: VkDevice, pCreateInfo: *const VkDescriptorPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorPool: *mut VkDescriptorPool) -> VkResult {
		(self.vk_create_descriptor_pool)(device, pCreateInfo, pAllocator, pDescriptorPool)
	}
	fn vkDestroyDescriptorPool(&self, device: VkDevice, descriptorPool: VkDescriptorPool, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_descriptor_pool)(device, descriptorPool, pAllocator)
	}
	fn vkResetDescriptorPool(&self, device: VkDevice, descriptorPool: VkDescriptorPool, flags: VkDescriptorPoolResetFlags) -> VkResult {
		(self.vk_reset_descriptor_pool)(device, descriptorPool, flags)
	}
	fn vkAllocateDescriptorSets(&self, device: VkDevice, pAllocateInfo: *const VkDescriptorSetAllocateInfo, pDescriptorSets: *mut VkDescriptorSet) -> VkResult {
		(self.vk_allocate_descriptor_sets)(device, pAllocateInfo, pDescriptorSets)
	}
	fn vkFreeDescriptorSets(&self, device: VkDevice, descriptorPool: VkDescriptorPool, descriptorSetCount: u32, pDescriptorSets: *const VkDescriptorSet) -> VkResult {
		(self.vk_free_descriptor_sets)(device, descriptorPool, descriptorSetCount, pDescriptorSets)
	}
	fn vkUpdateDescriptorSets(&self, device: VkDevice, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: *const VkCopyDescriptorSet) {
		(self.vk_update_descriptor_sets)(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies)
	}
	fn vkCreateFramebuffer(&self, device: VkDevice, pCreateInfo: *const VkFramebufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pFramebuffer: *mut VkFramebuffer) -> VkResult {
		(self.vk_create_framebuffer)(device, pCreateInfo, pAllocator, pFramebuffer)
	}
	fn vkDestroyFramebuffer(&self, device: VkDevice, framebuffer: VkFramebuffer, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_framebuffer)(device, framebuffer, pAllocator)
	}
	fn vkCreateRenderPass(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult {
		(self.vk_create_render_pass)(device, pCreateInfo, pAllocator, pRenderPass)
	}
	fn vkDestroyRenderPass(&self, device: VkDevice, renderPass: VkRenderPass, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_render_pass)(device, renderPass, pAllocator)
	}
	fn vkGetRenderAreaGranularity(&self, device: VkDevice, renderPass: VkRenderPass, pGranularity: *mut VkExtent2D) {
		(self.vk_get_render_area_granularity)(device, renderPass, pGranularity)
	}
	fn vkCreateCommandPool(&self, device: VkDevice, pCreateInfo: *const VkCommandPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pCommandPool: *mut VkCommandPool) -> VkResult {
		(self.vk_create_command_pool)(device, pCreateInfo, pAllocator, pCommandPool)
	}
	fn vkDestroyCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_command_pool)(device, commandPool, pAllocator)
	}
	fn vkResetCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolResetFlags) -> VkResult {
		(self.vk_reset_command_pool)(device, commandPool, flags)
	}
	fn vkAllocateCommandBuffers(&self, device: VkDevice, pAllocateInfo: *const VkCommandBufferAllocateInfo, pCommandBuffers: *mut VkCommandBuffer) -> VkResult {
		(self.vk_allocate_command_buffers)(device, pAllocateInfo, pCommandBuffers)
	}
	fn vkFreeCommandBuffers(&self, device: VkDevice, commandPool: VkCommandPool, commandBufferCount: u32, pCommandBuffers: *const VkCommandBuffer) {
		(self.vk_free_command_buffers)(device, commandPool, commandBufferCount, pCommandBuffers)
	}
	fn vkBeginCommandBuffer(&self, commandBuffer: VkCommandBuffer, pBeginInfo: *const VkCommandBufferBeginInfo) -> VkResult {
		(self.vk_begin_command_buffer)(commandBuffer, pBeginInfo)
	}
	fn vkEndCommandBuffer(&self, commandBuffer: VkCommandBuffer) -> VkResult {
		(self.vk_end_command_buffer)(commandBuffer)
	}
	fn vkResetCommandBuffer(&self, commandBuffer: VkCommandBuffer, flags: VkCommandBufferResetFlags) -> VkResult {
		(self.vk_reset_command_buffer)(commandBuffer, flags)
	}
	fn vkCmdBindPipeline(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline) {
		(self.vk_cmd_bind_pipeline)(commandBuffer, pipelineBindPoint, pipeline)
	}
	fn vkCmdSetViewport(&self, commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: *const VkViewport) {
		(self.vk_cmd_set_viewport)(commandBuffer, firstViewport, viewportCount, pViewports)
	}
	fn vkCmdSetScissor(&self, commandBuffer: VkCommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: *const VkRect2D) {
		(self.vk_cmd_set_scissor)(commandBuffer, firstScissor, scissorCount, pScissors)
	}
	fn vkCmdSetLineWidth(&self, commandBuffer: VkCommandBuffer, lineWidth: f32) {
		(self.vk_cmd_set_line_width)(commandBuffer, lineWidth)
	}
	fn vkCmdSetDepthBias(&self, commandBuffer: VkCommandBuffer, depthBiasConstantFactor: f32, depthBiasClamp: f32, depthBiasSlopeFactor: f32) {
		(self.vk_cmd_set_depth_bias)(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)
	}
	fn vkCmdSetBlendConstants(&self, commandBuffer: VkCommandBuffer, blendConstants: &[float; 4 as usize]) {
		(self.vk_cmd_set_blend_constants)(commandBuffer, blendConstants)
	}
	fn vkCmdSetDepthBounds(&self, commandBuffer: VkCommandBuffer, minDepthBounds: f32, maxDepthBounds: f32) {
		(self.vk_cmd_set_depth_bounds)(commandBuffer, minDepthBounds, maxDepthBounds)
	}
	fn vkCmdSetStencilCompareMask(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, compareMask: u32) {
		(self.vk_cmd_set_stencil_compare_mask)(commandBuffer, faceMask, compareMask)
	}
	fn vkCmdSetStencilWriteMask(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, writeMask: u32) {
		(self.vk_cmd_set_stencil_write_mask)(commandBuffer, faceMask, writeMask)
	}
	fn vkCmdSetStencilReference(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, reference: u32) {
		(self.vk_cmd_set_stencil_reference)(commandBuffer, faceMask, reference)
	}
	fn vkCmdBindDescriptorSets(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: *const VkDescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: *const uint32_t) {
		(self.vk_cmd_bind_descriptor_sets)(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets)
	}
	fn vkCmdBindIndexBuffer(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, indexType: VkIndexType) {
		(self.vk_cmd_bind_index_buffer)(commandBuffer, buffer, offset, indexType)
	}
	fn vkCmdBindVertexBuffers(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize) {
		(self.vk_cmd_bind_vertex_buffers)(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets)
	}
	fn vkCmdDraw(&self, commandBuffer: VkCommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32) {
		(self.vk_cmd_draw)(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance)
	}
	fn vkCmdDrawIndexed(&self, commandBuffer: VkCommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: i32, firstInstance: u32) {
		(self.vk_cmd_draw_indexed)(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)
	}
	fn vkCmdDrawIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) {
		(self.vk_cmd_draw_indirect)(commandBuffer, buffer, offset, drawCount, stride)
	}
	fn vkCmdDrawIndexedIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) {
		(self.vk_cmd_draw_indexed_indirect)(commandBuffer, buffer, offset, drawCount, stride)
	}
	fn vkCmdDispatch(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) {
		(self.vk_cmd_dispatch)(commandBuffer, groupCountX, groupCountY, groupCountZ)
	}
	fn vkCmdDispatchIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize) {
		(self.vk_cmd_dispatch_indirect)(commandBuffer, buffer, offset)
	}
	fn vkCmdCopyBuffer(&self, commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstBuffer: VkBuffer, regionCount: u32, pRegions: *const VkBufferCopy) {
		(self.vk_cmd_copy_buffer)(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions)
	}
	fn vkCmdCopyImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageCopy) {
		(self.vk_cmd_copy_image)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)
	}
	fn vkCmdBlitImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageBlit, filter: VkFilter) {
		(self.vk_cmd_blit_image)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter)
	}
	fn vkCmdCopyBufferToImage(&self, commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkBufferImageCopy) {
		(self.vk_cmd_copy_buffer_to_image)(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions)
	}
	fn vkCmdCopyImageToBuffer(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstBuffer: VkBuffer, regionCount: u32, pRegions: *const VkBufferImageCopy) {
		(self.vk_cmd_copy_image_to_buffer)(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions)
	}
	fn vkCmdUpdateBuffer(&self, commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, dataSize: VkDeviceSize, pData: *const c_void) {
		(self.vk_cmd_update_buffer)(commandBuffer, dstBuffer, dstOffset, dataSize, pData)
	}
	fn vkCmdFillBuffer(&self, commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, size: VkDeviceSize, data: u32) {
		(self.vk_cmd_fill_buffer)(commandBuffer, dstBuffer, dstOffset, size, data)
	}
	fn vkCmdClearColorImage(&self, commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pColor: *const VkClearColorValue, rangeCount: u32, pRanges: *const VkImageSubresourceRange) {
		(self.vk_cmd_clear_color_image)(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges)
	}
	fn vkCmdClearDepthStencilImage(&self, commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pDepthStencil: *const VkClearDepthStencilValue, rangeCount: u32, pRanges: *const VkImageSubresourceRange) {
		(self.vk_cmd_clear_depth_stencil_image)(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges)
	}
	fn vkCmdClearAttachments(&self, commandBuffer: VkCommandBuffer, attachmentCount: u32, pAttachments: *const VkClearAttachment, rectCount: u32, pRects: *const VkClearRect) {
		(self.vk_cmd_clear_attachments)(commandBuffer, attachmentCount, pAttachments, rectCount, pRects)
	}
	fn vkCmdResolveImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageResolve) {
		(self.vk_cmd_resolve_image)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)
	}
	fn vkCmdSetEvent(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) {
		(self.vk_cmd_set_event)(commandBuffer, event, stageMask)
	}
	fn vkCmdResetEvent(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) {
		(self.vk_cmd_reset_event)(commandBuffer, event, stageMask)
	}
	fn vkCmdWaitEvents(&self, commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const VkImageMemoryBarrier) {
		(self.vk_cmd_wait_events)(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)
	}
	fn vkCmdPipelineBarrier(&self, commandBuffer: VkCommandBuffer, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, dependencyFlags: VkDependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const VkImageMemoryBarrier) {
		(self.vk_cmd_pipeline_barrier)(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)
	}
	fn vkCmdBeginQuery(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags) {
		(self.vk_cmd_begin_query)(commandBuffer, queryPool, query, flags)
	}
	fn vkCmdEndQuery(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32) {
		(self.vk_cmd_end_query)(commandBuffer, queryPool, query)
	}
	fn vkCmdResetQueryPool(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) {
		(self.vk_cmd_reset_query_pool)(commandBuffer, queryPool, firstQuery, queryCount)
	}
	fn vkCmdWriteTimestamp(&self, commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, queryPool: VkQueryPool, query: u32) {
		(self.vk_cmd_write_timestamp)(commandBuffer, pipelineStage, queryPool, query)
	}
	fn vkCmdCopyQueryPoolResults(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, stride: VkDeviceSize, flags: VkQueryResultFlags) {
		(self.vk_cmd_copy_query_pool_results)(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags)
	}
	fn vkCmdPushConstants(&self, commandBuffer: VkCommandBuffer, layout: VkPipelineLayout, stageFlags: VkShaderStageFlags, offset: u32, size: u32, pValues: *const c_void) {
		(self.vk_cmd_push_constants)(commandBuffer, layout, stageFlags, offset, size, pValues)
	}
	fn vkCmdBeginRenderPass(&self, commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, contents: VkSubpassContents) {
		(self.vk_cmd_begin_render_pass)(commandBuffer, pRenderPassBegin, contents)
	}
	fn vkCmdNextSubpass(&self, commandBuffer: VkCommandBuffer, contents: VkSubpassContents) {
		(self.vk_cmd_next_subpass)(commandBuffer, contents)
	}
	fn vkCmdEndRenderPass(&self, commandBuffer: VkCommandBuffer) {
		(self.vk_cmd_end_render_pass)(commandBuffer)
	}
	fn vkCmdExecuteCommands(&self, commandBuffer: VkCommandBuffer, commandBufferCount: u32, pCommandBuffers: *const VkCommandBuffer) {
		(self.vk_cmd_execute_commands)(commandBuffer, commandBufferCount, pCommandBuffers)
	}
}
impl Default for Vulkan_VERSION_1_0 {
	fn default() -> Self {
		Self {
			vk_create_instance: dummy_vkCreateInstance,
			vk_destroy_instance: dummy_vkDestroyInstance,
			vk_enumerate_physical_devices: dummy_vkEnumeratePhysicalDevices,
			vk_get_physical_device_features: dummy_vkGetPhysicalDeviceFeatures,
			vk_get_physical_device_format_properties: dummy_vkGetPhysicalDeviceFormatProperties,
			vk_get_physical_device_image_format_properties: dummy_vkGetPhysicalDeviceImageFormatProperties,
			vk_get_physical_device_properties: dummy_vkGetPhysicalDeviceProperties,
			vk_get_physical_device_queue_family_properties: dummy_vkGetPhysicalDeviceQueueFamilyProperties,
			vk_get_physical_device_memory_properties: dummy_vkGetPhysicalDeviceMemoryProperties,
			vk_get_instance_proc_addr: dummy_vkGetInstanceProcAddr,
			vk_get_device_proc_addr: dummy_vkGetDeviceProcAddr,
			vk_create_device: dummy_vkCreateDevice,
			vk_destroy_device: dummy_vkDestroyDevice,
			vk_enumerate_instance_extension_properties: dummy_vkEnumerateInstanceExtensionProperties,
			vk_enumerate_device_extension_properties: dummy_vkEnumerateDeviceExtensionProperties,
			vk_enumerate_instance_layer_properties: dummy_vkEnumerateInstanceLayerProperties,
			vk_enumerate_device_layer_properties: dummy_vkEnumerateDeviceLayerProperties,
			vk_get_device_queue: dummy_vkGetDeviceQueue,
			vk_queue_submit: dummy_vkQueueSubmit,
			vk_queue_wait_idle: dummy_vkQueueWaitIdle,
			vk_device_wait_idle: dummy_vkDeviceWaitIdle,
			vk_allocate_memory: dummy_vkAllocateMemory,
			vk_free_memory: dummy_vkFreeMemory,
			vk_map_memory: dummy_vkMapMemory,
			vk_unmap_memory: dummy_vkUnmapMemory,
			vk_flush_mapped_memory_ranges: dummy_vkFlushMappedMemoryRanges,
			vk_invalidate_mapped_memory_ranges: dummy_vkInvalidateMappedMemoryRanges,
			vk_get_device_memory_commitment: dummy_vkGetDeviceMemoryCommitment,
			vk_bind_buffer_memory: dummy_vkBindBufferMemory,
			vk_bind_image_memory: dummy_vkBindImageMemory,
			vk_get_buffer_memory_requirements: dummy_vkGetBufferMemoryRequirements,
			vk_get_image_memory_requirements: dummy_vkGetImageMemoryRequirements,
			vk_get_image_sparse_memory_requirements: dummy_vkGetImageSparseMemoryRequirements,
			vk_get_physical_device_sparse_image_format_properties: dummy_vkGetPhysicalDeviceSparseImageFormatProperties,
			vk_queue_bind_sparse: dummy_vkQueueBindSparse,
			vk_create_fence: dummy_vkCreateFence,
			vk_destroy_fence: dummy_vkDestroyFence,
			vk_reset_fences: dummy_vkResetFences,
			vk_get_fence_status: dummy_vkGetFenceStatus,
			vk_wait_for_fences: dummy_vkWaitForFences,
			vk_create_semaphore: dummy_vkCreateSemaphore,
			vk_destroy_semaphore: dummy_vkDestroySemaphore,
			vk_create_event: dummy_vkCreateEvent,
			vk_destroy_event: dummy_vkDestroyEvent,
			vk_get_event_status: dummy_vkGetEventStatus,
			vk_set_event: dummy_vkSetEvent,
			vk_reset_event: dummy_vkResetEvent,
			vk_create_query_pool: dummy_vkCreateQueryPool,
			vk_destroy_query_pool: dummy_vkDestroyQueryPool,
			vk_get_query_pool_results: dummy_vkGetQueryPoolResults,
			vk_create_buffer: dummy_vkCreateBuffer,
			vk_destroy_buffer: dummy_vkDestroyBuffer,
			vk_create_buffer_view: dummy_vkCreateBufferView,
			vk_destroy_buffer_view: dummy_vkDestroyBufferView,
			vk_create_image: dummy_vkCreateImage,
			vk_destroy_image: dummy_vkDestroyImage,
			vk_get_image_subresource_layout: dummy_vkGetImageSubresourceLayout,
			vk_create_image_view: dummy_vkCreateImageView,
			vk_destroy_image_view: dummy_vkDestroyImageView,
			vk_create_shader_module: dummy_vkCreateShaderModule,
			vk_destroy_shader_module: dummy_vkDestroyShaderModule,
			vk_create_pipeline_cache: dummy_vkCreatePipelineCache,
			vk_destroy_pipeline_cache: dummy_vkDestroyPipelineCache,
			vk_get_pipeline_cache_data: dummy_vkGetPipelineCacheData,
			vk_merge_pipeline_caches: dummy_vkMergePipelineCaches,
			vk_create_graphics_pipelines: dummy_vkCreateGraphicsPipelines,
			vk_create_compute_pipelines: dummy_vkCreateComputePipelines,
			vk_destroy_pipeline: dummy_vkDestroyPipeline,
			vk_create_pipeline_layout: dummy_vkCreatePipelineLayout,
			vk_destroy_pipeline_layout: dummy_vkDestroyPipelineLayout,
			vk_create_sampler: dummy_vkCreateSampler,
			vk_destroy_sampler: dummy_vkDestroySampler,
			vk_create_descriptor_set_layout: dummy_vkCreateDescriptorSetLayout,
			vk_destroy_descriptor_set_layout: dummy_vkDestroyDescriptorSetLayout,
			vk_create_descriptor_pool: dummy_vkCreateDescriptorPool,
			vk_destroy_descriptor_pool: dummy_vkDestroyDescriptorPool,
			vk_reset_descriptor_pool: dummy_vkResetDescriptorPool,
			vk_allocate_descriptor_sets: dummy_vkAllocateDescriptorSets,
			vk_free_descriptor_sets: dummy_vkFreeDescriptorSets,
			vk_update_descriptor_sets: dummy_vkUpdateDescriptorSets,
			vk_create_framebuffer: dummy_vkCreateFramebuffer,
			vk_destroy_framebuffer: dummy_vkDestroyFramebuffer,
			vk_create_render_pass: dummy_vkCreateRenderPass,
			vk_destroy_render_pass: dummy_vkDestroyRenderPass,
			vk_get_render_area_granularity: dummy_vkGetRenderAreaGranularity,
			vk_create_command_pool: dummy_vkCreateCommandPool,
			vk_destroy_command_pool: dummy_vkDestroyCommandPool,
			vk_reset_command_pool: dummy_vkResetCommandPool,
			vk_allocate_command_buffers: dummy_vkAllocateCommandBuffers,
			vk_free_command_buffers: dummy_vkFreeCommandBuffers,
			vk_begin_command_buffer: dummy_vkBeginCommandBuffer,
			vk_end_command_buffer: dummy_vkEndCommandBuffer,
			vk_reset_command_buffer: dummy_vkResetCommandBuffer,
			vk_cmd_bind_pipeline: dummy_vkCmdBindPipeline,
			vk_cmd_set_viewport: dummy_vkCmdSetViewport,
			vk_cmd_set_scissor: dummy_vkCmdSetScissor,
			vk_cmd_set_line_width: dummy_vkCmdSetLineWidth,
			vk_cmd_set_depth_bias: dummy_vkCmdSetDepthBias,
			vk_cmd_set_blend_constants: dummy_vkCmdSetBlendConstants,
			vk_cmd_set_depth_bounds: dummy_vkCmdSetDepthBounds,
			vk_cmd_set_stencil_compare_mask: dummy_vkCmdSetStencilCompareMask,
			vk_cmd_set_stencil_write_mask: dummy_vkCmdSetStencilWriteMask,
			vk_cmd_set_stencil_reference: dummy_vkCmdSetStencilReference,
			vk_cmd_bind_descriptor_sets: dummy_vkCmdBindDescriptorSets,
			vk_cmd_bind_index_buffer: dummy_vkCmdBindIndexBuffer,
			vk_cmd_bind_vertex_buffers: dummy_vkCmdBindVertexBuffers,
			vk_cmd_draw: dummy_vkCmdDraw,
			vk_cmd_draw_indexed: dummy_vkCmdDrawIndexed,
			vk_cmd_draw_indirect: dummy_vkCmdDrawIndirect,
			vk_cmd_draw_indexed_indirect: dummy_vkCmdDrawIndexedIndirect,
			vk_cmd_dispatch: dummy_vkCmdDispatch,
			vk_cmd_dispatch_indirect: dummy_vkCmdDispatchIndirect,
			vk_cmd_copy_buffer: dummy_vkCmdCopyBuffer,
			vk_cmd_copy_image: dummy_vkCmdCopyImage,
			vk_cmd_blit_image: dummy_vkCmdBlitImage,
			vk_cmd_copy_buffer_to_image: dummy_vkCmdCopyBufferToImage,
			vk_cmd_copy_image_to_buffer: dummy_vkCmdCopyImageToBuffer,
			vk_cmd_update_buffer: dummy_vkCmdUpdateBuffer,
			vk_cmd_fill_buffer: dummy_vkCmdFillBuffer,
			vk_cmd_clear_color_image: dummy_vkCmdClearColorImage,
			vk_cmd_clear_depth_stencil_image: dummy_vkCmdClearDepthStencilImage,
			vk_cmd_clear_attachments: dummy_vkCmdClearAttachments,
			vk_cmd_resolve_image: dummy_vkCmdResolveImage,
			vk_cmd_set_event: dummy_vkCmdSetEvent,
			vk_cmd_reset_event: dummy_vkCmdResetEvent,
			vk_cmd_wait_events: dummy_vkCmdWaitEvents,
			vk_cmd_pipeline_barrier: dummy_vkCmdPipelineBarrier,
			vk_cmd_begin_query: dummy_vkCmdBeginQuery,
			vk_cmd_end_query: dummy_vkCmdEndQuery,
			vk_cmd_reset_query_pool: dummy_vkCmdResetQueryPool,
			vk_cmd_write_timestamp: dummy_vkCmdWriteTimestamp,
			vk_cmd_copy_query_pool_results: dummy_vkCmdCopyQueryPoolResults,
			vk_cmd_push_constants: dummy_vkCmdPushConstants,
			vk_cmd_begin_render_pass: dummy_vkCmdBeginRenderPass,
			vk_cmd_next_subpass: dummy_vkCmdNextSubpass,
			vk_cmd_end_render_pass: dummy_vkCmdEndRenderPass,
			vk_cmd_execute_commands: dummy_vkCmdExecuteCommands,
		}
	}
}
impl Vulkan_VERSION_1_0 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_instance: {let proc = get_proc_address(instance, "vkCreateInstance"); if proc == null() {dummy_vkCreateInstance} else {unsafe {transmute(proc)}}},
			vk_destroy_instance: {let proc = get_proc_address(instance, "vkDestroyInstance"); if proc == null() {dummy_vkDestroyInstance} else {unsafe {transmute(proc)}}},
			vk_enumerate_physical_devices: {let proc = get_proc_address(instance, "vkEnumeratePhysicalDevices"); if proc == null() {dummy_vkEnumeratePhysicalDevices} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_features: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceFeatures"); if proc == null() {dummy_vkGetPhysicalDeviceFeatures} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_format_properties: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceFormatProperties"); if proc == null() {dummy_vkGetPhysicalDeviceFormatProperties} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_image_format_properties: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceImageFormatProperties"); if proc == null() {dummy_vkGetPhysicalDeviceImageFormatProperties} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_properties: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceProperties"); if proc == null() {dummy_vkGetPhysicalDeviceProperties} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_queue_family_properties: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceQueueFamilyProperties"); if proc == null() {dummy_vkGetPhysicalDeviceQueueFamilyProperties} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_memory_properties: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceMemoryProperties"); if proc == null() {dummy_vkGetPhysicalDeviceMemoryProperties} else {unsafe {transmute(proc)}}},
			vk_get_instance_proc_addr: {let proc = get_proc_address(instance, "vkGetInstanceProcAddr"); if proc == null() {dummy_vkGetInstanceProcAddr} else {unsafe {transmute(proc)}}},
			vk_get_device_proc_addr: {let proc = get_proc_address(instance, "vkGetDeviceProcAddr"); if proc == null() {dummy_vkGetDeviceProcAddr} else {unsafe {transmute(proc)}}},
			vk_create_device: {let proc = get_proc_address(instance, "vkCreateDevice"); if proc == null() {dummy_vkCreateDevice} else {unsafe {transmute(proc)}}},
			vk_destroy_device: {let proc = get_proc_address(instance, "vkDestroyDevice"); if proc == null() {dummy_vkDestroyDevice} else {unsafe {transmute(proc)}}},
			vk_enumerate_instance_extension_properties: {let proc = get_proc_address(instance, "vkEnumerateInstanceExtensionProperties"); if proc == null() {dummy_vkEnumerateInstanceExtensionProperties} else {unsafe {transmute(proc)}}},
			vk_enumerate_device_extension_properties: {let proc = get_proc_address(instance, "vkEnumerateDeviceExtensionProperties"); if proc == null() {dummy_vkEnumerateDeviceExtensionProperties} else {unsafe {transmute(proc)}}},
			vk_enumerate_instance_layer_properties: {let proc = get_proc_address(instance, "vkEnumerateInstanceLayerProperties"); if proc == null() {dummy_vkEnumerateInstanceLayerProperties} else {unsafe {transmute(proc)}}},
			vk_enumerate_device_layer_properties: {let proc = get_proc_address(instance, "vkEnumerateDeviceLayerProperties"); if proc == null() {dummy_vkEnumerateDeviceLayerProperties} else {unsafe {transmute(proc)}}},
			vk_get_device_queue: {let proc = get_proc_address(instance, "vkGetDeviceQueue"); if proc == null() {dummy_vkGetDeviceQueue} else {unsafe {transmute(proc)}}},
			vk_queue_submit: {let proc = get_proc_address(instance, "vkQueueSubmit"); if proc == null() {dummy_vkQueueSubmit} else {unsafe {transmute(proc)}}},
			vk_queue_wait_idle: {let proc = get_proc_address(instance, "vkQueueWaitIdle"); if proc == null() {dummy_vkQueueWaitIdle} else {unsafe {transmute(proc)}}},
			vk_device_wait_idle: {let proc = get_proc_address(instance, "vkDeviceWaitIdle"); if proc == null() {dummy_vkDeviceWaitIdle} else {unsafe {transmute(proc)}}},
			vk_allocate_memory: {let proc = get_proc_address(instance, "vkAllocateMemory"); if proc == null() {dummy_vkAllocateMemory} else {unsafe {transmute(proc)}}},
			vk_free_memory: {let proc = get_proc_address(instance, "vkFreeMemory"); if proc == null() {dummy_vkFreeMemory} else {unsafe {transmute(proc)}}},
			vk_map_memory: {let proc = get_proc_address(instance, "vkMapMemory"); if proc == null() {dummy_vkMapMemory} else {unsafe {transmute(proc)}}},
			vk_unmap_memory: {let proc = get_proc_address(instance, "vkUnmapMemory"); if proc == null() {dummy_vkUnmapMemory} else {unsafe {transmute(proc)}}},
			vk_flush_mapped_memory_ranges: {let proc = get_proc_address(instance, "vkFlushMappedMemoryRanges"); if proc == null() {dummy_vkFlushMappedMemoryRanges} else {unsafe {transmute(proc)}}},
			vk_invalidate_mapped_memory_ranges: {let proc = get_proc_address(instance, "vkInvalidateMappedMemoryRanges"); if proc == null() {dummy_vkInvalidateMappedMemoryRanges} else {unsafe {transmute(proc)}}},
			vk_get_device_memory_commitment: {let proc = get_proc_address(instance, "vkGetDeviceMemoryCommitment"); if proc == null() {dummy_vkGetDeviceMemoryCommitment} else {unsafe {transmute(proc)}}},
			vk_bind_buffer_memory: {let proc = get_proc_address(instance, "vkBindBufferMemory"); if proc == null() {dummy_vkBindBufferMemory} else {unsafe {transmute(proc)}}},
			vk_bind_image_memory: {let proc = get_proc_address(instance, "vkBindImageMemory"); if proc == null() {dummy_vkBindImageMemory} else {unsafe {transmute(proc)}}},
			vk_get_buffer_memory_requirements: {let proc = get_proc_address(instance, "vkGetBufferMemoryRequirements"); if proc == null() {dummy_vkGetBufferMemoryRequirements} else {unsafe {transmute(proc)}}},
			vk_get_image_memory_requirements: {let proc = get_proc_address(instance, "vkGetImageMemoryRequirements"); if proc == null() {dummy_vkGetImageMemoryRequirements} else {unsafe {transmute(proc)}}},
			vk_get_image_sparse_memory_requirements: {let proc = get_proc_address(instance, "vkGetImageSparseMemoryRequirements"); if proc == null() {dummy_vkGetImageSparseMemoryRequirements} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_sparse_image_format_properties: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceSparseImageFormatProperties"); if proc == null() {dummy_vkGetPhysicalDeviceSparseImageFormatProperties} else {unsafe {transmute(proc)}}},
			vk_queue_bind_sparse: {let proc = get_proc_address(instance, "vkQueueBindSparse"); if proc == null() {dummy_vkQueueBindSparse} else {unsafe {transmute(proc)}}},
			vk_create_fence: {let proc = get_proc_address(instance, "vkCreateFence"); if proc == null() {dummy_vkCreateFence} else {unsafe {transmute(proc)}}},
			vk_destroy_fence: {let proc = get_proc_address(instance, "vkDestroyFence"); if proc == null() {dummy_vkDestroyFence} else {unsafe {transmute(proc)}}},
			vk_reset_fences: {let proc = get_proc_address(instance, "vkResetFences"); if proc == null() {dummy_vkResetFences} else {unsafe {transmute(proc)}}},
			vk_get_fence_status: {let proc = get_proc_address(instance, "vkGetFenceStatus"); if proc == null() {dummy_vkGetFenceStatus} else {unsafe {transmute(proc)}}},
			vk_wait_for_fences: {let proc = get_proc_address(instance, "vkWaitForFences"); if proc == null() {dummy_vkWaitForFences} else {unsafe {transmute(proc)}}},
			vk_create_semaphore: {let proc = get_proc_address(instance, "vkCreateSemaphore"); if proc == null() {dummy_vkCreateSemaphore} else {unsafe {transmute(proc)}}},
			vk_destroy_semaphore: {let proc = get_proc_address(instance, "vkDestroySemaphore"); if proc == null() {dummy_vkDestroySemaphore} else {unsafe {transmute(proc)}}},
			vk_create_event: {let proc = get_proc_address(instance, "vkCreateEvent"); if proc == null() {dummy_vkCreateEvent} else {unsafe {transmute(proc)}}},
			vk_destroy_event: {let proc = get_proc_address(instance, "vkDestroyEvent"); if proc == null() {dummy_vkDestroyEvent} else {unsafe {transmute(proc)}}},
			vk_get_event_status: {let proc = get_proc_address(instance, "vkGetEventStatus"); if proc == null() {dummy_vkGetEventStatus} else {unsafe {transmute(proc)}}},
			vk_set_event: {let proc = get_proc_address(instance, "vkSetEvent"); if proc == null() {dummy_vkSetEvent} else {unsafe {transmute(proc)}}},
			vk_reset_event: {let proc = get_proc_address(instance, "vkResetEvent"); if proc == null() {dummy_vkResetEvent} else {unsafe {transmute(proc)}}},
			vk_create_query_pool: {let proc = get_proc_address(instance, "vkCreateQueryPool"); if proc == null() {dummy_vkCreateQueryPool} else {unsafe {transmute(proc)}}},
			vk_destroy_query_pool: {let proc = get_proc_address(instance, "vkDestroyQueryPool"); if proc == null() {dummy_vkDestroyQueryPool} else {unsafe {transmute(proc)}}},
			vk_get_query_pool_results: {let proc = get_proc_address(instance, "vkGetQueryPoolResults"); if proc == null() {dummy_vkGetQueryPoolResults} else {unsafe {transmute(proc)}}},
			vk_create_buffer: {let proc = get_proc_address(instance, "vkCreateBuffer"); if proc == null() {dummy_vkCreateBuffer} else {unsafe {transmute(proc)}}},
			vk_destroy_buffer: {let proc = get_proc_address(instance, "vkDestroyBuffer"); if proc == null() {dummy_vkDestroyBuffer} else {unsafe {transmute(proc)}}},
			vk_create_buffer_view: {let proc = get_proc_address(instance, "vkCreateBufferView"); if proc == null() {dummy_vkCreateBufferView} else {unsafe {transmute(proc)}}},
			vk_destroy_buffer_view: {let proc = get_proc_address(instance, "vkDestroyBufferView"); if proc == null() {dummy_vkDestroyBufferView} else {unsafe {transmute(proc)}}},
			vk_create_image: {let proc = get_proc_address(instance, "vkCreateImage"); if proc == null() {dummy_vkCreateImage} else {unsafe {transmute(proc)}}},
			vk_destroy_image: {let proc = get_proc_address(instance, "vkDestroyImage"); if proc == null() {dummy_vkDestroyImage} else {unsafe {transmute(proc)}}},
			vk_get_image_subresource_layout: {let proc = get_proc_address(instance, "vkGetImageSubresourceLayout"); if proc == null() {dummy_vkGetImageSubresourceLayout} else {unsafe {transmute(proc)}}},
			vk_create_image_view: {let proc = get_proc_address(instance, "vkCreateImageView"); if proc == null() {dummy_vkCreateImageView} else {unsafe {transmute(proc)}}},
			vk_destroy_image_view: {let proc = get_proc_address(instance, "vkDestroyImageView"); if proc == null() {dummy_vkDestroyImageView} else {unsafe {transmute(proc)}}},
			vk_create_shader_module: {let proc = get_proc_address(instance, "vkCreateShaderModule"); if proc == null() {dummy_vkCreateShaderModule} else {unsafe {transmute(proc)}}},
			vk_destroy_shader_module: {let proc = get_proc_address(instance, "vkDestroyShaderModule"); if proc == null() {dummy_vkDestroyShaderModule} else {unsafe {transmute(proc)}}},
			vk_create_pipeline_cache: {let proc = get_proc_address(instance, "vkCreatePipelineCache"); if proc == null() {dummy_vkCreatePipelineCache} else {unsafe {transmute(proc)}}},
			vk_destroy_pipeline_cache: {let proc = get_proc_address(instance, "vkDestroyPipelineCache"); if proc == null() {dummy_vkDestroyPipelineCache} else {unsafe {transmute(proc)}}},
			vk_get_pipeline_cache_data: {let proc = get_proc_address(instance, "vkGetPipelineCacheData"); if proc == null() {dummy_vkGetPipelineCacheData} else {unsafe {transmute(proc)}}},
			vk_merge_pipeline_caches: {let proc = get_proc_address(instance, "vkMergePipelineCaches"); if proc == null() {dummy_vkMergePipelineCaches} else {unsafe {transmute(proc)}}},
			vk_create_graphics_pipelines: {let proc = get_proc_address(instance, "vkCreateGraphicsPipelines"); if proc == null() {dummy_vkCreateGraphicsPipelines} else {unsafe {transmute(proc)}}},
			vk_create_compute_pipelines: {let proc = get_proc_address(instance, "vkCreateComputePipelines"); if proc == null() {dummy_vkCreateComputePipelines} else {unsafe {transmute(proc)}}},
			vk_destroy_pipeline: {let proc = get_proc_address(instance, "vkDestroyPipeline"); if proc == null() {dummy_vkDestroyPipeline} else {unsafe {transmute(proc)}}},
			vk_create_pipeline_layout: {let proc = get_proc_address(instance, "vkCreatePipelineLayout"); if proc == null() {dummy_vkCreatePipelineLayout} else {unsafe {transmute(proc)}}},
			vk_destroy_pipeline_layout: {let proc = get_proc_address(instance, "vkDestroyPipelineLayout"); if proc == null() {dummy_vkDestroyPipelineLayout} else {unsafe {transmute(proc)}}},
			vk_create_sampler: {let proc = get_proc_address(instance, "vkCreateSampler"); if proc == null() {dummy_vkCreateSampler} else {unsafe {transmute(proc)}}},
			vk_destroy_sampler: {let proc = get_proc_address(instance, "vkDestroySampler"); if proc == null() {dummy_vkDestroySampler} else {unsafe {transmute(proc)}}},
			vk_create_descriptor_set_layout: {let proc = get_proc_address(instance, "vkCreateDescriptorSetLayout"); if proc == null() {dummy_vkCreateDescriptorSetLayout} else {unsafe {transmute(proc)}}},
			vk_destroy_descriptor_set_layout: {let proc = get_proc_address(instance, "vkDestroyDescriptorSetLayout"); if proc == null() {dummy_vkDestroyDescriptorSetLayout} else {unsafe {transmute(proc)}}},
			vk_create_descriptor_pool: {let proc = get_proc_address(instance, "vkCreateDescriptorPool"); if proc == null() {dummy_vkCreateDescriptorPool} else {unsafe {transmute(proc)}}},
			vk_destroy_descriptor_pool: {let proc = get_proc_address(instance, "vkDestroyDescriptorPool"); if proc == null() {dummy_vkDestroyDescriptorPool} else {unsafe {transmute(proc)}}},
			vk_reset_descriptor_pool: {let proc = get_proc_address(instance, "vkResetDescriptorPool"); if proc == null() {dummy_vkResetDescriptorPool} else {unsafe {transmute(proc)}}},
			vk_allocate_descriptor_sets: {let proc = get_proc_address(instance, "vkAllocateDescriptorSets"); if proc == null() {dummy_vkAllocateDescriptorSets} else {unsafe {transmute(proc)}}},
			vk_free_descriptor_sets: {let proc = get_proc_address(instance, "vkFreeDescriptorSets"); if proc == null() {dummy_vkFreeDescriptorSets} else {unsafe {transmute(proc)}}},
			vk_update_descriptor_sets: {let proc = get_proc_address(instance, "vkUpdateDescriptorSets"); if proc == null() {dummy_vkUpdateDescriptorSets} else {unsafe {transmute(proc)}}},
			vk_create_framebuffer: {let proc = get_proc_address(instance, "vkCreateFramebuffer"); if proc == null() {dummy_vkCreateFramebuffer} else {unsafe {transmute(proc)}}},
			vk_destroy_framebuffer: {let proc = get_proc_address(instance, "vkDestroyFramebuffer"); if proc == null() {dummy_vkDestroyFramebuffer} else {unsafe {transmute(proc)}}},
			vk_create_render_pass: {let proc = get_proc_address(instance, "vkCreateRenderPass"); if proc == null() {dummy_vkCreateRenderPass} else {unsafe {transmute(proc)}}},
			vk_destroy_render_pass: {let proc = get_proc_address(instance, "vkDestroyRenderPass"); if proc == null() {dummy_vkDestroyRenderPass} else {unsafe {transmute(proc)}}},
			vk_get_render_area_granularity: {let proc = get_proc_address(instance, "vkGetRenderAreaGranularity"); if proc == null() {dummy_vkGetRenderAreaGranularity} else {unsafe {transmute(proc)}}},
			vk_create_command_pool: {let proc = get_proc_address(instance, "vkCreateCommandPool"); if proc == null() {dummy_vkCreateCommandPool} else {unsafe {transmute(proc)}}},
			vk_destroy_command_pool: {let proc = get_proc_address(instance, "vkDestroyCommandPool"); if proc == null() {dummy_vkDestroyCommandPool} else {unsafe {transmute(proc)}}},
			vk_reset_command_pool: {let proc = get_proc_address(instance, "vkResetCommandPool"); if proc == null() {dummy_vkResetCommandPool} else {unsafe {transmute(proc)}}},
			vk_allocate_command_buffers: {let proc = get_proc_address(instance, "vkAllocateCommandBuffers"); if proc == null() {dummy_vkAllocateCommandBuffers} else {unsafe {transmute(proc)}}},
			vk_free_command_buffers: {let proc = get_proc_address(instance, "vkFreeCommandBuffers"); if proc == null() {dummy_vkFreeCommandBuffers} else {unsafe {transmute(proc)}}},
			vk_begin_command_buffer: {let proc = get_proc_address(instance, "vkBeginCommandBuffer"); if proc == null() {dummy_vkBeginCommandBuffer} else {unsafe {transmute(proc)}}},
			vk_end_command_buffer: {let proc = get_proc_address(instance, "vkEndCommandBuffer"); if proc == null() {dummy_vkEndCommandBuffer} else {unsafe {transmute(proc)}}},
			vk_reset_command_buffer: {let proc = get_proc_address(instance, "vkResetCommandBuffer"); if proc == null() {dummy_vkResetCommandBuffer} else {unsafe {transmute(proc)}}},
			vk_cmd_bind_pipeline: {let proc = get_proc_address(instance, "vkCmdBindPipeline"); if proc == null() {dummy_vkCmdBindPipeline} else {unsafe {transmute(proc)}}},
			vk_cmd_set_viewport: {let proc = get_proc_address(instance, "vkCmdSetViewport"); if proc == null() {dummy_vkCmdSetViewport} else {unsafe {transmute(proc)}}},
			vk_cmd_set_scissor: {let proc = get_proc_address(instance, "vkCmdSetScissor"); if proc == null() {dummy_vkCmdSetScissor} else {unsafe {transmute(proc)}}},
			vk_cmd_set_line_width: {let proc = get_proc_address(instance, "vkCmdSetLineWidth"); if proc == null() {dummy_vkCmdSetLineWidth} else {unsafe {transmute(proc)}}},
			vk_cmd_set_depth_bias: {let proc = get_proc_address(instance, "vkCmdSetDepthBias"); if proc == null() {dummy_vkCmdSetDepthBias} else {unsafe {transmute(proc)}}},
			vk_cmd_set_blend_constants: {let proc = get_proc_address(instance, "vkCmdSetBlendConstants"); if proc == null() {dummy_vkCmdSetBlendConstants} else {unsafe {transmute(proc)}}},
			vk_cmd_set_depth_bounds: {let proc = get_proc_address(instance, "vkCmdSetDepthBounds"); if proc == null() {dummy_vkCmdSetDepthBounds} else {unsafe {transmute(proc)}}},
			vk_cmd_set_stencil_compare_mask: {let proc = get_proc_address(instance, "vkCmdSetStencilCompareMask"); if proc == null() {dummy_vkCmdSetStencilCompareMask} else {unsafe {transmute(proc)}}},
			vk_cmd_set_stencil_write_mask: {let proc = get_proc_address(instance, "vkCmdSetStencilWriteMask"); if proc == null() {dummy_vkCmdSetStencilWriteMask} else {unsafe {transmute(proc)}}},
			vk_cmd_set_stencil_reference: {let proc = get_proc_address(instance, "vkCmdSetStencilReference"); if proc == null() {dummy_vkCmdSetStencilReference} else {unsafe {transmute(proc)}}},
			vk_cmd_bind_descriptor_sets: {let proc = get_proc_address(instance, "vkCmdBindDescriptorSets"); if proc == null() {dummy_vkCmdBindDescriptorSets} else {unsafe {transmute(proc)}}},
			vk_cmd_bind_index_buffer: {let proc = get_proc_address(instance, "vkCmdBindIndexBuffer"); if proc == null() {dummy_vkCmdBindIndexBuffer} else {unsafe {transmute(proc)}}},
			vk_cmd_bind_vertex_buffers: {let proc = get_proc_address(instance, "vkCmdBindVertexBuffers"); if proc == null() {dummy_vkCmdBindVertexBuffers} else {unsafe {transmute(proc)}}},
			vk_cmd_draw: {let proc = get_proc_address(instance, "vkCmdDraw"); if proc == null() {dummy_vkCmdDraw} else {unsafe {transmute(proc)}}},
			vk_cmd_draw_indexed: {let proc = get_proc_address(instance, "vkCmdDrawIndexed"); if proc == null() {dummy_vkCmdDrawIndexed} else {unsafe {transmute(proc)}}},
			vk_cmd_draw_indirect: {let proc = get_proc_address(instance, "vkCmdDrawIndirect"); if proc == null() {dummy_vkCmdDrawIndirect} else {unsafe {transmute(proc)}}},
			vk_cmd_draw_indexed_indirect: {let proc = get_proc_address(instance, "vkCmdDrawIndexedIndirect"); if proc == null() {dummy_vkCmdDrawIndexedIndirect} else {unsafe {transmute(proc)}}},
			vk_cmd_dispatch: {let proc = get_proc_address(instance, "vkCmdDispatch"); if proc == null() {dummy_vkCmdDispatch} else {unsafe {transmute(proc)}}},
			vk_cmd_dispatch_indirect: {let proc = get_proc_address(instance, "vkCmdDispatchIndirect"); if proc == null() {dummy_vkCmdDispatchIndirect} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_buffer: {let proc = get_proc_address(instance, "vkCmdCopyBuffer"); if proc == null() {dummy_vkCmdCopyBuffer} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_image: {let proc = get_proc_address(instance, "vkCmdCopyImage"); if proc == null() {dummy_vkCmdCopyImage} else {unsafe {transmute(proc)}}},
			vk_cmd_blit_image: {let proc = get_proc_address(instance, "vkCmdBlitImage"); if proc == null() {dummy_vkCmdBlitImage} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_buffer_to_image: {let proc = get_proc_address(instance, "vkCmdCopyBufferToImage"); if proc == null() {dummy_vkCmdCopyBufferToImage} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_image_to_buffer: {let proc = get_proc_address(instance, "vkCmdCopyImageToBuffer"); if proc == null() {dummy_vkCmdCopyImageToBuffer} else {unsafe {transmute(proc)}}},
			vk_cmd_update_buffer: {let proc = get_proc_address(instance, "vkCmdUpdateBuffer"); if proc == null() {dummy_vkCmdUpdateBuffer} else {unsafe {transmute(proc)}}},
			vk_cmd_fill_buffer: {let proc = get_proc_address(instance, "vkCmdFillBuffer"); if proc == null() {dummy_vkCmdFillBuffer} else {unsafe {transmute(proc)}}},
			vk_cmd_clear_color_image: {let proc = get_proc_address(instance, "vkCmdClearColorImage"); if proc == null() {dummy_vkCmdClearColorImage} else {unsafe {transmute(proc)}}},
			vk_cmd_clear_depth_stencil_image: {let proc = get_proc_address(instance, "vkCmdClearDepthStencilImage"); if proc == null() {dummy_vkCmdClearDepthStencilImage} else {unsafe {transmute(proc)}}},
			vk_cmd_clear_attachments: {let proc = get_proc_address(instance, "vkCmdClearAttachments"); if proc == null() {dummy_vkCmdClearAttachments} else {unsafe {transmute(proc)}}},
			vk_cmd_resolve_image: {let proc = get_proc_address(instance, "vkCmdResolveImage"); if proc == null() {dummy_vkCmdResolveImage} else {unsafe {transmute(proc)}}},
			vk_cmd_set_event: {let proc = get_proc_address(instance, "vkCmdSetEvent"); if proc == null() {dummy_vkCmdSetEvent} else {unsafe {transmute(proc)}}},
			vk_cmd_reset_event: {let proc = get_proc_address(instance, "vkCmdResetEvent"); if proc == null() {dummy_vkCmdResetEvent} else {unsafe {transmute(proc)}}},
			vk_cmd_wait_events: {let proc = get_proc_address(instance, "vkCmdWaitEvents"); if proc == null() {dummy_vkCmdWaitEvents} else {unsafe {transmute(proc)}}},
			vk_cmd_pipeline_barrier: {let proc = get_proc_address(instance, "vkCmdPipelineBarrier"); if proc == null() {dummy_vkCmdPipelineBarrier} else {unsafe {transmute(proc)}}},
			vk_cmd_begin_query: {let proc = get_proc_address(instance, "vkCmdBeginQuery"); if proc == null() {dummy_vkCmdBeginQuery} else {unsafe {transmute(proc)}}},
			vk_cmd_end_query: {let proc = get_proc_address(instance, "vkCmdEndQuery"); if proc == null() {dummy_vkCmdEndQuery} else {unsafe {transmute(proc)}}},
			vk_cmd_reset_query_pool: {let proc = get_proc_address(instance, "vkCmdResetQueryPool"); if proc == null() {dummy_vkCmdResetQueryPool} else {unsafe {transmute(proc)}}},
			vk_cmd_write_timestamp: {let proc = get_proc_address(instance, "vkCmdWriteTimestamp"); if proc == null() {dummy_vkCmdWriteTimestamp} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_query_pool_results: {let proc = get_proc_address(instance, "vkCmdCopyQueryPoolResults"); if proc == null() {dummy_vkCmdCopyQueryPoolResults} else {unsafe {transmute(proc)}}},
			vk_cmd_push_constants: {let proc = get_proc_address(instance, "vkCmdPushConstants"); if proc == null() {dummy_vkCmdPushConstants} else {unsafe {transmute(proc)}}},
			vk_cmd_begin_render_pass: {let proc = get_proc_address(instance, "vkCmdBeginRenderPass"); if proc == null() {dummy_vkCmdBeginRenderPass} else {unsafe {transmute(proc)}}},
			vk_cmd_next_subpass: {let proc = get_proc_address(instance, "vkCmdNextSubpass"); if proc == null() {dummy_vkCmdNextSubpass} else {unsafe {transmute(proc)}}},
			vk_cmd_end_render_pass: {let proc = get_proc_address(instance, "vkCmdEndRenderPass"); if proc == null() {dummy_vkCmdEndRenderPass} else {unsafe {transmute(proc)}}},
			vk_cmd_execute_commands: {let proc = get_proc_address(instance, "vkCmdExecuteCommands"); if proc == null() {dummy_vkCmdExecuteCommands} else {unsafe {transmute(proc)}}},
		}
	}
}
pub const VK_API_VERSION_1_1: u32 = 0x401000;
pub const VK_MAX_DEVICE_GROUP_SIZE: u32 = 32u32;
pub const VK_LUID_SIZE: u32 = 8u32;
pub const VK_QUEUE_FAMILY_EXTERNAL: u32 = !1u32;
pub type VkSubgroupFeatureFlags = VkFlags;
pub type VkPeerMemoryFeatureFlags = VkFlags;
pub type VkMemoryAllocateFlags = VkFlags;
pub type VkCommandPoolTrimFlags = VkFlags;
pub type VkDescriptorUpdateTemplateCreateFlags = VkFlags;
pub type VkExternalMemoryHandleTypeFlags = VkFlags;
pub type VkExternalMemoryFeatureFlags = VkFlags;
pub type VkExternalFenceHandleTypeFlags = VkFlags;
pub type VkExternalFenceFeatureFlags = VkFlags;
pub type VkFenceImportFlags = VkFlags;
pub type VkSemaphoreImportFlags = VkFlags;
pub type VkExternalSemaphoreHandleTypeFlags = VkFlags;
pub type VkExternalSemaphoreFeatureFlags = VkFlags;
pub type VkPhysicalDeviceVariablePointerFeatures = VkPhysicalDeviceVariablePointersFeatures;
pub type VkPhysicalDeviceShaderDrawParameterFeatures = VkPhysicalDeviceShaderDrawParametersFeatures;
// Define non-dispatchable handle `VkSamplerYcbcrConversion`
#[cfg(target_pointer_width = "32")] pub type VkSamplerYcbcrConversion = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkSamplerYcbcrConversion_T {}
#[cfg(target_pointer_width = "64")] pub type VkSamplerYcbcrConversion = *const VkSamplerYcbcrConversion_T;
// Define non-dispatchable handle `VkDescriptorUpdateTemplate`
#[cfg(target_pointer_width = "32")] pub type VkDescriptorUpdateTemplate = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkDescriptorUpdateTemplate_T {}
#[cfg(target_pointer_width = "64")] pub type VkDescriptorUpdateTemplate = *const VkDescriptorUpdateTemplate_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPointClippingBehavior {
	VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
	VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
	VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM = 0x7fffffff,
}
impl VkPointClippingBehavior {
	pub const VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR: VkPointClippingBehavior = VkPointClippingBehavior::VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES;
	pub const VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR: VkPointClippingBehavior = VkPointClippingBehavior::VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkTessellationDomainOrigin {
	VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
	VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
	VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM = 0x7fffffff,
}
impl VkTessellationDomainOrigin {
	pub const VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR: VkTessellationDomainOrigin = VkTessellationDomainOrigin::VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT;
	pub const VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR: VkTessellationDomainOrigin = VkTessellationDomainOrigin::VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSamplerYcbcrModelConversion {
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM = 0x7fffffff,
}
impl VkSamplerYcbcrModelConversion {
	pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR: VkSamplerYcbcrModelConversion = VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY;
	pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR: VkSamplerYcbcrModelConversion = VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY;
	pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR: VkSamplerYcbcrModelConversion = VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709;
	pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR: VkSamplerYcbcrModelConversion = VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601;
	pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR: VkSamplerYcbcrModelConversion = VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSamplerYcbcrRange {
	VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
	VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
	VK_SAMPLER_YCBCR_RANGE_MAX_ENUM = 0x7fffffff,
}
impl VkSamplerYcbcrRange {
	pub const VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR: VkSamplerYcbcrRange = VkSamplerYcbcrRange::VK_SAMPLER_YCBCR_RANGE_ITU_FULL;
	pub const VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR: VkSamplerYcbcrRange = VkSamplerYcbcrRange::VK_SAMPLER_YCBCR_RANGE_ITU_NARROW;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkChromaLocation {
	VK_CHROMA_LOCATION_COSITED_EVEN = 0,
	VK_CHROMA_LOCATION_MIDPOINT = 1,
	VK_CHROMA_LOCATION_MAX_ENUM = 0x7fffffff,
}
impl VkChromaLocation {
	pub const VK_CHROMA_LOCATION_COSITED_EVEN_KHR: VkChromaLocation = VkChromaLocation::VK_CHROMA_LOCATION_COSITED_EVEN;
	pub const VK_CHROMA_LOCATION_MIDPOINT_KHR: VkChromaLocation = VkChromaLocation::VK_CHROMA_LOCATION_MIDPOINT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDescriptorUpdateTemplateType {
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS = 1,
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM = 0x7fffffff,
}
impl VkDescriptorUpdateTemplateType {
	pub const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR: VkDescriptorUpdateTemplateType = VkDescriptorUpdateTemplateType::VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS;
	pub const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR: VkDescriptorUpdateTemplateType = VkDescriptorUpdateTemplateType::VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSubgroupFeatureFlagBits {
	VK_SUBGROUP_FEATURE_BASIC_BIT = 0x00000001,
	VK_SUBGROUP_FEATURE_VOTE_BIT = 0x00000002,
	VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 0x00000004,
	VK_SUBGROUP_FEATURE_BALLOT_BIT = 0x00000008,
	VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 0x00000010,
	VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 0x00000020,
	VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 0x00000040,
	VK_SUBGROUP_FEATURE_QUAD_BIT = 0x00000080,
	VK_SUBGROUP_FEATURE_ROTATE_BIT = 0x00000200,
	VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT = 0x00000400,
	VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 0x00000100,
	VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkSubgroupFeatureFlagBits {
	pub const VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR: VkSubgroupFeatureFlagBits = VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ROTATE_BIT;
	pub const VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR: VkSubgroupFeatureFlagBits = VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPeerMemoryFeatureFlagBits {
	VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 0x00000001,
	VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 0x00000002,
	VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 0x00000004,
	VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 0x00000008,
	VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkPeerMemoryFeatureFlagBits {
	pub const VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR: VkPeerMemoryFeatureFlagBits = VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT;
	pub const VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR: VkPeerMemoryFeatureFlagBits = VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_DST_BIT;
	pub const VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR: VkPeerMemoryFeatureFlagBits = VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT;
	pub const VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR: VkPeerMemoryFeatureFlagBits = VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkMemoryAllocateFlagBits {
	VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 0x00000001,
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT = 0x00000002,
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x00000004,
	VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT = 0x00000008,
	VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkMemoryAllocateFlagBits {
	pub const VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR: VkMemoryAllocateFlagBits = VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT;
	pub const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR: VkMemoryAllocateFlagBits = VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT;
	pub const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR: VkMemoryAllocateFlagBits = VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkExternalMemoryHandleTypeFlagBits {
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 0x00000008,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 0x00000010,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 0x00000020,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x00000040,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x00000200,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 0x00000400,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x00000080,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x00000100,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA = 0x00000800,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV = 0x00001000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX = 0x00004000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT = 0x00010000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT = 0x00020000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT = 0x00040000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkExternalMemoryHandleTypeFlagBits {
	pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalMemoryHandleTypeFlagBits = VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
	pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalMemoryHandleTypeFlagBits = VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
	pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalMemoryHandleTypeFlagBits = VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
	pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR: VkExternalMemoryHandleTypeFlagBits = VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT;
	pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR: VkExternalMemoryHandleTypeFlagBits = VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT;
	pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR: VkExternalMemoryHandleTypeFlagBits = VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT;
	pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR: VkExternalMemoryHandleTypeFlagBits = VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkExternalMemoryFeatureFlagBits {
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 0x00000001,
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 0x00000002,
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 0x00000004,
	VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkExternalMemoryFeatureFlagBits {
	pub const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR: VkExternalMemoryFeatureFlagBits = VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT;
	pub const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR: VkExternalMemoryFeatureFlagBits = VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT;
	pub const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR: VkExternalMemoryFeatureFlagBits = VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkExternalFenceHandleTypeFlagBits {
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000008,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkExternalFenceHandleTypeFlagBits {
	pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalFenceHandleTypeFlagBits = VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT;
	pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalFenceHandleTypeFlagBits = VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
	pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalFenceHandleTypeFlagBits = VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
	pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR: VkExternalFenceHandleTypeFlagBits = VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkExternalFenceFeatureFlagBits {
	VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 0x00000001,
	VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 0x00000002,
	VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkExternalFenceFeatureFlagBits {
	pub const VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR: VkExternalFenceFeatureFlagBits = VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT;
	pub const VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR: VkExternalFenceFeatureFlagBits = VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFenceImportFlagBits {
	VK_FENCE_IMPORT_TEMPORARY_BIT = 0x00000001,
	VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkFenceImportFlagBits {
	pub const VK_FENCE_IMPORT_TEMPORARY_BIT_KHR: VkFenceImportFlagBits = VkFenceImportFlagBits::VK_FENCE_IMPORT_TEMPORARY_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSemaphoreImportFlagBits {
	VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 0x00000001,
	VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkSemaphoreImportFlagBits {
	pub const VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR: VkSemaphoreImportFlagBits = VkSemaphoreImportFlagBits::VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkExternalSemaphoreHandleTypeFlagBits {
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 0x00000008,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000010,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA = 0x00000080,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkExternalSemaphoreHandleTypeFlagBits {
	pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT: VkExternalSemaphoreHandleTypeFlagBits = VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
	pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits = VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
	pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits = VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
	pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits = VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
	pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits = VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
	pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits = VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkExternalSemaphoreFeatureFlagBits {
	VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 0x00000001,
	VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 0x00000002,
	VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkExternalSemaphoreFeatureFlagBits {
	pub const VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR: VkExternalSemaphoreFeatureFlagBits = VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT;
	pub const VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR: VkExternalSemaphoreFeatureFlagBits = VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSubgroupProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub subgroupSize: u32,
	pub supportedStages: VkShaderStageFlags,
	pub supportedOperations: VkSubgroupFeatureFlags,
	pub quadOperationsInAllStages: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindBufferMemoryInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub buffer: VkBuffer,
	pub memory: VkDeviceMemory,
	pub memoryOffset: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindImageMemoryInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub image: VkImage,
	pub memory: VkDeviceMemory,
	pub memoryOffset: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevice16BitStorageFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub storageBuffer16BitAccess: VkBool32,
	pub uniformAndStorageBuffer16BitAccess: VkBool32,
	pub storagePushConstant16: VkBool32,
	pub storageInputOutput16: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryDedicatedRequirements {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub prefersDedicatedAllocation: VkBool32,
	pub requiresDedicatedAllocation: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryDedicatedAllocateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub image: VkImage,
	pub buffer: VkBuffer,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryAllocateFlagsInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkMemoryAllocateFlags,
	pub deviceMask: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceGroupRenderPassBeginInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub deviceMask: u32,
	pub deviceRenderAreaCount: u32,
	pub pDeviceRenderAreas: *const VkRect2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceGroupCommandBufferBeginInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub deviceMask: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceGroupSubmitInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub waitSemaphoreCount: u32,
	pub pWaitSemaphoreDeviceIndices: *const uint32_t,
	pub commandBufferCount: u32,
	pub pCommandBufferDeviceMasks: *const uint32_t,
	pub signalSemaphoreCount: u32,
	pub pSignalSemaphoreDeviceIndices: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceGroupBindSparseInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub resourceDeviceIndex: u32,
	pub memoryDeviceIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindBufferMemoryDeviceGroupInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub deviceIndexCount: u32,
	pub pDeviceIndices: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindImageMemoryDeviceGroupInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub deviceIndexCount: u32,
	pub pDeviceIndices: *const uint32_t,
	pub splitInstanceBindRegionCount: u32,
	pub pSplitInstanceBindRegions: *const VkRect2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceGroupProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub physicalDeviceCount: u32,
	pub physicalDevices: [VkPhysicalDevice; VK_MAX_DEVICE_GROUP_SIZE as usize],
	pub subsetAllocation: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceGroupDeviceCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub physicalDeviceCount: u32,
	pub pPhysicalDevices: *const VkPhysicalDevice,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBufferMemoryRequirementsInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub buffer: VkBuffer,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageMemoryRequirementsInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub image: VkImage,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageSparseMemoryRequirementsInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub image: VkImage,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryRequirements2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryRequirements: VkMemoryRequirements,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSparseImageMemoryRequirements2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryRequirements: VkSparseImageMemoryRequirements,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFeatures2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub features: VkPhysicalDeviceFeatures,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceProperties2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub properties: VkPhysicalDeviceProperties,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkFormatProperties2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub formatProperties: VkFormatProperties,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageFormatProperties2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageFormatProperties: VkImageFormatProperties,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceImageFormatInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub format: VkFormat,
	pub type_: VkImageType,
	pub tiling: VkImageTiling,
	pub usage: VkImageUsageFlags,
	pub flags: VkImageCreateFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkQueueFamilyProperties2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub queueFamilyProperties: VkQueueFamilyProperties,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMemoryProperties2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryProperties: VkPhysicalDeviceMemoryProperties,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSparseImageFormatProperties2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub properties: VkSparseImageFormatProperties,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSparseImageFormatInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub format: VkFormat,
	pub type_: VkImageType,
	pub samples: VkSampleCountFlagBits,
	pub usage: VkImageUsageFlags,
	pub tiling: VkImageTiling,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePointClippingProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pointClippingBehavior: VkPointClippingBehavior,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkInputAttachmentAspectReference {
	pub subpass: u32,
	pub inputAttachmentIndex: u32,
	pub aspectMask: VkImageAspectFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassInputAttachmentAspectCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub aspectReferenceCount: u32,
	pub pAspectReferences: *const VkInputAttachmentAspectReference,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageViewUsageCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub usage: VkImageUsageFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineTessellationDomainOriginStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub domainOrigin: VkTessellationDomainOrigin,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassMultiviewCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub subpassCount: u32,
	pub pViewMasks: *const uint32_t,
	pub dependencyCount: u32,
	pub pViewOffsets: *const int32_t,
	pub correlationMaskCount: u32,
	pub pCorrelationMasks: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMultiviewFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub multiview: VkBool32,
	pub multiviewGeometryShader: VkBool32,
	pub multiviewTessellationShader: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMultiviewProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxMultiviewViewCount: u32,
	pub maxMultiviewInstanceIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVariablePointersFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub variablePointersStorageBuffer: VkBool32,
	pub variablePointers: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceProtectedMemoryFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub protectedMemory: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceProtectedMemoryProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub protectedNoFault: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceQueueInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDeviceQueueCreateFlags,
	pub queueFamilyIndex: u32,
	pub queueIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkProtectedSubmitInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub protectedSubmit: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSamplerYcbcrConversionCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub format: VkFormat,
	pub ycbcrModel: VkSamplerYcbcrModelConversion,
	pub ycbcrRange: VkSamplerYcbcrRange,
	pub components: VkComponentMapping,
	pub xChromaOffset: VkChromaLocation,
	pub yChromaOffset: VkChromaLocation,
	pub chromaFilter: VkFilter,
	pub forceExplicitReconstruction: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSamplerYcbcrConversionInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub conversion: VkSamplerYcbcrConversion,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindImagePlaneMemoryInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub planeAspect: VkImageAspectFlagBits,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImagePlaneMemoryRequirementsInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub planeAspect: VkImageAspectFlagBits,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSamplerYcbcrConversionFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub samplerYcbcrConversion: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSamplerYcbcrConversionImageFormatProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub combinedImageSamplerDescriptorCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorUpdateTemplateEntry {
	pub dstBinding: u32,
	pub dstArrayElement: u32,
	pub descriptorCount: u32,
	pub descriptorType: VkDescriptorType,
	pub offset: usize,
	pub stride: usize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorUpdateTemplateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDescriptorUpdateTemplateCreateFlags,
	pub descriptorUpdateEntryCount: u32,
	pub pDescriptorUpdateEntries: *const VkDescriptorUpdateTemplateEntry,
	pub templateType: VkDescriptorUpdateTemplateType,
	pub descriptorSetLayout: VkDescriptorSetLayout,
	pub pipelineBindPoint: VkPipelineBindPoint,
	pub pipelineLayout: VkPipelineLayout,
	pub set: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExternalMemoryProperties {
	pub externalMemoryFeatures: VkExternalMemoryFeatureFlags,
	pub exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlags,
	pub compatibleHandleTypes: VkExternalMemoryHandleTypeFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceExternalImageFormatInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExternalImageFormatProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub externalMemoryProperties: VkExternalMemoryProperties,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceExternalBufferInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkBufferCreateFlags,
	pub usage: VkBufferUsageFlags,
	pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExternalBufferProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub externalMemoryProperties: VkExternalMemoryProperties,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceIDProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceUUID: [u8; VK_UUID_SIZE as usize],
	pub driverUUID: [u8; VK_UUID_SIZE as usize],
	pub deviceLUID: [u8; VK_LUID_SIZE as usize],
	pub deviceNodeMask: u32,
	pub deviceLUIDValid: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExternalMemoryImageCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes: VkExternalMemoryHandleTypeFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExternalMemoryBufferCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes: VkExternalMemoryHandleTypeFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExportMemoryAllocateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes: VkExternalMemoryHandleTypeFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceExternalFenceInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleType: VkExternalFenceHandleTypeFlagBits,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExternalFenceProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlags,
	pub compatibleHandleTypes: VkExternalFenceHandleTypeFlags,
	pub externalFenceFeatures: VkExternalFenceFeatureFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExportFenceCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes: VkExternalFenceHandleTypeFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExportSemaphoreCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes: VkExternalSemaphoreHandleTypeFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceExternalSemaphoreInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleType: VkExternalSemaphoreHandleTypeFlagBits,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExternalSemaphoreProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlags,
	pub compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlags,
	pub externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance3Properties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxPerSetDescriptors: u32,
	pub maxMemoryAllocationSize: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorSetLayoutSupport {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub supported: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderDrawParametersFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderDrawParameters: VkBool32,
}
type PFN_vkEnumerateInstanceVersion = extern "system" fn(pApiVersion: *mut uint32_t) -> VkResult;
type PFN_vkBindBufferMemory2 = extern "system" fn(device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindBufferMemoryInfo) -> VkResult;
type PFN_vkBindImageMemory2 = extern "system" fn(device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindImageMemoryInfo) -> VkResult;
type PFN_vkGetDeviceGroupPeerMemoryFeatures = extern "system" fn(device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags);
type PFN_vkCmdSetDeviceMask = extern "system" fn(commandBuffer: VkCommandBuffer, deviceMask: u32);
type PFN_vkCmdDispatchBase = extern "system" fn(commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32);
type PFN_vkEnumeratePhysicalDeviceGroups = extern "system" fn(instance: VkInstance, pPhysicalDeviceGroupCount: *mut uint32_t, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties) -> VkResult;
type PFN_vkGetImageMemoryRequirements2 = extern "system" fn(device: VkDevice, pInfo: *const VkImageMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2);
type PFN_vkGetBufferMemoryRequirements2 = extern "system" fn(device: VkDevice, pInfo: *const VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2);
type PFN_vkGetImageSparseMemoryRequirements2 = extern "system" fn(device: VkDevice, pInfo: *const VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2);
type PFN_vkGetPhysicalDeviceFeatures2 = extern "system" fn(physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2);
type PFN_vkGetPhysicalDeviceProperties2 = extern "system" fn(physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties2);
type PFN_vkGetPhysicalDeviceFormatProperties2 = extern "system" fn(physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties2);
type PFN_vkGetPhysicalDeviceImageFormatProperties2 = extern "system" fn(physicalDevice: VkPhysicalDevice, pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *mut VkImageFormatProperties2) -> VkResult;
type PFN_vkGetPhysicalDeviceQueueFamilyProperties2 = extern "system" fn(physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties2);
type PFN_vkGetPhysicalDeviceMemoryProperties2 = extern "system" fn(physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2);
type PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 = extern "system" fn(physicalDevice: VkPhysicalDevice, pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties2);
type PFN_vkTrimCommandPool = extern "system" fn(device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags);
type PFN_vkGetDeviceQueue2 = extern "system" fn(device: VkDevice, pQueueInfo: *const VkDeviceQueueInfo2, pQueue: *mut VkQueue);
type PFN_vkCreateSamplerYcbcrConversion = extern "system" fn(device: VkDevice, pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo, pAllocator: *const VkAllocationCallbacks, pYcbcrConversion: *mut VkSamplerYcbcrConversion) -> VkResult;
type PFN_vkDestroySamplerYcbcrConversion = extern "system" fn(device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCreateDescriptorUpdateTemplate = extern "system" fn(device: VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate) -> VkResult;
type PFN_vkDestroyDescriptorUpdateTemplate = extern "system" fn(device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *const VkAllocationCallbacks);
type PFN_vkUpdateDescriptorSetWithTemplate = extern "system" fn(device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: *const c_void);
type PFN_vkGetPhysicalDeviceExternalBufferProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut VkExternalBufferProperties);
type PFN_vkGetPhysicalDeviceExternalFenceProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut VkExternalFenceProperties);
type PFN_vkGetPhysicalDeviceExternalSemaphoreProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties);
type PFN_vkGetDescriptorSetLayoutSupport = extern "system" fn(device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pSupport: *mut VkDescriptorSetLayoutSupport);
extern "system" fn dummy_vkEnumerateInstanceVersion(_: *mut uint32_t) -> VkResult {
	panic!("Vulkan function pointer of `vkEnumerateInstanceVersion()` is NULL");
}
extern "system" fn dummy_vkBindBufferMemory2(_: VkDevice, _: u32, _: *const VkBindBufferMemoryInfo) -> VkResult {
	panic!("Vulkan function pointer of `vkBindBufferMemory2()` is NULL");
}
extern "system" fn dummy_vkBindImageMemory2(_: VkDevice, _: u32, _: *const VkBindImageMemoryInfo) -> VkResult {
	panic!("Vulkan function pointer of `vkBindImageMemory2()` is NULL");
}
extern "system" fn dummy_vkGetDeviceGroupPeerMemoryFeatures(_: VkDevice, _: u32, _: u32, _: u32, _: *mut VkPeerMemoryFeatureFlags) {
	panic!("Vulkan function pointer of `vkGetDeviceGroupPeerMemoryFeatures()` is NULL");
}
extern "system" fn dummy_vkCmdSetDeviceMask(_: VkCommandBuffer, _: u32) {
	panic!("Vulkan function pointer of `vkCmdSetDeviceMask()` is NULL");
}
extern "system" fn dummy_vkCmdDispatchBase(_: VkCommandBuffer, _: u32, _: u32, _: u32, _: u32, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdDispatchBase()` is NULL");
}
extern "system" fn dummy_vkEnumeratePhysicalDeviceGroups(_: VkInstance, _: *mut uint32_t, _: *mut VkPhysicalDeviceGroupProperties) -> VkResult {
	panic!("Vulkan function pointer of `vkEnumeratePhysicalDeviceGroups()` is NULL");
}
extern "system" fn dummy_vkGetImageMemoryRequirements2(_: VkDevice, _: *const VkImageMemoryRequirementsInfo2, _: *mut VkMemoryRequirements2) {
	panic!("Vulkan function pointer of `vkGetImageMemoryRequirements2()` is NULL");
}
extern "system" fn dummy_vkGetBufferMemoryRequirements2(_: VkDevice, _: *const VkBufferMemoryRequirementsInfo2, _: *mut VkMemoryRequirements2) {
	panic!("Vulkan function pointer of `vkGetBufferMemoryRequirements2()` is NULL");
}
extern "system" fn dummy_vkGetImageSparseMemoryRequirements2(_: VkDevice, _: *const VkImageSparseMemoryRequirementsInfo2, _: *mut uint32_t, _: *mut VkSparseImageMemoryRequirements2) {
	panic!("Vulkan function pointer of `vkGetImageSparseMemoryRequirements2()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceFeatures2(_: VkPhysicalDevice, _: *mut VkPhysicalDeviceFeatures2) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceFeatures2()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceProperties2(_: VkPhysicalDevice, _: *mut VkPhysicalDeviceProperties2) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceProperties2()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceFormatProperties2(_: VkPhysicalDevice, _: VkFormat, _: *mut VkFormatProperties2) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceFormatProperties2()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceImageFormatProperties2(_: VkPhysicalDevice, _: *const VkPhysicalDeviceImageFormatInfo2, _: *mut VkImageFormatProperties2) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceImageFormatProperties2()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceQueueFamilyProperties2(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkQueueFamilyProperties2) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceQueueFamilyProperties2()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceMemoryProperties2(_: VkPhysicalDevice, _: *mut VkPhysicalDeviceMemoryProperties2) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceMemoryProperties2()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceSparseImageFormatProperties2(_: VkPhysicalDevice, _: *const VkPhysicalDeviceSparseImageFormatInfo2, _: *mut uint32_t, _: *mut VkSparseImageFormatProperties2) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceSparseImageFormatProperties2()` is NULL");
}
extern "system" fn dummy_vkTrimCommandPool(_: VkDevice, _: VkCommandPool, _: VkCommandPoolTrimFlags) {
	panic!("Vulkan function pointer of `vkTrimCommandPool()` is NULL");
}
extern "system" fn dummy_vkGetDeviceQueue2(_: VkDevice, _: *const VkDeviceQueueInfo2, _: *mut VkQueue) {
	panic!("Vulkan function pointer of `vkGetDeviceQueue2()` is NULL");
}
extern "system" fn dummy_vkCreateSamplerYcbcrConversion(_: VkDevice, _: *const VkSamplerYcbcrConversionCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkSamplerYcbcrConversion) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateSamplerYcbcrConversion()` is NULL");
}
extern "system" fn dummy_vkDestroySamplerYcbcrConversion(_: VkDevice, _: VkSamplerYcbcrConversion, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroySamplerYcbcrConversion()` is NULL");
}
extern "system" fn dummy_vkCreateDescriptorUpdateTemplate(_: VkDevice, _: *const VkDescriptorUpdateTemplateCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkDescriptorUpdateTemplate) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateDescriptorUpdateTemplate()` is NULL");
}
extern "system" fn dummy_vkDestroyDescriptorUpdateTemplate(_: VkDevice, _: VkDescriptorUpdateTemplate, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyDescriptorUpdateTemplate()` is NULL");
}
extern "system" fn dummy_vkUpdateDescriptorSetWithTemplate(_: VkDevice, _: VkDescriptorSet, _: VkDescriptorUpdateTemplate, _: *const c_void) {
	panic!("Vulkan function pointer of `vkUpdateDescriptorSetWithTemplate()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceExternalBufferProperties(_: VkPhysicalDevice, _: *const VkPhysicalDeviceExternalBufferInfo, _: *mut VkExternalBufferProperties) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceExternalBufferProperties()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceExternalFenceProperties(_: VkPhysicalDevice, _: *const VkPhysicalDeviceExternalFenceInfo, _: *mut VkExternalFenceProperties) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceExternalFenceProperties()` is NULL");
}
extern "system" fn dummy_vkGetPhysicalDeviceExternalSemaphoreProperties(_: VkPhysicalDevice, _: *const VkPhysicalDeviceExternalSemaphoreInfo, _: *mut VkExternalSemaphoreProperties) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceExternalSemaphoreProperties()` is NULL");
}
extern "system" fn dummy_vkGetDescriptorSetLayoutSupport(_: VkDevice, _: *const VkDescriptorSetLayoutCreateInfo, _: *mut VkDescriptorSetLayoutSupport) {
	panic!("Vulkan function pointer of `vkGetDescriptorSetLayoutSupport()` is NULL");
}
pub trait VK_VERSION_1_1: Debug {
	fn vkEnumerateInstanceVersion(&self, pApiVersion: *mut uint32_t) -> VkResult;
	fn vkBindBufferMemory2(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindBufferMemoryInfo) -> VkResult;
	fn vkBindImageMemory2(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindImageMemoryInfo) -> VkResult;
	fn vkGetDeviceGroupPeerMemoryFeatures(&self, device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags);
	fn vkCmdSetDeviceMask(&self, commandBuffer: VkCommandBuffer, deviceMask: u32);
	fn vkCmdDispatchBase(&self, commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32);
	fn vkEnumeratePhysicalDeviceGroups(&self, instance: VkInstance, pPhysicalDeviceGroupCount: *mut uint32_t, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties) -> VkResult;
	fn vkGetImageMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkImageMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2);
	fn vkGetBufferMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2);
	fn vkGetImageSparseMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2);
	fn vkGetPhysicalDeviceFeatures2(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2);
	fn vkGetPhysicalDeviceProperties2(&self, physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties2);
	fn vkGetPhysicalDeviceFormatProperties2(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties2);
	fn vkGetPhysicalDeviceImageFormatProperties2(&self, physicalDevice: VkPhysicalDevice, pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *mut VkImageFormatProperties2) -> VkResult;
	fn vkGetPhysicalDeviceQueueFamilyProperties2(&self, physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties2);
	fn vkGetPhysicalDeviceMemoryProperties2(&self, physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2);
	fn vkGetPhysicalDeviceSparseImageFormatProperties2(&self, physicalDevice: VkPhysicalDevice, pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties2);
	fn vkTrimCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags);
	fn vkGetDeviceQueue2(&self, device: VkDevice, pQueueInfo: *const VkDeviceQueueInfo2, pQueue: *mut VkQueue);
	fn vkCreateSamplerYcbcrConversion(&self, device: VkDevice, pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo, pAllocator: *const VkAllocationCallbacks, pYcbcrConversion: *mut VkSamplerYcbcrConversion) -> VkResult;
	fn vkDestroySamplerYcbcrConversion(&self, device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *const VkAllocationCallbacks);
	fn vkCreateDescriptorUpdateTemplate(&self, device: VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate) -> VkResult;
	fn vkDestroyDescriptorUpdateTemplate(&self, device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *const VkAllocationCallbacks);
	fn vkUpdateDescriptorSetWithTemplate(&self, device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: *const c_void);
	fn vkGetPhysicalDeviceExternalBufferProperties(&self, physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut VkExternalBufferProperties);
	fn vkGetPhysicalDeviceExternalFenceProperties(&self, physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut VkExternalFenceProperties);
	fn vkGetPhysicalDeviceExternalSemaphoreProperties(&self, physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties);
	fn vkGetDescriptorSetLayoutSupport(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pSupport: *mut VkDescriptorSetLayoutSupport);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_VERSION_1_1 {
	vk_enumerate_instance_version: PFN_vkEnumerateInstanceVersion,
	vk_bind_buffer_memory2: PFN_vkBindBufferMemory2,
	vk_bind_image_memory2: PFN_vkBindImageMemory2,
	vk_get_device_group_peer_memory_features: PFN_vkGetDeviceGroupPeerMemoryFeatures,
	vk_cmd_set_device_mask: PFN_vkCmdSetDeviceMask,
	vk_cmd_dispatch_base: PFN_vkCmdDispatchBase,
	vk_enumerate_physical_device_groups: PFN_vkEnumeratePhysicalDeviceGroups,
	vk_get_image_memory_requirements2: PFN_vkGetImageMemoryRequirements2,
	vk_get_buffer_memory_requirements2: PFN_vkGetBufferMemoryRequirements2,
	vk_get_image_sparse_memory_requirements2: PFN_vkGetImageSparseMemoryRequirements2,
	vk_get_physical_device_features2: PFN_vkGetPhysicalDeviceFeatures2,
	vk_get_physical_device_properties2: PFN_vkGetPhysicalDeviceProperties2,
	vk_get_physical_device_format_properties2: PFN_vkGetPhysicalDeviceFormatProperties2,
	vk_get_physical_device_image_format_properties2: PFN_vkGetPhysicalDeviceImageFormatProperties2,
	vk_get_physical_device_queue_family_properties2: PFN_vkGetPhysicalDeviceQueueFamilyProperties2,
	vk_get_physical_device_memory_properties2: PFN_vkGetPhysicalDeviceMemoryProperties2,
	vk_get_physical_device_sparse_image_format_properties2: PFN_vkGetPhysicalDeviceSparseImageFormatProperties2,
	vk_trim_command_pool: PFN_vkTrimCommandPool,
	vk_get_device_queue2: PFN_vkGetDeviceQueue2,
	vk_create_sampler_ycbcr_conversion: PFN_vkCreateSamplerYcbcrConversion,
	vk_destroy_sampler_ycbcr_conversion: PFN_vkDestroySamplerYcbcrConversion,
	vk_create_descriptor_update_template: PFN_vkCreateDescriptorUpdateTemplate,
	vk_destroy_descriptor_update_template: PFN_vkDestroyDescriptorUpdateTemplate,
	vk_update_descriptor_set_with_template: PFN_vkUpdateDescriptorSetWithTemplate,
	vk_get_physical_device_external_buffer_properties: PFN_vkGetPhysicalDeviceExternalBufferProperties,
	vk_get_physical_device_external_fence_properties: PFN_vkGetPhysicalDeviceExternalFenceProperties,
	vk_get_physical_device_external_semaphore_properties: PFN_vkGetPhysicalDeviceExternalSemaphoreProperties,
	vk_get_descriptor_set_layout_support: PFN_vkGetDescriptorSetLayoutSupport,
}
impl VK_VERSION_1_1 for Vulkan_VERSION_1_1 {
	fn vkEnumerateInstanceVersion(&self, pApiVersion: *mut uint32_t) -> VkResult {
		(self.vk_enumerate_instance_version)(pApiVersion)
	}
	fn vkBindBufferMemory2(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindBufferMemoryInfo) -> VkResult {
		(self.vk_bind_buffer_memory2)(device, bindInfoCount, pBindInfos)
	}
	fn vkBindImageMemory2(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindImageMemoryInfo) -> VkResult {
		(self.vk_bind_image_memory2)(device, bindInfoCount, pBindInfos)
	}
	fn vkGetDeviceGroupPeerMemoryFeatures(&self, device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags) {
		(self.vk_get_device_group_peer_memory_features)(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures)
	}
	fn vkCmdSetDeviceMask(&self, commandBuffer: VkCommandBuffer, deviceMask: u32) {
		(self.vk_cmd_set_device_mask)(commandBuffer, deviceMask)
	}
	fn vkCmdDispatchBase(&self, commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32) {
		(self.vk_cmd_dispatch_base)(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)
	}
	fn vkEnumeratePhysicalDeviceGroups(&self, instance: VkInstance, pPhysicalDeviceGroupCount: *mut uint32_t, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties) -> VkResult {
		(self.vk_enumerate_physical_device_groups)(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties)
	}
	fn vkGetImageMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkImageMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_get_image_memory_requirements2)(device, pInfo, pMemoryRequirements)
	}
	fn vkGetBufferMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_get_buffer_memory_requirements2)(device, pInfo, pMemoryRequirements)
	}
	fn vkGetImageSparseMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2) {
		(self.vk_get_image_sparse_memory_requirements2)(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements)
	}
	fn vkGetPhysicalDeviceFeatures2(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2) {
		(self.vk_get_physical_device_features2)(physicalDevice, pFeatures)
	}
	fn vkGetPhysicalDeviceProperties2(&self, physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties2) {
		(self.vk_get_physical_device_properties2)(physicalDevice, pProperties)
	}
	fn vkGetPhysicalDeviceFormatProperties2(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties2) {
		(self.vk_get_physical_device_format_properties2)(physicalDevice, format, pFormatProperties)
	}
	fn vkGetPhysicalDeviceImageFormatProperties2(&self, physicalDevice: VkPhysicalDevice, pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *mut VkImageFormatProperties2) -> VkResult {
		(self.vk_get_physical_device_image_format_properties2)(physicalDevice, pImageFormatInfo, pImageFormatProperties)
	}
	fn vkGetPhysicalDeviceQueueFamilyProperties2(&self, physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties2) {
		(self.vk_get_physical_device_queue_family_properties2)(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)
	}
	fn vkGetPhysicalDeviceMemoryProperties2(&self, physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2) {
		(self.vk_get_physical_device_memory_properties2)(physicalDevice, pMemoryProperties)
	}
	fn vkGetPhysicalDeviceSparseImageFormatProperties2(&self, physicalDevice: VkPhysicalDevice, pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties2) {
		(self.vk_get_physical_device_sparse_image_format_properties2)(physicalDevice, pFormatInfo, pPropertyCount, pProperties)
	}
	fn vkTrimCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) {
		(self.vk_trim_command_pool)(device, commandPool, flags)
	}
	fn vkGetDeviceQueue2(&self, device: VkDevice, pQueueInfo: *const VkDeviceQueueInfo2, pQueue: *mut VkQueue) {
		(self.vk_get_device_queue2)(device, pQueueInfo, pQueue)
	}
	fn vkCreateSamplerYcbcrConversion(&self, device: VkDevice, pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo, pAllocator: *const VkAllocationCallbacks, pYcbcrConversion: *mut VkSamplerYcbcrConversion) -> VkResult {
		(self.vk_create_sampler_ycbcr_conversion)(device, pCreateInfo, pAllocator, pYcbcrConversion)
	}
	fn vkDestroySamplerYcbcrConversion(&self, device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_sampler_ycbcr_conversion)(device, ycbcrConversion, pAllocator)
	}
	fn vkCreateDescriptorUpdateTemplate(&self, device: VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate) -> VkResult {
		(self.vk_create_descriptor_update_template)(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate)
	}
	fn vkDestroyDescriptorUpdateTemplate(&self, device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_descriptor_update_template)(device, descriptorUpdateTemplate, pAllocator)
	}
	fn vkUpdateDescriptorSetWithTemplate(&self, device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: *const c_void) {
		(self.vk_update_descriptor_set_with_template)(device, descriptorSet, descriptorUpdateTemplate, pData)
	}
	fn vkGetPhysicalDeviceExternalBufferProperties(&self, physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut VkExternalBufferProperties) {
		(self.vk_get_physical_device_external_buffer_properties)(physicalDevice, pExternalBufferInfo, pExternalBufferProperties)
	}
	fn vkGetPhysicalDeviceExternalFenceProperties(&self, physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut VkExternalFenceProperties) {
		(self.vk_get_physical_device_external_fence_properties)(physicalDevice, pExternalFenceInfo, pExternalFenceProperties)
	}
	fn vkGetPhysicalDeviceExternalSemaphoreProperties(&self, physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties) {
		(self.vk_get_physical_device_external_semaphore_properties)(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties)
	}
	fn vkGetDescriptorSetLayoutSupport(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pSupport: *mut VkDescriptorSetLayoutSupport) {
		(self.vk_get_descriptor_set_layout_support)(device, pCreateInfo, pSupport)
	}
}
impl Default for Vulkan_VERSION_1_1 {
	fn default() -> Self {
		Self {
			vk_enumerate_instance_version: dummy_vkEnumerateInstanceVersion,
			vk_bind_buffer_memory2: dummy_vkBindBufferMemory2,
			vk_bind_image_memory2: dummy_vkBindImageMemory2,
			vk_get_device_group_peer_memory_features: dummy_vkGetDeviceGroupPeerMemoryFeatures,
			vk_cmd_set_device_mask: dummy_vkCmdSetDeviceMask,
			vk_cmd_dispatch_base: dummy_vkCmdDispatchBase,
			vk_enumerate_physical_device_groups: dummy_vkEnumeratePhysicalDeviceGroups,
			vk_get_image_memory_requirements2: dummy_vkGetImageMemoryRequirements2,
			vk_get_buffer_memory_requirements2: dummy_vkGetBufferMemoryRequirements2,
			vk_get_image_sparse_memory_requirements2: dummy_vkGetImageSparseMemoryRequirements2,
			vk_get_physical_device_features2: dummy_vkGetPhysicalDeviceFeatures2,
			vk_get_physical_device_properties2: dummy_vkGetPhysicalDeviceProperties2,
			vk_get_physical_device_format_properties2: dummy_vkGetPhysicalDeviceFormatProperties2,
			vk_get_physical_device_image_format_properties2: dummy_vkGetPhysicalDeviceImageFormatProperties2,
			vk_get_physical_device_queue_family_properties2: dummy_vkGetPhysicalDeviceQueueFamilyProperties2,
			vk_get_physical_device_memory_properties2: dummy_vkGetPhysicalDeviceMemoryProperties2,
			vk_get_physical_device_sparse_image_format_properties2: dummy_vkGetPhysicalDeviceSparseImageFormatProperties2,
			vk_trim_command_pool: dummy_vkTrimCommandPool,
			vk_get_device_queue2: dummy_vkGetDeviceQueue2,
			vk_create_sampler_ycbcr_conversion: dummy_vkCreateSamplerYcbcrConversion,
			vk_destroy_sampler_ycbcr_conversion: dummy_vkDestroySamplerYcbcrConversion,
			vk_create_descriptor_update_template: dummy_vkCreateDescriptorUpdateTemplate,
			vk_destroy_descriptor_update_template: dummy_vkDestroyDescriptorUpdateTemplate,
			vk_update_descriptor_set_with_template: dummy_vkUpdateDescriptorSetWithTemplate,
			vk_get_physical_device_external_buffer_properties: dummy_vkGetPhysicalDeviceExternalBufferProperties,
			vk_get_physical_device_external_fence_properties: dummy_vkGetPhysicalDeviceExternalFenceProperties,
			vk_get_physical_device_external_semaphore_properties: dummy_vkGetPhysicalDeviceExternalSemaphoreProperties,
			vk_get_descriptor_set_layout_support: dummy_vkGetDescriptorSetLayoutSupport,
		}
	}
}
impl Vulkan_VERSION_1_1 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_enumerate_instance_version: {let proc = get_proc_address(instance, "vkEnumerateInstanceVersion"); if proc == null() {dummy_vkEnumerateInstanceVersion} else {unsafe {transmute(proc)}}},
			vk_bind_buffer_memory2: {let proc = get_proc_address(instance, "vkBindBufferMemory2"); if proc == null() {dummy_vkBindBufferMemory2} else {unsafe {transmute(proc)}}},
			vk_bind_image_memory2: {let proc = get_proc_address(instance, "vkBindImageMemory2"); if proc == null() {dummy_vkBindImageMemory2} else {unsafe {transmute(proc)}}},
			vk_get_device_group_peer_memory_features: {let proc = get_proc_address(instance, "vkGetDeviceGroupPeerMemoryFeatures"); if proc == null() {dummy_vkGetDeviceGroupPeerMemoryFeatures} else {unsafe {transmute(proc)}}},
			vk_cmd_set_device_mask: {let proc = get_proc_address(instance, "vkCmdSetDeviceMask"); if proc == null() {dummy_vkCmdSetDeviceMask} else {unsafe {transmute(proc)}}},
			vk_cmd_dispatch_base: {let proc = get_proc_address(instance, "vkCmdDispatchBase"); if proc == null() {dummy_vkCmdDispatchBase} else {unsafe {transmute(proc)}}},
			vk_enumerate_physical_device_groups: {let proc = get_proc_address(instance, "vkEnumeratePhysicalDeviceGroups"); if proc == null() {dummy_vkEnumeratePhysicalDeviceGroups} else {unsafe {transmute(proc)}}},
			vk_get_image_memory_requirements2: {let proc = get_proc_address(instance, "vkGetImageMemoryRequirements2"); if proc == null() {dummy_vkGetImageMemoryRequirements2} else {unsafe {transmute(proc)}}},
			vk_get_buffer_memory_requirements2: {let proc = get_proc_address(instance, "vkGetBufferMemoryRequirements2"); if proc == null() {dummy_vkGetBufferMemoryRequirements2} else {unsafe {transmute(proc)}}},
			vk_get_image_sparse_memory_requirements2: {let proc = get_proc_address(instance, "vkGetImageSparseMemoryRequirements2"); if proc == null() {dummy_vkGetImageSparseMemoryRequirements2} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_features2: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceFeatures2"); if proc == null() {dummy_vkGetPhysicalDeviceFeatures2} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_properties2: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceProperties2"); if proc == null() {dummy_vkGetPhysicalDeviceProperties2} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_format_properties2: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceFormatProperties2"); if proc == null() {dummy_vkGetPhysicalDeviceFormatProperties2} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_image_format_properties2: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceImageFormatProperties2"); if proc == null() {dummy_vkGetPhysicalDeviceImageFormatProperties2} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_queue_family_properties2: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceQueueFamilyProperties2"); if proc == null() {dummy_vkGetPhysicalDeviceQueueFamilyProperties2} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_memory_properties2: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceMemoryProperties2"); if proc == null() {dummy_vkGetPhysicalDeviceMemoryProperties2} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_sparse_image_format_properties2: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceSparseImageFormatProperties2"); if proc == null() {dummy_vkGetPhysicalDeviceSparseImageFormatProperties2} else {unsafe {transmute(proc)}}},
			vk_trim_command_pool: {let proc = get_proc_address(instance, "vkTrimCommandPool"); if proc == null() {dummy_vkTrimCommandPool} else {unsafe {transmute(proc)}}},
			vk_get_device_queue2: {let proc = get_proc_address(instance, "vkGetDeviceQueue2"); if proc == null() {dummy_vkGetDeviceQueue2} else {unsafe {transmute(proc)}}},
			vk_create_sampler_ycbcr_conversion: {let proc = get_proc_address(instance, "vkCreateSamplerYcbcrConversion"); if proc == null() {dummy_vkCreateSamplerYcbcrConversion} else {unsafe {transmute(proc)}}},
			vk_destroy_sampler_ycbcr_conversion: {let proc = get_proc_address(instance, "vkDestroySamplerYcbcrConversion"); if proc == null() {dummy_vkDestroySamplerYcbcrConversion} else {unsafe {transmute(proc)}}},
			vk_create_descriptor_update_template: {let proc = get_proc_address(instance, "vkCreateDescriptorUpdateTemplate"); if proc == null() {dummy_vkCreateDescriptorUpdateTemplate} else {unsafe {transmute(proc)}}},
			vk_destroy_descriptor_update_template: {let proc = get_proc_address(instance, "vkDestroyDescriptorUpdateTemplate"); if proc == null() {dummy_vkDestroyDescriptorUpdateTemplate} else {unsafe {transmute(proc)}}},
			vk_update_descriptor_set_with_template: {let proc = get_proc_address(instance, "vkUpdateDescriptorSetWithTemplate"); if proc == null() {dummy_vkUpdateDescriptorSetWithTemplate} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_external_buffer_properties: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceExternalBufferProperties"); if proc == null() {dummy_vkGetPhysicalDeviceExternalBufferProperties} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_external_fence_properties: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceExternalFenceProperties"); if proc == null() {dummy_vkGetPhysicalDeviceExternalFenceProperties} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_external_semaphore_properties: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceExternalSemaphoreProperties"); if proc == null() {dummy_vkGetPhysicalDeviceExternalSemaphoreProperties} else {unsafe {transmute(proc)}}},
			vk_get_descriptor_set_layout_support: {let proc = get_proc_address(instance, "vkGetDescriptorSetLayoutSupport"); if proc == null() {dummy_vkGetDescriptorSetLayoutSupport} else {unsafe {transmute(proc)}}},
		}
	}
}
pub const VK_API_VERSION_1_2: u32 = 0x402000;
pub const VK_MAX_DRIVER_NAME_SIZE: u32 = 256u32;
pub const VK_MAX_DRIVER_INFO_SIZE: u32 = 256u32;
pub type VkResolveModeFlags = VkFlags;
pub type VkDescriptorBindingFlags = VkFlags;
pub type VkSemaphoreWaitFlags = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDriverId {
	VK_DRIVER_ID_AMD_PROPRIETARY = 1,
	VK_DRIVER_ID_AMD_OPEN_SOURCE = 2,
	VK_DRIVER_ID_MESA_RADV = 3,
	VK_DRIVER_ID_NVIDIA_PROPRIETARY = 4,
	VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5,
	VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6,
	VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 7,
	VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 8,
	VK_DRIVER_ID_ARM_PROPRIETARY = 9,
	VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 10,
	VK_DRIVER_ID_GGP_PROPRIETARY = 11,
	VK_DRIVER_ID_BROADCOM_PROPRIETARY = 12,
	VK_DRIVER_ID_MESA_LLVMPIPE = 13,
	VK_DRIVER_ID_MOLTENVK = 14,
	VK_DRIVER_ID_COREAVI_PROPRIETARY = 15,
	VK_DRIVER_ID_JUICE_PROPRIETARY = 16,
	VK_DRIVER_ID_VERISILICON_PROPRIETARY = 17,
	VK_DRIVER_ID_MESA_TURNIP = 18,
	VK_DRIVER_ID_MESA_V3DV = 19,
	VK_DRIVER_ID_MESA_PANVK = 20,
	VK_DRIVER_ID_SAMSUNG_PROPRIETARY = 21,
	VK_DRIVER_ID_MESA_VENUS = 22,
	VK_DRIVER_ID_MESA_DOZEN = 23,
	VK_DRIVER_ID_MESA_NVK = 24,
	VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA = 25,
	VK_DRIVER_ID_MESA_HONEYKRISP = 26,
	VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN = 27,
	VK_DRIVER_ID_MAX_ENUM = 0x7fffffff,
}
impl VkDriverId {
	pub const VK_DRIVER_ID_AMD_PROPRIETARY_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_AMD_PROPRIETARY;
	pub const VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_AMD_OPEN_SOURCE;
	pub const VK_DRIVER_ID_MESA_RADV_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_MESA_RADV;
	pub const VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_NVIDIA_PROPRIETARY;
	pub const VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS;
	pub const VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA;
	pub const VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_IMAGINATION_PROPRIETARY;
	pub const VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_QUALCOMM_PROPRIETARY;
	pub const VK_DRIVER_ID_ARM_PROPRIETARY_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_ARM_PROPRIETARY;
	pub const VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_GOOGLE_SWIFTSHADER;
	pub const VK_DRIVER_ID_GGP_PROPRIETARY_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_GGP_PROPRIETARY;
	pub const VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_BROADCOM_PROPRIETARY;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkShaderFloatControlsIndependence {
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM = 0x7fffffff,
}
impl VkShaderFloatControlsIndependence {
	pub const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR: VkShaderFloatControlsIndependence = VkShaderFloatControlsIndependence::VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY;
	pub const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR: VkShaderFloatControlsIndependence = VkShaderFloatControlsIndependence::VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL;
	pub const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR: VkShaderFloatControlsIndependence = VkShaderFloatControlsIndependence::VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSamplerReductionMode {
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0,
	VK_SAMPLER_REDUCTION_MODE_MIN = 1,
	VK_SAMPLER_REDUCTION_MODE_MAX = 2,
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM = 1000521000,
	VK_SAMPLER_REDUCTION_MODE_MAX_ENUM = 0x7fffffff,
}
impl VkSamplerReductionMode {
	pub const VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT: VkSamplerReductionMode = VkSamplerReductionMode::VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE;
	pub const VK_SAMPLER_REDUCTION_MODE_MIN_EXT: VkSamplerReductionMode = VkSamplerReductionMode::VK_SAMPLER_REDUCTION_MODE_MIN;
	pub const VK_SAMPLER_REDUCTION_MODE_MAX_EXT: VkSamplerReductionMode = VkSamplerReductionMode::VK_SAMPLER_REDUCTION_MODE_MAX;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSemaphoreType {
	VK_SEMAPHORE_TYPE_BINARY = 0,
	VK_SEMAPHORE_TYPE_TIMELINE = 1,
	VK_SEMAPHORE_TYPE_MAX_ENUM = 0x7fffffff,
}
impl VkSemaphoreType {
	pub const VK_SEMAPHORE_TYPE_BINARY_KHR: VkSemaphoreType = VkSemaphoreType::VK_SEMAPHORE_TYPE_BINARY;
	pub const VK_SEMAPHORE_TYPE_TIMELINE_KHR: VkSemaphoreType = VkSemaphoreType::VK_SEMAPHORE_TYPE_TIMELINE;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkResolveModeFlagBits {
	VK_RESOLVE_MODE_NONE = 0,
	VK_RESOLVE_MODE_SAMPLE_ZERO_BIT = 0x00000001,
	VK_RESOLVE_MODE_AVERAGE_BIT = 0x00000002,
	VK_RESOLVE_MODE_MIN_BIT = 0x00000004,
	VK_RESOLVE_MODE_MAX_BIT = 0x00000008,
	VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID = 0x00000010,
	VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkResolveModeFlagBits {
	pub const VK_RESOLVE_MODE_NONE_KHR: VkResolveModeFlagBits = VkResolveModeFlagBits::VK_RESOLVE_MODE_NONE;
	pub const VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR: VkResolveModeFlagBits = VkResolveModeFlagBits::VK_RESOLVE_MODE_SAMPLE_ZERO_BIT;
	pub const VK_RESOLVE_MODE_AVERAGE_BIT_KHR: VkResolveModeFlagBits = VkResolveModeFlagBits::VK_RESOLVE_MODE_AVERAGE_BIT;
	pub const VK_RESOLVE_MODE_MIN_BIT_KHR: VkResolveModeFlagBits = VkResolveModeFlagBits::VK_RESOLVE_MODE_MIN_BIT;
	pub const VK_RESOLVE_MODE_MAX_BIT_KHR: VkResolveModeFlagBits = VkResolveModeFlagBits::VK_RESOLVE_MODE_MAX_BIT;
	pub const VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID: VkResolveModeFlagBits = VkResolveModeFlagBits::VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDescriptorBindingFlagBits {
	VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = 0x00000001,
	VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = 0x00000002,
	VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = 0x00000004,
	VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = 0x00000008,
	VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkDescriptorBindingFlagBits {
	pub const VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT: VkDescriptorBindingFlagBits = VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT;
	pub const VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT: VkDescriptorBindingFlagBits = VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT;
	pub const VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT: VkDescriptorBindingFlagBits = VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT;
	pub const VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT: VkDescriptorBindingFlagBits = VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSemaphoreWaitFlagBits {
	VK_SEMAPHORE_WAIT_ANY_BIT = 0x00000001,
	VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkSemaphoreWaitFlagBits {
	pub const VK_SEMAPHORE_WAIT_ANY_BIT_KHR: VkSemaphoreWaitFlagBits = VkSemaphoreWaitFlagBits::VK_SEMAPHORE_WAIT_ANY_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVulkan11Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub storageBuffer16BitAccess: VkBool32,
	pub uniformAndStorageBuffer16BitAccess: VkBool32,
	pub storagePushConstant16: VkBool32,
	pub storageInputOutput16: VkBool32,
	pub multiview: VkBool32,
	pub multiviewGeometryShader: VkBool32,
	pub multiviewTessellationShader: VkBool32,
	pub variablePointersStorageBuffer: VkBool32,
	pub variablePointers: VkBool32,
	pub protectedMemory: VkBool32,
	pub samplerYcbcrConversion: VkBool32,
	pub shaderDrawParameters: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVulkan11Properties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceUUID: [u8; VK_UUID_SIZE as usize],
	pub driverUUID: [u8; VK_UUID_SIZE as usize],
	pub deviceLUID: [u8; VK_LUID_SIZE as usize],
	pub deviceNodeMask: u32,
	pub deviceLUIDValid: VkBool32,
	pub subgroupSize: u32,
	pub subgroupSupportedStages: VkShaderStageFlags,
	pub subgroupSupportedOperations: VkSubgroupFeatureFlags,
	pub subgroupQuadOperationsInAllStages: VkBool32,
	pub pointClippingBehavior: VkPointClippingBehavior,
	pub maxMultiviewViewCount: u32,
	pub maxMultiviewInstanceIndex: u32,
	pub protectedNoFault: VkBool32,
	pub maxPerSetDescriptors: u32,
	pub maxMemoryAllocationSize: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVulkan12Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub samplerMirrorClampToEdge: VkBool32,
	pub drawIndirectCount: VkBool32,
	pub storageBuffer8BitAccess: VkBool32,
	pub uniformAndStorageBuffer8BitAccess: VkBool32,
	pub storagePushConstant8: VkBool32,
	pub shaderBufferInt64Atomics: VkBool32,
	pub shaderSharedInt64Atomics: VkBool32,
	pub shaderFloat16: VkBool32,
	pub shaderInt8: VkBool32,
	pub descriptorIndexing: VkBool32,
	pub shaderInputAttachmentArrayDynamicIndexing: VkBool32,
	pub shaderUniformTexelBufferArrayDynamicIndexing: VkBool32,
	pub shaderStorageTexelBufferArrayDynamicIndexing: VkBool32,
	pub shaderUniformBufferArrayNonUniformIndexing: VkBool32,
	pub shaderSampledImageArrayNonUniformIndexing: VkBool32,
	pub shaderStorageBufferArrayNonUniformIndexing: VkBool32,
	pub shaderStorageImageArrayNonUniformIndexing: VkBool32,
	pub shaderInputAttachmentArrayNonUniformIndexing: VkBool32,
	pub shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32,
	pub shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32,
	pub descriptorBindingUniformBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingSampledImageUpdateAfterBind: VkBool32,
	pub descriptorBindingStorageImageUpdateAfterBind: VkBool32,
	pub descriptorBindingStorageBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingUpdateUnusedWhilePending: VkBool32,
	pub descriptorBindingPartiallyBound: VkBool32,
	pub descriptorBindingVariableDescriptorCount: VkBool32,
	pub runtimeDescriptorArray: VkBool32,
	pub samplerFilterMinmax: VkBool32,
	pub scalarBlockLayout: VkBool32,
	pub imagelessFramebuffer: VkBool32,
	pub uniformBufferStandardLayout: VkBool32,
	pub shaderSubgroupExtendedTypes: VkBool32,
	pub separateDepthStencilLayouts: VkBool32,
	pub hostQueryReset: VkBool32,
	pub timelineSemaphore: VkBool32,
	pub bufferDeviceAddress: VkBool32,
	pub bufferDeviceAddressCaptureReplay: VkBool32,
	pub bufferDeviceAddressMultiDevice: VkBool32,
	pub vulkanMemoryModel: VkBool32,
	pub vulkanMemoryModelDeviceScope: VkBool32,
	pub vulkanMemoryModelAvailabilityVisibilityChains: VkBool32,
	pub shaderOutputViewportIndex: VkBool32,
	pub shaderOutputLayer: VkBool32,
	pub subgroupBroadcastDynamicId: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkConformanceVersion {
	pub major: u8,
	pub minor: u8,
	pub subminor: u8,
	pub patch: u8,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVulkan12Properties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub driverID: VkDriverId,
	pub driverName: [i8; VK_MAX_DRIVER_NAME_SIZE as usize],
	pub driverInfo: [i8; VK_MAX_DRIVER_INFO_SIZE as usize],
	pub conformanceVersion: VkConformanceVersion,
	pub denormBehaviorIndependence: VkShaderFloatControlsIndependence,
	pub roundingModeIndependence: VkShaderFloatControlsIndependence,
	pub shaderSignedZeroInfNanPreserveFloat16: VkBool32,
	pub shaderSignedZeroInfNanPreserveFloat32: VkBool32,
	pub shaderSignedZeroInfNanPreserveFloat64: VkBool32,
	pub shaderDenormPreserveFloat16: VkBool32,
	pub shaderDenormPreserveFloat32: VkBool32,
	pub shaderDenormPreserveFloat64: VkBool32,
	pub shaderDenormFlushToZeroFloat16: VkBool32,
	pub shaderDenormFlushToZeroFloat32: VkBool32,
	pub shaderDenormFlushToZeroFloat64: VkBool32,
	pub shaderRoundingModeRTEFloat16: VkBool32,
	pub shaderRoundingModeRTEFloat32: VkBool32,
	pub shaderRoundingModeRTEFloat64: VkBool32,
	pub shaderRoundingModeRTZFloat16: VkBool32,
	pub shaderRoundingModeRTZFloat32: VkBool32,
	pub shaderRoundingModeRTZFloat64: VkBool32,
	pub maxUpdateAfterBindDescriptorsInAllPools: u32,
	pub shaderUniformBufferArrayNonUniformIndexingNative: VkBool32,
	pub shaderSampledImageArrayNonUniformIndexingNative: VkBool32,
	pub shaderStorageBufferArrayNonUniformIndexingNative: VkBool32,
	pub shaderStorageImageArrayNonUniformIndexingNative: VkBool32,
	pub shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32,
	pub robustBufferAccessUpdateAfterBind: VkBool32,
	pub quadDivergentImplicitLod: VkBool32,
	pub maxPerStageDescriptorUpdateAfterBindSamplers: u32,
	pub maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32,
	pub maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32,
	pub maxPerStageDescriptorUpdateAfterBindSampledImages: u32,
	pub maxPerStageDescriptorUpdateAfterBindStorageImages: u32,
	pub maxPerStageDescriptorUpdateAfterBindInputAttachments: u32,
	pub maxPerStageUpdateAfterBindResources: u32,
	pub maxDescriptorSetUpdateAfterBindSamplers: u32,
	pub maxDescriptorSetUpdateAfterBindUniformBuffers: u32,
	pub maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindStorageBuffers: u32,
	pub maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindSampledImages: u32,
	pub maxDescriptorSetUpdateAfterBindStorageImages: u32,
	pub maxDescriptorSetUpdateAfterBindInputAttachments: u32,
	pub supportedDepthResolveModes: VkResolveModeFlags,
	pub supportedStencilResolveModes: VkResolveModeFlags,
	pub independentResolveNone: VkBool32,
	pub independentResolve: VkBool32,
	pub filterMinmaxSingleComponentFormats: VkBool32,
	pub filterMinmaxImageComponentMapping: VkBool32,
	pub maxTimelineSemaphoreValueDifference: u64,
	pub framebufferIntegerColorSampleCounts: VkSampleCountFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageFormatListCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub viewFormatCount: u32,
	pub pViewFormats: *const VkFormat,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAttachmentDescription2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkAttachmentDescriptionFlags,
	pub format: VkFormat,
	pub samples: VkSampleCountFlagBits,
	pub loadOp: VkAttachmentLoadOp,
	pub storeOp: VkAttachmentStoreOp,
	pub stencilLoadOp: VkAttachmentLoadOp,
	pub stencilStoreOp: VkAttachmentStoreOp,
	pub initialLayout: VkImageLayout,
	pub finalLayout: VkImageLayout,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAttachmentReference2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub attachment: u32,
	pub layout: VkImageLayout,
	pub aspectMask: VkImageAspectFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSubpassDescription2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkSubpassDescriptionFlags,
	pub pipelineBindPoint: VkPipelineBindPoint,
	pub viewMask: u32,
	pub inputAttachmentCount: u32,
	pub pInputAttachments: *const VkAttachmentReference2,
	pub colorAttachmentCount: u32,
	pub pColorAttachments: *const VkAttachmentReference2,
	pub pResolveAttachments: *const VkAttachmentReference2,
	pub pDepthStencilAttachment: *const VkAttachmentReference2,
	pub preserveAttachmentCount: u32,
	pub pPreserveAttachments: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSubpassDependency2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcSubpass: u32,
	pub dstSubpass: u32,
	pub srcStageMask: VkPipelineStageFlags,
	pub dstStageMask: VkPipelineStageFlags,
	pub srcAccessMask: VkAccessFlags,
	pub dstAccessMask: VkAccessFlags,
	pub dependencyFlags: VkDependencyFlags,
	pub viewOffset: i32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassCreateInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkRenderPassCreateFlags,
	pub attachmentCount: u32,
	pub pAttachments: *const VkAttachmentDescription2,
	pub subpassCount: u32,
	pub pSubpasses: *const VkSubpassDescription2,
	pub dependencyCount: u32,
	pub pDependencies: *const VkSubpassDependency2,
	pub correlatedViewMaskCount: u32,
	pub pCorrelatedViewMasks: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSubpassBeginInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub contents: VkSubpassContents,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSubpassEndInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevice8BitStorageFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub storageBuffer8BitAccess: VkBool32,
	pub uniformAndStorageBuffer8BitAccess: VkBool32,
	pub storagePushConstant8: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDriverProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub driverID: VkDriverId,
	pub driverName: [i8; VK_MAX_DRIVER_NAME_SIZE as usize],
	pub driverInfo: [i8; VK_MAX_DRIVER_INFO_SIZE as usize],
	pub conformanceVersion: VkConformanceVersion,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderAtomicInt64Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderBufferInt64Atomics: VkBool32,
	pub shaderSharedInt64Atomics: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderFloat16Int8Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderFloat16: VkBool32,
	pub shaderInt8: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFloatControlsProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub denormBehaviorIndependence: VkShaderFloatControlsIndependence,
	pub roundingModeIndependence: VkShaderFloatControlsIndependence,
	pub shaderSignedZeroInfNanPreserveFloat16: VkBool32,
	pub shaderSignedZeroInfNanPreserveFloat32: VkBool32,
	pub shaderSignedZeroInfNanPreserveFloat64: VkBool32,
	pub shaderDenormPreserveFloat16: VkBool32,
	pub shaderDenormPreserveFloat32: VkBool32,
	pub shaderDenormPreserveFloat64: VkBool32,
	pub shaderDenormFlushToZeroFloat16: VkBool32,
	pub shaderDenormFlushToZeroFloat32: VkBool32,
	pub shaderDenormFlushToZeroFloat64: VkBool32,
	pub shaderRoundingModeRTEFloat16: VkBool32,
	pub shaderRoundingModeRTEFloat32: VkBool32,
	pub shaderRoundingModeRTEFloat64: VkBool32,
	pub shaderRoundingModeRTZFloat16: VkBool32,
	pub shaderRoundingModeRTZFloat32: VkBool32,
	pub shaderRoundingModeRTZFloat64: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorSetLayoutBindingFlagsCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub bindingCount: u32,
	pub pBindingFlags: *const VkDescriptorBindingFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorIndexingFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderInputAttachmentArrayDynamicIndexing: VkBool32,
	pub shaderUniformTexelBufferArrayDynamicIndexing: VkBool32,
	pub shaderStorageTexelBufferArrayDynamicIndexing: VkBool32,
	pub shaderUniformBufferArrayNonUniformIndexing: VkBool32,
	pub shaderSampledImageArrayNonUniformIndexing: VkBool32,
	pub shaderStorageBufferArrayNonUniformIndexing: VkBool32,
	pub shaderStorageImageArrayNonUniformIndexing: VkBool32,
	pub shaderInputAttachmentArrayNonUniformIndexing: VkBool32,
	pub shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32,
	pub shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32,
	pub descriptorBindingUniformBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingSampledImageUpdateAfterBind: VkBool32,
	pub descriptorBindingStorageImageUpdateAfterBind: VkBool32,
	pub descriptorBindingStorageBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingUpdateUnusedWhilePending: VkBool32,
	pub descriptorBindingPartiallyBound: VkBool32,
	pub descriptorBindingVariableDescriptorCount: VkBool32,
	pub runtimeDescriptorArray: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorIndexingProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxUpdateAfterBindDescriptorsInAllPools: u32,
	pub shaderUniformBufferArrayNonUniformIndexingNative: VkBool32,
	pub shaderSampledImageArrayNonUniformIndexingNative: VkBool32,
	pub shaderStorageBufferArrayNonUniformIndexingNative: VkBool32,
	pub shaderStorageImageArrayNonUniformIndexingNative: VkBool32,
	pub shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32,
	pub robustBufferAccessUpdateAfterBind: VkBool32,
	pub quadDivergentImplicitLod: VkBool32,
	pub maxPerStageDescriptorUpdateAfterBindSamplers: u32,
	pub maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32,
	pub maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32,
	pub maxPerStageDescriptorUpdateAfterBindSampledImages: u32,
	pub maxPerStageDescriptorUpdateAfterBindStorageImages: u32,
	pub maxPerStageDescriptorUpdateAfterBindInputAttachments: u32,
	pub maxPerStageUpdateAfterBindResources: u32,
	pub maxDescriptorSetUpdateAfterBindSamplers: u32,
	pub maxDescriptorSetUpdateAfterBindUniformBuffers: u32,
	pub maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindStorageBuffers: u32,
	pub maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindSampledImages: u32,
	pub maxDescriptorSetUpdateAfterBindStorageImages: u32,
	pub maxDescriptorSetUpdateAfterBindInputAttachments: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorSetVariableDescriptorCountAllocateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub descriptorSetCount: u32,
	pub pDescriptorCounts: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorSetVariableDescriptorCountLayoutSupport {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxVariableDescriptorCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSubpassDescriptionDepthStencilResolve {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub depthResolveMode: VkResolveModeFlagBits,
	pub stencilResolveMode: VkResolveModeFlagBits,
	pub pDepthStencilResolveAttachment: *const VkAttachmentReference2,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDepthStencilResolveProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub supportedDepthResolveModes: VkResolveModeFlags,
	pub supportedStencilResolveModes: VkResolveModeFlags,
	pub independentResolveNone: VkBool32,
	pub independentResolve: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceScalarBlockLayoutFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub scalarBlockLayout: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageStencilUsageCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stencilUsage: VkImageUsageFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSamplerReductionModeCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub reductionMode: VkSamplerReductionMode,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSamplerFilterMinmaxProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub filterMinmaxSingleComponentFormats: VkBool32,
	pub filterMinmaxImageComponentMapping: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVulkanMemoryModelFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub vulkanMemoryModel: VkBool32,
	pub vulkanMemoryModelDeviceScope: VkBool32,
	pub vulkanMemoryModelAvailabilityVisibilityChains: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceImagelessFramebufferFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imagelessFramebuffer: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkFramebufferAttachmentImageInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkImageCreateFlags,
	pub usage: VkImageUsageFlags,
	pub width: u32,
	pub height: u32,
	pub layerCount: u32,
	pub viewFormatCount: u32,
	pub pViewFormats: *const VkFormat,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkFramebufferAttachmentsCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub attachmentImageInfoCount: u32,
	pub pAttachmentImageInfos: *const VkFramebufferAttachmentImageInfo,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassAttachmentBeginInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub attachmentCount: u32,
	pub pAttachments: *const VkImageView,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceUniformBufferStandardLayoutFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub uniformBufferStandardLayout: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderSubgroupExtendedTypes: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub separateDepthStencilLayouts: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAttachmentReferenceStencilLayout {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub stencilLayout: VkImageLayout,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAttachmentDescriptionStencilLayout {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub stencilInitialLayout: VkImageLayout,
	pub stencilFinalLayout: VkImageLayout,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceHostQueryResetFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub hostQueryReset: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceTimelineSemaphoreFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub timelineSemaphore: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceTimelineSemaphoreProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxTimelineSemaphoreValueDifference: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSemaphoreTypeCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub semaphoreType: VkSemaphoreType,
	pub initialValue: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTimelineSemaphoreSubmitInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub waitSemaphoreValueCount: u32,
	pub pWaitSemaphoreValues: *const uint64_t,
	pub signalSemaphoreValueCount: u32,
	pub pSignalSemaphoreValues: *const uint64_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSemaphoreWaitInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkSemaphoreWaitFlags,
	pub semaphoreCount: u32,
	pub pSemaphores: *const VkSemaphore,
	pub pValues: *const uint64_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSemaphoreSignalInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub semaphore: VkSemaphore,
	pub value: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceBufferDeviceAddressFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub bufferDeviceAddress: VkBool32,
	pub bufferDeviceAddressCaptureReplay: VkBool32,
	pub bufferDeviceAddressMultiDevice: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBufferDeviceAddressInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub buffer: VkBuffer,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBufferOpaqueCaptureAddressCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub opaqueCaptureAddress: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryOpaqueCaptureAddressAllocateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub opaqueCaptureAddress: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceMemoryOpaqueCaptureAddressInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub memory: VkDeviceMemory,
}
type PFN_vkCmdDrawIndirectCount = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
type PFN_vkCmdDrawIndexedIndirectCount = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
type PFN_vkCreateRenderPass2 = extern "system" fn(device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo2, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult;
type PFN_vkCmdBeginRenderPass2 = extern "system" fn(commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, pSubpassBeginInfo: *const VkSubpassBeginInfo);
type PFN_vkCmdNextSubpass2 = extern "system" fn(commandBuffer: VkCommandBuffer, pSubpassBeginInfo: *const VkSubpassBeginInfo, pSubpassEndInfo: *const VkSubpassEndInfo);
type PFN_vkCmdEndRenderPass2 = extern "system" fn(commandBuffer: VkCommandBuffer, pSubpassEndInfo: *const VkSubpassEndInfo);
type PFN_vkResetQueryPool = extern "system" fn(device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32);
type PFN_vkGetSemaphoreCounterValue = extern "system" fn(device: VkDevice, semaphore: VkSemaphore, pValue: *mut uint64_t) -> VkResult;
type PFN_vkWaitSemaphores = extern "system" fn(device: VkDevice, pWaitInfo: *const VkSemaphoreWaitInfo, timeout: u64) -> VkResult;
type PFN_vkSignalSemaphore = extern "system" fn(device: VkDevice, pSignalInfo: *const VkSemaphoreSignalInfo) -> VkResult;
type PFN_vkGetBufferDeviceAddress = extern "system" fn(device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress;
type PFN_vkGetBufferOpaqueCaptureAddress = extern "system" fn(device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> u64;
type PFN_vkGetDeviceMemoryOpaqueCaptureAddress = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo) -> u64;
extern "system" fn dummy_vkCmdDrawIndirectCount(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkBuffer, _: VkDeviceSize, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdDrawIndirectCount()` is NULL");
}
extern "system" fn dummy_vkCmdDrawIndexedIndirectCount(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkBuffer, _: VkDeviceSize, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdDrawIndexedIndirectCount()` is NULL");
}
extern "system" fn dummy_vkCreateRenderPass2(_: VkDevice, _: *const VkRenderPassCreateInfo2, _: *const VkAllocationCallbacks, _: *mut VkRenderPass) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateRenderPass2()` is NULL");
}
extern "system" fn dummy_vkCmdBeginRenderPass2(_: VkCommandBuffer, _: *const VkRenderPassBeginInfo, _: *const VkSubpassBeginInfo) {
	panic!("Vulkan function pointer of `vkCmdBeginRenderPass2()` is NULL");
}
extern "system" fn dummy_vkCmdNextSubpass2(_: VkCommandBuffer, _: *const VkSubpassBeginInfo, _: *const VkSubpassEndInfo) {
	panic!("Vulkan function pointer of `vkCmdNextSubpass2()` is NULL");
}
extern "system" fn dummy_vkCmdEndRenderPass2(_: VkCommandBuffer, _: *const VkSubpassEndInfo) {
	panic!("Vulkan function pointer of `vkCmdEndRenderPass2()` is NULL");
}
extern "system" fn dummy_vkResetQueryPool(_: VkDevice, _: VkQueryPool, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkResetQueryPool()` is NULL");
}
extern "system" fn dummy_vkGetSemaphoreCounterValue(_: VkDevice, _: VkSemaphore, _: *mut uint64_t) -> VkResult {
	panic!("Vulkan function pointer of `vkGetSemaphoreCounterValue()` is NULL");
}
extern "system" fn dummy_vkWaitSemaphores(_: VkDevice, _: *const VkSemaphoreWaitInfo, _: u64) -> VkResult {
	panic!("Vulkan function pointer of `vkWaitSemaphores()` is NULL");
}
extern "system" fn dummy_vkSignalSemaphore(_: VkDevice, _: *const VkSemaphoreSignalInfo) -> VkResult {
	panic!("Vulkan function pointer of `vkSignalSemaphore()` is NULL");
}
extern "system" fn dummy_vkGetBufferDeviceAddress(_: VkDevice, _: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress {
	panic!("Vulkan function pointer of `vkGetBufferDeviceAddress()` is NULL");
}
extern "system" fn dummy_vkGetBufferOpaqueCaptureAddress(_: VkDevice, _: *const VkBufferDeviceAddressInfo) -> u64 {
	panic!("Vulkan function pointer of `vkGetBufferOpaqueCaptureAddress()` is NULL");
}
extern "system" fn dummy_vkGetDeviceMemoryOpaqueCaptureAddress(_: VkDevice, _: *const VkDeviceMemoryOpaqueCaptureAddressInfo) -> u64 {
	panic!("Vulkan function pointer of `vkGetDeviceMemoryOpaqueCaptureAddress()` is NULL");
}
pub trait VK_VERSION_1_2: Debug {
	fn vkCmdDrawIndirectCount(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
	fn vkCmdDrawIndexedIndirectCount(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
	fn vkCreateRenderPass2(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo2, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult;
	fn vkCmdBeginRenderPass2(&self, commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, pSubpassBeginInfo: *const VkSubpassBeginInfo);
	fn vkCmdNextSubpass2(&self, commandBuffer: VkCommandBuffer, pSubpassBeginInfo: *const VkSubpassBeginInfo, pSubpassEndInfo: *const VkSubpassEndInfo);
	fn vkCmdEndRenderPass2(&self, commandBuffer: VkCommandBuffer, pSubpassEndInfo: *const VkSubpassEndInfo);
	fn vkResetQueryPool(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32);
	fn vkGetSemaphoreCounterValue(&self, device: VkDevice, semaphore: VkSemaphore, pValue: *mut uint64_t) -> VkResult;
	fn vkWaitSemaphores(&self, device: VkDevice, pWaitInfo: *const VkSemaphoreWaitInfo, timeout: u64) -> VkResult;
	fn vkSignalSemaphore(&self, device: VkDevice, pSignalInfo: *const VkSemaphoreSignalInfo) -> VkResult;
	fn vkGetBufferDeviceAddress(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress;
	fn vkGetBufferOpaqueCaptureAddress(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> u64;
	fn vkGetDeviceMemoryOpaqueCaptureAddress(&self, device: VkDevice, pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo) -> u64;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_VERSION_1_2 {
	vk_cmd_draw_indirect_count: PFN_vkCmdDrawIndirectCount,
	vk_cmd_draw_indexed_indirect_count: PFN_vkCmdDrawIndexedIndirectCount,
	vk_create_render_pass2: PFN_vkCreateRenderPass2,
	vk_cmd_begin_render_pass2: PFN_vkCmdBeginRenderPass2,
	vk_cmd_next_subpass2: PFN_vkCmdNextSubpass2,
	vk_cmd_end_render_pass2: PFN_vkCmdEndRenderPass2,
	vk_reset_query_pool: PFN_vkResetQueryPool,
	vk_get_semaphore_counter_value: PFN_vkGetSemaphoreCounterValue,
	vk_wait_semaphores: PFN_vkWaitSemaphores,
	vk_signal_semaphore: PFN_vkSignalSemaphore,
	vk_get_buffer_device_address: PFN_vkGetBufferDeviceAddress,
	vk_get_buffer_opaque_capture_address: PFN_vkGetBufferOpaqueCaptureAddress,
	vk_get_device_memory_opaque_capture_address: PFN_vkGetDeviceMemoryOpaqueCaptureAddress,
}
impl VK_VERSION_1_2 for Vulkan_VERSION_1_2 {
	fn vkCmdDrawIndirectCount(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) {
		(self.vk_cmd_draw_indirect_count)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	}
	fn vkCmdDrawIndexedIndirectCount(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) {
		(self.vk_cmd_draw_indexed_indirect_count)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	}
	fn vkCreateRenderPass2(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo2, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult {
		(self.vk_create_render_pass2)(device, pCreateInfo, pAllocator, pRenderPass)
	}
	fn vkCmdBeginRenderPass2(&self, commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, pSubpassBeginInfo: *const VkSubpassBeginInfo) {
		(self.vk_cmd_begin_render_pass2)(commandBuffer, pRenderPassBegin, pSubpassBeginInfo)
	}
	fn vkCmdNextSubpass2(&self, commandBuffer: VkCommandBuffer, pSubpassBeginInfo: *const VkSubpassBeginInfo, pSubpassEndInfo: *const VkSubpassEndInfo) {
		(self.vk_cmd_next_subpass2)(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo)
	}
	fn vkCmdEndRenderPass2(&self, commandBuffer: VkCommandBuffer, pSubpassEndInfo: *const VkSubpassEndInfo) {
		(self.vk_cmd_end_render_pass2)(commandBuffer, pSubpassEndInfo)
	}
	fn vkResetQueryPool(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) {
		(self.vk_reset_query_pool)(device, queryPool, firstQuery, queryCount)
	}
	fn vkGetSemaphoreCounterValue(&self, device: VkDevice, semaphore: VkSemaphore, pValue: *mut uint64_t) -> VkResult {
		(self.vk_get_semaphore_counter_value)(device, semaphore, pValue)
	}
	fn vkWaitSemaphores(&self, device: VkDevice, pWaitInfo: *const VkSemaphoreWaitInfo, timeout: u64) -> VkResult {
		(self.vk_wait_semaphores)(device, pWaitInfo, timeout)
	}
	fn vkSignalSemaphore(&self, device: VkDevice, pSignalInfo: *const VkSemaphoreSignalInfo) -> VkResult {
		(self.vk_signal_semaphore)(device, pSignalInfo)
	}
	fn vkGetBufferDeviceAddress(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress {
		(self.vk_get_buffer_device_address)(device, pInfo)
	}
	fn vkGetBufferOpaqueCaptureAddress(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> u64 {
		(self.vk_get_buffer_opaque_capture_address)(device, pInfo)
	}
	fn vkGetDeviceMemoryOpaqueCaptureAddress(&self, device: VkDevice, pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo) -> u64 {
		(self.vk_get_device_memory_opaque_capture_address)(device, pInfo)
	}
}
impl Default for Vulkan_VERSION_1_2 {
	fn default() -> Self {
		Self {
			vk_cmd_draw_indirect_count: dummy_vkCmdDrawIndirectCount,
			vk_cmd_draw_indexed_indirect_count: dummy_vkCmdDrawIndexedIndirectCount,
			vk_create_render_pass2: dummy_vkCreateRenderPass2,
			vk_cmd_begin_render_pass2: dummy_vkCmdBeginRenderPass2,
			vk_cmd_next_subpass2: dummy_vkCmdNextSubpass2,
			vk_cmd_end_render_pass2: dummy_vkCmdEndRenderPass2,
			vk_reset_query_pool: dummy_vkResetQueryPool,
			vk_get_semaphore_counter_value: dummy_vkGetSemaphoreCounterValue,
			vk_wait_semaphores: dummy_vkWaitSemaphores,
			vk_signal_semaphore: dummy_vkSignalSemaphore,
			vk_get_buffer_device_address: dummy_vkGetBufferDeviceAddress,
			vk_get_buffer_opaque_capture_address: dummy_vkGetBufferOpaqueCaptureAddress,
			vk_get_device_memory_opaque_capture_address: dummy_vkGetDeviceMemoryOpaqueCaptureAddress,
		}
	}
}
impl Vulkan_VERSION_1_2 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_draw_indirect_count: {let proc = get_proc_address(instance, "vkCmdDrawIndirectCount"); if proc == null() {dummy_vkCmdDrawIndirectCount} else {unsafe {transmute(proc)}}},
			vk_cmd_draw_indexed_indirect_count: {let proc = get_proc_address(instance, "vkCmdDrawIndexedIndirectCount"); if proc == null() {dummy_vkCmdDrawIndexedIndirectCount} else {unsafe {transmute(proc)}}},
			vk_create_render_pass2: {let proc = get_proc_address(instance, "vkCreateRenderPass2"); if proc == null() {dummy_vkCreateRenderPass2} else {unsafe {transmute(proc)}}},
			vk_cmd_begin_render_pass2: {let proc = get_proc_address(instance, "vkCmdBeginRenderPass2"); if proc == null() {dummy_vkCmdBeginRenderPass2} else {unsafe {transmute(proc)}}},
			vk_cmd_next_subpass2: {let proc = get_proc_address(instance, "vkCmdNextSubpass2"); if proc == null() {dummy_vkCmdNextSubpass2} else {unsafe {transmute(proc)}}},
			vk_cmd_end_render_pass2: {let proc = get_proc_address(instance, "vkCmdEndRenderPass2"); if proc == null() {dummy_vkCmdEndRenderPass2} else {unsafe {transmute(proc)}}},
			vk_reset_query_pool: {let proc = get_proc_address(instance, "vkResetQueryPool"); if proc == null() {dummy_vkResetQueryPool} else {unsafe {transmute(proc)}}},
			vk_get_semaphore_counter_value: {let proc = get_proc_address(instance, "vkGetSemaphoreCounterValue"); if proc == null() {dummy_vkGetSemaphoreCounterValue} else {unsafe {transmute(proc)}}},
			vk_wait_semaphores: {let proc = get_proc_address(instance, "vkWaitSemaphores"); if proc == null() {dummy_vkWaitSemaphores} else {unsafe {transmute(proc)}}},
			vk_signal_semaphore: {let proc = get_proc_address(instance, "vkSignalSemaphore"); if proc == null() {dummy_vkSignalSemaphore} else {unsafe {transmute(proc)}}},
			vk_get_buffer_device_address: {let proc = get_proc_address(instance, "vkGetBufferDeviceAddress"); if proc == null() {dummy_vkGetBufferDeviceAddress} else {unsafe {transmute(proc)}}},
			vk_get_buffer_opaque_capture_address: {let proc = get_proc_address(instance, "vkGetBufferOpaqueCaptureAddress"); if proc == null() {dummy_vkGetBufferOpaqueCaptureAddress} else {unsafe {transmute(proc)}}},
			vk_get_device_memory_opaque_capture_address: {let proc = get_proc_address(instance, "vkGetDeviceMemoryOpaqueCaptureAddress"); if proc == null() {dummy_vkGetDeviceMemoryOpaqueCaptureAddress} else {unsafe {transmute(proc)}}},
		}
	}
}
pub const VK_API_VERSION_1_3: u32 = 0x403000;
pub type VkFlags64 = u64;
pub type VkPipelineCreationFeedbackFlags = VkFlags;
pub type VkToolPurposeFlags = VkFlags;
pub type VkPrivateDataSlotCreateFlags = VkFlags;
pub type VkPipelineStageFlags2 = VkFlags64;
pub type VkPipelineStageFlagBits2 = VkFlags64;
pub type VkAccessFlags2 = VkFlags64;
pub type VkAccessFlagBits2 = VkFlags64;
pub type VkSubmitFlags = VkFlags;
pub type VkRenderingFlags = VkFlags;
pub type VkFormatFeatureFlags2 = VkFlags64;
pub type VkFormatFeatureFlagBits2 = VkFlags64;
// Define non-dispatchable handle `VkPrivateDataSlot`
#[cfg(target_pointer_width = "32")] pub type VkPrivateDataSlot = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkPrivateDataSlot_T {}
#[cfg(target_pointer_width = "64")] pub type VkPrivateDataSlot = *const VkPrivateDataSlot_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineCreationFeedbackFlagBits {
	VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT = 0x00000001,
	VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT = 0x00000002,
	VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT = 0x00000004,
	VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineCreationFeedbackFlagBits {
	pub const VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT: VkPipelineCreationFeedbackFlagBits = VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT;
	pub const VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT: VkPipelineCreationFeedbackFlagBits = VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT;
	pub const VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT: VkPipelineCreationFeedbackFlagBits = VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkToolPurposeFlagBits {
	VK_TOOL_PURPOSE_VALIDATION_BIT = 0x00000001,
	VK_TOOL_PURPOSE_PROFILING_BIT = 0x00000002,
	VK_TOOL_PURPOSE_TRACING_BIT = 0x00000004,
	VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT = 0x00000008,
	VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT = 0x00000010,
	VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = 0x00000020,
	VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = 0x00000040,
	VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkToolPurposeFlagBits {
	pub const VK_TOOL_PURPOSE_VALIDATION_BIT_EXT: VkToolPurposeFlagBits = VkToolPurposeFlagBits::VK_TOOL_PURPOSE_VALIDATION_BIT;
	pub const VK_TOOL_PURPOSE_PROFILING_BIT_EXT: VkToolPurposeFlagBits = VkToolPurposeFlagBits::VK_TOOL_PURPOSE_PROFILING_BIT;
	pub const VK_TOOL_PURPOSE_TRACING_BIT_EXT: VkToolPurposeFlagBits = VkToolPurposeFlagBits::VK_TOOL_PURPOSE_TRACING_BIT;
	pub const VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT: VkToolPurposeFlagBits = VkToolPurposeFlagBits::VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT;
	pub const VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT: VkToolPurposeFlagBits = VkToolPurposeFlagBits::VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSubmitFlagBits {
	VK_SUBMIT_PROTECTED_BIT = 0x00000001,
	VK_SUBMIT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkSubmitFlagBits {
	pub const VK_SUBMIT_PROTECTED_BIT_KHR: VkSubmitFlagBits = VkSubmitFlagBits::VK_SUBMIT_PROTECTED_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkRenderingFlagBits {
	VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT = 0x00000001,
	VK_RENDERING_SUSPENDING_BIT = 0x00000002,
	VK_RENDERING_RESUMING_BIT = 0x00000004,
	VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x00000008,
	VK_RENDERING_CONTENTS_INLINE_BIT_KHR = 0x00000010,
	VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE = 0x00000020,
	VK_RENDERING_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkRenderingFlagBits {
	pub const VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR: VkRenderingFlagBits = VkRenderingFlagBits::VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT;
	pub const VK_RENDERING_SUSPENDING_BIT_KHR: VkRenderingFlagBits = VkRenderingFlagBits::VK_RENDERING_SUSPENDING_BIT;
	pub const VK_RENDERING_RESUMING_BIT_KHR: VkRenderingFlagBits = VkRenderingFlagBits::VK_RENDERING_RESUMING_BIT;
	pub const VK_RENDERING_CONTENTS_INLINE_BIT_EXT: VkRenderingFlagBits = VkRenderingFlagBits::VK_RENDERING_CONTENTS_INLINE_BIT_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVulkan13Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub robustImageAccess: VkBool32,
	pub inlineUniformBlock: VkBool32,
	pub descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32,
	pub pipelineCreationCacheControl: VkBool32,
	pub privateData: VkBool32,
	pub shaderDemoteToHelperInvocation: VkBool32,
	pub shaderTerminateInvocation: VkBool32,
	pub subgroupSizeControl: VkBool32,
	pub computeFullSubgroups: VkBool32,
	pub synchronization2: VkBool32,
	pub textureCompressionASTC_HDR: VkBool32,
	pub shaderZeroInitializeWorkgroupMemory: VkBool32,
	pub dynamicRendering: VkBool32,
	pub shaderIntegerDotProduct: VkBool32,
	pub maintenance4: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVulkan13Properties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minSubgroupSize: u32,
	pub maxSubgroupSize: u32,
	pub maxComputeWorkgroupSubgroups: u32,
	pub requiredSubgroupSizeStages: VkShaderStageFlags,
	pub maxInlineUniformBlockSize: u32,
	pub maxPerStageDescriptorInlineUniformBlocks: u32,
	pub maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32,
	pub maxDescriptorSetInlineUniformBlocks: u32,
	pub maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32,
	pub maxInlineUniformTotalSize: u32,
	pub integerDotProduct8BitUnsignedAccelerated: VkBool32,
	pub integerDotProduct8BitSignedAccelerated: VkBool32,
	pub integerDotProduct8BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProduct4x8BitPackedUnsignedAccelerated: VkBool32,
	pub integerDotProduct4x8BitPackedSignedAccelerated: VkBool32,
	pub integerDotProduct4x8BitPackedMixedSignednessAccelerated: VkBool32,
	pub integerDotProduct16BitUnsignedAccelerated: VkBool32,
	pub integerDotProduct16BitSignedAccelerated: VkBool32,
	pub integerDotProduct16BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProduct32BitUnsignedAccelerated: VkBool32,
	pub integerDotProduct32BitSignedAccelerated: VkBool32,
	pub integerDotProduct32BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProduct64BitUnsignedAccelerated: VkBool32,
	pub integerDotProduct64BitSignedAccelerated: VkBool32,
	pub integerDotProduct64BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating8BitSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating16BitSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating32BitSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating64BitSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: VkBool32,
	pub storageTexelBufferOffsetAlignmentBytes: VkDeviceSize,
	pub storageTexelBufferOffsetSingleTexelAlignment: VkBool32,
	pub uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize,
	pub uniformTexelBufferOffsetSingleTexelAlignment: VkBool32,
	pub maxBufferSize: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineCreationFeedback {
	pub flags: VkPipelineCreationFeedbackFlags,
	pub duration: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineCreationFeedbackCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pPipelineCreationFeedback: *mut VkPipelineCreationFeedback,
	pub pipelineStageCreationFeedbackCount: u32,
	pub pPipelineStageCreationFeedbacks: *mut VkPipelineCreationFeedback,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderTerminateInvocationFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderTerminateInvocation: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceToolProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub name: [i8; VK_MAX_EXTENSION_NAME_SIZE as usize],
	pub version: [i8; VK_MAX_EXTENSION_NAME_SIZE as usize],
	pub purposes: VkToolPurposeFlags,
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub layer: [i8; VK_MAX_EXTENSION_NAME_SIZE as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderDemoteToHelperInvocation: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePrivateDataFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub privateData: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDevicePrivateDataCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub privateDataSlotRequestCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPrivateDataSlotCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPrivateDataSlotCreateFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePipelineCreationCacheControlFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineCreationCacheControl: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryBarrier2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcStageMask: VkPipelineStageFlags2,
	pub srcAccessMask: VkAccessFlags2,
	pub dstStageMask: VkPipelineStageFlags2,
	pub dstAccessMask: VkAccessFlags2,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBufferMemoryBarrier2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcStageMask: VkPipelineStageFlags2,
	pub srcAccessMask: VkAccessFlags2,
	pub dstStageMask: VkPipelineStageFlags2,
	pub dstAccessMask: VkAccessFlags2,
	pub srcQueueFamilyIndex: u32,
	pub dstQueueFamilyIndex: u32,
	pub buffer: VkBuffer,
	pub offset: VkDeviceSize,
	pub size: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageMemoryBarrier2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcStageMask: VkPipelineStageFlags2,
	pub srcAccessMask: VkAccessFlags2,
	pub dstStageMask: VkPipelineStageFlags2,
	pub dstAccessMask: VkAccessFlags2,
	pub oldLayout: VkImageLayout,
	pub newLayout: VkImageLayout,
	pub srcQueueFamilyIndex: u32,
	pub dstQueueFamilyIndex: u32,
	pub image: VkImage,
	pub subresourceRange: VkImageSubresourceRange,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDependencyInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dependencyFlags: VkDependencyFlags,
	pub memoryBarrierCount: u32,
	pub pMemoryBarriers: *const VkMemoryBarrier2,
	pub bufferMemoryBarrierCount: u32,
	pub pBufferMemoryBarriers: *const VkBufferMemoryBarrier2,
	pub imageMemoryBarrierCount: u32,
	pub pImageMemoryBarriers: *const VkImageMemoryBarrier2,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSemaphoreSubmitInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub semaphore: VkSemaphore,
	pub value: u64,
	pub stageMask: VkPipelineStageFlags2,
	pub deviceIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCommandBufferSubmitInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub commandBuffer: VkCommandBuffer,
	pub deviceMask: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSubmitInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkSubmitFlags,
	pub waitSemaphoreInfoCount: u32,
	pub pWaitSemaphoreInfos: *const VkSemaphoreSubmitInfo,
	pub commandBufferInfoCount: u32,
	pub pCommandBufferInfos: *const VkCommandBufferSubmitInfo,
	pub signalSemaphoreInfoCount: u32,
	pub pSignalSemaphoreInfos: *const VkSemaphoreSubmitInfo,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSynchronization2Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub synchronization2: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderZeroInitializeWorkgroupMemory: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceImageRobustnessFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub robustImageAccess: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBufferCopy2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcOffset: VkDeviceSize,
	pub dstOffset: VkDeviceSize,
	pub size: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyBufferInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcBuffer: VkBuffer,
	pub dstBuffer: VkBuffer,
	pub regionCount: u32,
	pub pRegions: *const VkBufferCopy2,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageCopy2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcSubresource: VkImageSubresourceLayers,
	pub srcOffset: VkOffset3D,
	pub dstSubresource: VkImageSubresourceLayers,
	pub dstOffset: VkOffset3D,
	pub extent: VkExtent3D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyImageInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcImage: VkImage,
	pub srcImageLayout: VkImageLayout,
	pub dstImage: VkImage,
	pub dstImageLayout: VkImageLayout,
	pub regionCount: u32,
	pub pRegions: *const VkImageCopy2,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBufferImageCopy2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub bufferOffset: VkDeviceSize,
	pub bufferRowLength: u32,
	pub bufferImageHeight: u32,
	pub imageSubresource: VkImageSubresourceLayers,
	pub imageOffset: VkOffset3D,
	pub imageExtent: VkExtent3D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyBufferToImageInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcBuffer: VkBuffer,
	pub dstImage: VkImage,
	pub dstImageLayout: VkImageLayout,
	pub regionCount: u32,
	pub pRegions: *const VkBufferImageCopy2,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyImageToBufferInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcImage: VkImage,
	pub srcImageLayout: VkImageLayout,
	pub dstBuffer: VkBuffer,
	pub regionCount: u32,
	pub pRegions: *const VkBufferImageCopy2,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageBlit2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcSubresource: VkImageSubresourceLayers,
	pub srcOffsets: [VkOffset3D; 2 as usize],
	pub dstSubresource: VkImageSubresourceLayers,
	pub dstOffsets: [VkOffset3D; 2 as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBlitImageInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcImage: VkImage,
	pub srcImageLayout: VkImageLayout,
	pub dstImage: VkImage,
	pub dstImageLayout: VkImageLayout,
	pub regionCount: u32,
	pub pRegions: *const VkImageBlit2,
	pub filter: VkFilter,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageResolve2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcSubresource: VkImageSubresourceLayers,
	pub srcOffset: VkOffset3D,
	pub dstSubresource: VkImageSubresourceLayers,
	pub dstOffset: VkOffset3D,
	pub extent: VkExtent3D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkResolveImageInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcImage: VkImage,
	pub srcImageLayout: VkImageLayout,
	pub dstImage: VkImage,
	pub dstImageLayout: VkImageLayout,
	pub regionCount: u32,
	pub pRegions: *const VkImageResolve2,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSubgroupSizeControlFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub subgroupSizeControl: VkBool32,
	pub computeFullSubgroups: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSubgroupSizeControlProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minSubgroupSize: u32,
	pub maxSubgroupSize: u32,
	pub maxComputeWorkgroupSubgroups: u32,
	pub requiredSubgroupSizeStages: VkShaderStageFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub requiredSubgroupSize: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceInlineUniformBlockFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub inlineUniformBlock: VkBool32,
	pub descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceInlineUniformBlockProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxInlineUniformBlockSize: u32,
	pub maxPerStageDescriptorInlineUniformBlocks: u32,
	pub maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32,
	pub maxDescriptorSetInlineUniformBlocks: u32,
	pub maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkWriteDescriptorSetInlineUniformBlock {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dataSize: u32,
	pub pData: *const c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorPoolInlineUniformBlockCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maxInlineUniformBlockBindings: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceTextureCompressionASTCHDRFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub textureCompressionASTC_HDR: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderingAttachmentInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub imageView: VkImageView,
	pub imageLayout: VkImageLayout,
	pub resolveMode: VkResolveModeFlagBits,
	pub resolveImageView: VkImageView,
	pub resolveImageLayout: VkImageLayout,
	pub loadOp: VkAttachmentLoadOp,
	pub storeOp: VkAttachmentStoreOp,
	pub clearValue: VkClearValue,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderingInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkRenderingFlags,
	pub renderArea: VkRect2D,
	pub layerCount: u32,
	pub viewMask: u32,
	pub colorAttachmentCount: u32,
	pub pColorAttachments: *const VkRenderingAttachmentInfo,
	pub pDepthAttachment: *const VkRenderingAttachmentInfo,
	pub pStencilAttachment: *const VkRenderingAttachmentInfo,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineRenderingCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub viewMask: u32,
	pub colorAttachmentCount: u32,
	pub pColorAttachmentFormats: *const VkFormat,
	pub depthAttachmentFormat: VkFormat,
	pub stencilAttachmentFormat: VkFormat,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDynamicRenderingFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub dynamicRendering: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCommandBufferInheritanceRenderingInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkRenderingFlags,
	pub viewMask: u32,
	pub colorAttachmentCount: u32,
	pub pColorAttachmentFormats: *const VkFormat,
	pub depthAttachmentFormat: VkFormat,
	pub stencilAttachmentFormat: VkFormat,
	pub rasterizationSamples: VkSampleCountFlagBits,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderIntegerDotProductFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderIntegerDotProduct: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderIntegerDotProductProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub integerDotProduct8BitUnsignedAccelerated: VkBool32,
	pub integerDotProduct8BitSignedAccelerated: VkBool32,
	pub integerDotProduct8BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProduct4x8BitPackedUnsignedAccelerated: VkBool32,
	pub integerDotProduct4x8BitPackedSignedAccelerated: VkBool32,
	pub integerDotProduct4x8BitPackedMixedSignednessAccelerated: VkBool32,
	pub integerDotProduct16BitUnsignedAccelerated: VkBool32,
	pub integerDotProduct16BitSignedAccelerated: VkBool32,
	pub integerDotProduct16BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProduct32BitUnsignedAccelerated: VkBool32,
	pub integerDotProduct32BitSignedAccelerated: VkBool32,
	pub integerDotProduct32BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProduct64BitUnsignedAccelerated: VkBool32,
	pub integerDotProduct64BitSignedAccelerated: VkBool32,
	pub integerDotProduct64BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating8BitSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating16BitSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating32BitSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating64BitSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceTexelBufferAlignmentProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub storageTexelBufferOffsetAlignmentBytes: VkDeviceSize,
	pub storageTexelBufferOffsetSingleTexelAlignment: VkBool32,
	pub uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize,
	pub uniformTexelBufferOffsetSingleTexelAlignment: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkFormatProperties3 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub linearTilingFeatures: VkFormatFeatureFlags2,
	pub optimalTilingFeatures: VkFormatFeatureFlags2,
	pub bufferFeatures: VkFormatFeatureFlags2,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance4Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maintenance4: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance4Properties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxBufferSize: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceBufferMemoryRequirements {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pCreateInfo: *const VkBufferCreateInfo,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceImageMemoryRequirements {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pCreateInfo: *const VkImageCreateInfo,
	pub planeAspect: VkImageAspectFlagBits,
}
type PFN_vkGetPhysicalDeviceToolProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pToolCount: *mut uint32_t, pToolProperties: *mut VkPhysicalDeviceToolProperties) -> VkResult;
type PFN_vkCreatePrivateDataSlot = extern "system" fn(device: VkDevice, pCreateInfo: *const VkPrivateDataSlotCreateInfo, pAllocator: *const VkAllocationCallbacks, pPrivateDataSlot: *mut VkPrivateDataSlot) -> VkResult;
type PFN_vkDestroyPrivateDataSlot = extern "system" fn(device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: *const VkAllocationCallbacks);
type PFN_vkSetPrivateData = extern "system" fn(device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, data: u64) -> VkResult;
type PFN_vkGetPrivateData = extern "system" fn(device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, pData: *mut uint64_t);
type PFN_vkCmdSetEvent2 = extern "system" fn(commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *const VkDependencyInfo);
type PFN_vkCmdResetEvent2 = extern "system" fn(commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2);
type PFN_vkCmdWaitEvents2 = extern "system" fn(commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, pDependencyInfos: *const VkDependencyInfo);
type PFN_vkCmdPipelineBarrier2 = extern "system" fn(commandBuffer: VkCommandBuffer, pDependencyInfo: *const VkDependencyInfo);
type PFN_vkCmdWriteTimestamp2 = extern "system" fn(commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: u32);
type PFN_vkQueueSubmit2 = extern "system" fn(queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo2, fence: VkFence) -> VkResult;
type PFN_vkCmdCopyBuffer2 = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2);
type PFN_vkCmdCopyImage2 = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyImageInfo: *const VkCopyImageInfo2);
type PFN_vkCmdCopyBufferToImage2 = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: *const VkCopyBufferToImageInfo2);
type PFN_vkCmdCopyImageToBuffer2 = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: *const VkCopyImageToBufferInfo2);
type PFN_vkCmdBlitImage2 = extern "system" fn(commandBuffer: VkCommandBuffer, pBlitImageInfo: *const VkBlitImageInfo2);
type PFN_vkCmdResolveImage2 = extern "system" fn(commandBuffer: VkCommandBuffer, pResolveImageInfo: *const VkResolveImageInfo2);
type PFN_vkCmdBeginRendering = extern "system" fn(commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo);
type PFN_vkCmdEndRendering = extern "system" fn(commandBuffer: VkCommandBuffer);
type PFN_vkCmdSetCullMode = extern "system" fn(commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags);
type PFN_vkCmdSetFrontFace = extern "system" fn(commandBuffer: VkCommandBuffer, frontFace: VkFrontFace);
type PFN_vkCmdSetPrimitiveTopology = extern "system" fn(commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology);
type PFN_vkCmdSetViewportWithCount = extern "system" fn(commandBuffer: VkCommandBuffer, viewportCount: u32, pViewports: *const VkViewport);
type PFN_vkCmdSetScissorWithCount = extern "system" fn(commandBuffer: VkCommandBuffer, scissorCount: u32, pScissors: *const VkRect2D);
type PFN_vkCmdBindVertexBuffers2 = extern "system" fn(commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize, pStrides: *const VkDeviceSize);
type PFN_vkCmdSetDepthTestEnable = extern "system" fn(commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32);
type PFN_vkCmdSetDepthWriteEnable = extern "system" fn(commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32);
type PFN_vkCmdSetDepthCompareOp = extern "system" fn(commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp);
type PFN_vkCmdSetDepthBoundsTestEnable = extern "system" fn(commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32);
type PFN_vkCmdSetStencilTestEnable = extern "system" fn(commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32);
type PFN_vkCmdSetStencilOp = extern "system" fn(commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp);
type PFN_vkCmdSetRasterizerDiscardEnable = extern "system" fn(commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32);
type PFN_vkCmdSetDepthBiasEnable = extern "system" fn(commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32);
type PFN_vkCmdSetPrimitiveRestartEnable = extern "system" fn(commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32);
type PFN_vkGetDeviceBufferMemoryRequirements = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceBufferMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2);
type PFN_vkGetDeviceImageMemoryRequirements = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2);
type PFN_vkGetDeviceImageSparseMemoryRequirements = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2);
extern "system" fn dummy_vkGetPhysicalDeviceToolProperties(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkPhysicalDeviceToolProperties) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceToolProperties()` is NULL");
}
extern "system" fn dummy_vkCreatePrivateDataSlot(_: VkDevice, _: *const VkPrivateDataSlotCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkPrivateDataSlot) -> VkResult {
	panic!("Vulkan function pointer of `vkCreatePrivateDataSlot()` is NULL");
}
extern "system" fn dummy_vkDestroyPrivateDataSlot(_: VkDevice, _: VkPrivateDataSlot, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroyPrivateDataSlot()` is NULL");
}
extern "system" fn dummy_vkSetPrivateData(_: VkDevice, _: VkObjectType, _: u64, _: VkPrivateDataSlot, _: u64) -> VkResult {
	panic!("Vulkan function pointer of `vkSetPrivateData()` is NULL");
}
extern "system" fn dummy_vkGetPrivateData(_: VkDevice, _: VkObjectType, _: u64, _: VkPrivateDataSlot, _: *mut uint64_t) {
	panic!("Vulkan function pointer of `vkGetPrivateData()` is NULL");
}
extern "system" fn dummy_vkCmdSetEvent2(_: VkCommandBuffer, _: VkEvent, _: *const VkDependencyInfo) {
	panic!("Vulkan function pointer of `vkCmdSetEvent2()` is NULL");
}
extern "system" fn dummy_vkCmdResetEvent2(_: VkCommandBuffer, _: VkEvent, _: VkPipelineStageFlags2) {
	panic!("Vulkan function pointer of `vkCmdResetEvent2()` is NULL");
}
extern "system" fn dummy_vkCmdWaitEvents2(_: VkCommandBuffer, _: u32, _: *const VkEvent, _: *const VkDependencyInfo) {
	panic!("Vulkan function pointer of `vkCmdWaitEvents2()` is NULL");
}
extern "system" fn dummy_vkCmdPipelineBarrier2(_: VkCommandBuffer, _: *const VkDependencyInfo) {
	panic!("Vulkan function pointer of `vkCmdPipelineBarrier2()` is NULL");
}
extern "system" fn dummy_vkCmdWriteTimestamp2(_: VkCommandBuffer, _: VkPipelineStageFlags2, _: VkQueryPool, _: u32) {
	panic!("Vulkan function pointer of `vkCmdWriteTimestamp2()` is NULL");
}
extern "system" fn dummy_vkQueueSubmit2(_: VkQueue, _: u32, _: *const VkSubmitInfo2, _: VkFence) -> VkResult {
	panic!("Vulkan function pointer of `vkQueueSubmit2()` is NULL");
}
extern "system" fn dummy_vkCmdCopyBuffer2(_: VkCommandBuffer, _: *const VkCopyBufferInfo2) {
	panic!("Vulkan function pointer of `vkCmdCopyBuffer2()` is NULL");
}
extern "system" fn dummy_vkCmdCopyImage2(_: VkCommandBuffer, _: *const VkCopyImageInfo2) {
	panic!("Vulkan function pointer of `vkCmdCopyImage2()` is NULL");
}
extern "system" fn dummy_vkCmdCopyBufferToImage2(_: VkCommandBuffer, _: *const VkCopyBufferToImageInfo2) {
	panic!("Vulkan function pointer of `vkCmdCopyBufferToImage2()` is NULL");
}
extern "system" fn dummy_vkCmdCopyImageToBuffer2(_: VkCommandBuffer, _: *const VkCopyImageToBufferInfo2) {
	panic!("Vulkan function pointer of `vkCmdCopyImageToBuffer2()` is NULL");
}
extern "system" fn dummy_vkCmdBlitImage2(_: VkCommandBuffer, _: *const VkBlitImageInfo2) {
	panic!("Vulkan function pointer of `vkCmdBlitImage2()` is NULL");
}
extern "system" fn dummy_vkCmdResolveImage2(_: VkCommandBuffer, _: *const VkResolveImageInfo2) {
	panic!("Vulkan function pointer of `vkCmdResolveImage2()` is NULL");
}
extern "system" fn dummy_vkCmdBeginRendering(_: VkCommandBuffer, _: *const VkRenderingInfo) {
	panic!("Vulkan function pointer of `vkCmdBeginRendering()` is NULL");
}
extern "system" fn dummy_vkCmdEndRendering(_: VkCommandBuffer) {
	panic!("Vulkan function pointer of `vkCmdEndRendering()` is NULL");
}
extern "system" fn dummy_vkCmdSetCullMode(_: VkCommandBuffer, _: VkCullModeFlags) {
	panic!("Vulkan function pointer of `vkCmdSetCullMode()` is NULL");
}
extern "system" fn dummy_vkCmdSetFrontFace(_: VkCommandBuffer, _: VkFrontFace) {
	panic!("Vulkan function pointer of `vkCmdSetFrontFace()` is NULL");
}
extern "system" fn dummy_vkCmdSetPrimitiveTopology(_: VkCommandBuffer, _: VkPrimitiveTopology) {
	panic!("Vulkan function pointer of `vkCmdSetPrimitiveTopology()` is NULL");
}
extern "system" fn dummy_vkCmdSetViewportWithCount(_: VkCommandBuffer, _: u32, _: *const VkViewport) {
	panic!("Vulkan function pointer of `vkCmdSetViewportWithCount()` is NULL");
}
extern "system" fn dummy_vkCmdSetScissorWithCount(_: VkCommandBuffer, _: u32, _: *const VkRect2D) {
	panic!("Vulkan function pointer of `vkCmdSetScissorWithCount()` is NULL");
}
extern "system" fn dummy_vkCmdBindVertexBuffers2(_: VkCommandBuffer, _: u32, _: u32, _: *const VkBuffer, _: *const VkDeviceSize, _: *const VkDeviceSize, _: *const VkDeviceSize) {
	panic!("Vulkan function pointer of `vkCmdBindVertexBuffers2()` is NULL");
}
extern "system" fn dummy_vkCmdSetDepthTestEnable(_: VkCommandBuffer, _: VkBool32) {
	panic!("Vulkan function pointer of `vkCmdSetDepthTestEnable()` is NULL");
}
extern "system" fn dummy_vkCmdSetDepthWriteEnable(_: VkCommandBuffer, _: VkBool32) {
	panic!("Vulkan function pointer of `vkCmdSetDepthWriteEnable()` is NULL");
}
extern "system" fn dummy_vkCmdSetDepthCompareOp(_: VkCommandBuffer, _: VkCompareOp) {
	panic!("Vulkan function pointer of `vkCmdSetDepthCompareOp()` is NULL");
}
extern "system" fn dummy_vkCmdSetDepthBoundsTestEnable(_: VkCommandBuffer, _: VkBool32) {
	panic!("Vulkan function pointer of `vkCmdSetDepthBoundsTestEnable()` is NULL");
}
extern "system" fn dummy_vkCmdSetStencilTestEnable(_: VkCommandBuffer, _: VkBool32) {
	panic!("Vulkan function pointer of `vkCmdSetStencilTestEnable()` is NULL");
}
extern "system" fn dummy_vkCmdSetStencilOp(_: VkCommandBuffer, _: VkStencilFaceFlags, _: VkStencilOp, _: VkStencilOp, _: VkStencilOp, _: VkCompareOp) {
	panic!("Vulkan function pointer of `vkCmdSetStencilOp()` is NULL");
}
extern "system" fn dummy_vkCmdSetRasterizerDiscardEnable(_: VkCommandBuffer, _: VkBool32) {
	panic!("Vulkan function pointer of `vkCmdSetRasterizerDiscardEnable()` is NULL");
}
extern "system" fn dummy_vkCmdSetDepthBiasEnable(_: VkCommandBuffer, _: VkBool32) {
	panic!("Vulkan function pointer of `vkCmdSetDepthBiasEnable()` is NULL");
}
extern "system" fn dummy_vkCmdSetPrimitiveRestartEnable(_: VkCommandBuffer, _: VkBool32) {
	panic!("Vulkan function pointer of `vkCmdSetPrimitiveRestartEnable()` is NULL");
}
extern "system" fn dummy_vkGetDeviceBufferMemoryRequirements(_: VkDevice, _: *const VkDeviceBufferMemoryRequirements, _: *mut VkMemoryRequirements2) {
	panic!("Vulkan function pointer of `vkGetDeviceBufferMemoryRequirements()` is NULL");
}
extern "system" fn dummy_vkGetDeviceImageMemoryRequirements(_: VkDevice, _: *const VkDeviceImageMemoryRequirements, _: *mut VkMemoryRequirements2) {
	panic!("Vulkan function pointer of `vkGetDeviceImageMemoryRequirements()` is NULL");
}
extern "system" fn dummy_vkGetDeviceImageSparseMemoryRequirements(_: VkDevice, _: *const VkDeviceImageMemoryRequirements, _: *mut uint32_t, _: *mut VkSparseImageMemoryRequirements2) {
	panic!("Vulkan function pointer of `vkGetDeviceImageSparseMemoryRequirements()` is NULL");
}
pub trait VK_VERSION_1_3: Debug {
	fn vkGetPhysicalDeviceToolProperties(&self, physicalDevice: VkPhysicalDevice, pToolCount: *mut uint32_t, pToolProperties: *mut VkPhysicalDeviceToolProperties) -> VkResult;
	fn vkCreatePrivateDataSlot(&self, device: VkDevice, pCreateInfo: *const VkPrivateDataSlotCreateInfo, pAllocator: *const VkAllocationCallbacks, pPrivateDataSlot: *mut VkPrivateDataSlot) -> VkResult;
	fn vkDestroyPrivateDataSlot(&self, device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: *const VkAllocationCallbacks);
	fn vkSetPrivateData(&self, device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, data: u64) -> VkResult;
	fn vkGetPrivateData(&self, device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, pData: *mut uint64_t);
	fn vkCmdSetEvent2(&self, commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *const VkDependencyInfo);
	fn vkCmdResetEvent2(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2);
	fn vkCmdWaitEvents2(&self, commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, pDependencyInfos: *const VkDependencyInfo);
	fn vkCmdPipelineBarrier2(&self, commandBuffer: VkCommandBuffer, pDependencyInfo: *const VkDependencyInfo);
	fn vkCmdWriteTimestamp2(&self, commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: u32);
	fn vkQueueSubmit2(&self, queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo2, fence: VkFence) -> VkResult;
	fn vkCmdCopyBuffer2(&self, commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2);
	fn vkCmdCopyImage2(&self, commandBuffer: VkCommandBuffer, pCopyImageInfo: *const VkCopyImageInfo2);
	fn vkCmdCopyBufferToImage2(&self, commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: *const VkCopyBufferToImageInfo2);
	fn vkCmdCopyImageToBuffer2(&self, commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: *const VkCopyImageToBufferInfo2);
	fn vkCmdBlitImage2(&self, commandBuffer: VkCommandBuffer, pBlitImageInfo: *const VkBlitImageInfo2);
	fn vkCmdResolveImage2(&self, commandBuffer: VkCommandBuffer, pResolveImageInfo: *const VkResolveImageInfo2);
	fn vkCmdBeginRendering(&self, commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo);
	fn vkCmdEndRendering(&self, commandBuffer: VkCommandBuffer);
	fn vkCmdSetCullMode(&self, commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags);
	fn vkCmdSetFrontFace(&self, commandBuffer: VkCommandBuffer, frontFace: VkFrontFace);
	fn vkCmdSetPrimitiveTopology(&self, commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology);
	fn vkCmdSetViewportWithCount(&self, commandBuffer: VkCommandBuffer, viewportCount: u32, pViewports: *const VkViewport);
	fn vkCmdSetScissorWithCount(&self, commandBuffer: VkCommandBuffer, scissorCount: u32, pScissors: *const VkRect2D);
	fn vkCmdBindVertexBuffers2(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize, pStrides: *const VkDeviceSize);
	fn vkCmdSetDepthTestEnable(&self, commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32);
	fn vkCmdSetDepthWriteEnable(&self, commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32);
	fn vkCmdSetDepthCompareOp(&self, commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp);
	fn vkCmdSetDepthBoundsTestEnable(&self, commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32);
	fn vkCmdSetStencilTestEnable(&self, commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32);
	fn vkCmdSetStencilOp(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp);
	fn vkCmdSetRasterizerDiscardEnable(&self, commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32);
	fn vkCmdSetDepthBiasEnable(&self, commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32);
	fn vkCmdSetPrimitiveRestartEnable(&self, commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32);
	fn vkGetDeviceBufferMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceBufferMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2);
	fn vkGetDeviceImageMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2);
	fn vkGetDeviceImageSparseMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_VERSION_1_3 {
	vk_get_physical_device_tool_properties: PFN_vkGetPhysicalDeviceToolProperties,
	vk_create_private_data_slot: PFN_vkCreatePrivateDataSlot,
	vk_destroy_private_data_slot: PFN_vkDestroyPrivateDataSlot,
	vk_set_private_data: PFN_vkSetPrivateData,
	vk_get_private_data: PFN_vkGetPrivateData,
	vk_cmd_set_event2: PFN_vkCmdSetEvent2,
	vk_cmd_reset_event2: PFN_vkCmdResetEvent2,
	vk_cmd_wait_events2: PFN_vkCmdWaitEvents2,
	vk_cmd_pipeline_barrier2: PFN_vkCmdPipelineBarrier2,
	vk_cmd_write_timestamp2: PFN_vkCmdWriteTimestamp2,
	vk_queue_submit2: PFN_vkQueueSubmit2,
	vk_cmd_copy_buffer2: PFN_vkCmdCopyBuffer2,
	vk_cmd_copy_image2: PFN_vkCmdCopyImage2,
	vk_cmd_copy_buffer_to_image2: PFN_vkCmdCopyBufferToImage2,
	vk_cmd_copy_image_to_buffer2: PFN_vkCmdCopyImageToBuffer2,
	vk_cmd_blit_image2: PFN_vkCmdBlitImage2,
	vk_cmd_resolve_image2: PFN_vkCmdResolveImage2,
	vk_cmd_begin_rendering: PFN_vkCmdBeginRendering,
	vk_cmd_end_rendering: PFN_vkCmdEndRendering,
	vk_cmd_set_cull_mode: PFN_vkCmdSetCullMode,
	vk_cmd_set_front_face: PFN_vkCmdSetFrontFace,
	vk_cmd_set_primitive_topology: PFN_vkCmdSetPrimitiveTopology,
	vk_cmd_set_viewport_with_count: PFN_vkCmdSetViewportWithCount,
	vk_cmd_set_scissor_with_count: PFN_vkCmdSetScissorWithCount,
	vk_cmd_bind_vertex_buffers2: PFN_vkCmdBindVertexBuffers2,
	vk_cmd_set_depth_test_enable: PFN_vkCmdSetDepthTestEnable,
	vk_cmd_set_depth_write_enable: PFN_vkCmdSetDepthWriteEnable,
	vk_cmd_set_depth_compare_op: PFN_vkCmdSetDepthCompareOp,
	vk_cmd_set_depth_bounds_test_enable: PFN_vkCmdSetDepthBoundsTestEnable,
	vk_cmd_set_stencil_test_enable: PFN_vkCmdSetStencilTestEnable,
	vk_cmd_set_stencil_op: PFN_vkCmdSetStencilOp,
	vk_cmd_set_rasterizer_discard_enable: PFN_vkCmdSetRasterizerDiscardEnable,
	vk_cmd_set_depth_bias_enable: PFN_vkCmdSetDepthBiasEnable,
	vk_cmd_set_primitive_restart_enable: PFN_vkCmdSetPrimitiveRestartEnable,
	vk_get_device_buffer_memory_requirements: PFN_vkGetDeviceBufferMemoryRequirements,
	vk_get_device_image_memory_requirements: PFN_vkGetDeviceImageMemoryRequirements,
	vk_get_device_image_sparse_memory_requirements: PFN_vkGetDeviceImageSparseMemoryRequirements,
}
impl VK_VERSION_1_3 for Vulkan_VERSION_1_3 {
	fn vkGetPhysicalDeviceToolProperties(&self, physicalDevice: VkPhysicalDevice, pToolCount: *mut uint32_t, pToolProperties: *mut VkPhysicalDeviceToolProperties) -> VkResult {
		(self.vk_get_physical_device_tool_properties)(physicalDevice, pToolCount, pToolProperties)
	}
	fn vkCreatePrivateDataSlot(&self, device: VkDevice, pCreateInfo: *const VkPrivateDataSlotCreateInfo, pAllocator: *const VkAllocationCallbacks, pPrivateDataSlot: *mut VkPrivateDataSlot) -> VkResult {
		(self.vk_create_private_data_slot)(device, pCreateInfo, pAllocator, pPrivateDataSlot)
	}
	fn vkDestroyPrivateDataSlot(&self, device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_private_data_slot)(device, privateDataSlot, pAllocator)
	}
	fn vkSetPrivateData(&self, device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, data: u64) -> VkResult {
		(self.vk_set_private_data)(device, objectType, objectHandle, privateDataSlot, data)
	}
	fn vkGetPrivateData(&self, device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, pData: *mut uint64_t) {
		(self.vk_get_private_data)(device, objectType, objectHandle, privateDataSlot, pData)
	}
	fn vkCmdSetEvent2(&self, commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *const VkDependencyInfo) {
		(self.vk_cmd_set_event2)(commandBuffer, event, pDependencyInfo)
	}
	fn vkCmdResetEvent2(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2) {
		(self.vk_cmd_reset_event2)(commandBuffer, event, stageMask)
	}
	fn vkCmdWaitEvents2(&self, commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, pDependencyInfos: *const VkDependencyInfo) {
		(self.vk_cmd_wait_events2)(commandBuffer, eventCount, pEvents, pDependencyInfos)
	}
	fn vkCmdPipelineBarrier2(&self, commandBuffer: VkCommandBuffer, pDependencyInfo: *const VkDependencyInfo) {
		(self.vk_cmd_pipeline_barrier2)(commandBuffer, pDependencyInfo)
	}
	fn vkCmdWriteTimestamp2(&self, commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: u32) {
		(self.vk_cmd_write_timestamp2)(commandBuffer, stage, queryPool, query)
	}
	fn vkQueueSubmit2(&self, queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo2, fence: VkFence) -> VkResult {
		(self.vk_queue_submit2)(queue, submitCount, pSubmits, fence)
	}
	fn vkCmdCopyBuffer2(&self, commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2) {
		(self.vk_cmd_copy_buffer2)(commandBuffer, pCopyBufferInfo)
	}
	fn vkCmdCopyImage2(&self, commandBuffer: VkCommandBuffer, pCopyImageInfo: *const VkCopyImageInfo2) {
		(self.vk_cmd_copy_image2)(commandBuffer, pCopyImageInfo)
	}
	fn vkCmdCopyBufferToImage2(&self, commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: *const VkCopyBufferToImageInfo2) {
		(self.vk_cmd_copy_buffer_to_image2)(commandBuffer, pCopyBufferToImageInfo)
	}
	fn vkCmdCopyImageToBuffer2(&self, commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: *const VkCopyImageToBufferInfo2) {
		(self.vk_cmd_copy_image_to_buffer2)(commandBuffer, pCopyImageToBufferInfo)
	}
	fn vkCmdBlitImage2(&self, commandBuffer: VkCommandBuffer, pBlitImageInfo: *const VkBlitImageInfo2) {
		(self.vk_cmd_blit_image2)(commandBuffer, pBlitImageInfo)
	}
	fn vkCmdResolveImage2(&self, commandBuffer: VkCommandBuffer, pResolveImageInfo: *const VkResolveImageInfo2) {
		(self.vk_cmd_resolve_image2)(commandBuffer, pResolveImageInfo)
	}
	fn vkCmdBeginRendering(&self, commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo) {
		(self.vk_cmd_begin_rendering)(commandBuffer, pRenderingInfo)
	}
	fn vkCmdEndRendering(&self, commandBuffer: VkCommandBuffer) {
		(self.vk_cmd_end_rendering)(commandBuffer)
	}
	fn vkCmdSetCullMode(&self, commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) {
		(self.vk_cmd_set_cull_mode)(commandBuffer, cullMode)
	}
	fn vkCmdSetFrontFace(&self, commandBuffer: VkCommandBuffer, frontFace: VkFrontFace) {
		(self.vk_cmd_set_front_face)(commandBuffer, frontFace)
	}
	fn vkCmdSetPrimitiveTopology(&self, commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology) {
		(self.vk_cmd_set_primitive_topology)(commandBuffer, primitiveTopology)
	}
	fn vkCmdSetViewportWithCount(&self, commandBuffer: VkCommandBuffer, viewportCount: u32, pViewports: *const VkViewport) {
		(self.vk_cmd_set_viewport_with_count)(commandBuffer, viewportCount, pViewports)
	}
	fn vkCmdSetScissorWithCount(&self, commandBuffer: VkCommandBuffer, scissorCount: u32, pScissors: *const VkRect2D) {
		(self.vk_cmd_set_scissor_with_count)(commandBuffer, scissorCount, pScissors)
	}
	fn vkCmdBindVertexBuffers2(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize, pStrides: *const VkDeviceSize) {
		(self.vk_cmd_bind_vertex_buffers2)(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides)
	}
	fn vkCmdSetDepthTestEnable(&self, commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32) {
		(self.vk_cmd_set_depth_test_enable)(commandBuffer, depthTestEnable)
	}
	fn vkCmdSetDepthWriteEnable(&self, commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32) {
		(self.vk_cmd_set_depth_write_enable)(commandBuffer, depthWriteEnable)
	}
	fn vkCmdSetDepthCompareOp(&self, commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp) {
		(self.vk_cmd_set_depth_compare_op)(commandBuffer, depthCompareOp)
	}
	fn vkCmdSetDepthBoundsTestEnable(&self, commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32) {
		(self.vk_cmd_set_depth_bounds_test_enable)(commandBuffer, depthBoundsTestEnable)
	}
	fn vkCmdSetStencilTestEnable(&self, commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32) {
		(self.vk_cmd_set_stencil_test_enable)(commandBuffer, stencilTestEnable)
	}
	fn vkCmdSetStencilOp(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp) {
		(self.vk_cmd_set_stencil_op)(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp)
	}
	fn vkCmdSetRasterizerDiscardEnable(&self, commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32) {
		(self.vk_cmd_set_rasterizer_discard_enable)(commandBuffer, rasterizerDiscardEnable)
	}
	fn vkCmdSetDepthBiasEnable(&self, commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32) {
		(self.vk_cmd_set_depth_bias_enable)(commandBuffer, depthBiasEnable)
	}
	fn vkCmdSetPrimitiveRestartEnable(&self, commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32) {
		(self.vk_cmd_set_primitive_restart_enable)(commandBuffer, primitiveRestartEnable)
	}
	fn vkGetDeviceBufferMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceBufferMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_get_device_buffer_memory_requirements)(device, pInfo, pMemoryRequirements)
	}
	fn vkGetDeviceImageMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_get_device_image_memory_requirements)(device, pInfo, pMemoryRequirements)
	}
	fn vkGetDeviceImageSparseMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2) {
		(self.vk_get_device_image_sparse_memory_requirements)(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements)
	}
}
impl Default for Vulkan_VERSION_1_3 {
	fn default() -> Self {
		Self {
			vk_get_physical_device_tool_properties: dummy_vkGetPhysicalDeviceToolProperties,
			vk_create_private_data_slot: dummy_vkCreatePrivateDataSlot,
			vk_destroy_private_data_slot: dummy_vkDestroyPrivateDataSlot,
			vk_set_private_data: dummy_vkSetPrivateData,
			vk_get_private_data: dummy_vkGetPrivateData,
			vk_cmd_set_event2: dummy_vkCmdSetEvent2,
			vk_cmd_reset_event2: dummy_vkCmdResetEvent2,
			vk_cmd_wait_events2: dummy_vkCmdWaitEvents2,
			vk_cmd_pipeline_barrier2: dummy_vkCmdPipelineBarrier2,
			vk_cmd_write_timestamp2: dummy_vkCmdWriteTimestamp2,
			vk_queue_submit2: dummy_vkQueueSubmit2,
			vk_cmd_copy_buffer2: dummy_vkCmdCopyBuffer2,
			vk_cmd_copy_image2: dummy_vkCmdCopyImage2,
			vk_cmd_copy_buffer_to_image2: dummy_vkCmdCopyBufferToImage2,
			vk_cmd_copy_image_to_buffer2: dummy_vkCmdCopyImageToBuffer2,
			vk_cmd_blit_image2: dummy_vkCmdBlitImage2,
			vk_cmd_resolve_image2: dummy_vkCmdResolveImage2,
			vk_cmd_begin_rendering: dummy_vkCmdBeginRendering,
			vk_cmd_end_rendering: dummy_vkCmdEndRendering,
			vk_cmd_set_cull_mode: dummy_vkCmdSetCullMode,
			vk_cmd_set_front_face: dummy_vkCmdSetFrontFace,
			vk_cmd_set_primitive_topology: dummy_vkCmdSetPrimitiveTopology,
			vk_cmd_set_viewport_with_count: dummy_vkCmdSetViewportWithCount,
			vk_cmd_set_scissor_with_count: dummy_vkCmdSetScissorWithCount,
			vk_cmd_bind_vertex_buffers2: dummy_vkCmdBindVertexBuffers2,
			vk_cmd_set_depth_test_enable: dummy_vkCmdSetDepthTestEnable,
			vk_cmd_set_depth_write_enable: dummy_vkCmdSetDepthWriteEnable,
			vk_cmd_set_depth_compare_op: dummy_vkCmdSetDepthCompareOp,
			vk_cmd_set_depth_bounds_test_enable: dummy_vkCmdSetDepthBoundsTestEnable,
			vk_cmd_set_stencil_test_enable: dummy_vkCmdSetStencilTestEnable,
			vk_cmd_set_stencil_op: dummy_vkCmdSetStencilOp,
			vk_cmd_set_rasterizer_discard_enable: dummy_vkCmdSetRasterizerDiscardEnable,
			vk_cmd_set_depth_bias_enable: dummy_vkCmdSetDepthBiasEnable,
			vk_cmd_set_primitive_restart_enable: dummy_vkCmdSetPrimitiveRestartEnable,
			vk_get_device_buffer_memory_requirements: dummy_vkGetDeviceBufferMemoryRequirements,
			vk_get_device_image_memory_requirements: dummy_vkGetDeviceImageMemoryRequirements,
			vk_get_device_image_sparse_memory_requirements: dummy_vkGetDeviceImageSparseMemoryRequirements,
		}
	}
}
impl Vulkan_VERSION_1_3 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_tool_properties: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceToolProperties"); if proc == null() {dummy_vkGetPhysicalDeviceToolProperties} else {unsafe {transmute(proc)}}},
			vk_create_private_data_slot: {let proc = get_proc_address(instance, "vkCreatePrivateDataSlot"); if proc == null() {dummy_vkCreatePrivateDataSlot} else {unsafe {transmute(proc)}}},
			vk_destroy_private_data_slot: {let proc = get_proc_address(instance, "vkDestroyPrivateDataSlot"); if proc == null() {dummy_vkDestroyPrivateDataSlot} else {unsafe {transmute(proc)}}},
			vk_set_private_data: {let proc = get_proc_address(instance, "vkSetPrivateData"); if proc == null() {dummy_vkSetPrivateData} else {unsafe {transmute(proc)}}},
			vk_get_private_data: {let proc = get_proc_address(instance, "vkGetPrivateData"); if proc == null() {dummy_vkGetPrivateData} else {unsafe {transmute(proc)}}},
			vk_cmd_set_event2: {let proc = get_proc_address(instance, "vkCmdSetEvent2"); if proc == null() {dummy_vkCmdSetEvent2} else {unsafe {transmute(proc)}}},
			vk_cmd_reset_event2: {let proc = get_proc_address(instance, "vkCmdResetEvent2"); if proc == null() {dummy_vkCmdResetEvent2} else {unsafe {transmute(proc)}}},
			vk_cmd_wait_events2: {let proc = get_proc_address(instance, "vkCmdWaitEvents2"); if proc == null() {dummy_vkCmdWaitEvents2} else {unsafe {transmute(proc)}}},
			vk_cmd_pipeline_barrier2: {let proc = get_proc_address(instance, "vkCmdPipelineBarrier2"); if proc == null() {dummy_vkCmdPipelineBarrier2} else {unsafe {transmute(proc)}}},
			vk_cmd_write_timestamp2: {let proc = get_proc_address(instance, "vkCmdWriteTimestamp2"); if proc == null() {dummy_vkCmdWriteTimestamp2} else {unsafe {transmute(proc)}}},
			vk_queue_submit2: {let proc = get_proc_address(instance, "vkQueueSubmit2"); if proc == null() {dummy_vkQueueSubmit2} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_buffer2: {let proc = get_proc_address(instance, "vkCmdCopyBuffer2"); if proc == null() {dummy_vkCmdCopyBuffer2} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_image2: {let proc = get_proc_address(instance, "vkCmdCopyImage2"); if proc == null() {dummy_vkCmdCopyImage2} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_buffer_to_image2: {let proc = get_proc_address(instance, "vkCmdCopyBufferToImage2"); if proc == null() {dummy_vkCmdCopyBufferToImage2} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_image_to_buffer2: {let proc = get_proc_address(instance, "vkCmdCopyImageToBuffer2"); if proc == null() {dummy_vkCmdCopyImageToBuffer2} else {unsafe {transmute(proc)}}},
			vk_cmd_blit_image2: {let proc = get_proc_address(instance, "vkCmdBlitImage2"); if proc == null() {dummy_vkCmdBlitImage2} else {unsafe {transmute(proc)}}},
			vk_cmd_resolve_image2: {let proc = get_proc_address(instance, "vkCmdResolveImage2"); if proc == null() {dummy_vkCmdResolveImage2} else {unsafe {transmute(proc)}}},
			vk_cmd_begin_rendering: {let proc = get_proc_address(instance, "vkCmdBeginRendering"); if proc == null() {dummy_vkCmdBeginRendering} else {unsafe {transmute(proc)}}},
			vk_cmd_end_rendering: {let proc = get_proc_address(instance, "vkCmdEndRendering"); if proc == null() {dummy_vkCmdEndRendering} else {unsafe {transmute(proc)}}},
			vk_cmd_set_cull_mode: {let proc = get_proc_address(instance, "vkCmdSetCullMode"); if proc == null() {dummy_vkCmdSetCullMode} else {unsafe {transmute(proc)}}},
			vk_cmd_set_front_face: {let proc = get_proc_address(instance, "vkCmdSetFrontFace"); if proc == null() {dummy_vkCmdSetFrontFace} else {unsafe {transmute(proc)}}},
			vk_cmd_set_primitive_topology: {let proc = get_proc_address(instance, "vkCmdSetPrimitiveTopology"); if proc == null() {dummy_vkCmdSetPrimitiveTopology} else {unsafe {transmute(proc)}}},
			vk_cmd_set_viewport_with_count: {let proc = get_proc_address(instance, "vkCmdSetViewportWithCount"); if proc == null() {dummy_vkCmdSetViewportWithCount} else {unsafe {transmute(proc)}}},
			vk_cmd_set_scissor_with_count: {let proc = get_proc_address(instance, "vkCmdSetScissorWithCount"); if proc == null() {dummy_vkCmdSetScissorWithCount} else {unsafe {transmute(proc)}}},
			vk_cmd_bind_vertex_buffers2: {let proc = get_proc_address(instance, "vkCmdBindVertexBuffers2"); if proc == null() {dummy_vkCmdBindVertexBuffers2} else {unsafe {transmute(proc)}}},
			vk_cmd_set_depth_test_enable: {let proc = get_proc_address(instance, "vkCmdSetDepthTestEnable"); if proc == null() {dummy_vkCmdSetDepthTestEnable} else {unsafe {transmute(proc)}}},
			vk_cmd_set_depth_write_enable: {let proc = get_proc_address(instance, "vkCmdSetDepthWriteEnable"); if proc == null() {dummy_vkCmdSetDepthWriteEnable} else {unsafe {transmute(proc)}}},
			vk_cmd_set_depth_compare_op: {let proc = get_proc_address(instance, "vkCmdSetDepthCompareOp"); if proc == null() {dummy_vkCmdSetDepthCompareOp} else {unsafe {transmute(proc)}}},
			vk_cmd_set_depth_bounds_test_enable: {let proc = get_proc_address(instance, "vkCmdSetDepthBoundsTestEnable"); if proc == null() {dummy_vkCmdSetDepthBoundsTestEnable} else {unsafe {transmute(proc)}}},
			vk_cmd_set_stencil_test_enable: {let proc = get_proc_address(instance, "vkCmdSetStencilTestEnable"); if proc == null() {dummy_vkCmdSetStencilTestEnable} else {unsafe {transmute(proc)}}},
			vk_cmd_set_stencil_op: {let proc = get_proc_address(instance, "vkCmdSetStencilOp"); if proc == null() {dummy_vkCmdSetStencilOp} else {unsafe {transmute(proc)}}},
			vk_cmd_set_rasterizer_discard_enable: {let proc = get_proc_address(instance, "vkCmdSetRasterizerDiscardEnable"); if proc == null() {dummy_vkCmdSetRasterizerDiscardEnable} else {unsafe {transmute(proc)}}},
			vk_cmd_set_depth_bias_enable: {let proc = get_proc_address(instance, "vkCmdSetDepthBiasEnable"); if proc == null() {dummy_vkCmdSetDepthBiasEnable} else {unsafe {transmute(proc)}}},
			vk_cmd_set_primitive_restart_enable: {let proc = get_proc_address(instance, "vkCmdSetPrimitiveRestartEnable"); if proc == null() {dummy_vkCmdSetPrimitiveRestartEnable} else {unsafe {transmute(proc)}}},
			vk_get_device_buffer_memory_requirements: {let proc = get_proc_address(instance, "vkGetDeviceBufferMemoryRequirements"); if proc == null() {dummy_vkGetDeviceBufferMemoryRequirements} else {unsafe {transmute(proc)}}},
			vk_get_device_image_memory_requirements: {let proc = get_proc_address(instance, "vkGetDeviceImageMemoryRequirements"); if proc == null() {dummy_vkGetDeviceImageMemoryRequirements} else {unsafe {transmute(proc)}}},
			vk_get_device_image_sparse_memory_requirements: {let proc = get_proc_address(instance, "vkGetDeviceImageSparseMemoryRequirements"); if proc == null() {dummy_vkGetDeviceImageSparseMemoryRequirements} else {unsafe {transmute(proc)}}},
		}
	}
}
pub const VK_API_VERSION_1_4: u32 = 0x404000;
pub const VK_MAX_GLOBAL_PRIORITY_SIZE: u32 = 16u32;
pub type VkMemoryUnmapFlags = VkFlags;
pub type VkPipelineCreateFlags2 = VkFlags64;
pub type VkPipelineCreateFlagBits2 = VkFlags64;
pub type VkBufferUsageFlags2 = VkFlags64;
pub type VkBufferUsageFlagBits2 = VkFlags64;
pub type VkHostImageCopyFlags = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineRobustnessBufferBehavior {
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT = 0,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED = 1,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS = 2,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 = 3,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineRobustnessBufferBehavior {
	pub const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT: VkPipelineRobustnessBufferBehavior = VkPipelineRobustnessBufferBehavior::VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT;
	pub const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT: VkPipelineRobustnessBufferBehavior = VkPipelineRobustnessBufferBehavior::VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED;
	pub const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT: VkPipelineRobustnessBufferBehavior = VkPipelineRobustnessBufferBehavior::VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS;
	pub const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT: VkPipelineRobustnessBufferBehavior = VkPipelineRobustnessBufferBehavior::VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineRobustnessImageBehavior {
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT = 0,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED = 1,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS = 2,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2 = 3,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineRobustnessImageBehavior {
	pub const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT: VkPipelineRobustnessImageBehavior = VkPipelineRobustnessImageBehavior::VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT;
	pub const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT: VkPipelineRobustnessImageBehavior = VkPipelineRobustnessImageBehavior::VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED;
	pub const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT: VkPipelineRobustnessImageBehavior = VkPipelineRobustnessImageBehavior::VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS;
	pub const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT: VkPipelineRobustnessImageBehavior = VkPipelineRobustnessImageBehavior::VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueueGlobalPriority {
	VK_QUEUE_GLOBAL_PRIORITY_LOW = 128,
	VK_QUEUE_GLOBAL_PRIORITY_MEDIUM = 256,
	VK_QUEUE_GLOBAL_PRIORITY_HIGH = 512,
	VK_QUEUE_GLOBAL_PRIORITY_REALTIME = 1024,
	VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM = 0x7fffffff,
}
impl VkQueueGlobalPriority {
	pub const VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT: VkQueueGlobalPriority = VkQueueGlobalPriority::VK_QUEUE_GLOBAL_PRIORITY_LOW;
	pub const VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT: VkQueueGlobalPriority = VkQueueGlobalPriority::VK_QUEUE_GLOBAL_PRIORITY_MEDIUM;
	pub const VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT: VkQueueGlobalPriority = VkQueueGlobalPriority::VK_QUEUE_GLOBAL_PRIORITY_HIGH;
	pub const VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT: VkQueueGlobalPriority = VkQueueGlobalPriority::VK_QUEUE_GLOBAL_PRIORITY_REALTIME;
	pub const VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR: VkQueueGlobalPriority = VkQueueGlobalPriority::VK_QUEUE_GLOBAL_PRIORITY_LOW;
	pub const VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR: VkQueueGlobalPriority = VkQueueGlobalPriority::VK_QUEUE_GLOBAL_PRIORITY_MEDIUM;
	pub const VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR: VkQueueGlobalPriority = VkQueueGlobalPriority::VK_QUEUE_GLOBAL_PRIORITY_HIGH;
	pub const VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR: VkQueueGlobalPriority = VkQueueGlobalPriority::VK_QUEUE_GLOBAL_PRIORITY_REALTIME;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkLineRasterizationMode {
	VK_LINE_RASTERIZATION_MODE_DEFAULT = 0,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR = 1,
	VK_LINE_RASTERIZATION_MODE_BRESENHAM = 2,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH = 3,
	VK_LINE_RASTERIZATION_MODE_MAX_ENUM = 0x7fffffff,
}
impl VkLineRasterizationMode {
	pub const VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT: VkLineRasterizationMode = VkLineRasterizationMode::VK_LINE_RASTERIZATION_MODE_DEFAULT;
	pub const VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT: VkLineRasterizationMode = VkLineRasterizationMode::VK_LINE_RASTERIZATION_MODE_RECTANGULAR;
	pub const VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT: VkLineRasterizationMode = VkLineRasterizationMode::VK_LINE_RASTERIZATION_MODE_BRESENHAM;
	pub const VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT: VkLineRasterizationMode = VkLineRasterizationMode::VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH;
	pub const VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR: VkLineRasterizationMode = VkLineRasterizationMode::VK_LINE_RASTERIZATION_MODE_DEFAULT;
	pub const VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR: VkLineRasterizationMode = VkLineRasterizationMode::VK_LINE_RASTERIZATION_MODE_RECTANGULAR;
	pub const VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR: VkLineRasterizationMode = VkLineRasterizationMode::VK_LINE_RASTERIZATION_MODE_BRESENHAM;
	pub const VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR: VkLineRasterizationMode = VkLineRasterizationMode::VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkMemoryUnmapFlagBits {
	VK_MEMORY_UNMAP_RESERVE_BIT_EXT = 0x00000001,
	VK_MEMORY_UNMAP_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkHostImageCopyFlagBits {
	VK_HOST_IMAGE_COPY_MEMCPY_BIT = 0x00000001,
	VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkHostImageCopyFlagBits {
	pub const VK_HOST_IMAGE_COPY_MEMCPY: VkHostImageCopyFlagBits = VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY_BIT;
	pub const VK_HOST_IMAGE_COPY_MEMCPY_BIT_EXT: VkHostImageCopyFlagBits = VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY_BIT;
	pub const VK_HOST_IMAGE_COPY_MEMCPY_EXT: VkHostImageCopyFlagBits = VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY_BIT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVulkan14Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub globalPriorityQuery: VkBool32,
	pub shaderSubgroupRotate: VkBool32,
	pub shaderSubgroupRotateClustered: VkBool32,
	pub shaderFloatControls2: VkBool32,
	pub shaderExpectAssume: VkBool32,
	pub rectangularLines: VkBool32,
	pub bresenhamLines: VkBool32,
	pub smoothLines: VkBool32,
	pub stippledRectangularLines: VkBool32,
	pub stippledBresenhamLines: VkBool32,
	pub stippledSmoothLines: VkBool32,
	pub vertexAttributeInstanceRateDivisor: VkBool32,
	pub vertexAttributeInstanceRateZeroDivisor: VkBool32,
	pub indexTypeUint8: VkBool32,
	pub dynamicRenderingLocalRead: VkBool32,
	pub maintenance5: VkBool32,
	pub maintenance6: VkBool32,
	pub pipelineProtectedAccess: VkBool32,
	pub pipelineRobustness: VkBool32,
	pub hostImageCopy: VkBool32,
	pub pushDescriptor: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVulkan14Properties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub lineSubPixelPrecisionBits: u32,
	pub maxVertexAttribDivisor: u32,
	pub supportsNonZeroFirstInstance: VkBool32,
	pub maxPushDescriptors: u32,
	pub dynamicRenderingLocalReadDepthStencilAttachments: VkBool32,
	pub dynamicRenderingLocalReadMultisampledAttachments: VkBool32,
	pub earlyFragmentMultisampleCoverageAfterSampleCounting: VkBool32,
	pub earlyFragmentSampleMaskTestBeforeSampleCounting: VkBool32,
	pub depthStencilSwizzleOneSupport: VkBool32,
	pub polygonModePointSize: VkBool32,
	pub nonStrictSinglePixelWideLinesUseParallelogram: VkBool32,
	pub nonStrictWideLinesUseParallelogram: VkBool32,
	pub blockTexelViewCompatibleMultipleLayers: VkBool32,
	pub maxCombinedImageSamplerDescriptorCount: u32,
	pub fragmentShadingRateClampCombinerInputs: VkBool32,
	pub defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehavior,
	pub defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehavior,
	pub defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehavior,
	pub defaultRobustnessImages: VkPipelineRobustnessImageBehavior,
	pub copySrcLayoutCount: u32,
	pub pCopySrcLayouts: *mut VkImageLayout,
	pub copyDstLayoutCount: u32,
	pub pCopyDstLayouts: *mut VkImageLayout,
	pub optimalTilingLayoutUUID: [u8; VK_UUID_SIZE as usize],
	pub identicalMemoryTypeRequirements: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceQueueGlobalPriorityCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub globalPriority: VkQueueGlobalPriority,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceGlobalPriorityQueryFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub globalPriorityQuery: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkQueueFamilyGlobalPriorityProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub priorityCount: u32,
	pub priorities: [VkQueueGlobalPriority; VK_MAX_GLOBAL_PRIORITY_SIZE as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderSubgroupRotateFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderSubgroupRotate: VkBool32,
	pub shaderSubgroupRotateClustered: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderFloatControls2Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderFloatControls2: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderExpectAssumeFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderExpectAssume: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceLineRasterizationFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rectangularLines: VkBool32,
	pub bresenhamLines: VkBool32,
	pub smoothLines: VkBool32,
	pub stippledRectangularLines: VkBool32,
	pub stippledBresenhamLines: VkBool32,
	pub stippledSmoothLines: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceLineRasterizationProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub lineSubPixelPrecisionBits: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineRasterizationLineStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub lineRasterizationMode: VkLineRasterizationMode,
	pub stippledLineEnable: VkBool32,
	pub lineStippleFactor: u32,
	pub lineStipplePattern: u16,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVertexAttributeDivisorProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxVertexAttribDivisor: u32,
	pub supportsNonZeroFirstInstance: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVertexInputBindingDivisorDescription {
	pub binding: u32,
	pub divisor: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineVertexInputDivisorStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub vertexBindingDivisorCount: u32,
	pub pVertexBindingDivisors: *const VkVertexInputBindingDivisorDescription,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVertexAttributeDivisorFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub vertexAttributeInstanceRateDivisor: VkBool32,
	pub vertexAttributeInstanceRateZeroDivisor: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceIndexTypeUint8Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub indexTypeUint8: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryMapInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkMemoryMapFlags,
	pub memory: VkDeviceMemory,
	pub offset: VkDeviceSize,
	pub size: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryUnmapInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkMemoryUnmapFlags,
	pub memory: VkDeviceMemory,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance5Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maintenance5: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance5Properties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub earlyFragmentMultisampleCoverageAfterSampleCounting: VkBool32,
	pub earlyFragmentSampleMaskTestBeforeSampleCounting: VkBool32,
	pub depthStencilSwizzleOneSupport: VkBool32,
	pub polygonModePointSize: VkBool32,
	pub nonStrictSinglePixelWideLinesUseParallelogram: VkBool32,
	pub nonStrictWideLinesUseParallelogram: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderingAreaInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub viewMask: u32,
	pub colorAttachmentCount: u32,
	pub pColorAttachmentFormats: *const VkFormat,
	pub depthAttachmentFormat: VkFormat,
	pub stencilAttachmentFormat: VkFormat,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageSubresource2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageSubresource: VkImageSubresource,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceImageSubresourceInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pCreateInfo: *const VkImageCreateInfo,
	pub pSubresource: *const VkImageSubresource2,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSubresourceLayout2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub subresourceLayout: VkSubresourceLayout,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineCreateFlags2CreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCreateFlags2,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBufferUsageFlags2CreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub usage: VkBufferUsageFlags2,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePushDescriptorProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxPushDescriptors: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDynamicRenderingLocalReadFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub dynamicRenderingLocalRead: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderingAttachmentLocationInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub colorAttachmentCount: u32,
	pub pColorAttachmentLocations: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderingInputAttachmentIndexInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub colorAttachmentCount: u32,
	pub pColorAttachmentInputIndices: *const uint32_t,
	pub pDepthInputAttachmentIndex: *const uint32_t,
	pub pStencilInputAttachmentIndex: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance6Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maintenance6: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance6Properties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub blockTexelViewCompatibleMultipleLayers: VkBool32,
	pub maxCombinedImageSamplerDescriptorCount: u32,
	pub fragmentShadingRateClampCombinerInputs: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindMemoryStatus {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pResult: *mut VkResult,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindDescriptorSetsInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stageFlags: VkShaderStageFlags,
	pub layout: VkPipelineLayout,
	pub firstSet: u32,
	pub descriptorSetCount: u32,
	pub pDescriptorSets: *const VkDescriptorSet,
	pub dynamicOffsetCount: u32,
	pub pDynamicOffsets: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPushConstantsInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub layout: VkPipelineLayout,
	pub stageFlags: VkShaderStageFlags,
	pub offset: u32,
	pub size: u32,
	pub pValues: *const c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPushDescriptorSetInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stageFlags: VkShaderStageFlags,
	pub layout: VkPipelineLayout,
	pub set: u32,
	pub descriptorWriteCount: u32,
	pub pDescriptorWrites: *const VkWriteDescriptorSet,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPushDescriptorSetWithTemplateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
	pub layout: VkPipelineLayout,
	pub set: u32,
	pub pData: *const c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePipelineProtectedAccessFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineProtectedAccess: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePipelineRobustnessFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineRobustness: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePipelineRobustnessProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehavior,
	pub defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehavior,
	pub defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehavior,
	pub defaultRobustnessImages: VkPipelineRobustnessImageBehavior,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineRobustnessCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub storageBuffers: VkPipelineRobustnessBufferBehavior,
	pub uniformBuffers: VkPipelineRobustnessBufferBehavior,
	pub vertexInputs: VkPipelineRobustnessBufferBehavior,
	pub images: VkPipelineRobustnessImageBehavior,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceHostImageCopyFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub hostImageCopy: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceHostImageCopyProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub copySrcLayoutCount: u32,
	pub pCopySrcLayouts: *mut VkImageLayout,
	pub copyDstLayoutCount: u32,
	pub pCopyDstLayouts: *mut VkImageLayout,
	pub optimalTilingLayoutUUID: [u8; VK_UUID_SIZE as usize],
	pub identicalMemoryTypeRequirements: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryToImageCopy {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pHostPointer: *const c_void,
	pub memoryRowLength: u32,
	pub memoryImageHeight: u32,
	pub imageSubresource: VkImageSubresourceLayers,
	pub imageOffset: VkOffset3D,
	pub imageExtent: VkExtent3D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageToMemoryCopy {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pHostPointer: *mut c_void,
	pub memoryRowLength: u32,
	pub memoryImageHeight: u32,
	pub imageSubresource: VkImageSubresourceLayers,
	pub imageOffset: VkOffset3D,
	pub imageExtent: VkExtent3D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyMemoryToImageInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkHostImageCopyFlags,
	pub dstImage: VkImage,
	pub dstImageLayout: VkImageLayout,
	pub regionCount: u32,
	pub pRegions: *const VkMemoryToImageCopy,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyImageToMemoryInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkHostImageCopyFlags,
	pub srcImage: VkImage,
	pub srcImageLayout: VkImageLayout,
	pub regionCount: u32,
	pub pRegions: *const VkImageToMemoryCopy,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyImageToImageInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkHostImageCopyFlags,
	pub srcImage: VkImage,
	pub srcImageLayout: VkImageLayout,
	pub dstImage: VkImage,
	pub dstImageLayout: VkImageLayout,
	pub regionCount: u32,
	pub pRegions: *const VkImageCopy2,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkHostImageLayoutTransitionInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub image: VkImage,
	pub oldLayout: VkImageLayout,
	pub newLayout: VkImageLayout,
	pub subresourceRange: VkImageSubresourceRange,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSubresourceHostMemcpySize {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub size: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkHostImageCopyDevicePerformanceQuery {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub optimalDeviceAccess: VkBool32,
	pub identicalMemoryLayout: VkBool32,
}
type PFN_vkCmdSetLineStipple = extern "system" fn(commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16);
type PFN_vkMapMemory2 = extern "system" fn(device: VkDevice, pMemoryMapInfo: *const VkMemoryMapInfo, ppData: *mut *mut c_void) -> VkResult;
type PFN_vkUnmapMemory2 = extern "system" fn(device: VkDevice, pMemoryUnmapInfo: *const VkMemoryUnmapInfo) -> VkResult;
type PFN_vkCmdBindIndexBuffer2 = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType);
type PFN_vkGetRenderingAreaGranularity = extern "system" fn(device: VkDevice, pRenderingAreaInfo: *const VkRenderingAreaInfo, pGranularity: *mut VkExtent2D);
type PFN_vkGetDeviceImageSubresourceLayout = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceImageSubresourceInfo, pLayout: *mut VkSubresourceLayout2);
type PFN_vkGetImageSubresourceLayout2 = extern "system" fn(device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource2, pLayout: *mut VkSubresourceLayout2);
type PFN_vkCmdPushDescriptorSet = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet);
type PFN_vkCmdPushDescriptorSetWithTemplate = extern "system" fn(commandBuffer: VkCommandBuffer, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: u32, pData: *const c_void);
type PFN_vkCmdSetRenderingAttachmentLocations = extern "system" fn(commandBuffer: VkCommandBuffer, pLocationInfo: *const VkRenderingAttachmentLocationInfo);
type PFN_vkCmdSetRenderingInputAttachmentIndices = extern "system" fn(commandBuffer: VkCommandBuffer, pInputAttachmentIndexInfo: *const VkRenderingInputAttachmentIndexInfo);
type PFN_vkCmdBindDescriptorSets2 = extern "system" fn(commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo);
type PFN_vkCmdPushConstants2 = extern "system" fn(commandBuffer: VkCommandBuffer, pPushConstantsInfo: *const VkPushConstantsInfo);
type PFN_vkCmdPushDescriptorSet2 = extern "system" fn(commandBuffer: VkCommandBuffer, pPushDescriptorSetInfo: *const VkPushDescriptorSetInfo);
type PFN_vkCmdPushDescriptorSetWithTemplate2 = extern "system" fn(commandBuffer: VkCommandBuffer, pPushDescriptorSetWithTemplateInfo: *const VkPushDescriptorSetWithTemplateInfo);
type PFN_vkCopyMemoryToImage = extern "system" fn(device: VkDevice, pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo) -> VkResult;
type PFN_vkCopyImageToMemory = extern "system" fn(device: VkDevice, pCopyImageToMemoryInfo: *const VkCopyImageToMemoryInfo) -> VkResult;
type PFN_vkCopyImageToImage = extern "system" fn(device: VkDevice, pCopyImageToImageInfo: *const VkCopyImageToImageInfo) -> VkResult;
type PFN_vkTransitionImageLayout = extern "system" fn(device: VkDevice, transitionCount: u32, pTransitions: *const VkHostImageLayoutTransitionInfo) -> VkResult;
extern "system" fn dummy_vkCmdSetLineStipple(_: VkCommandBuffer, _: u32, _: u16) {
	panic!("Vulkan function pointer of `vkCmdSetLineStipple()` is NULL");
}
extern "system" fn dummy_vkMapMemory2(_: VkDevice, _: *const VkMemoryMapInfo, _: *mut *mut c_void) -> VkResult {
	panic!("Vulkan function pointer of `vkMapMemory2()` is NULL");
}
extern "system" fn dummy_vkUnmapMemory2(_: VkDevice, _: *const VkMemoryUnmapInfo) -> VkResult {
	panic!("Vulkan function pointer of `vkUnmapMemory2()` is NULL");
}
extern "system" fn dummy_vkCmdBindIndexBuffer2(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkDeviceSize, _: VkIndexType) {
	panic!("Vulkan function pointer of `vkCmdBindIndexBuffer2()` is NULL");
}
extern "system" fn dummy_vkGetRenderingAreaGranularity(_: VkDevice, _: *const VkRenderingAreaInfo, _: *mut VkExtent2D) {
	panic!("Vulkan function pointer of `vkGetRenderingAreaGranularity()` is NULL");
}
extern "system" fn dummy_vkGetDeviceImageSubresourceLayout(_: VkDevice, _: *const VkDeviceImageSubresourceInfo, _: *mut VkSubresourceLayout2) {
	panic!("Vulkan function pointer of `vkGetDeviceImageSubresourceLayout()` is NULL");
}
extern "system" fn dummy_vkGetImageSubresourceLayout2(_: VkDevice, _: VkImage, _: *const VkImageSubresource2, _: *mut VkSubresourceLayout2) {
	panic!("Vulkan function pointer of `vkGetImageSubresourceLayout2()` is NULL");
}
extern "system" fn dummy_vkCmdPushDescriptorSet(_: VkCommandBuffer, _: VkPipelineBindPoint, _: VkPipelineLayout, _: u32, _: u32, _: *const VkWriteDescriptorSet) {
	panic!("Vulkan function pointer of `vkCmdPushDescriptorSet()` is NULL");
}
extern "system" fn dummy_vkCmdPushDescriptorSetWithTemplate(_: VkCommandBuffer, _: VkDescriptorUpdateTemplate, _: VkPipelineLayout, _: u32, _: *const c_void) {
	panic!("Vulkan function pointer of `vkCmdPushDescriptorSetWithTemplate()` is NULL");
}
extern "system" fn dummy_vkCmdSetRenderingAttachmentLocations(_: VkCommandBuffer, _: *const VkRenderingAttachmentLocationInfo) {
	panic!("Vulkan function pointer of `vkCmdSetRenderingAttachmentLocations()` is NULL");
}
extern "system" fn dummy_vkCmdSetRenderingInputAttachmentIndices(_: VkCommandBuffer, _: *const VkRenderingInputAttachmentIndexInfo) {
	panic!("Vulkan function pointer of `vkCmdSetRenderingInputAttachmentIndices()` is NULL");
}
extern "system" fn dummy_vkCmdBindDescriptorSets2(_: VkCommandBuffer, _: *const VkBindDescriptorSetsInfo) {
	panic!("Vulkan function pointer of `vkCmdBindDescriptorSets2()` is NULL");
}
extern "system" fn dummy_vkCmdPushConstants2(_: VkCommandBuffer, _: *const VkPushConstantsInfo) {
	panic!("Vulkan function pointer of `vkCmdPushConstants2()` is NULL");
}
extern "system" fn dummy_vkCmdPushDescriptorSet2(_: VkCommandBuffer, _: *const VkPushDescriptorSetInfo) {
	panic!("Vulkan function pointer of `vkCmdPushDescriptorSet2()` is NULL");
}
extern "system" fn dummy_vkCmdPushDescriptorSetWithTemplate2(_: VkCommandBuffer, _: *const VkPushDescriptorSetWithTemplateInfo) {
	panic!("Vulkan function pointer of `vkCmdPushDescriptorSetWithTemplate2()` is NULL");
}
extern "system" fn dummy_vkCopyMemoryToImage(_: VkDevice, _: *const VkCopyMemoryToImageInfo) -> VkResult {
	panic!("Vulkan function pointer of `vkCopyMemoryToImage()` is NULL");
}
extern "system" fn dummy_vkCopyImageToMemory(_: VkDevice, _: *const VkCopyImageToMemoryInfo) -> VkResult {
	panic!("Vulkan function pointer of `vkCopyImageToMemory()` is NULL");
}
extern "system" fn dummy_vkCopyImageToImage(_: VkDevice, _: *const VkCopyImageToImageInfo) -> VkResult {
	panic!("Vulkan function pointer of `vkCopyImageToImage()` is NULL");
}
extern "system" fn dummy_vkTransitionImageLayout(_: VkDevice, _: u32, _: *const VkHostImageLayoutTransitionInfo) -> VkResult {
	panic!("Vulkan function pointer of `vkTransitionImageLayout()` is NULL");
}
pub trait VK_VERSION_1_4: Debug {
	fn vkCmdSetLineStipple(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16);
	fn vkMapMemory2(&self, device: VkDevice, pMemoryMapInfo: *const VkMemoryMapInfo, ppData: *mut *mut c_void) -> VkResult;
	fn vkUnmapMemory2(&self, device: VkDevice, pMemoryUnmapInfo: *const VkMemoryUnmapInfo) -> VkResult;
	fn vkCmdBindIndexBuffer2(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType);
	fn vkGetRenderingAreaGranularity(&self, device: VkDevice, pRenderingAreaInfo: *const VkRenderingAreaInfo, pGranularity: *mut VkExtent2D);
	fn vkGetDeviceImageSubresourceLayout(&self, device: VkDevice, pInfo: *const VkDeviceImageSubresourceInfo, pLayout: *mut VkSubresourceLayout2);
	fn vkGetImageSubresourceLayout2(&self, device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource2, pLayout: *mut VkSubresourceLayout2);
	fn vkCmdPushDescriptorSet(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet);
	fn vkCmdPushDescriptorSetWithTemplate(&self, commandBuffer: VkCommandBuffer, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: u32, pData: *const c_void);
	fn vkCmdSetRenderingAttachmentLocations(&self, commandBuffer: VkCommandBuffer, pLocationInfo: *const VkRenderingAttachmentLocationInfo);
	fn vkCmdSetRenderingInputAttachmentIndices(&self, commandBuffer: VkCommandBuffer, pInputAttachmentIndexInfo: *const VkRenderingInputAttachmentIndexInfo);
	fn vkCmdBindDescriptorSets2(&self, commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo);
	fn vkCmdPushConstants2(&self, commandBuffer: VkCommandBuffer, pPushConstantsInfo: *const VkPushConstantsInfo);
	fn vkCmdPushDescriptorSet2(&self, commandBuffer: VkCommandBuffer, pPushDescriptorSetInfo: *const VkPushDescriptorSetInfo);
	fn vkCmdPushDescriptorSetWithTemplate2(&self, commandBuffer: VkCommandBuffer, pPushDescriptorSetWithTemplateInfo: *const VkPushDescriptorSetWithTemplateInfo);
	fn vkCopyMemoryToImage(&self, device: VkDevice, pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo) -> VkResult;
	fn vkCopyImageToMemory(&self, device: VkDevice, pCopyImageToMemoryInfo: *const VkCopyImageToMemoryInfo) -> VkResult;
	fn vkCopyImageToImage(&self, device: VkDevice, pCopyImageToImageInfo: *const VkCopyImageToImageInfo) -> VkResult;
	fn vkTransitionImageLayout(&self, device: VkDevice, transitionCount: u32, pTransitions: *const VkHostImageLayoutTransitionInfo) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_VERSION_1_4 {
	vk_cmd_set_line_stipple: PFN_vkCmdSetLineStipple,
	vk_map_memory2: PFN_vkMapMemory2,
	vk_unmap_memory2: PFN_vkUnmapMemory2,
	vk_cmd_bind_index_buffer2: PFN_vkCmdBindIndexBuffer2,
	vk_get_rendering_area_granularity: PFN_vkGetRenderingAreaGranularity,
	vk_get_device_image_subresource_layout: PFN_vkGetDeviceImageSubresourceLayout,
	vk_get_image_subresource_layout2: PFN_vkGetImageSubresourceLayout2,
	vk_cmd_push_descriptor_set: PFN_vkCmdPushDescriptorSet,
	vk_cmd_push_descriptor_set_with_template: PFN_vkCmdPushDescriptorSetWithTemplate,
	vk_cmd_set_rendering_attachment_locations: PFN_vkCmdSetRenderingAttachmentLocations,
	vk_cmd_set_rendering_input_attachment_indices: PFN_vkCmdSetRenderingInputAttachmentIndices,
	vk_cmd_bind_descriptor_sets2: PFN_vkCmdBindDescriptorSets2,
	vk_cmd_push_constants2: PFN_vkCmdPushConstants2,
	vk_cmd_push_descriptor_set2: PFN_vkCmdPushDescriptorSet2,
	vk_cmd_push_descriptor_set_with_template2: PFN_vkCmdPushDescriptorSetWithTemplate2,
	vk_copy_memory_to_image: PFN_vkCopyMemoryToImage,
	vk_copy_image_to_memory: PFN_vkCopyImageToMemory,
	vk_copy_image_to_image: PFN_vkCopyImageToImage,
	vk_transition_image_layout: PFN_vkTransitionImageLayout,
}
impl VK_VERSION_1_4 for Vulkan_VERSION_1_4 {
	fn vkCmdSetLineStipple(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) {
		(self.vk_cmd_set_line_stipple)(commandBuffer, lineStippleFactor, lineStipplePattern)
	}
	fn vkMapMemory2(&self, device: VkDevice, pMemoryMapInfo: *const VkMemoryMapInfo, ppData: *mut *mut c_void) -> VkResult {
		(self.vk_map_memory2)(device, pMemoryMapInfo, ppData)
	}
	fn vkUnmapMemory2(&self, device: VkDevice, pMemoryUnmapInfo: *const VkMemoryUnmapInfo) -> VkResult {
		(self.vk_unmap_memory2)(device, pMemoryUnmapInfo)
	}
	fn vkCmdBindIndexBuffer2(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType) {
		(self.vk_cmd_bind_index_buffer2)(commandBuffer, buffer, offset, size, indexType)
	}
	fn vkGetRenderingAreaGranularity(&self, device: VkDevice, pRenderingAreaInfo: *const VkRenderingAreaInfo, pGranularity: *mut VkExtent2D) {
		(self.vk_get_rendering_area_granularity)(device, pRenderingAreaInfo, pGranularity)
	}
	fn vkGetDeviceImageSubresourceLayout(&self, device: VkDevice, pInfo: *const VkDeviceImageSubresourceInfo, pLayout: *mut VkSubresourceLayout2) {
		(self.vk_get_device_image_subresource_layout)(device, pInfo, pLayout)
	}
	fn vkGetImageSubresourceLayout2(&self, device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource2, pLayout: *mut VkSubresourceLayout2) {
		(self.vk_get_image_subresource_layout2)(device, image, pSubresource, pLayout)
	}
	fn vkCmdPushDescriptorSet(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet) {
		(self.vk_cmd_push_descriptor_set)(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites)
	}
	fn vkCmdPushDescriptorSetWithTemplate(&self, commandBuffer: VkCommandBuffer, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: u32, pData: *const c_void) {
		(self.vk_cmd_push_descriptor_set_with_template)(commandBuffer, descriptorUpdateTemplate, layout, set, pData)
	}
	fn vkCmdSetRenderingAttachmentLocations(&self, commandBuffer: VkCommandBuffer, pLocationInfo: *const VkRenderingAttachmentLocationInfo) {
		(self.vk_cmd_set_rendering_attachment_locations)(commandBuffer, pLocationInfo)
	}
	fn vkCmdSetRenderingInputAttachmentIndices(&self, commandBuffer: VkCommandBuffer, pInputAttachmentIndexInfo: *const VkRenderingInputAttachmentIndexInfo) {
		(self.vk_cmd_set_rendering_input_attachment_indices)(commandBuffer, pInputAttachmentIndexInfo)
	}
	fn vkCmdBindDescriptorSets2(&self, commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo) {
		(self.vk_cmd_bind_descriptor_sets2)(commandBuffer, pBindDescriptorSetsInfo)
	}
	fn vkCmdPushConstants2(&self, commandBuffer: VkCommandBuffer, pPushConstantsInfo: *const VkPushConstantsInfo) {
		(self.vk_cmd_push_constants2)(commandBuffer, pPushConstantsInfo)
	}
	fn vkCmdPushDescriptorSet2(&self, commandBuffer: VkCommandBuffer, pPushDescriptorSetInfo: *const VkPushDescriptorSetInfo) {
		(self.vk_cmd_push_descriptor_set2)(commandBuffer, pPushDescriptorSetInfo)
	}
	fn vkCmdPushDescriptorSetWithTemplate2(&self, commandBuffer: VkCommandBuffer, pPushDescriptorSetWithTemplateInfo: *const VkPushDescriptorSetWithTemplateInfo) {
		(self.vk_cmd_push_descriptor_set_with_template2)(commandBuffer, pPushDescriptorSetWithTemplateInfo)
	}
	fn vkCopyMemoryToImage(&self, device: VkDevice, pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo) -> VkResult {
		(self.vk_copy_memory_to_image)(device, pCopyMemoryToImageInfo)
	}
	fn vkCopyImageToMemory(&self, device: VkDevice, pCopyImageToMemoryInfo: *const VkCopyImageToMemoryInfo) -> VkResult {
		(self.vk_copy_image_to_memory)(device, pCopyImageToMemoryInfo)
	}
	fn vkCopyImageToImage(&self, device: VkDevice, pCopyImageToImageInfo: *const VkCopyImageToImageInfo) -> VkResult {
		(self.vk_copy_image_to_image)(device, pCopyImageToImageInfo)
	}
	fn vkTransitionImageLayout(&self, device: VkDevice, transitionCount: u32, pTransitions: *const VkHostImageLayoutTransitionInfo) -> VkResult {
		(self.vk_transition_image_layout)(device, transitionCount, pTransitions)
	}
}
impl Default for Vulkan_VERSION_1_4 {
	fn default() -> Self {
		Self {
			vk_cmd_set_line_stipple: dummy_vkCmdSetLineStipple,
			vk_map_memory2: dummy_vkMapMemory2,
			vk_unmap_memory2: dummy_vkUnmapMemory2,
			vk_cmd_bind_index_buffer2: dummy_vkCmdBindIndexBuffer2,
			vk_get_rendering_area_granularity: dummy_vkGetRenderingAreaGranularity,
			vk_get_device_image_subresource_layout: dummy_vkGetDeviceImageSubresourceLayout,
			vk_get_image_subresource_layout2: dummy_vkGetImageSubresourceLayout2,
			vk_cmd_push_descriptor_set: dummy_vkCmdPushDescriptorSet,
			vk_cmd_push_descriptor_set_with_template: dummy_vkCmdPushDescriptorSetWithTemplate,
			vk_cmd_set_rendering_attachment_locations: dummy_vkCmdSetRenderingAttachmentLocations,
			vk_cmd_set_rendering_input_attachment_indices: dummy_vkCmdSetRenderingInputAttachmentIndices,
			vk_cmd_bind_descriptor_sets2: dummy_vkCmdBindDescriptorSets2,
			vk_cmd_push_constants2: dummy_vkCmdPushConstants2,
			vk_cmd_push_descriptor_set2: dummy_vkCmdPushDescriptorSet2,
			vk_cmd_push_descriptor_set_with_template2: dummy_vkCmdPushDescriptorSetWithTemplate2,
			vk_copy_memory_to_image: dummy_vkCopyMemoryToImage,
			vk_copy_image_to_memory: dummy_vkCopyImageToMemory,
			vk_copy_image_to_image: dummy_vkCopyImageToImage,
			vk_transition_image_layout: dummy_vkTransitionImageLayout,
		}
	}
}
impl Vulkan_VERSION_1_4 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_line_stipple: {let proc = get_proc_address(instance, "vkCmdSetLineStipple"); if proc == null() {dummy_vkCmdSetLineStipple} else {unsafe {transmute(proc)}}},
			vk_map_memory2: {let proc = get_proc_address(instance, "vkMapMemory2"); if proc == null() {dummy_vkMapMemory2} else {unsafe {transmute(proc)}}},
			vk_unmap_memory2: {let proc = get_proc_address(instance, "vkUnmapMemory2"); if proc == null() {dummy_vkUnmapMemory2} else {unsafe {transmute(proc)}}},
			vk_cmd_bind_index_buffer2: {let proc = get_proc_address(instance, "vkCmdBindIndexBuffer2"); if proc == null() {dummy_vkCmdBindIndexBuffer2} else {unsafe {transmute(proc)}}},
			vk_get_rendering_area_granularity: {let proc = get_proc_address(instance, "vkGetRenderingAreaGranularity"); if proc == null() {dummy_vkGetRenderingAreaGranularity} else {unsafe {transmute(proc)}}},
			vk_get_device_image_subresource_layout: {let proc = get_proc_address(instance, "vkGetDeviceImageSubresourceLayout"); if proc == null() {dummy_vkGetDeviceImageSubresourceLayout} else {unsafe {transmute(proc)}}},
			vk_get_image_subresource_layout2: {let proc = get_proc_address(instance, "vkGetImageSubresourceLayout2"); if proc == null() {dummy_vkGetImageSubresourceLayout2} else {unsafe {transmute(proc)}}},
			vk_cmd_push_descriptor_set: {let proc = get_proc_address(instance, "vkCmdPushDescriptorSet"); if proc == null() {dummy_vkCmdPushDescriptorSet} else {unsafe {transmute(proc)}}},
			vk_cmd_push_descriptor_set_with_template: {let proc = get_proc_address(instance, "vkCmdPushDescriptorSetWithTemplate"); if proc == null() {dummy_vkCmdPushDescriptorSetWithTemplate} else {unsafe {transmute(proc)}}},
			vk_cmd_set_rendering_attachment_locations: {let proc = get_proc_address(instance, "vkCmdSetRenderingAttachmentLocations"); if proc == null() {dummy_vkCmdSetRenderingAttachmentLocations} else {unsafe {transmute(proc)}}},
			vk_cmd_set_rendering_input_attachment_indices: {let proc = get_proc_address(instance, "vkCmdSetRenderingInputAttachmentIndices"); if proc == null() {dummy_vkCmdSetRenderingInputAttachmentIndices} else {unsafe {transmute(proc)}}},
			vk_cmd_bind_descriptor_sets2: {let proc = get_proc_address(instance, "vkCmdBindDescriptorSets2"); if proc == null() {dummy_vkCmdBindDescriptorSets2} else {unsafe {transmute(proc)}}},
			vk_cmd_push_constants2: {let proc = get_proc_address(instance, "vkCmdPushConstants2"); if proc == null() {dummy_vkCmdPushConstants2} else {unsafe {transmute(proc)}}},
			vk_cmd_push_descriptor_set2: {let proc = get_proc_address(instance, "vkCmdPushDescriptorSet2"); if proc == null() {dummy_vkCmdPushDescriptorSet2} else {unsafe {transmute(proc)}}},
			vk_cmd_push_descriptor_set_with_template2: {let proc = get_proc_address(instance, "vkCmdPushDescriptorSetWithTemplate2"); if proc == null() {dummy_vkCmdPushDescriptorSetWithTemplate2} else {unsafe {transmute(proc)}}},
			vk_copy_memory_to_image: {let proc = get_proc_address(instance, "vkCopyMemoryToImage"); if proc == null() {dummy_vkCopyMemoryToImage} else {unsafe {transmute(proc)}}},
			vk_copy_image_to_memory: {let proc = get_proc_address(instance, "vkCopyImageToMemory"); if proc == null() {dummy_vkCopyImageToMemory} else {unsafe {transmute(proc)}}},
			vk_copy_image_to_image: {let proc = get_proc_address(instance, "vkCopyImageToImage"); if proc == null() {dummy_vkCopyImageToImage} else {unsafe {transmute(proc)}}},
			vk_transition_image_layout: {let proc = get_proc_address(instance, "vkTransitionImageLayout"); if proc == null() {dummy_vkTransitionImageLayout} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkCompositeAlphaFlagsKHR = VkFlags;
pub type VkSurfaceTransformFlagsKHR = VkFlags;
// Define non-dispatchable handle `VkSurfaceKHR`
#[cfg(target_pointer_width = "32")] pub type VkSurfaceKHR = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkSurfaceKHR_T {}
#[cfg(target_pointer_width = "64")] pub type VkSurfaceKHR = *const VkSurfaceKHR_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPresentModeKHR {
	VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
	VK_PRESENT_MODE_MAILBOX_KHR = 1,
	VK_PRESENT_MODE_FIFO_KHR = 2,
	VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
	VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
	VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
	VK_PRESENT_MODE_FIFO_LATEST_READY_KHR = 1000361000,
	VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkPresentModeKHR {
	pub const VK_PRESENT_MODE_FIFO_LATEST_READY_EXT: VkPresentModeKHR = VkPresentModeKHR::VK_PRESENT_MODE_FIFO_LATEST_READY_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkColorSpaceKHR {
	VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
	VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
	VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
	VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003,
	VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
	VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
	VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
	VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
	VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
	VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
	VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
	VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
	VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
	VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
	VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
	VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000,
	VK_COLOR_SPACE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkColorSpaceKHR {
	pub const VK_COLORSPACE_SRGB_NONLINEAR_KHR: VkColorSpaceKHR = VkColorSpaceKHR::VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
	pub const VK_COLOR_SPACE_DCI_P3_LINEAR_EXT: VkColorSpaceKHR = VkColorSpaceKHR::VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSurfaceTransformFlagBitsKHR {
	VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001,
	VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002,
	VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004,
	VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
	VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100,
	VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCompositeAlphaFlagBitsKHR {
	VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
	VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x00000002,
	VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
	VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x00000008,
	VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSurfaceCapabilitiesKHR {
	pub minImageCount: u32,
	pub maxImageCount: u32,
	pub currentExtent: VkExtent2D,
	pub minImageExtent: VkExtent2D,
	pub maxImageExtent: VkExtent2D,
	pub maxImageArrayLayers: u32,
	pub supportedTransforms: VkSurfaceTransformFlagsKHR,
	pub currentTransform: VkSurfaceTransformFlagBitsKHR,
	pub supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
	pub supportedUsageFlags: VkImageUsageFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSurfaceFormatKHR {
	pub format: VkFormat,
	pub colorSpace: VkColorSpaceKHR,
}
type PFN_vkDestroySurfaceKHR = extern "system" fn(instance: VkInstance, surface: VkSurfaceKHR, pAllocator: *const VkAllocationCallbacks);
type PFN_vkGetPhysicalDeviceSurfaceSupportKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, surface: VkSurfaceKHR, pSupported: *mut VkBool32) -> VkResult;
type PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *mut VkSurfaceCapabilitiesKHR) -> VkResult;
type PFN_vkGetPhysicalDeviceSurfaceFormatsKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceFormatCount: *mut uint32_t, pSurfaceFormats: *mut VkSurfaceFormatKHR) -> VkResult;
type PFN_vkGetPhysicalDeviceSurfacePresentModesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pPresentModeCount: *mut uint32_t, pPresentModes: *mut VkPresentModeKHR) -> VkResult;
extern "system" fn dummy_vkDestroySurfaceKHR(_: VkInstance, _: VkSurfaceKHR, _: *const VkAllocationCallbacks) {
	panic!("Vulkan function pointer of `vkDestroySurfaceKHR()` is NULL");
}
pub trait VK_KHR_surface: Debug {
	fn vkDestroySurfaceKHR(&self, instance: VkInstance, surface: VkSurfaceKHR, pAllocator: *const VkAllocationCallbacks);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_surface {
	vk_destroy_surface_khr: PFN_vkDestroySurfaceKHR,
}
impl VK_KHR_surface for Vulkan_KHR_surface {
	fn vkDestroySurfaceKHR(&self, instance: VkInstance, surface: VkSurfaceKHR, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_destroy_surface_khr)(instance, surface, pAllocator)
	}
}
impl Default for Vulkan_KHR_surface {
	fn default() -> Self {
		Self {
			vk_destroy_surface_khr: dummy_vkDestroySurfaceKHR,
		}
	}
}
impl Vulkan_KHR_surface {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_destroy_surface_khr: {let proc = get_proc_address(instance, "vkDestroySurfaceKHR"); if proc == null() {dummy_vkDestroySurfaceKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkSwapchainCreateFlagsKHR = VkFlags;
pub type VkDeviceGroupPresentModeFlagsKHR = VkFlags;
// Define non-dispatchable handle `VkSwapchainKHR`
#[cfg(target_pointer_width = "32")] pub type VkSwapchainKHR = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkSwapchainKHR_T {}
#[cfg(target_pointer_width = "64")] pub type VkSwapchainKHR = *const VkSwapchainKHR_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSwapchainCreateFlagBitsKHR {
	VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 0x00000001,
	VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 0x00000002,
	VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = 0x00000004,
	VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR = 0x00000040,
	VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR = 0x00000080,
	VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR = 0x00000008,
	VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkSwapchainCreateFlagBitsKHR {
	pub const VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT: VkSwapchainCreateFlagBitsKHR = VkSwapchainCreateFlagBitsKHR::VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceGroupPresentModeFlagBitsKHR {
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 0x00000001,
	VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 0x00000002,
	VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 0x00000004,
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 0x00000008,
	VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSwapchainCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkSwapchainCreateFlagsKHR,
	pub surface: VkSurfaceKHR,
	pub minImageCount: u32,
	pub imageFormat: VkFormat,
	pub imageColorSpace: VkColorSpaceKHR,
	pub imageExtent: VkExtent2D,
	pub imageArrayLayers: u32,
	pub imageUsage: VkImageUsageFlags,
	pub imageSharingMode: VkSharingMode,
	pub queueFamilyIndexCount: u32,
	pub pQueueFamilyIndices: *const uint32_t,
	pub preTransform: VkSurfaceTransformFlagBitsKHR,
	pub compositeAlpha: VkCompositeAlphaFlagBitsKHR,
	pub presentMode: VkPresentModeKHR,
	pub clipped: VkBool32,
	pub oldSwapchain: VkSwapchainKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPresentInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub waitSemaphoreCount: u32,
	pub pWaitSemaphores: *const VkSemaphore,
	pub swapchainCount: u32,
	pub pSwapchains: *const VkSwapchainKHR,
	pub pImageIndices: *const uint32_t,
	pub pResults: *mut VkResult,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageSwapchainCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchain: VkSwapchainKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindImageMemorySwapchainInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchain: VkSwapchainKHR,
	pub imageIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAcquireNextImageInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchain: VkSwapchainKHR,
	pub timeout: u64,
	pub semaphore: VkSemaphore,
	pub fence: VkFence,
	pub deviceMask: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceGroupPresentCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentMask: [u32; VK_MAX_DEVICE_GROUP_SIZE as usize],
	pub modes: VkDeviceGroupPresentModeFlagsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceGroupPresentInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount: u32,
	pub pDeviceMasks: *const uint32_t,
	pub mode: VkDeviceGroupPresentModeFlagBitsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceGroupSwapchainCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub modes: VkDeviceGroupPresentModeFlagsKHR,
}
type PFN_vkCreateSwapchainKHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchain: *mut VkSwapchainKHR) -> VkResult;
type PFN_vkDestroySwapchainKHR = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pAllocator: *const VkAllocationCallbacks);
type PFN_vkGetSwapchainImagesKHR = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pSwapchainImageCount: *mut uint32_t, pSwapchainImages: *mut VkImage) -> VkResult;
type PFN_vkAcquireNextImageKHR = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, timeout: u64, semaphore: VkSemaphore, fence: VkFence, pImageIndex: *mut uint32_t) -> VkResult;
type PFN_vkQueuePresentKHR = extern "system" fn(queue: VkQueue, pPresentInfo: *const VkPresentInfoKHR) -> VkResult;
type PFN_vkGetDeviceGroupPresentCapabilitiesKHR = extern "system" fn(device: VkDevice, pDeviceGroupPresentCapabilities: *mut VkDeviceGroupPresentCapabilitiesKHR) -> VkResult;
type PFN_vkGetDeviceGroupSurfacePresentModesKHR = extern "system" fn(device: VkDevice, surface: VkSurfaceKHR, pModes: *mut VkDeviceGroupPresentModeFlagsKHR) -> VkResult;
type PFN_vkGetPhysicalDevicePresentRectanglesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pRectCount: *mut uint32_t, pRects: *mut VkRect2D) -> VkResult;
type PFN_vkAcquireNextImage2KHR = extern "system" fn(device: VkDevice, pAcquireInfo: *const VkAcquireNextImageInfoKHR, pImageIndex: *mut uint32_t) -> VkResult;
extern "system" fn dummy_vkCreateSwapchainKHR(_: VkDevice, _: *const VkSwapchainCreateInfoKHR, _: *const VkAllocationCallbacks, _: *mut VkSwapchainKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateSwapchainKHR()` is NULL");
}
pub trait VK_KHR_swapchain: Debug {
	fn vkCreateSwapchainKHR(&self, device: VkDevice, pCreateInfo: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchain: *mut VkSwapchainKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_swapchain {
	vk_create_swapchain_khr: PFN_vkCreateSwapchainKHR,
}
impl VK_KHR_swapchain for Vulkan_KHR_swapchain {
	fn vkCreateSwapchainKHR(&self, device: VkDevice, pCreateInfo: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchain: *mut VkSwapchainKHR) -> VkResult {
		(self.vk_create_swapchain_khr)(device, pCreateInfo, pAllocator, pSwapchain)
	}
}
impl Default for Vulkan_KHR_swapchain {
	fn default() -> Self {
		Self {
			vk_create_swapchain_khr: dummy_vkCreateSwapchainKHR,
		}
	}
}
impl Vulkan_KHR_swapchain {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_swapchain_khr: {let proc = get_proc_address(instance, "vkCreateSwapchainKHR"); if proc == null() {dummy_vkCreateSwapchainKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkDisplayModeCreateFlagsKHR = VkFlags;
pub type VkDisplayPlaneAlphaFlagsKHR = VkFlags;
pub type VkDisplaySurfaceCreateFlagsKHR = VkFlags;
// Define non-dispatchable handle `VkDisplayKHR`
#[cfg(target_pointer_width = "32")] pub type VkDisplayKHR = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkDisplayKHR_T {}
#[cfg(target_pointer_width = "64")] pub type VkDisplayKHR = *const VkDisplayKHR_T;
// Define non-dispatchable handle `VkDisplayModeKHR`
#[cfg(target_pointer_width = "32")] pub type VkDisplayModeKHR = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkDisplayModeKHR_T {}
#[cfg(target_pointer_width = "64")] pub type VkDisplayModeKHR = *const VkDisplayModeKHR_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDisplayPlaneAlphaFlagBitsKHR {
	VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
	VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002,
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004,
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
	VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplayModeParametersKHR {
	pub visibleRegion: VkExtent2D,
	pub refreshRate: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplayModeCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDisplayModeCreateFlagsKHR,
	pub parameters: VkDisplayModeParametersKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplayModePropertiesKHR {
	pub displayMode: VkDisplayModeKHR,
	pub parameters: VkDisplayModeParametersKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplayPlaneCapabilitiesKHR {
	pub supportedAlpha: VkDisplayPlaneAlphaFlagsKHR,
	pub minSrcPosition: VkOffset2D,
	pub maxSrcPosition: VkOffset2D,
	pub minSrcExtent: VkExtent2D,
	pub maxSrcExtent: VkExtent2D,
	pub minDstPosition: VkOffset2D,
	pub maxDstPosition: VkOffset2D,
	pub minDstExtent: VkExtent2D,
	pub maxDstExtent: VkExtent2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplayPlanePropertiesKHR {
	pub currentDisplay: VkDisplayKHR,
	pub currentStackIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplayPropertiesKHR {
	pub display: VkDisplayKHR,
	pub displayName: *const i8,
	pub physicalDimensions: VkExtent2D,
	pub physicalResolution: VkExtent2D,
	pub supportedTransforms: VkSurfaceTransformFlagsKHR,
	pub planeReorderPossible: VkBool32,
	pub persistentContent: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplaySurfaceCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDisplaySurfaceCreateFlagsKHR,
	pub displayMode: VkDisplayModeKHR,
	pub planeIndex: u32,
	pub planeStackIndex: u32,
	pub transform: VkSurfaceTransformFlagBitsKHR,
	pub globalAlpha: f32,
	pub alphaMode: VkDisplayPlaneAlphaFlagBitsKHR,
	pub imageExtent: VkExtent2D,
}
type PFN_vkGetPhysicalDeviceDisplayPropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayPropertiesKHR) -> VkResult;
type PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayPlanePropertiesKHR) -> VkResult;
type PFN_vkGetDisplayPlaneSupportedDisplaysKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, planeIndex: u32, pDisplayCount: *mut uint32_t, pDisplays: *mut VkDisplayKHR) -> VkResult;
type PFN_vkGetDisplayModePropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayModePropertiesKHR) -> VkResult;
type PFN_vkCreateDisplayModeKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pCreateInfo: *const VkDisplayModeCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pMode: *mut VkDisplayModeKHR) -> VkResult;
type PFN_vkGetDisplayPlaneCapabilitiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, mode: VkDisplayModeKHR, planeIndex: u32, pCapabilities: *mut VkDisplayPlaneCapabilitiesKHR) -> VkResult;
type PFN_vkCreateDisplayPlaneSurfaceKHR = extern "system" fn(instance: VkInstance, pCreateInfo: *const VkDisplaySurfaceCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR) -> VkResult;
extern "system" fn dummy_vkGetPhysicalDeviceDisplayPropertiesKHR(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkDisplayPropertiesKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceDisplayPropertiesKHR()` is NULL");
}
pub trait VK_KHR_display: Debug {
	fn vkGetPhysicalDeviceDisplayPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayPropertiesKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_display {
	vk_get_physical_device_display_properties_khr: PFN_vkGetPhysicalDeviceDisplayPropertiesKHR,
}
impl VK_KHR_display for Vulkan_KHR_display {
	fn vkGetPhysicalDeviceDisplayPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayPropertiesKHR) -> VkResult {
		(self.vk_get_physical_device_display_properties_khr)(physicalDevice, pPropertyCount, pProperties)
	}
}
impl Default for Vulkan_KHR_display {
	fn default() -> Self {
		Self {
			vk_get_physical_device_display_properties_khr: dummy_vkGetPhysicalDeviceDisplayPropertiesKHR,
		}
	}
}
impl Vulkan_KHR_display {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_display_properties_khr: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceDisplayPropertiesKHR"); if proc == null() {dummy_vkGetPhysicalDeviceDisplayPropertiesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplayPresentInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcRect: VkRect2D,
	pub dstRect: VkRect2D,
	pub persistent: VkBool32,
}
type PFN_vkCreateSharedSwapchainsKHR = extern "system" fn(device: VkDevice, swapchainCount: u32, pCreateInfos: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchains: *mut VkSwapchainKHR) -> VkResult;
extern "system" fn dummy_vkCreateSharedSwapchainsKHR(_: VkDevice, _: u32, _: *const VkSwapchainCreateInfoKHR, _: *const VkAllocationCallbacks, _: *mut VkSwapchainKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateSharedSwapchainsKHR()` is NULL");
}
pub trait VK_KHR_display_swapchain: Debug {
	fn vkCreateSharedSwapchainsKHR(&self, device: VkDevice, swapchainCount: u32, pCreateInfos: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchains: *mut VkSwapchainKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_display_swapchain {
	vk_create_shared_swapchains_khr: PFN_vkCreateSharedSwapchainsKHR,
}
impl VK_KHR_display_swapchain for Vulkan_KHR_display_swapchain {
	fn vkCreateSharedSwapchainsKHR(&self, device: VkDevice, swapchainCount: u32, pCreateInfos: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchains: *mut VkSwapchainKHR) -> VkResult {
		(self.vk_create_shared_swapchains_khr)(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains)
	}
}
impl Default for Vulkan_KHR_display_swapchain {
	fn default() -> Self {
		Self {
			vk_create_shared_swapchains_khr: dummy_vkCreateSharedSwapchainsKHR,
		}
	}
}
impl Vulkan_KHR_display_swapchain {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_shared_swapchains_khr: {let proc = get_proc_address(instance, "vkCreateSharedSwapchainsKHR"); if proc == null() {dummy_vkCreateSharedSwapchainsKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub trait VK_KHR_sampler_mirror_clamp_to_edge: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_sampler_mirror_clamp_to_edge {}
impl VK_KHR_sampler_mirror_clamp_to_edge for Vulkan_KHR_sampler_mirror_clamp_to_edge {}
impl Default for Vulkan_KHR_sampler_mirror_clamp_to_edge {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_sampler_mirror_clamp_to_edge {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkVideoCodecOperationFlagsKHR = VkFlags;
pub type VkVideoChromaSubsamplingFlagsKHR = VkFlags;
pub type VkVideoComponentBitDepthFlagsKHR = VkFlags;
pub type VkVideoCapabilityFlagsKHR = VkFlags;
pub type VkVideoSessionCreateFlagsKHR = VkFlags;
pub type VkVideoSessionParametersCreateFlagsKHR = VkFlags;
pub type VkVideoBeginCodingFlagsKHR = VkFlags;
pub type VkVideoEndCodingFlagsKHR = VkFlags;
pub type VkVideoCodingControlFlagsKHR = VkFlags;
// Define non-dispatchable handle `VkVideoSessionKHR`
#[cfg(target_pointer_width = "32")] pub type VkVideoSessionKHR = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkVideoSessionKHR_T {}
#[cfg(target_pointer_width = "64")] pub type VkVideoSessionKHR = *const VkVideoSessionKHR_T;
// Define non-dispatchable handle `VkVideoSessionParametersKHR`
#[cfg(target_pointer_width = "32")] pub type VkVideoSessionParametersKHR = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkVideoSessionParametersKHR_T {}
#[cfg(target_pointer_width = "64")] pub type VkVideoSessionParametersKHR = *const VkVideoSessionParametersKHR_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueryResultStatusKHR {
	VK_QUERY_RESULT_STATUS_ERROR_KHR = -1,
	VK_QUERY_RESULT_STATUS_NOT_READY_KHR = 0,
	VK_QUERY_RESULT_STATUS_COMPLETE_KHR = 1,
	VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR = -1000299000,
	VK_QUERY_RESULT_STATUS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoCodecOperationFlagBitsKHR {
	VK_VIDEO_CODEC_OPERATION_NONE_KHR = 0,
	VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR = 0x00010000,
	VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR = 0x00020000,
	VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR = 0x00000001,
	VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR = 0x00000002,
	VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR = 0x00000004,
	VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR = 0x00040000,
	VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR = 0x00000008,
	VK_VIDEO_CODEC_OPERATION_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoChromaSubsamplingFlagBitsKHR {
	VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR = 0,
	VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR = 0x00000001,
	VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR = 0x00000002,
	VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR = 0x00000004,
	VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR = 0x00000008,
	VK_VIDEO_CHROMA_SUBSAMPLING_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoComponentBitDepthFlagBitsKHR {
	VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR = 0,
	VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR = 0x00000001,
	VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR = 0x00000004,
	VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR = 0x00000010,
	VK_VIDEO_COMPONENT_BIT_DEPTH_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoCapabilityFlagBitsKHR {
	VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR = 0x00000001,
	VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR = 0x00000002,
	VK_VIDEO_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoSessionCreateFlagBitsKHR {
	VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR = 0x00000001,
	VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR = 0x00000002,
	VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR = 0x00000004,
	VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x00000008,
	VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR = 0x00000010,
	VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR = 0x00000020,
	VK_VIDEO_SESSION_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoSessionParametersCreateFlagBitsKHR {
	VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR = 0x00000001,
	VK_VIDEO_SESSION_PARAMETERS_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoCodingControlFlagBitsKHR {
	VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR = 0x00000001,
	VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR = 0x00000002,
	VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR = 0x00000004,
	VK_VIDEO_CODING_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkQueueFamilyQueryResultStatusPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub queryResultStatusSupport: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkQueueFamilyVideoPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub videoCodecOperations: VkVideoCodecOperationFlagsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoProfileInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub videoCodecOperation: VkVideoCodecOperationFlagBitsKHR,
	pub chromaSubsampling: VkVideoChromaSubsamplingFlagsKHR,
	pub lumaBitDepth: VkVideoComponentBitDepthFlagsKHR,
	pub chromaBitDepth: VkVideoComponentBitDepthFlagsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoProfileListInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub profileCount: u32,
	pub pProfiles: *const VkVideoProfileInfoKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkVideoCapabilityFlagsKHR,
	pub minBitstreamBufferOffsetAlignment: VkDeviceSize,
	pub minBitstreamBufferSizeAlignment: VkDeviceSize,
	pub pictureAccessGranularity: VkExtent2D,
	pub minCodedExtent: VkExtent2D,
	pub maxCodedExtent: VkExtent2D,
	pub maxDpbSlots: u32,
	pub maxActiveReferencePictures: u32,
	pub stdHeaderVersion: VkExtensionProperties,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVideoFormatInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub imageUsage: VkImageUsageFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoFormatPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub format: VkFormat,
	pub componentMapping: VkComponentMapping,
	pub imageCreateFlags: VkImageCreateFlags,
	pub imageType: VkImageType,
	pub imageTiling: VkImageTiling,
	pub imageUsageFlags: VkImageUsageFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoPictureResourceInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub codedOffset: VkOffset2D,
	pub codedExtent: VkExtent2D,
	pub baseArrayLayer: u32,
	pub imageViewBinding: VkImageView,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoReferenceSlotInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub slotIndex: i32,
	pub pPictureResource: *const VkVideoPictureResourceInfoKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoSessionMemoryRequirementsKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryBindIndex: u32,
	pub memoryRequirements: VkMemoryRequirements,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindVideoSessionMemoryInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub memoryBindIndex: u32,
	pub memory: VkDeviceMemory,
	pub memoryOffset: VkDeviceSize,
	pub memorySize: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoSessionCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub queueFamilyIndex: u32,
	pub flags: VkVideoSessionCreateFlagsKHR,
	pub pVideoProfile: *const VkVideoProfileInfoKHR,
	pub pictureFormat: VkFormat,
	pub maxCodedExtent: VkExtent2D,
	pub referencePictureFormat: VkFormat,
	pub maxDpbSlots: u32,
	pub maxActiveReferencePictures: u32,
	pub pStdHeaderVersion: *const VkExtensionProperties,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoSessionParametersCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoSessionParametersCreateFlagsKHR,
	pub videoSessionParametersTemplate: VkVideoSessionParametersKHR,
	pub videoSession: VkVideoSessionKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoSessionParametersUpdateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub updateSequenceCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoBeginCodingInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoBeginCodingFlagsKHR,
	pub videoSession: VkVideoSessionKHR,
	pub videoSessionParameters: VkVideoSessionParametersKHR,
	pub referenceSlotCount: u32,
	pub pReferenceSlots: *const VkVideoReferenceSlotInfoKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEndCodingInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoEndCodingFlagsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoCodingControlInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoCodingControlFlagsKHR,
}
type PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pVideoProfile: *const VkVideoProfileInfoKHR, pCapabilities: *mut VkVideoCapabilitiesKHR) -> VkResult;
type PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pVideoFormatInfo: *const VkPhysicalDeviceVideoFormatInfoKHR, pVideoFormatPropertyCount: *mut uint32_t, pVideoFormatProperties: *mut VkVideoFormatPropertiesKHR) -> VkResult;
type PFN_vkCreateVideoSessionKHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkVideoSessionCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pVideoSession: *mut VkVideoSessionKHR) -> VkResult;
type PFN_vkDestroyVideoSessionKHR = extern "system" fn(device: VkDevice, videoSession: VkVideoSessionKHR, pAllocator: *const VkAllocationCallbacks);
type PFN_vkGetVideoSessionMemoryRequirementsKHR = extern "system" fn(device: VkDevice, videoSession: VkVideoSessionKHR, pMemoryRequirementsCount: *mut uint32_t, pMemoryRequirements: *mut VkVideoSessionMemoryRequirementsKHR) -> VkResult;
type PFN_vkBindVideoSessionMemoryKHR = extern "system" fn(device: VkDevice, videoSession: VkVideoSessionKHR, bindSessionMemoryInfoCount: u32, pBindSessionMemoryInfos: *const VkBindVideoSessionMemoryInfoKHR) -> VkResult;
type PFN_vkCreateVideoSessionParametersKHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkVideoSessionParametersCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pVideoSessionParameters: *mut VkVideoSessionParametersKHR) -> VkResult;
type PFN_vkUpdateVideoSessionParametersKHR = extern "system" fn(device: VkDevice, videoSessionParameters: VkVideoSessionParametersKHR, pUpdateInfo: *const VkVideoSessionParametersUpdateInfoKHR) -> VkResult;
type PFN_vkDestroyVideoSessionParametersKHR = extern "system" fn(device: VkDevice, videoSessionParameters: VkVideoSessionParametersKHR, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCmdBeginVideoCodingKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pBeginInfo: *const VkVideoBeginCodingInfoKHR);
type PFN_vkCmdEndVideoCodingKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pEndCodingInfo: *const VkVideoEndCodingInfoKHR);
type PFN_vkCmdControlVideoCodingKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pCodingControlInfo: *const VkVideoCodingControlInfoKHR);
extern "system" fn dummy_vkGetPhysicalDeviceVideoCapabilitiesKHR(_: VkPhysicalDevice, _: *const VkVideoProfileInfoKHR, _: *mut VkVideoCapabilitiesKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceVideoCapabilitiesKHR()` is NULL");
}
pub trait VK_KHR_video_queue: Debug {
	fn vkGetPhysicalDeviceVideoCapabilitiesKHR(&self, physicalDevice: VkPhysicalDevice, pVideoProfile: *const VkVideoProfileInfoKHR, pCapabilities: *mut VkVideoCapabilitiesKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_queue {
	vk_get_physical_device_video_capabilities_khr: PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR,
}
impl VK_KHR_video_queue for Vulkan_KHR_video_queue {
	fn vkGetPhysicalDeviceVideoCapabilitiesKHR(&self, physicalDevice: VkPhysicalDevice, pVideoProfile: *const VkVideoProfileInfoKHR, pCapabilities: *mut VkVideoCapabilitiesKHR) -> VkResult {
		(self.vk_get_physical_device_video_capabilities_khr)(physicalDevice, pVideoProfile, pCapabilities)
	}
}
impl Default for Vulkan_KHR_video_queue {
	fn default() -> Self {
		Self {
			vk_get_physical_device_video_capabilities_khr: dummy_vkGetPhysicalDeviceVideoCapabilitiesKHR,
		}
	}
}
impl Vulkan_KHR_video_queue {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_video_capabilities_khr: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceVideoCapabilitiesKHR"); if proc == null() {dummy_vkGetPhysicalDeviceVideoCapabilitiesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkVideoDecodeCapabilityFlagsKHR = VkFlags;
pub type VkVideoDecodeUsageFlagsKHR = VkFlags;
pub type VkVideoDecodeFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoDecodeCapabilityFlagBitsKHR {
	VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR = 0x00000001,
	VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR = 0x00000002,
	VK_VIDEO_DECODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoDecodeUsageFlagBitsKHR {
	VK_VIDEO_DECODE_USAGE_DEFAULT_KHR = 0,
	VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR = 0x00000001,
	VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR = 0x00000002,
	VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR = 0x00000004,
	VK_VIDEO_DECODE_USAGE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkVideoDecodeCapabilityFlagsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeUsageInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub videoUsageHints: VkVideoDecodeUsageFlagsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoDecodeFlagsKHR,
	pub srcBuffer: VkBuffer,
	pub srcBufferOffset: VkDeviceSize,
	pub srcBufferRange: VkDeviceSize,
	pub dstPictureResource: VkVideoPictureResourceInfoKHR,
	pub pSetupReferenceSlot: *const VkVideoReferenceSlotInfoKHR,
	pub referenceSlotCount: u32,
	pub pReferenceSlots: *const VkVideoReferenceSlotInfoKHR,
}
type PFN_vkCmdDecodeVideoKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pDecodeInfo: *const VkVideoDecodeInfoKHR);
extern "system" fn dummy_vkCmdDecodeVideoKHR(_: VkCommandBuffer, _: *const VkVideoDecodeInfoKHR) {
	panic!("Vulkan function pointer of `vkCmdDecodeVideoKHR()` is NULL");
}
pub trait VK_KHR_video_decode_queue: Debug {
	fn vkCmdDecodeVideoKHR(&self, commandBuffer: VkCommandBuffer, pDecodeInfo: *const VkVideoDecodeInfoKHR);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_decode_queue {
	vk_cmd_decode_video_khr: PFN_vkCmdDecodeVideoKHR,
}
impl VK_KHR_video_decode_queue for Vulkan_KHR_video_decode_queue {
	fn vkCmdDecodeVideoKHR(&self, commandBuffer: VkCommandBuffer, pDecodeInfo: *const VkVideoDecodeInfoKHR) {
		(self.vk_cmd_decode_video_khr)(commandBuffer, pDecodeInfo)
	}
}
impl Default for Vulkan_KHR_video_decode_queue {
	fn default() -> Self {
		Self {
			vk_cmd_decode_video_khr: dummy_vkCmdDecodeVideoKHR,
		}
	}
}
impl Vulkan_KHR_video_decode_queue {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_decode_video_khr: {let proc = get_proc_address(instance, "vkCmdDecodeVideoKHR"); if proc == null() {dummy_vkCmdDecodeVideoKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkVideoEncodeH264CapabilityFlagsKHR = VkFlags;
pub type VkVideoEncodeH264StdFlagsKHR = VkFlags;
pub type VkVideoEncodeH264RateControlFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeH264CapabilityFlagBitsKHR {
	VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR = 0x00000040,
	VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR = 0x00000080,
	VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR = 0x00000100,
	VK_VIDEO_ENCODE_H264_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR = 0x00000400,
	VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR = 0x00000200,
	VK_VIDEO_ENCODE_H264_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeH264StdFlagBitsKHR {
	VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR = 0x00000040,
	VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR = 0x00000080,
	VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR = 0x00000100,
	VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR = 0x00000200,
	VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR = 0x00000400,
	VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR = 0x00000800,
	VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR = 0x00001000,
	VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR = 0x00002000,
	VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR = 0x00004000,
	VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR = 0x00008000,
	VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR = 0x00010000,
	VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR = 0x00020000,
	VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR = 0x00080000,
	VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR = 0x00100000,
	VK_VIDEO_ENCODE_H264_STD_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeH264RateControlFlagBitsKHR {
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264CapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkVideoEncodeH264CapabilityFlagsKHR,
	pub maxLevelIdc: StdVideoH264LevelIdc,
	pub maxSliceCount: u32,
	pub maxPPictureL0ReferenceCount: u32,
	pub maxBPictureL0ReferenceCount: u32,
	pub maxL1ReferenceCount: u32,
	pub maxTemporalLayerCount: u32,
	pub expectDyadicTemporalLayerPattern: VkBool32,
	pub minQp: i32,
	pub maxQp: i32,
	pub prefersGopRemainingFrames: VkBool32,
	pub requiresGopRemainingFrames: VkBool32,
	pub stdSyntaxFlags: VkVideoEncodeH264StdFlagsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264QpKHR {
	pub qpI: i32,
	pub qpP: i32,
	pub qpB: i32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264QualityLevelPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub preferredRateControlFlags: VkVideoEncodeH264RateControlFlagsKHR,
	pub preferredGopFrameCount: u32,
	pub preferredIdrPeriod: u32,
	pub preferredConsecutiveBFrameCount: u32,
	pub preferredTemporalLayerCount: u32,
	pub preferredConstantQp: VkVideoEncodeH264QpKHR,
	pub preferredMaxL0ReferenceCount: u32,
	pub preferredMaxL1ReferenceCount: u32,
	pub preferredStdEntropyCodingModeFlag: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264SessionCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useMaxLevelIdc: VkBool32,
	pub maxLevelIdc: StdVideoH264LevelIdc,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264SessionParametersAddInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdSPSCount: u32,
	pub pStdSPSs: *const StdVideoH264SequenceParameterSet,
	pub stdPPSCount: u32,
	pub pStdPPSs: *const StdVideoH264PictureParameterSet,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264SessionParametersCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maxStdSPSCount: u32,
	pub maxStdPPSCount: u32,
	pub pParametersAddInfo: *const VkVideoEncodeH264SessionParametersAddInfoKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264SessionParametersGetInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub writeStdSPS: VkBool32,
	pub writeStdPPS: VkBool32,
	pub stdSPSId: u32,
	pub stdPPSId: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264SessionParametersFeedbackInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub hasStdSPSOverrides: VkBool32,
	pub hasStdPPSOverrides: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264NaluSliceInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub constantQp: i32,
	pub pStdSliceHeader: *const StdVideoEncodeH264SliceHeader,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264PictureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub naluSliceEntryCount: u32,
	pub pNaluSliceEntries: *const VkVideoEncodeH264NaluSliceInfoKHR,
	pub pStdPictureInfo: *const StdVideoEncodeH264PictureInfo,
	pub generatePrefixNalu: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264DpbSlotInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdReferenceInfo: *const StdVideoEncodeH264ReferenceInfo,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264ProfileInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdProfileIdc: StdVideoH264ProfileIdc,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264RateControlInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoEncodeH264RateControlFlagsKHR,
	pub gopFrameCount: u32,
	pub idrPeriod: u32,
	pub consecutiveBFrameCount: u32,
	pub temporalLayerCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264FrameSizeKHR {
	pub frameISize: u32,
	pub framePSize: u32,
	pub frameBSize: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264RateControlLayerInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useMinQp: VkBool32,
	pub minQp: VkVideoEncodeH264QpKHR,
	pub useMaxQp: VkBool32,
	pub maxQp: VkVideoEncodeH264QpKHR,
	pub useMaxFrameSize: VkBool32,
	pub maxFrameSize: VkVideoEncodeH264FrameSizeKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264GopRemainingFrameInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useGopRemainingFrames: VkBool32,
	pub gopRemainingI: u32,
	pub gopRemainingP: u32,
	pub gopRemainingB: u32,
}
pub trait VK_KHR_video_encode_h264: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_encode_h264 {}
impl VK_KHR_video_encode_h264 for Vulkan_KHR_video_encode_h264 {}
impl Default for Vulkan_KHR_video_encode_h264 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_encode_h264 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const STD_VIDEO_H264_CPB_CNT_LIST_SIZE: u32 = 32u32;
pub const STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS: u32 = 6u32;
pub const STD_VIDEO_H264_SCALING_LIST_4X4_NUM_ELEMENTS: u32 = 16u32;
pub const STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS: u32 = 6u32;
pub const STD_VIDEO_H264_SCALING_LIST_8X8_NUM_ELEMENTS: u32 = 64u32;
pub const STD_VIDEO_H264_MAX_NUM_LIST_REF: u32 = 32u32;
pub const STD_VIDEO_H264_MAX_CHROMA_PLANES: u32 = 2u32;
pub const STD_VIDEO_H264_NO_REFERENCE_PICTURE: u32 = 0xffu32;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264ChromaFormatIdc {
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_MONOCHROME = 0,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_420 = 1,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_422 = 2,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_444 = 3,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH264ChromaFormatIdc {
	pub const STD_VIDEO_H264_CHROMA_FORMAT_IDC_MAX_ENUM: StdVideoH264ChromaFormatIdc = StdVideoH264ChromaFormatIdc::STD_VIDEO_H264_CHROMA_FORMAT_IDC_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264ProfileIdc {
	STD_VIDEO_H264_PROFILE_IDC_BASELINE = 66,
	STD_VIDEO_H264_PROFILE_IDC_MAIN = 77,
	STD_VIDEO_H264_PROFILE_IDC_HIGH = 100,
	STD_VIDEO_H264_PROFILE_IDC_HIGH_444_PREDICTIVE = 244,
	STD_VIDEO_H264_PROFILE_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH264ProfileIdc {
	pub const STD_VIDEO_H264_PROFILE_IDC_MAX_ENUM: StdVideoH264ProfileIdc = StdVideoH264ProfileIdc::STD_VIDEO_H264_PROFILE_IDC_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264LevelIdc {
	STD_VIDEO_H264_LEVEL_IDC_1_0 = 0,
	STD_VIDEO_H264_LEVEL_IDC_1_1 = 1,
	STD_VIDEO_H264_LEVEL_IDC_1_2 = 2,
	STD_VIDEO_H264_LEVEL_IDC_1_3 = 3,
	STD_VIDEO_H264_LEVEL_IDC_2_0 = 4,
	STD_VIDEO_H264_LEVEL_IDC_2_1 = 5,
	STD_VIDEO_H264_LEVEL_IDC_2_2 = 6,
	STD_VIDEO_H264_LEVEL_IDC_3_0 = 7,
	STD_VIDEO_H264_LEVEL_IDC_3_1 = 8,
	STD_VIDEO_H264_LEVEL_IDC_3_2 = 9,
	STD_VIDEO_H264_LEVEL_IDC_4_0 = 10,
	STD_VIDEO_H264_LEVEL_IDC_4_1 = 11,
	STD_VIDEO_H264_LEVEL_IDC_4_2 = 12,
	STD_VIDEO_H264_LEVEL_IDC_5_0 = 13,
	STD_VIDEO_H264_LEVEL_IDC_5_1 = 14,
	STD_VIDEO_H264_LEVEL_IDC_5_2 = 15,
	STD_VIDEO_H264_LEVEL_IDC_6_0 = 16,
	STD_VIDEO_H264_LEVEL_IDC_6_1 = 17,
	STD_VIDEO_H264_LEVEL_IDC_6_2 = 18,
	STD_VIDEO_H264_LEVEL_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH264LevelIdc {
	pub const STD_VIDEO_H264_LEVEL_IDC_MAX_ENUM: StdVideoH264LevelIdc = StdVideoH264LevelIdc::STD_VIDEO_H264_LEVEL_IDC_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264PocType {
	STD_VIDEO_H264_POC_TYPE_0 = 0,
	STD_VIDEO_H264_POC_TYPE_1 = 1,
	STD_VIDEO_H264_POC_TYPE_2 = 2,
	STD_VIDEO_H264_POC_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoH264PocType {
	pub const STD_VIDEO_H264_POC_TYPE_MAX_ENUM: StdVideoH264PocType = StdVideoH264PocType::STD_VIDEO_H264_POC_TYPE_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264AspectRatioIdc {
	STD_VIDEO_H264_ASPECT_RATIO_IDC_UNSPECIFIED = 0,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_SQUARE = 1,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_12_11 = 2,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_10_11 = 3,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_16_11 = 4,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_40_33 = 5,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_24_11 = 6,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_20_11 = 7,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_32_11 = 8,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_80_33 = 9,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_18_11 = 10,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_15_11 = 11,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_64_33 = 12,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_160_99 = 13,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_4_3 = 14,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_3_2 = 15,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_2_1 = 16,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_EXTENDED_SAR = 255,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH264AspectRatioIdc {
	pub const STD_VIDEO_H264_ASPECT_RATIO_IDC_MAX_ENUM: StdVideoH264AspectRatioIdc = StdVideoH264AspectRatioIdc::STD_VIDEO_H264_ASPECT_RATIO_IDC_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264WeightedBipredIdc {
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_DEFAULT = 0,
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_EXPLICIT = 1,
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_IMPLICIT = 2,
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH264WeightedBipredIdc {
	pub const STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_MAX_ENUM: StdVideoH264WeightedBipredIdc = StdVideoH264WeightedBipredIdc::STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264ModificationOfPicNumsIdc {
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_SUBTRACT = 0,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_ADD = 1,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_LONG_TERM = 2,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_END = 3,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH264ModificationOfPicNumsIdc {
	pub const STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_MAX_ENUM: StdVideoH264ModificationOfPicNumsIdc = StdVideoH264ModificationOfPicNumsIdc::STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264MemMgmtControlOp {
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_END = 0,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_SHORT_TERM = 1,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_LONG_TERM = 2,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_LONG_TERM = 3,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_SET_MAX_LONG_TERM_INDEX = 4,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_ALL = 5,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_CURRENT_AS_LONG_TERM = 6,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_INVALID = 0x7fffffff,
}
impl StdVideoH264MemMgmtControlOp {
	pub const STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MAX_ENUM: StdVideoH264MemMgmtControlOp = StdVideoH264MemMgmtControlOp::STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264CabacInitIdc {
	STD_VIDEO_H264_CABAC_INIT_IDC_0 = 0,
	STD_VIDEO_H264_CABAC_INIT_IDC_1 = 1,
	STD_VIDEO_H264_CABAC_INIT_IDC_2 = 2,
	STD_VIDEO_H264_CABAC_INIT_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH264CabacInitIdc {
	pub const STD_VIDEO_H264_CABAC_INIT_IDC_MAX_ENUM: StdVideoH264CabacInitIdc = StdVideoH264CabacInitIdc::STD_VIDEO_H264_CABAC_INIT_IDC_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264DisableDeblockingFilterIdc {
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_DISABLED = 0,
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_ENABLED = 1,
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_PARTIAL = 2,
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH264DisableDeblockingFilterIdc {
	pub const STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_MAX_ENUM: StdVideoH264DisableDeblockingFilterIdc = StdVideoH264DisableDeblockingFilterIdc::STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264SliceType {
	STD_VIDEO_H264_SLICE_TYPE_P = 0,
	STD_VIDEO_H264_SLICE_TYPE_B = 1,
	STD_VIDEO_H264_SLICE_TYPE_I = 2,
	STD_VIDEO_H264_SLICE_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoH264SliceType {
	pub const STD_VIDEO_H264_SLICE_TYPE_MAX_ENUM: StdVideoH264SliceType = StdVideoH264SliceType::STD_VIDEO_H264_SLICE_TYPE_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264PictureType {
	STD_VIDEO_H264_PICTURE_TYPE_P = 0,
	STD_VIDEO_H264_PICTURE_TYPE_B = 1,
	STD_VIDEO_H264_PICTURE_TYPE_I = 2,
	STD_VIDEO_H264_PICTURE_TYPE_IDR = 5,
	STD_VIDEO_H264_PICTURE_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoH264PictureType {
	pub const STD_VIDEO_H264_PICTURE_TYPE_MAX_ENUM: StdVideoH264PictureType = StdVideoH264PictureType::STD_VIDEO_H264_PICTURE_TYPE_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264NonVclNaluType {
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_SPS = 0,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_PPS = 1,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_AUD = 2,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_PREFIX = 3,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_SEQUENCE = 4,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_STREAM = 5,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_PRECODED = 6,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoH264NonVclNaluType {
	pub const STD_VIDEO_H264_NON_VCL_NALU_TYPE_MAX_ENUM: StdVideoH264NonVclNaluType = StdVideoH264NonVclNaluType::STD_VIDEO_H264_NON_VCL_NALU_TYPE_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH264SpsVuiFlags {
	/// Bitfield: aspect_ratio_info_present_flag: u32 in 1 bits
	/// Bitfield: overscan_info_present_flag: u32 in 1 bits
	/// Bitfield: overscan_appropriate_flag: u32 in 1 bits
	/// Bitfield: video_signal_type_present_flag: u32 in 1 bits
	/// Bitfield: video_full_range_flag: u32 in 1 bits
	/// Bitfield: color_description_present_flag: u32 in 1 bits
	/// Bitfield: chroma_loc_info_present_flag: u32 in 1 bits
	/// Bitfield: timing_info_present_flag: u32 in 1 bits
	/// Bitfield: fixed_frame_rate_flag: u32 in 1 bits
	/// Bitfield: bitstream_restriction_flag: u32 in 1 bits
	/// Bitfield: nal_hrd_parameters_present_flag: u32 in 1 bits
	/// Bitfield: vcl_hrd_parameters_present_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH264SpsVuiFlags {
	pub fn get_aspect_ratio_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_aspect_ratio_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_overscan_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_overscan_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_overscan_appropriate_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_overscan_appropriate_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_video_signal_type_present_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_video_signal_type_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_video_full_range_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_video_full_range_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_color_description_present_flag(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_color_description_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_chroma_loc_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_chroma_loc_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_timing_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_timing_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_fixed_frame_rate_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_fixed_frame_rate_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_bitstream_restriction_flag(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_bitstream_restriction_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_nal_hrd_parameters_present_flag(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_nal_hrd_parameters_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_vcl_hrd_parameters_present_flag(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_vcl_hrd_parameters_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH264HrdParameters {
	pub cpb_cnt_minus1: u8,
	pub bit_rate_scale: u8,
	pub cpb_size_scale: u8,
	pub reserved1: u8,
	pub bit_rate_value_minus1: [u32; STD_VIDEO_H264_CPB_CNT_LIST_SIZE as usize],
	pub cpb_size_value_minus1: [u32; STD_VIDEO_H264_CPB_CNT_LIST_SIZE as usize],
	pub cbr_flag: [u8; STD_VIDEO_H264_CPB_CNT_LIST_SIZE as usize],
	pub initial_cpb_removal_delay_length_minus1: u32,
	pub cpb_removal_delay_length_minus1: u32,
	pub dpb_output_delay_length_minus1: u32,
	pub time_offset_length: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH264SequenceParameterSetVui {
	pub flags: StdVideoH264SpsVuiFlags,
	pub aspect_ratio_idc: StdVideoH264AspectRatioIdc,
	pub sar_width: u16,
	pub sar_height: u16,
	pub video_format: u8,
	pub colour_primaries: u8,
	pub transfer_characteristics: u8,
	pub matrix_coefficients: u8,
	pub num_units_in_tick: u32,
	pub time_scale: u32,
	pub max_num_reorder_frames: u8,
	pub max_dec_frame_buffering: u8,
	pub chroma_sample_loc_type_top_field: u8,
	pub chroma_sample_loc_type_bottom_field: u8,
	pub reserved1: u32,
	pub pHrdParameters: *const StdVideoH264HrdParameters,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH264SpsFlags {
	/// Bitfield: constraint_set0_flag: u32 in 1 bits
	/// Bitfield: constraint_set1_flag: u32 in 1 bits
	/// Bitfield: constraint_set2_flag: u32 in 1 bits
	/// Bitfield: constraint_set3_flag: u32 in 1 bits
	/// Bitfield: constraint_set4_flag: u32 in 1 bits
	/// Bitfield: constraint_set5_flag: u32 in 1 bits
	/// Bitfield: direct_8x8_inference_flag: u32 in 1 bits
	/// Bitfield: mb_adaptive_frame_field_flag: u32 in 1 bits
	/// Bitfield: frame_mbs_only_flag: u32 in 1 bits
	/// Bitfield: delta_pic_order_always_zero_flag: u32 in 1 bits
	/// Bitfield: separate_colour_plane_flag: u32 in 1 bits
	/// Bitfield: gaps_in_frame_num_value_allowed_flag: u32 in 1 bits
	/// Bitfield: qpprime_y_zero_transform_bypass_flag: u32 in 1 bits
	/// Bitfield: frame_cropping_flag: u32 in 1 bits
	/// Bitfield: seq_scaling_matrix_present_flag: u32 in 1 bits
	/// Bitfield: vui_parameters_present_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH264SpsFlags {
	pub fn get_constraint_set0_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_constraint_set0_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_constraint_set1_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_constraint_set1_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_constraint_set2_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_constraint_set2_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_constraint_set3_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_constraint_set3_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_constraint_set4_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_constraint_set4_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_constraint_set5_flag(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_constraint_set5_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_direct_8x8_inference_flag(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_direct_8x8_inference_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_mb_adaptive_frame_field_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_mb_adaptive_frame_field_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_frame_mbs_only_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_frame_mbs_only_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_delta_pic_order_always_zero_flag(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_delta_pic_order_always_zero_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_separate_colour_plane_flag(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_separate_colour_plane_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_gaps_in_frame_num_value_allowed_flag(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_gaps_in_frame_num_value_allowed_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
	pub fn get_qpprime_y_zero_transform_bypass_flag(&self) -> u32 {
		(self.bitfield1 >> 12) & 0x1
	}
	pub fn set_qpprime_y_zero_transform_bypass_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 12;
	}
	pub fn get_frame_cropping_flag(&self) -> u32 {
		(self.bitfield1 >> 13) & 0x1
	}
	pub fn set_frame_cropping_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 13;
	}
	pub fn get_seq_scaling_matrix_present_flag(&self) -> u32 {
		(self.bitfield1 >> 14) & 0x1
	}
	pub fn set_seq_scaling_matrix_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 14;
	}
	pub fn get_vui_parameters_present_flag(&self) -> u32 {
		(self.bitfield1 >> 15) & 0x1
	}
	pub fn set_vui_parameters_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 15;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH264ScalingLists {
	pub scaling_list_present_mask: u16,
	pub use_default_scaling_matrix_mask: u16,
	pub ScalingList4x4: [u8; STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS as usize],
	pub ScalingList8x8: [u8; STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH264SequenceParameterSet {
	pub flags: StdVideoH264SpsFlags,
	pub profile_idc: StdVideoH264ProfileIdc,
	pub level_idc: StdVideoH264LevelIdc,
	pub chroma_format_idc: StdVideoH264ChromaFormatIdc,
	pub seq_parameter_set_id: u8,
	pub bit_depth_luma_minus8: u8,
	pub bit_depth_chroma_minus8: u8,
	pub log2_max_frame_num_minus4: u8,
	pub pic_order_cnt_type: StdVideoH264PocType,
	pub offset_for_non_ref_pic: i32,
	pub offset_for_top_to_bottom_field: i32,
	pub log2_max_pic_order_cnt_lsb_minus4: u8,
	pub num_ref_frames_in_pic_order_cnt_cycle: u8,
	pub max_num_ref_frames: u8,
	pub reserved1: u8,
	pub pic_width_in_mbs_minus1: u32,
	pub pic_height_in_map_units_minus1: u32,
	pub frame_crop_left_offset: u32,
	pub frame_crop_right_offset: u32,
	pub frame_crop_top_offset: u32,
	pub frame_crop_bottom_offset: u32,
	pub reserved2: u32,
	pub pOffsetForRefFrame: *const int32_t,
	pub pScalingLists: *const StdVideoH264ScalingLists,
	pub pSequenceParameterSetVui: *const StdVideoH264SequenceParameterSetVui,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH264PpsFlags {
	/// Bitfield: transform_8x8_mode_flag: u32 in 1 bits
	/// Bitfield: redundant_pic_cnt_present_flag: u32 in 1 bits
	/// Bitfield: constrained_intra_pred_flag: u32 in 1 bits
	/// Bitfield: deblocking_filter_control_present_flag: u32 in 1 bits
	/// Bitfield: weighted_pred_flag: u32 in 1 bits
	/// Bitfield: bottom_field_pic_order_in_frame_present_flag: u32 in 1 bits
	/// Bitfield: entropy_coding_mode_flag: u32 in 1 bits
	/// Bitfield: pic_scaling_matrix_present_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH264PpsFlags {
	pub fn get_transform_8x8_mode_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_transform_8x8_mode_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_redundant_pic_cnt_present_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_redundant_pic_cnt_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_constrained_intra_pred_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_constrained_intra_pred_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_deblocking_filter_control_present_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_deblocking_filter_control_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_weighted_pred_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_weighted_pred_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_bottom_field_pic_order_in_frame_present_flag(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_bottom_field_pic_order_in_frame_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_entropy_coding_mode_flag(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_entropy_coding_mode_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_pic_scaling_matrix_present_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_pic_scaling_matrix_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH264PictureParameterSet {
	pub flags: StdVideoH264PpsFlags,
	pub seq_parameter_set_id: u8,
	pub pic_parameter_set_id: u8,
	pub num_ref_idx_l0_default_active_minus1: u8,
	pub num_ref_idx_l1_default_active_minus1: u8,
	pub weighted_bipred_idc: StdVideoH264WeightedBipredIdc,
	pub pic_init_qp_minus26: i8,
	pub pic_init_qs_minus26: i8,
	pub chroma_qp_index_offset: i8,
	pub second_chroma_qp_index_offset: i8,
	pub pScalingLists: *const StdVideoH264ScalingLists,
}
pub trait vulkan_video_codec_h264std: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_h264std {}
impl vulkan_video_codec_h264std for Vulkan_video_codec_h264std {}
impl Default for Vulkan_video_codec_h264std {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_h264std {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait vulkan_video_codecs_common: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codecs_common {}
impl vulkan_video_codecs_common for Vulkan_video_codecs_common {}
impl Default for Vulkan_video_codecs_common {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codecs_common {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_API_VERSION_1_0_0: u32 = 0x400000;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH264WeightTableFlags {
	pub luma_weight_l0_flag: u32,
	pub chroma_weight_l0_flag: u32,
	pub luma_weight_l1_flag: u32,
	pub chroma_weight_l1_flag: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH264WeightTable {
	pub flags: StdVideoEncodeH264WeightTableFlags,
	pub luma_log2_weight_denom: u8,
	pub chroma_log2_weight_denom: u8,
	pub luma_weight_l0: [i8; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub luma_offset_l0: [i8; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub chroma_weight_l0: [i8; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub chroma_offset_l0: [i8; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub luma_weight_l1: [i8; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub luma_offset_l1: [i8; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub chroma_weight_l1: [i8; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub chroma_offset_l1: [i8; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH264SliceHeaderFlags {
	/// Bitfield: direct_spatial_mv_pred_flag: u32 in 1 bits
	/// Bitfield: num_ref_idx_active_override_flag: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoEncodeH264SliceHeaderFlags {
	pub fn get_direct_spatial_mv_pred_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_direct_spatial_mv_pred_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_num_ref_idx_active_override_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_num_ref_idx_active_override_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH264PictureInfoFlags {
	/// Bitfield: IdrPicFlag: u32 in 1 bits
	/// Bitfield: is_reference: u32 in 1 bits
	/// Bitfield: no_output_of_prior_pics_flag: u32 in 1 bits
	/// Bitfield: long_term_reference_flag: u32 in 1 bits
	/// Bitfield: adaptive_ref_pic_marking_mode_flag: u32 in 1 bits
	/// Bitfield: reserved: u32 in 27 bits
	bitfield1: u32,
}
impl StdVideoEncodeH264PictureInfoFlags {
	pub fn get_IdrPicFlag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_IdrPicFlag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_is_reference(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_is_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_no_output_of_prior_pics_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_no_output_of_prior_pics_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_long_term_reference_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_long_term_reference_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_adaptive_ref_pic_marking_mode_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_adaptive_ref_pic_marking_mode_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x7ffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7ffffff) << 5;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH264ReferenceInfoFlags {
	/// Bitfield: used_for_long_term_reference: u32 in 1 bits
	/// Bitfield: reserved: u32 in 31 bits
	bitfield1: u32,
}
impl StdVideoEncodeH264ReferenceInfoFlags {
	pub fn get_used_for_long_term_reference(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_used_for_long_term_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x7fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7fffffff) << 1;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH264ReferenceListsInfoFlags {
	/// Bitfield: ref_pic_list_modification_flag_l0: u32 in 1 bits
	/// Bitfield: ref_pic_list_modification_flag_l1: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoEncodeH264ReferenceListsInfoFlags {
	pub fn get_ref_pic_list_modification_flag_l0(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_ref_pic_list_modification_flag_l0(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_ref_pic_list_modification_flag_l1(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_ref_pic_list_modification_flag_l1(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH264RefListModEntry {
	pub modification_of_pic_nums_idc: StdVideoH264ModificationOfPicNumsIdc,
	pub abs_diff_pic_num_minus1: u16,
	pub long_term_pic_num: u16,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH264RefPicMarkingEntry {
	pub memory_management_control_operation: StdVideoH264MemMgmtControlOp,
	pub difference_of_pic_nums_minus1: u16,
	pub long_term_pic_num: u16,
	pub long_term_frame_idx: u16,
	pub max_long_term_frame_idx_plus1: u16,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH264ReferenceListsInfo {
	pub flags: StdVideoEncodeH264ReferenceListsInfoFlags,
	pub num_ref_idx_l0_active_minus1: u8,
	pub num_ref_idx_l1_active_minus1: u8,
	pub RefPicList0: [u8; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub RefPicList1: [u8; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub refList0ModOpCount: u8,
	pub refList1ModOpCount: u8,
	pub refPicMarkingOpCount: u8,
	pub reserved1: [u8; 7 as usize],
	pub pRefList0ModOperations: *const StdVideoEncodeH264RefListModEntry,
	pub pRefList1ModOperations: *const StdVideoEncodeH264RefListModEntry,
	pub pRefPicMarkingOperations: *const StdVideoEncodeH264RefPicMarkingEntry,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH264PictureInfo {
	pub flags: StdVideoEncodeH264PictureInfoFlags,
	pub seq_parameter_set_id: u8,
	pub pic_parameter_set_id: u8,
	pub idr_pic_id: u16,
	pub primary_pic_type: StdVideoH264PictureType,
	pub frame_num: u32,
	pub PicOrderCnt: i32,
	pub temporal_id: u8,
	pub reserved1: [u8; 3 as usize],
	pub pRefLists: *const StdVideoEncodeH264ReferenceListsInfo,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH264ReferenceInfo {
	pub flags: StdVideoEncodeH264ReferenceInfoFlags,
	pub primary_pic_type: StdVideoH264PictureType,
	pub FrameNum: u32,
	pub PicOrderCnt: i32,
	pub long_term_pic_num: u16,
	pub long_term_frame_idx: u16,
	pub temporal_id: u8,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH264SliceHeader {
	pub flags: StdVideoEncodeH264SliceHeaderFlags,
	pub first_mb_in_slice: u32,
	pub slice_type: StdVideoH264SliceType,
	pub slice_alpha_c0_offset_div2: i8,
	pub slice_beta_offset_div2: i8,
	pub slice_qp_delta: i8,
	pub reserved1: u8,
	pub cabac_init_idc: StdVideoH264CabacInitIdc,
	pub disable_deblocking_filter_idc: StdVideoH264DisableDeblockingFilterIdc,
	pub pWeightTable: *const StdVideoEncodeH264WeightTable,
}
pub trait vulkan_video_codec_h264std_encode: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_h264std_encode {}
impl vulkan_video_codec_h264std_encode for Vulkan_video_codec_h264std_encode {}
impl Default for Vulkan_video_codec_h264std_encode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_h264std_encode {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkVideoEncodeH265CapabilityFlagsKHR = VkFlags;
pub type VkVideoEncodeH265StdFlagsKHR = VkFlags;
pub type VkVideoEncodeH265CtbSizeFlagsKHR = VkFlags;
pub type VkVideoEncodeH265TransformBlockSizeFlagsKHR = VkFlags;
pub type VkVideoEncodeH265RateControlFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeH265CapabilityFlagBitsKHR {
	VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR = 0x00000040,
	VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR = 0x00000080,
	VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR = 0x00000100,
	VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR = 0x00000200,
	VK_VIDEO_ENCODE_H265_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR = 0x00000800,
	VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR = 0x00000400,
	VK_VIDEO_ENCODE_H265_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeH265StdFlagBitsKHR {
	VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR = 0x00000040,
	VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR = 0x00000080,
	VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR = 0x00000100,
	VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR = 0x00000200,
	VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR = 0x00000400,
	VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR = 0x00000800,
	VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR = 0x00001000,
	VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR = 0x00002000,
	VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR = 0x00004000,
	VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR = 0x00008000,
	VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR = 0x00010000,
	VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR = 0x00020000,
	VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR = 0x00040000,
	VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR = 0x00080000,
	VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR = 0x00100000,
	VK_VIDEO_ENCODE_H265_STD_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeH265CtbSizeFlagBitsKHR {
	VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_CTB_SIZE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeH265TransformBlockSizeFlagBitsKHR {
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeH265RateControlFlagBitsKHR {
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265CapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkVideoEncodeH265CapabilityFlagsKHR,
	pub maxLevelIdc: StdVideoH265LevelIdc,
	pub maxSliceSegmentCount: u32,
	pub maxTiles: VkExtent2D,
	pub ctbSizes: VkVideoEncodeH265CtbSizeFlagsKHR,
	pub transformBlockSizes: VkVideoEncodeH265TransformBlockSizeFlagsKHR,
	pub maxPPictureL0ReferenceCount: u32,
	pub maxBPictureL0ReferenceCount: u32,
	pub maxL1ReferenceCount: u32,
	pub maxSubLayerCount: u32,
	pub expectDyadicTemporalSubLayerPattern: VkBool32,
	pub minQp: i32,
	pub maxQp: i32,
	pub prefersGopRemainingFrames: VkBool32,
	pub requiresGopRemainingFrames: VkBool32,
	pub stdSyntaxFlags: VkVideoEncodeH265StdFlagsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265SessionCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useMaxLevelIdc: VkBool32,
	pub maxLevelIdc: StdVideoH265LevelIdc,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265QpKHR {
	pub qpI: i32,
	pub qpP: i32,
	pub qpB: i32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265QualityLevelPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub preferredRateControlFlags: VkVideoEncodeH265RateControlFlagsKHR,
	pub preferredGopFrameCount: u32,
	pub preferredIdrPeriod: u32,
	pub preferredConsecutiveBFrameCount: u32,
	pub preferredSubLayerCount: u32,
	pub preferredConstantQp: VkVideoEncodeH265QpKHR,
	pub preferredMaxL0ReferenceCount: u32,
	pub preferredMaxL1ReferenceCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265SessionParametersAddInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdVPSCount: u32,
	pub pStdVPSs: *const StdVideoH265VideoParameterSet,
	pub stdSPSCount: u32,
	pub pStdSPSs: *const StdVideoH265SequenceParameterSet,
	pub stdPPSCount: u32,
	pub pStdPPSs: *const StdVideoH265PictureParameterSet,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265SessionParametersCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maxStdVPSCount: u32,
	pub maxStdSPSCount: u32,
	pub maxStdPPSCount: u32,
	pub pParametersAddInfo: *const VkVideoEncodeH265SessionParametersAddInfoKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265SessionParametersGetInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub writeStdVPS: VkBool32,
	pub writeStdSPS: VkBool32,
	pub writeStdPPS: VkBool32,
	pub stdVPSId: u32,
	pub stdSPSId: u32,
	pub stdPPSId: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265SessionParametersFeedbackInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub hasStdVPSOverrides: VkBool32,
	pub hasStdSPSOverrides: VkBool32,
	pub hasStdPPSOverrides: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265NaluSliceSegmentInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub constantQp: i32,
	pub pStdSliceSegmentHeader: *const StdVideoEncodeH265SliceSegmentHeader,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265PictureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub naluSliceSegmentEntryCount: u32,
	pub pNaluSliceSegmentEntries: *const VkVideoEncodeH265NaluSliceSegmentInfoKHR,
	pub pStdPictureInfo: *const StdVideoEncodeH265PictureInfo,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265DpbSlotInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdReferenceInfo: *const StdVideoEncodeH265ReferenceInfo,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265ProfileInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdProfileIdc: StdVideoH265ProfileIdc,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265RateControlInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoEncodeH265RateControlFlagsKHR,
	pub gopFrameCount: u32,
	pub idrPeriod: u32,
	pub consecutiveBFrameCount: u32,
	pub subLayerCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265FrameSizeKHR {
	pub frameISize: u32,
	pub framePSize: u32,
	pub frameBSize: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265RateControlLayerInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useMinQp: VkBool32,
	pub minQp: VkVideoEncodeH265QpKHR,
	pub useMaxQp: VkBool32,
	pub maxQp: VkVideoEncodeH265QpKHR,
	pub useMaxFrameSize: VkBool32,
	pub maxFrameSize: VkVideoEncodeH265FrameSizeKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265GopRemainingFrameInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useGopRemainingFrames: VkBool32,
	pub gopRemainingI: u32,
	pub gopRemainingP: u32,
	pub gopRemainingB: u32,
}
pub trait VK_KHR_video_encode_h265: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_encode_h265 {}
impl VK_KHR_video_encode_h265 for Vulkan_KHR_video_encode_h265 {}
impl Default for Vulkan_KHR_video_encode_h265 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_encode_h265 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const STD_VIDEO_H265_CPB_CNT_LIST_SIZE: u32 = 32u32;
pub const STD_VIDEO_H265_SUBLAYERS_LIST_SIZE: u32 = 7u32;
pub const STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS: u32 = 6u32;
pub const STD_VIDEO_H265_SCALING_LIST_4X4_NUM_ELEMENTS: u32 = 16u32;
pub const STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS: u32 = 6u32;
pub const STD_VIDEO_H265_SCALING_LIST_8X8_NUM_ELEMENTS: u32 = 64u32;
pub const STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS: u32 = 6u32;
pub const STD_VIDEO_H265_SCALING_LIST_16X16_NUM_ELEMENTS: u32 = 64u32;
pub const STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS: u32 = 2u32;
pub const STD_VIDEO_H265_SCALING_LIST_32X32_NUM_ELEMENTS: u32 = 64u32;
pub const STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE: u32 = 6u32;
pub const STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE: u32 = 19u32;
pub const STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE: u32 = 21u32;
pub const STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE: u32 = 3u32;
pub const STD_VIDEO_H265_PREDICTOR_PALETTE_COMP_ENTRIES_LIST_SIZE: u32 = 128u32;
pub const STD_VIDEO_H265_MAX_NUM_LIST_REF: u32 = 15u32;
pub const STD_VIDEO_H265_MAX_CHROMA_PLANES: u32 = 2u32;
pub const STD_VIDEO_H265_MAX_SHORT_TERM_REF_PIC_SETS: u32 = 64u32;
pub const STD_VIDEO_H265_MAX_DPB_SIZE: u32 = 16u32;
pub const STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS: u32 = 32u32;
pub const STD_VIDEO_H265_MAX_LONG_TERM_PICS: u32 = 16u32;
pub const STD_VIDEO_H265_MAX_DELTA_POC: u32 = 48u32;
pub const STD_VIDEO_H265_NO_REFERENCE_PICTURE: u32 = 0xffu32;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH265ChromaFormatIdc {
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_MONOCHROME = 0,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_420 = 1,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_422 = 2,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_444 = 3,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH265ChromaFormatIdc {
	pub const STD_VIDEO_H265_CHROMA_FORMAT_IDC_MAX_ENUM: StdVideoH265ChromaFormatIdc = StdVideoH265ChromaFormatIdc::STD_VIDEO_H265_CHROMA_FORMAT_IDC_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH265ProfileIdc {
	STD_VIDEO_H265_PROFILE_IDC_MAIN = 1,
	STD_VIDEO_H265_PROFILE_IDC_MAIN_10 = 2,
	STD_VIDEO_H265_PROFILE_IDC_MAIN_STILL_PICTURE = 3,
	STD_VIDEO_H265_PROFILE_IDC_FORMAT_RANGE_EXTENSIONS = 4,
	STD_VIDEO_H265_PROFILE_IDC_SCC_EXTENSIONS = 9,
	STD_VIDEO_H265_PROFILE_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH265ProfileIdc {
	pub const STD_VIDEO_H265_PROFILE_IDC_MAX_ENUM: StdVideoH265ProfileIdc = StdVideoH265ProfileIdc::STD_VIDEO_H265_PROFILE_IDC_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH265LevelIdc {
	STD_VIDEO_H265_LEVEL_IDC_1_0 = 0,
	STD_VIDEO_H265_LEVEL_IDC_2_0 = 1,
	STD_VIDEO_H265_LEVEL_IDC_2_1 = 2,
	STD_VIDEO_H265_LEVEL_IDC_3_0 = 3,
	STD_VIDEO_H265_LEVEL_IDC_3_1 = 4,
	STD_VIDEO_H265_LEVEL_IDC_4_0 = 5,
	STD_VIDEO_H265_LEVEL_IDC_4_1 = 6,
	STD_VIDEO_H265_LEVEL_IDC_5_0 = 7,
	STD_VIDEO_H265_LEVEL_IDC_5_1 = 8,
	STD_VIDEO_H265_LEVEL_IDC_5_2 = 9,
	STD_VIDEO_H265_LEVEL_IDC_6_0 = 10,
	STD_VIDEO_H265_LEVEL_IDC_6_1 = 11,
	STD_VIDEO_H265_LEVEL_IDC_6_2 = 12,
	STD_VIDEO_H265_LEVEL_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH265LevelIdc {
	pub const STD_VIDEO_H265_LEVEL_IDC_MAX_ENUM: StdVideoH265LevelIdc = StdVideoH265LevelIdc::STD_VIDEO_H265_LEVEL_IDC_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH265SliceType {
	STD_VIDEO_H265_SLICE_TYPE_B = 0,
	STD_VIDEO_H265_SLICE_TYPE_P = 1,
	STD_VIDEO_H265_SLICE_TYPE_I = 2,
	STD_VIDEO_H265_SLICE_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoH265SliceType {
	pub const STD_VIDEO_H265_SLICE_TYPE_MAX_ENUM: StdVideoH265SliceType = StdVideoH265SliceType::STD_VIDEO_H265_SLICE_TYPE_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH265PictureType {
	STD_VIDEO_H265_PICTURE_TYPE_P = 0,
	STD_VIDEO_H265_PICTURE_TYPE_B = 1,
	STD_VIDEO_H265_PICTURE_TYPE_I = 2,
	STD_VIDEO_H265_PICTURE_TYPE_IDR = 3,
	STD_VIDEO_H265_PICTURE_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoH265PictureType {
	pub const STD_VIDEO_H265_PICTURE_TYPE_MAX_ENUM: StdVideoH265PictureType = StdVideoH265PictureType::STD_VIDEO_H265_PICTURE_TYPE_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH265AspectRatioIdc {
	STD_VIDEO_H265_ASPECT_RATIO_IDC_UNSPECIFIED = 0,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_SQUARE = 1,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_12_11 = 2,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_10_11 = 3,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_16_11 = 4,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_40_33 = 5,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_24_11 = 6,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_20_11 = 7,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_32_11 = 8,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_80_33 = 9,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_18_11 = 10,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_15_11 = 11,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_64_33 = 12,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_160_99 = 13,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_4_3 = 14,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_3_2 = 15,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_2_1 = 16,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_EXTENDED_SAR = 255,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH265AspectRatioIdc {
	pub const STD_VIDEO_H265_ASPECT_RATIO_IDC_MAX_ENUM: StdVideoH265AspectRatioIdc = StdVideoH265AspectRatioIdc::STD_VIDEO_H265_ASPECT_RATIO_IDC_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265DecPicBufMgr {
	pub max_latency_increase_plus1: [u32; STD_VIDEO_H265_SUBLAYERS_LIST_SIZE as usize],
	pub max_dec_pic_buffering_minus1: [u8; STD_VIDEO_H265_SUBLAYERS_LIST_SIZE as usize],
	pub max_num_reorder_pics: [u8; STD_VIDEO_H265_SUBLAYERS_LIST_SIZE as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265SubLayerHrdParameters {
	pub bit_rate_value_minus1: [u32; STD_VIDEO_H265_CPB_CNT_LIST_SIZE as usize],
	pub cpb_size_value_minus1: [u32; STD_VIDEO_H265_CPB_CNT_LIST_SIZE as usize],
	pub cpb_size_du_value_minus1: [u32; STD_VIDEO_H265_CPB_CNT_LIST_SIZE as usize],
	pub bit_rate_du_value_minus1: [u32; STD_VIDEO_H265_CPB_CNT_LIST_SIZE as usize],
	pub cbr_flag: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265HrdFlags {
	/// Bitfield: nal_hrd_parameters_present_flag: u32 in 1 bits
	/// Bitfield: vcl_hrd_parameters_present_flag: u32 in 1 bits
	/// Bitfield: sub_pic_hrd_params_present_flag: u32 in 1 bits
	/// Bitfield: sub_pic_cpb_params_in_pic_timing_sei_flag: u32 in 1 bits
	/// Bitfield: fixed_pic_rate_general_flag: u32 in 8 bits
	/// Bitfield: fixed_pic_rate_within_cvs_flag: u32 in 8 bits
	/// Bitfield: low_delay_hrd_flag: u32 in 8 bits
	pub bitfield1: u32,
}
impl StdVideoH265HrdFlags {
	pub fn get_nal_hrd_parameters_present_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_nal_hrd_parameters_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_vcl_hrd_parameters_present_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_vcl_hrd_parameters_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_sub_pic_hrd_params_present_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_sub_pic_hrd_params_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_sub_pic_cpb_params_in_pic_timing_sei_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_sub_pic_cpb_params_in_pic_timing_sei_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_fixed_pic_rate_general_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0xff
	}
	pub fn set_fixed_pic_rate_general_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0xff) << 4;
	}
	pub fn get_fixed_pic_rate_within_cvs_flag(&self) -> u32 {
		(self.bitfield1 >> 12) & 0xff
	}
	pub fn set_fixed_pic_rate_within_cvs_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0xff) << 12;
	}
	pub fn get_low_delay_hrd_flag(&self) -> u32 {
		(self.bitfield1 >> 20) & 0xff
	}
	pub fn set_low_delay_hrd_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0xff) << 20;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265HrdParameters {
	pub flags: StdVideoH265HrdFlags,
	pub tick_divisor_minus2: u8,
	pub du_cpb_removal_delay_increment_length_minus1: u8,
	pub dpb_output_delay_du_length_minus1: u8,
	pub bit_rate_scale: u8,
	pub cpb_size_scale: u8,
	pub cpb_size_du_scale: u8,
	pub initial_cpb_removal_delay_length_minus1: u8,
	pub au_cpb_removal_delay_length_minus1: u8,
	pub dpb_output_delay_length_minus1: u8,
	pub cpb_cnt_minus1: [u8; STD_VIDEO_H265_SUBLAYERS_LIST_SIZE as usize],
	pub elemental_duration_in_tc_minus1: [u16; STD_VIDEO_H265_SUBLAYERS_LIST_SIZE as usize],
	pub reserved: [u16; 3 as usize],
	pub pSubLayerHrdParametersNal: *const StdVideoH265SubLayerHrdParameters,
	pub pSubLayerHrdParametersVcl: *const StdVideoH265SubLayerHrdParameters,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265VpsFlags {
	/// Bitfield: vps_temporal_id_nesting_flag: u32 in 1 bits
	/// Bitfield: vps_sub_layer_ordering_info_present_flag: u32 in 1 bits
	/// Bitfield: vps_timing_info_present_flag: u32 in 1 bits
	/// Bitfield: vps_poc_proportional_to_timing_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH265VpsFlags {
	pub fn get_vps_temporal_id_nesting_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_vps_temporal_id_nesting_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_vps_sub_layer_ordering_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_vps_sub_layer_ordering_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_vps_timing_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_vps_timing_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_vps_poc_proportional_to_timing_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_vps_poc_proportional_to_timing_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265ProfileTierLevelFlags {
	/// Bitfield: general_tier_flag: u32 in 1 bits
	/// Bitfield: general_progressive_source_flag: u32 in 1 bits
	/// Bitfield: general_interlaced_source_flag: u32 in 1 bits
	/// Bitfield: general_non_packed_constraint_flag: u32 in 1 bits
	/// Bitfield: general_frame_only_constraint_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH265ProfileTierLevelFlags {
	pub fn get_general_tier_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_general_tier_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_general_progressive_source_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_general_progressive_source_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_general_interlaced_source_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_general_interlaced_source_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_general_non_packed_constraint_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_general_non_packed_constraint_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_general_frame_only_constraint_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_general_frame_only_constraint_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265ProfileTierLevel {
	pub flags: StdVideoH265ProfileTierLevelFlags,
	pub general_profile_idc: StdVideoH265ProfileIdc,
	pub general_level_idc: StdVideoH265LevelIdc,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265VideoParameterSet {
	pub flags: StdVideoH265VpsFlags,
	pub vps_video_parameter_set_id: u8,
	pub vps_max_sub_layers_minus1: u8,
	pub reserved1: u8,
	pub reserved2: u8,
	pub vps_num_units_in_tick: u32,
	pub vps_time_scale: u32,
	pub vps_num_ticks_poc_diff_one_minus1: u32,
	pub reserved3: u32,
	pub pDecPicBufMgr: *const StdVideoH265DecPicBufMgr,
	pub pHrdParameters: *const StdVideoH265HrdParameters,
	pub pProfileTierLevel: *const StdVideoH265ProfileTierLevel,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265ScalingLists {
	pub ScalingList4x4: [u8; STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS as usize],
	pub ScalingList8x8: [u8; STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS as usize],
	pub ScalingList16x16: [u8; STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS as usize],
	pub ScalingList32x32: [u8; STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS as usize],
	pub ScalingListDCCoef16x16: [u8; STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS as usize],
	pub ScalingListDCCoef32x32: [u8; STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265SpsVuiFlags {
	/// Bitfield: aspect_ratio_info_present_flag: u32 in 1 bits
	/// Bitfield: overscan_info_present_flag: u32 in 1 bits
	/// Bitfield: overscan_appropriate_flag: u32 in 1 bits
	/// Bitfield: video_signal_type_present_flag: u32 in 1 bits
	/// Bitfield: video_full_range_flag: u32 in 1 bits
	/// Bitfield: colour_description_present_flag: u32 in 1 bits
	/// Bitfield: chroma_loc_info_present_flag: u32 in 1 bits
	/// Bitfield: neutral_chroma_indication_flag: u32 in 1 bits
	/// Bitfield: field_seq_flag: u32 in 1 bits
	/// Bitfield: frame_field_info_present_flag: u32 in 1 bits
	/// Bitfield: default_display_window_flag: u32 in 1 bits
	/// Bitfield: vui_timing_info_present_flag: u32 in 1 bits
	/// Bitfield: vui_poc_proportional_to_timing_flag: u32 in 1 bits
	/// Bitfield: vui_hrd_parameters_present_flag: u32 in 1 bits
	/// Bitfield: bitstream_restriction_flag: u32 in 1 bits
	/// Bitfield: tiles_fixed_structure_flag: u32 in 1 bits
	/// Bitfield: motion_vectors_over_pic_boundaries_flag: u32 in 1 bits
	/// Bitfield: restricted_ref_pic_lists_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH265SpsVuiFlags {
	pub fn get_aspect_ratio_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_aspect_ratio_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_overscan_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_overscan_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_overscan_appropriate_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_overscan_appropriate_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_video_signal_type_present_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_video_signal_type_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_video_full_range_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_video_full_range_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_colour_description_present_flag(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_colour_description_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_chroma_loc_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_chroma_loc_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_neutral_chroma_indication_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_neutral_chroma_indication_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_field_seq_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_field_seq_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_frame_field_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_frame_field_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_default_display_window_flag(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_default_display_window_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_vui_timing_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_vui_timing_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
	pub fn get_vui_poc_proportional_to_timing_flag(&self) -> u32 {
		(self.bitfield1 >> 12) & 0x1
	}
	pub fn set_vui_poc_proportional_to_timing_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 12;
	}
	pub fn get_vui_hrd_parameters_present_flag(&self) -> u32 {
		(self.bitfield1 >> 13) & 0x1
	}
	pub fn set_vui_hrd_parameters_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 13;
	}
	pub fn get_bitstream_restriction_flag(&self) -> u32 {
		(self.bitfield1 >> 14) & 0x1
	}
	pub fn set_bitstream_restriction_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 14;
	}
	pub fn get_tiles_fixed_structure_flag(&self) -> u32 {
		(self.bitfield1 >> 15) & 0x1
	}
	pub fn set_tiles_fixed_structure_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 15;
	}
	pub fn get_motion_vectors_over_pic_boundaries_flag(&self) -> u32 {
		(self.bitfield1 >> 16) & 0x1
	}
	pub fn set_motion_vectors_over_pic_boundaries_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 16;
	}
	pub fn get_restricted_ref_pic_lists_flag(&self) -> u32 {
		(self.bitfield1 >> 17) & 0x1
	}
	pub fn set_restricted_ref_pic_lists_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 17;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265SequenceParameterSetVui {
	pub flags: StdVideoH265SpsVuiFlags,
	pub aspect_ratio_idc: StdVideoH265AspectRatioIdc,
	pub sar_width: u16,
	pub sar_height: u16,
	pub video_format: u8,
	pub colour_primaries: u8,
	pub transfer_characteristics: u8,
	pub matrix_coeffs: u8,
	pub chroma_sample_loc_type_top_field: u8,
	pub chroma_sample_loc_type_bottom_field: u8,
	pub reserved1: u8,
	pub reserved2: u8,
	pub def_disp_win_left_offset: u16,
	pub def_disp_win_right_offset: u16,
	pub def_disp_win_top_offset: u16,
	pub def_disp_win_bottom_offset: u16,
	pub vui_num_units_in_tick: u32,
	pub vui_time_scale: u32,
	pub vui_num_ticks_poc_diff_one_minus1: u32,
	pub min_spatial_segmentation_idc: u16,
	pub reserved3: u16,
	pub max_bytes_per_pic_denom: u8,
	pub max_bits_per_min_cu_denom: u8,
	pub log2_max_mv_length_horizontal: u8,
	pub log2_max_mv_length_vertical: u8,
	pub pHrdParameters: *const StdVideoH265HrdParameters,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265PredictorPaletteEntries {
	pub PredictorPaletteEntries: [u16; STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265SpsFlags {
	/// Bitfield: sps_temporal_id_nesting_flag: u32 in 1 bits
	/// Bitfield: separate_colour_plane_flag: u32 in 1 bits
	/// Bitfield: conformance_window_flag: u32 in 1 bits
	/// Bitfield: sps_sub_layer_ordering_info_present_flag: u32 in 1 bits
	/// Bitfield: scaling_list_enabled_flag: u32 in 1 bits
	/// Bitfield: sps_scaling_list_data_present_flag: u32 in 1 bits
	/// Bitfield: amp_enabled_flag: u32 in 1 bits
	/// Bitfield: sample_adaptive_offset_enabled_flag: u32 in 1 bits
	/// Bitfield: pcm_enabled_flag: u32 in 1 bits
	/// Bitfield: pcm_loop_filter_disabled_flag: u32 in 1 bits
	/// Bitfield: long_term_ref_pics_present_flag: u32 in 1 bits
	/// Bitfield: sps_temporal_mvp_enabled_flag: u32 in 1 bits
	/// Bitfield: strong_intra_smoothing_enabled_flag: u32 in 1 bits
	/// Bitfield: vui_parameters_present_flag: u32 in 1 bits
	/// Bitfield: sps_extension_present_flag: u32 in 1 bits
	/// Bitfield: sps_range_extension_flag: u32 in 1 bits
	/// Bitfield: transform_skip_rotation_enabled_flag: u32 in 1 bits
	/// Bitfield: transform_skip_context_enabled_flag: u32 in 1 bits
	/// Bitfield: implicit_rdpcm_enabled_flag: u32 in 1 bits
	/// Bitfield: explicit_rdpcm_enabled_flag: u32 in 1 bits
	/// Bitfield: extended_precision_processing_flag: u32 in 1 bits
	/// Bitfield: intra_smoothing_disabled_flag: u32 in 1 bits
	/// Bitfield: high_precision_offsets_enabled_flag: u32 in 1 bits
	/// Bitfield: persistent_rice_adaptation_enabled_flag: u32 in 1 bits
	/// Bitfield: cabac_bypass_alignment_enabled_flag: u32 in 1 bits
	/// Bitfield: sps_scc_extension_flag: u32 in 1 bits
	/// Bitfield: sps_curr_pic_ref_enabled_flag: u32 in 1 bits
	/// Bitfield: palette_mode_enabled_flag: u32 in 1 bits
	/// Bitfield: sps_palette_predictor_initializers_present_flag: u32 in 1 bits
	/// Bitfield: intra_boundary_filtering_disabled_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH265SpsFlags {
	pub fn get_sps_temporal_id_nesting_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_sps_temporal_id_nesting_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_separate_colour_plane_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_separate_colour_plane_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_conformance_window_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_conformance_window_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_sps_sub_layer_ordering_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_sps_sub_layer_ordering_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_scaling_list_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_scaling_list_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_sps_scaling_list_data_present_flag(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_sps_scaling_list_data_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_amp_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_amp_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_sample_adaptive_offset_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_sample_adaptive_offset_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_pcm_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_pcm_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_pcm_loop_filter_disabled_flag(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_pcm_loop_filter_disabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_long_term_ref_pics_present_flag(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_long_term_ref_pics_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_sps_temporal_mvp_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_sps_temporal_mvp_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
	pub fn get_strong_intra_smoothing_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 12) & 0x1
	}
	pub fn set_strong_intra_smoothing_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 12;
	}
	pub fn get_vui_parameters_present_flag(&self) -> u32 {
		(self.bitfield1 >> 13) & 0x1
	}
	pub fn set_vui_parameters_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 13;
	}
	pub fn get_sps_extension_present_flag(&self) -> u32 {
		(self.bitfield1 >> 14) & 0x1
	}
	pub fn set_sps_extension_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 14;
	}
	pub fn get_sps_range_extension_flag(&self) -> u32 {
		(self.bitfield1 >> 15) & 0x1
	}
	pub fn set_sps_range_extension_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 15;
	}
	pub fn get_transform_skip_rotation_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 16) & 0x1
	}
	pub fn set_transform_skip_rotation_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 16;
	}
	pub fn get_transform_skip_context_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 17) & 0x1
	}
	pub fn set_transform_skip_context_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 17;
	}
	pub fn get_implicit_rdpcm_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 18) & 0x1
	}
	pub fn set_implicit_rdpcm_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 18;
	}
	pub fn get_explicit_rdpcm_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 19) & 0x1
	}
	pub fn set_explicit_rdpcm_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 19;
	}
	pub fn get_extended_precision_processing_flag(&self) -> u32 {
		(self.bitfield1 >> 20) & 0x1
	}
	pub fn set_extended_precision_processing_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 20;
	}
	pub fn get_intra_smoothing_disabled_flag(&self) -> u32 {
		(self.bitfield1 >> 21) & 0x1
	}
	pub fn set_intra_smoothing_disabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 21;
	}
	pub fn get_high_precision_offsets_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 22) & 0x1
	}
	pub fn set_high_precision_offsets_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 22;
	}
	pub fn get_persistent_rice_adaptation_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 23) & 0x1
	}
	pub fn set_persistent_rice_adaptation_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 23;
	}
	pub fn get_cabac_bypass_alignment_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 24) & 0x1
	}
	pub fn set_cabac_bypass_alignment_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 24;
	}
	pub fn get_sps_scc_extension_flag(&self) -> u32 {
		(self.bitfield1 >> 25) & 0x1
	}
	pub fn set_sps_scc_extension_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 25;
	}
	pub fn get_sps_curr_pic_ref_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 26) & 0x1
	}
	pub fn set_sps_curr_pic_ref_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 26;
	}
	pub fn get_palette_mode_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 27) & 0x1
	}
	pub fn set_palette_mode_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 27;
	}
	pub fn get_sps_palette_predictor_initializers_present_flag(&self) -> u32 {
		(self.bitfield1 >> 28) & 0x1
	}
	pub fn set_sps_palette_predictor_initializers_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 28;
	}
	pub fn get_intra_boundary_filtering_disabled_flag(&self) -> u32 {
		(self.bitfield1 >> 29) & 0x1
	}
	pub fn set_intra_boundary_filtering_disabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 29;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265ShortTermRefPicSetFlags {
	/// Bitfield: inter_ref_pic_set_prediction_flag: u32 in 1 bits
	/// Bitfield: delta_rps_sign: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH265ShortTermRefPicSetFlags {
	pub fn get_inter_ref_pic_set_prediction_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_inter_ref_pic_set_prediction_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_delta_rps_sign(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_delta_rps_sign(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265ShortTermRefPicSet {
	pub flags: StdVideoH265ShortTermRefPicSetFlags,
	pub delta_idx_minus1: u32,
	pub use_delta_flag: u16,
	pub abs_delta_rps_minus1: u16,
	pub used_by_curr_pic_flag: u16,
	pub used_by_curr_pic_s0_flag: u16,
	pub used_by_curr_pic_s1_flag: u16,
	pub reserved1: u16,
	pub reserved2: u8,
	pub reserved3: u8,
	pub num_negative_pics: u8,
	pub num_positive_pics: u8,
	pub delta_poc_s0_minus1: [u16; STD_VIDEO_H265_MAX_DPB_SIZE as usize],
	pub delta_poc_s1_minus1: [u16; STD_VIDEO_H265_MAX_DPB_SIZE as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265LongTermRefPicsSps {
	pub used_by_curr_pic_lt_sps_flag: u32,
	pub lt_ref_pic_poc_lsb_sps: [u32; STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265SequenceParameterSet {
	pub flags: StdVideoH265SpsFlags,
	pub chroma_format_idc: StdVideoH265ChromaFormatIdc,
	pub pic_width_in_luma_samples: u32,
	pub pic_height_in_luma_samples: u32,
	pub sps_video_parameter_set_id: u8,
	pub sps_max_sub_layers_minus1: u8,
	pub sps_seq_parameter_set_id: u8,
	pub bit_depth_luma_minus8: u8,
	pub bit_depth_chroma_minus8: u8,
	pub log2_max_pic_order_cnt_lsb_minus4: u8,
	pub log2_min_luma_coding_block_size_minus3: u8,
	pub log2_diff_max_min_luma_coding_block_size: u8,
	pub log2_min_luma_transform_block_size_minus2: u8,
	pub log2_diff_max_min_luma_transform_block_size: u8,
	pub max_transform_hierarchy_depth_inter: u8,
	pub max_transform_hierarchy_depth_intra: u8,
	pub num_short_term_ref_pic_sets: u8,
	pub num_long_term_ref_pics_sps: u8,
	pub pcm_sample_bit_depth_luma_minus1: u8,
	pub pcm_sample_bit_depth_chroma_minus1: u8,
	pub log2_min_pcm_luma_coding_block_size_minus3: u8,
	pub log2_diff_max_min_pcm_luma_coding_block_size: u8,
	pub reserved1: u8,
	pub reserved2: u8,
	pub palette_max_size: u8,
	pub delta_palette_max_predictor_size: u8,
	pub motion_vector_resolution_control_idc: u8,
	pub sps_num_palette_predictor_initializers_minus1: u8,
	pub conf_win_left_offset: u32,
	pub conf_win_right_offset: u32,
	pub conf_win_top_offset: u32,
	pub conf_win_bottom_offset: u32,
	pub pProfileTierLevel: *const StdVideoH265ProfileTierLevel,
	pub pDecPicBufMgr: *const StdVideoH265DecPicBufMgr,
	pub pScalingLists: *const StdVideoH265ScalingLists,
	pub pShortTermRefPicSet: *const StdVideoH265ShortTermRefPicSet,
	pub pLongTermRefPicsSps: *const StdVideoH265LongTermRefPicsSps,
	pub pSequenceParameterSetVui: *const StdVideoH265SequenceParameterSetVui,
	pub pPredictorPaletteEntries: *const StdVideoH265PredictorPaletteEntries,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265PpsFlags {
	/// Bitfield: dependent_slice_segments_enabled_flag: u32 in 1 bits
	/// Bitfield: output_flag_present_flag: u32 in 1 bits
	/// Bitfield: sign_data_hiding_enabled_flag: u32 in 1 bits
	/// Bitfield: cabac_init_present_flag: u32 in 1 bits
	/// Bitfield: constrained_intra_pred_flag: u32 in 1 bits
	/// Bitfield: transform_skip_enabled_flag: u32 in 1 bits
	/// Bitfield: cu_qp_delta_enabled_flag: u32 in 1 bits
	/// Bitfield: pps_slice_chroma_qp_offsets_present_flag: u32 in 1 bits
	/// Bitfield: weighted_pred_flag: u32 in 1 bits
	/// Bitfield: weighted_bipred_flag: u32 in 1 bits
	/// Bitfield: transquant_bypass_enabled_flag: u32 in 1 bits
	/// Bitfield: tiles_enabled_flag: u32 in 1 bits
	/// Bitfield: entropy_coding_sync_enabled_flag: u32 in 1 bits
	/// Bitfield: uniform_spacing_flag: u32 in 1 bits
	/// Bitfield: loop_filter_across_tiles_enabled_flag: u32 in 1 bits
	/// Bitfield: pps_loop_filter_across_slices_enabled_flag: u32 in 1 bits
	/// Bitfield: deblocking_filter_control_present_flag: u32 in 1 bits
	/// Bitfield: deblocking_filter_override_enabled_flag: u32 in 1 bits
	/// Bitfield: pps_deblocking_filter_disabled_flag: u32 in 1 bits
	/// Bitfield: pps_scaling_list_data_present_flag: u32 in 1 bits
	/// Bitfield: lists_modification_present_flag: u32 in 1 bits
	/// Bitfield: slice_segment_header_extension_present_flag: u32 in 1 bits
	/// Bitfield: pps_extension_present_flag: u32 in 1 bits
	/// Bitfield: cross_component_prediction_enabled_flag: u32 in 1 bits
	/// Bitfield: chroma_qp_offset_list_enabled_flag: u32 in 1 bits
	/// Bitfield: pps_curr_pic_ref_enabled_flag: u32 in 1 bits
	/// Bitfield: residual_adaptive_colour_transform_enabled_flag: u32 in 1 bits
	/// Bitfield: pps_slice_act_qp_offsets_present_flag: u32 in 1 bits
	/// Bitfield: pps_palette_predictor_initializers_present_flag: u32 in 1 bits
	/// Bitfield: monochrome_palette_flag: u32 in 1 bits
	/// Bitfield: pps_range_extension_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH265PpsFlags {
	pub fn get_dependent_slice_segments_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_dependent_slice_segments_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_output_flag_present_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_output_flag_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_sign_data_hiding_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_sign_data_hiding_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_cabac_init_present_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_cabac_init_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_constrained_intra_pred_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_constrained_intra_pred_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_transform_skip_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_transform_skip_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_cu_qp_delta_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_cu_qp_delta_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_pps_slice_chroma_qp_offsets_present_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_pps_slice_chroma_qp_offsets_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_weighted_pred_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_weighted_pred_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_weighted_bipred_flag(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_weighted_bipred_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_transquant_bypass_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_transquant_bypass_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_tiles_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_tiles_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
	pub fn get_entropy_coding_sync_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 12) & 0x1
	}
	pub fn set_entropy_coding_sync_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 12;
	}
	pub fn get_uniform_spacing_flag(&self) -> u32 {
		(self.bitfield1 >> 13) & 0x1
	}
	pub fn set_uniform_spacing_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 13;
	}
	pub fn get_loop_filter_across_tiles_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 14) & 0x1
	}
	pub fn set_loop_filter_across_tiles_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 14;
	}
	pub fn get_pps_loop_filter_across_slices_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 15) & 0x1
	}
	pub fn set_pps_loop_filter_across_slices_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 15;
	}
	pub fn get_deblocking_filter_control_present_flag(&self) -> u32 {
		(self.bitfield1 >> 16) & 0x1
	}
	pub fn set_deblocking_filter_control_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 16;
	}
	pub fn get_deblocking_filter_override_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 17) & 0x1
	}
	pub fn set_deblocking_filter_override_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 17;
	}
	pub fn get_pps_deblocking_filter_disabled_flag(&self) -> u32 {
		(self.bitfield1 >> 18) & 0x1
	}
	pub fn set_pps_deblocking_filter_disabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 18;
	}
	pub fn get_pps_scaling_list_data_present_flag(&self) -> u32 {
		(self.bitfield1 >> 19) & 0x1
	}
	pub fn set_pps_scaling_list_data_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 19;
	}
	pub fn get_lists_modification_present_flag(&self) -> u32 {
		(self.bitfield1 >> 20) & 0x1
	}
	pub fn set_lists_modification_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 20;
	}
	pub fn get_slice_segment_header_extension_present_flag(&self) -> u32 {
		(self.bitfield1 >> 21) & 0x1
	}
	pub fn set_slice_segment_header_extension_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 21;
	}
	pub fn get_pps_extension_present_flag(&self) -> u32 {
		(self.bitfield1 >> 22) & 0x1
	}
	pub fn set_pps_extension_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 22;
	}
	pub fn get_cross_component_prediction_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 23) & 0x1
	}
	pub fn set_cross_component_prediction_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 23;
	}
	pub fn get_chroma_qp_offset_list_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 24) & 0x1
	}
	pub fn set_chroma_qp_offset_list_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 24;
	}
	pub fn get_pps_curr_pic_ref_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 25) & 0x1
	}
	pub fn set_pps_curr_pic_ref_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 25;
	}
	pub fn get_residual_adaptive_colour_transform_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 26) & 0x1
	}
	pub fn set_residual_adaptive_colour_transform_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 26;
	}
	pub fn get_pps_slice_act_qp_offsets_present_flag(&self) -> u32 {
		(self.bitfield1 >> 27) & 0x1
	}
	pub fn set_pps_slice_act_qp_offsets_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 27;
	}
	pub fn get_pps_palette_predictor_initializers_present_flag(&self) -> u32 {
		(self.bitfield1 >> 28) & 0x1
	}
	pub fn set_pps_palette_predictor_initializers_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 28;
	}
	pub fn get_monochrome_palette_flag(&self) -> u32 {
		(self.bitfield1 >> 29) & 0x1
	}
	pub fn set_monochrome_palette_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 29;
	}
	pub fn get_pps_range_extension_flag(&self) -> u32 {
		(self.bitfield1 >> 30) & 0x1
	}
	pub fn set_pps_range_extension_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 30;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoH265PictureParameterSet {
	pub flags: StdVideoH265PpsFlags,
	pub pps_pic_parameter_set_id: u8,
	pub pps_seq_parameter_set_id: u8,
	pub sps_video_parameter_set_id: u8,
	pub num_extra_slice_header_bits: u8,
	pub num_ref_idx_l0_default_active_minus1: u8,
	pub num_ref_idx_l1_default_active_minus1: u8,
	pub init_qp_minus26: i8,
	pub diff_cu_qp_delta_depth: u8,
	pub pps_cb_qp_offset: i8,
	pub pps_cr_qp_offset: i8,
	pub pps_beta_offset_div2: i8,
	pub pps_tc_offset_div2: i8,
	pub log2_parallel_merge_level_minus2: u8,
	pub log2_max_transform_skip_block_size_minus2: u8,
	pub diff_cu_chroma_qp_offset_depth: u8,
	pub chroma_qp_offset_list_len_minus1: u8,
	pub cb_qp_offset_list: [i8; STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE as usize],
	pub cr_qp_offset_list: [i8; STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE as usize],
	pub log2_sao_offset_scale_luma: u8,
	pub log2_sao_offset_scale_chroma: u8,
	pub pps_act_y_qp_offset_plus5: i8,
	pub pps_act_cb_qp_offset_plus5: i8,
	pub pps_act_cr_qp_offset_plus3: i8,
	pub pps_num_palette_predictor_initializers: u8,
	pub luma_bit_depth_entry_minus8: u8,
	pub chroma_bit_depth_entry_minus8: u8,
	pub num_tile_columns_minus1: u8,
	pub num_tile_rows_minus1: u8,
	pub reserved1: u8,
	pub reserved2: u8,
	pub column_width_minus1: [u16; STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE as usize],
	pub row_height_minus1: [u16; STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE as usize],
	pub reserved3: u32,
	pub pScalingLists: *const StdVideoH265ScalingLists,
	pub pPredictorPaletteEntries: *const StdVideoH265PredictorPaletteEntries,
}
pub trait vulkan_video_codec_h265std: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_h265std {}
impl vulkan_video_codec_h265std for Vulkan_video_codec_h265std {}
impl Default for Vulkan_video_codec_h265std {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_h265std {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_API_VERSION_1_0_0: u32 = 0x400000;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH265WeightTableFlags {
	pub luma_weight_l0_flag: u16,
	pub chroma_weight_l0_flag: u16,
	pub luma_weight_l1_flag: u16,
	pub chroma_weight_l1_flag: u16,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH265WeightTable {
	pub flags: StdVideoEncodeH265WeightTableFlags,
	pub luma_log2_weight_denom: u8,
	pub delta_chroma_log2_weight_denom: i8,
	pub delta_luma_weight_l0: [i8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub luma_offset_l0: [i8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub delta_chroma_weight_l0: [i8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub delta_chroma_offset_l0: [i8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub delta_luma_weight_l1: [i8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub luma_offset_l1: [i8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub delta_chroma_weight_l1: [i8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub delta_chroma_offset_l1: [i8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH265SliceSegmentHeaderFlags {
	/// Bitfield: first_slice_segment_in_pic_flag: u32 in 1 bits
	/// Bitfield: dependent_slice_segment_flag: u32 in 1 bits
	/// Bitfield: slice_sao_luma_flag: u32 in 1 bits
	/// Bitfield: slice_sao_chroma_flag: u32 in 1 bits
	/// Bitfield: num_ref_idx_active_override_flag: u32 in 1 bits
	/// Bitfield: mvd_l1_zero_flag: u32 in 1 bits
	/// Bitfield: cabac_init_flag: u32 in 1 bits
	/// Bitfield: cu_chroma_qp_offset_enabled_flag: u32 in 1 bits
	/// Bitfield: deblocking_filter_override_flag: u32 in 1 bits
	/// Bitfield: slice_deblocking_filter_disabled_flag: u32 in 1 bits
	/// Bitfield: collocated_from_l0_flag: u32 in 1 bits
	/// Bitfield: slice_loop_filter_across_slices_enabled_flag: u32 in 1 bits
	/// Bitfield: reserved: u32 in 20 bits
	bitfield1: u32,
}
impl StdVideoEncodeH265SliceSegmentHeaderFlags {
	pub fn get_first_slice_segment_in_pic_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_first_slice_segment_in_pic_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_dependent_slice_segment_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_dependent_slice_segment_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_slice_sao_luma_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_slice_sao_luma_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_slice_sao_chroma_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_slice_sao_chroma_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_num_ref_idx_active_override_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_num_ref_idx_active_override_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_mvd_l1_zero_flag(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_mvd_l1_zero_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_cabac_init_flag(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_cabac_init_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_cu_chroma_qp_offset_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_cu_chroma_qp_offset_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_deblocking_filter_override_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_deblocking_filter_override_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_slice_deblocking_filter_disabled_flag(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_slice_deblocking_filter_disabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_collocated_from_l0_flag(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_collocated_from_l0_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_slice_loop_filter_across_slices_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_slice_loop_filter_across_slices_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 12) & 0xfffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0xfffff) << 12;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH265SliceSegmentHeader {
	pub flags: StdVideoEncodeH265SliceSegmentHeaderFlags,
	pub slice_type: StdVideoH265SliceType,
	pub slice_segment_address: u32,
	pub collocated_ref_idx: u8,
	pub MaxNumMergeCand: u8,
	pub slice_cb_qp_offset: i8,
	pub slice_cr_qp_offset: i8,
	pub slice_beta_offset_div2: i8,
	pub slice_tc_offset_div2: i8,
	pub slice_act_y_qp_offset: i8,
	pub slice_act_cb_qp_offset: i8,
	pub slice_act_cr_qp_offset: i8,
	pub slice_qp_delta: i8,
	pub reserved1: u16,
	pub pWeightTable: *const StdVideoEncodeH265WeightTable,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH265ReferenceListsInfoFlags {
	/// Bitfield: ref_pic_list_modification_flag_l0: u32 in 1 bits
	/// Bitfield: ref_pic_list_modification_flag_l1: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoEncodeH265ReferenceListsInfoFlags {
	pub fn get_ref_pic_list_modification_flag_l0(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_ref_pic_list_modification_flag_l0(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_ref_pic_list_modification_flag_l1(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_ref_pic_list_modification_flag_l1(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH265ReferenceListsInfo {
	pub flags: StdVideoEncodeH265ReferenceListsInfoFlags,
	pub num_ref_idx_l0_active_minus1: u8,
	pub num_ref_idx_l1_active_minus1: u8,
	pub RefPicList0: [u8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub RefPicList1: [u8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub list_entry_l0: [u8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub list_entry_l1: [u8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH265PictureInfoFlags {
	/// Bitfield: is_reference: u32 in 1 bits
	/// Bitfield: IrapPicFlag: u32 in 1 bits
	/// Bitfield: used_for_long_term_reference: u32 in 1 bits
	/// Bitfield: discardable_flag: u32 in 1 bits
	/// Bitfield: cross_layer_bla_flag: u32 in 1 bits
	/// Bitfield: pic_output_flag: u32 in 1 bits
	/// Bitfield: no_output_of_prior_pics_flag: u32 in 1 bits
	/// Bitfield: short_term_ref_pic_set_sps_flag: u32 in 1 bits
	/// Bitfield: slice_temporal_mvp_enabled_flag: u32 in 1 bits
	/// Bitfield: reserved: u32 in 23 bits
	bitfield1: u32,
}
impl StdVideoEncodeH265PictureInfoFlags {
	pub fn get_is_reference(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_is_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_IrapPicFlag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_IrapPicFlag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_used_for_long_term_reference(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_used_for_long_term_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_discardable_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_discardable_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_cross_layer_bla_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_cross_layer_bla_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_pic_output_flag(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_pic_output_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_no_output_of_prior_pics_flag(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_no_output_of_prior_pics_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_short_term_ref_pic_set_sps_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_short_term_ref_pic_set_sps_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_slice_temporal_mvp_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_slice_temporal_mvp_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x7fffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7fffff) << 9;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH265LongTermRefPics {
	pub num_long_term_sps: u8,
	pub num_long_term_pics: u8,
	pub lt_idx_sps: [u8; STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS as usize],
	pub poc_lsb_lt: [u8; STD_VIDEO_H265_MAX_LONG_TERM_PICS as usize],
	pub used_by_curr_pic_lt_flag: u16,
	pub delta_poc_msb_present_flag: [u8; STD_VIDEO_H265_MAX_DELTA_POC as usize],
	pub delta_poc_msb_cycle_lt: [u8; STD_VIDEO_H265_MAX_DELTA_POC as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH265PictureInfo {
	pub flags: StdVideoEncodeH265PictureInfoFlags,
	pub pic_type: StdVideoH265PictureType,
	pub sps_video_parameter_set_id: u8,
	pub pps_seq_parameter_set_id: u8,
	pub pps_pic_parameter_set_id: u8,
	pub short_term_ref_pic_set_idx: u8,
	pub PicOrderCntVal: i32,
	pub TemporalId: u8,
	pub reserved1: [u8; 7 as usize],
	pub pRefLists: *const StdVideoEncodeH265ReferenceListsInfo,
	pub pShortTermRefPicSet: *const StdVideoH265ShortTermRefPicSet,
	pub pLongTermRefPics: *const StdVideoEncodeH265LongTermRefPics,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH265ReferenceInfoFlags {
	/// Bitfield: used_for_long_term_reference: u32 in 1 bits
	/// Bitfield: unused_for_reference: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoEncodeH265ReferenceInfoFlags {
	pub fn get_used_for_long_term_reference(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_used_for_long_term_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_unused_for_reference(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_unused_for_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeH265ReferenceInfo {
	pub flags: StdVideoEncodeH265ReferenceInfoFlags,
	pub pic_type: StdVideoH265PictureType,
	pub PicOrderCntVal: i32,
	pub TemporalId: u8,
}
pub trait vulkan_video_codec_h265std_encode: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_h265std_encode {}
impl vulkan_video_codec_h265std_encode for Vulkan_video_codec_h265std_encode {}
impl Default for Vulkan_video_codec_h265std_encode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_h265std_encode {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkVideoDecodeH264PictureLayoutFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoDecodeH264PictureLayoutFlagBitsKHR {
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR = 0,
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR = 0x00000001,
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR = 0x00000002,
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeH264ProfileInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdProfileIdc: StdVideoH264ProfileIdc,
	pub pictureLayout: VkVideoDecodeH264PictureLayoutFlagBitsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeH264CapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxLevelIdc: StdVideoH264LevelIdc,
	pub fieldOffsetGranularity: VkOffset2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeH264SessionParametersAddInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdSPSCount: u32,
	pub pStdSPSs: *const StdVideoH264SequenceParameterSet,
	pub stdPPSCount: u32,
	pub pStdPPSs: *const StdVideoH264PictureParameterSet,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeH264SessionParametersCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maxStdSPSCount: u32,
	pub maxStdPPSCount: u32,
	pub pParametersAddInfo: *const VkVideoDecodeH264SessionParametersAddInfoKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeH264PictureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdPictureInfo: *const StdVideoDecodeH264PictureInfo,
	pub sliceCount: u32,
	pub pSliceOffsets: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeH264DpbSlotInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdReferenceInfo: *const StdVideoDecodeH264ReferenceInfo,
}
pub trait VK_KHR_video_decode_h264: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_decode_h264 {}
impl VK_KHR_video_decode_h264 for Vulkan_KHR_video_decode_h264 {}
impl Default for Vulkan_KHR_video_decode_h264 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_decode_h264 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_API_VERSION_1_0_0: u32 = 0x400000;
pub const STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE: u32 = 2u32;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoDecodeH264FieldOrderCount {
	STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_TOP = 0,
	STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_BOTTOM = 1,
	STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_INVALID = 0x7fffffff,
}
impl StdVideoDecodeH264FieldOrderCount {
	pub const STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_MAX_ENUM: StdVideoDecodeH264FieldOrderCount = StdVideoDecodeH264FieldOrderCount::STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoDecodeH264PictureInfoFlags {
	/// Bitfield: field_pic_flag: u32 in 1 bits
	/// Bitfield: is_intra: u32 in 1 bits
	/// Bitfield: IdrPicFlag: u32 in 1 bits
	/// Bitfield: bottom_field_flag: u32 in 1 bits
	/// Bitfield: is_reference: u32 in 1 bits
	/// Bitfield: complementary_field_pair: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoDecodeH264PictureInfoFlags {
	pub fn get_field_pic_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_field_pic_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_is_intra(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_is_intra(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_IdrPicFlag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_IdrPicFlag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_bottom_field_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_bottom_field_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_is_reference(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_is_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_complementary_field_pair(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_complementary_field_pair(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoDecodeH264PictureInfo {
	pub flags: StdVideoDecodeH264PictureInfoFlags,
	pub seq_parameter_set_id: u8,
	pub pic_parameter_set_id: u8,
	pub reserved1: u8,
	pub reserved2: u8,
	pub frame_num: u16,
	pub idr_pic_id: u16,
	pub PicOrderCnt: [i32; STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoDecodeH264ReferenceInfoFlags {
	/// Bitfield: top_field_flag: u32 in 1 bits
	/// Bitfield: bottom_field_flag: u32 in 1 bits
	/// Bitfield: used_for_long_term_reference: u32 in 1 bits
	/// Bitfield: is_non_existing: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoDecodeH264ReferenceInfoFlags {
	pub fn get_top_field_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_top_field_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_bottom_field_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_bottom_field_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_used_for_long_term_reference(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_used_for_long_term_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_is_non_existing(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_is_non_existing(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoDecodeH264ReferenceInfo {
	pub flags: StdVideoDecodeH264ReferenceInfoFlags,
	pub FrameNum: u16,
	pub reserved: u16,
	pub PicOrderCnt: [i32; STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE as usize],
}
pub trait vulkan_video_codec_h264std_decode: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_h264std_decode {}
impl vulkan_video_codec_h264std_decode for Vulkan_video_codec_h264std_decode {}
impl Default for Vulkan_video_codec_h264std_decode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_h264std_decode {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkRenderingFlagsKHR = VkRenderingFlags;
pub type VkRenderingFlagBitsKHR = VkRenderingFlagBits;
pub type VkRenderingInfoKHR = VkRenderingInfo;
pub type VkRenderingAttachmentInfoKHR = VkRenderingAttachmentInfo;
pub type VkPipelineRenderingCreateInfoKHR = VkPipelineRenderingCreateInfo;
pub type VkPhysicalDeviceDynamicRenderingFeaturesKHR = VkPhysicalDeviceDynamicRenderingFeatures;
pub type VkCommandBufferInheritanceRenderingInfoKHR = VkCommandBufferInheritanceRenderingInfo;
type PFN_vkCmdBeginRenderingKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo);
type PFN_vkCmdEndRenderingKHR = extern "system" fn(commandBuffer: VkCommandBuffer);
extern "system" fn dummy_vkCmdBeginRenderingKHR(_: VkCommandBuffer, _: *const VkRenderingInfo) {
	panic!("Vulkan function pointer of `vkCmdBeginRenderingKHR()` is NULL");
}
pub trait VK_KHR_dynamic_rendering: Debug {
	fn vkCmdBeginRenderingKHR(&self, commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_dynamic_rendering {
	vk_cmd_begin_rendering_khr: PFN_vkCmdBeginRenderingKHR,
}
impl VK_KHR_dynamic_rendering for Vulkan_KHR_dynamic_rendering {
	fn vkCmdBeginRenderingKHR(&self, commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo) {
		(self.vk_cmd_begin_rendering_khr)(commandBuffer, pRenderingInfo)
	}
}
impl Default for Vulkan_KHR_dynamic_rendering {
	fn default() -> Self {
		Self {
			vk_cmd_begin_rendering_khr: dummy_vkCmdBeginRenderingKHR,
		}
	}
}
impl Vulkan_KHR_dynamic_rendering {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_begin_rendering_khr: {let proc = get_proc_address(instance, "vkCmdBeginRenderingKHR"); if proc == null() {dummy_vkCmdBeginRenderingKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkRenderPassMultiviewCreateInfoKHR = VkRenderPassMultiviewCreateInfo;
pub type VkPhysicalDeviceMultiviewFeaturesKHR = VkPhysicalDeviceMultiviewFeatures;
pub type VkPhysicalDeviceMultiviewPropertiesKHR = VkPhysicalDeviceMultiviewProperties;
pub trait VK_KHR_multiview: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_multiview {}
impl VK_KHR_multiview for Vulkan_KHR_multiview {}
impl Default for Vulkan_KHR_multiview {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_multiview {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceFeatures2KHR = VkPhysicalDeviceFeatures2;
pub type VkPhysicalDeviceProperties2KHR = VkPhysicalDeviceProperties2;
pub type VkFormatProperties2KHR = VkFormatProperties2;
pub type VkImageFormatProperties2KHR = VkImageFormatProperties2;
pub type VkPhysicalDeviceImageFormatInfo2KHR = VkPhysicalDeviceImageFormatInfo2;
pub type VkQueueFamilyProperties2KHR = VkQueueFamilyProperties2;
pub type VkPhysicalDeviceMemoryProperties2KHR = VkPhysicalDeviceMemoryProperties2;
pub type VkSparseImageFormatProperties2KHR = VkSparseImageFormatProperties2;
pub type VkPhysicalDeviceSparseImageFormatInfo2KHR = VkPhysicalDeviceSparseImageFormatInfo2;
type PFN_vkGetPhysicalDeviceFeatures2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2);
type PFN_vkGetPhysicalDeviceProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties2);
type PFN_vkGetPhysicalDeviceFormatProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties2);
type PFN_vkGetPhysicalDeviceImageFormatProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *mut VkImageFormatProperties2) -> VkResult;
type PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties2);
type PFN_vkGetPhysicalDeviceMemoryProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2);
type PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties2);
extern "system" fn dummy_vkGetPhysicalDeviceFeatures2KHR(_: VkPhysicalDevice, _: *mut VkPhysicalDeviceFeatures2) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceFeatures2KHR()` is NULL");
}
pub trait VK_KHR_get_physical_device_properties2: Debug {
	fn vkGetPhysicalDeviceFeatures2KHR(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_get_physical_device_properties2 {
	vk_get_physical_device_features2_khr: PFN_vkGetPhysicalDeviceFeatures2KHR,
}
impl VK_KHR_get_physical_device_properties2 for Vulkan_KHR_get_physical_device_properties2 {
	fn vkGetPhysicalDeviceFeatures2KHR(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2) {
		(self.vk_get_physical_device_features2_khr)(physicalDevice, pFeatures)
	}
}
impl Default for Vulkan_KHR_get_physical_device_properties2 {
	fn default() -> Self {
		Self {
			vk_get_physical_device_features2_khr: dummy_vkGetPhysicalDeviceFeatures2KHR,
		}
	}
}
impl Vulkan_KHR_get_physical_device_properties2 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_features2_khr: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceFeatures2KHR"); if proc == null() {dummy_vkGetPhysicalDeviceFeatures2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPeerMemoryFeatureFlagsKHR = VkPeerMemoryFeatureFlags;
pub type VkPeerMemoryFeatureFlagBitsKHR = VkPeerMemoryFeatureFlagBits;
pub type VkMemoryAllocateFlagsKHR = VkMemoryAllocateFlags;
pub type VkMemoryAllocateFlagBitsKHR = VkMemoryAllocateFlagBits;
pub type VkMemoryAllocateFlagsInfoKHR = VkMemoryAllocateFlagsInfo;
pub type VkDeviceGroupRenderPassBeginInfoKHR = VkDeviceGroupRenderPassBeginInfo;
pub type VkDeviceGroupCommandBufferBeginInfoKHR = VkDeviceGroupCommandBufferBeginInfo;
pub type VkDeviceGroupSubmitInfoKHR = VkDeviceGroupSubmitInfo;
pub type VkDeviceGroupBindSparseInfoKHR = VkDeviceGroupBindSparseInfo;
pub type VkBindBufferMemoryDeviceGroupInfoKHR = VkBindBufferMemoryDeviceGroupInfo;
pub type VkBindImageMemoryDeviceGroupInfoKHR = VkBindImageMemoryDeviceGroupInfo;
type PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR = extern "system" fn(device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags);
type PFN_vkCmdSetDeviceMaskKHR = extern "system" fn(commandBuffer: VkCommandBuffer, deviceMask: u32);
type PFN_vkCmdDispatchBaseKHR = extern "system" fn(commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32);
extern "system" fn dummy_vkGetDeviceGroupPeerMemoryFeaturesKHR(_: VkDevice, _: u32, _: u32, _: u32, _: *mut VkPeerMemoryFeatureFlags) {
	panic!("Vulkan function pointer of `vkGetDeviceGroupPeerMemoryFeaturesKHR()` is NULL");
}
pub trait VK_KHR_device_group: Debug {
	fn vkGetDeviceGroupPeerMemoryFeaturesKHR(&self, device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_device_group {
	vk_get_device_group_peer_memory_features_khr: PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR,
}
impl VK_KHR_device_group for Vulkan_KHR_device_group {
	fn vkGetDeviceGroupPeerMemoryFeaturesKHR(&self, device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags) {
		(self.vk_get_device_group_peer_memory_features_khr)(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures)
	}
}
impl Default for Vulkan_KHR_device_group {
	fn default() -> Self {
		Self {
			vk_get_device_group_peer_memory_features_khr: dummy_vkGetDeviceGroupPeerMemoryFeaturesKHR,
		}
	}
}
impl Vulkan_KHR_device_group {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_device_group_peer_memory_features_khr: {let proc = get_proc_address(instance, "vkGetDeviceGroupPeerMemoryFeaturesKHR"); if proc == null() {dummy_vkGetDeviceGroupPeerMemoryFeaturesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub trait VK_KHR_shader_draw_parameters: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_draw_parameters {}
impl VK_KHR_shader_draw_parameters for Vulkan_KHR_shader_draw_parameters {}
impl Default for Vulkan_KHR_shader_draw_parameters {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_draw_parameters {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkCommandPoolTrimFlagsKHR = VkCommandPoolTrimFlags;
type PFN_vkTrimCommandPoolKHR = extern "system" fn(device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags);
extern "system" fn dummy_vkTrimCommandPoolKHR(_: VkDevice, _: VkCommandPool, _: VkCommandPoolTrimFlags) {
	panic!("Vulkan function pointer of `vkTrimCommandPoolKHR()` is NULL");
}
pub trait VK_KHR_maintenance1: Debug {
	fn vkTrimCommandPoolKHR(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance1 {
	vk_trim_command_pool_khr: PFN_vkTrimCommandPoolKHR,
}
impl VK_KHR_maintenance1 for Vulkan_KHR_maintenance1 {
	fn vkTrimCommandPoolKHR(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) {
		(self.vk_trim_command_pool_khr)(device, commandPool, flags)
	}
}
impl Default for Vulkan_KHR_maintenance1 {
	fn default() -> Self {
		Self {
			vk_trim_command_pool_khr: dummy_vkTrimCommandPoolKHR,
		}
	}
}
impl Vulkan_KHR_maintenance1 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_trim_command_pool_khr: {let proc = get_proc_address(instance, "vkTrimCommandPoolKHR"); if proc == null() {dummy_vkTrimCommandPoolKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub const VK_MAX_DEVICE_GROUP_SIZE_KHR: u32 = 32u32;
pub type VkPhysicalDeviceGroupPropertiesKHR = VkPhysicalDeviceGroupProperties;
pub type VkDeviceGroupDeviceCreateInfoKHR = VkDeviceGroupDeviceCreateInfo;
type PFN_vkEnumeratePhysicalDeviceGroupsKHR = extern "system" fn(instance: VkInstance, pPhysicalDeviceGroupCount: *mut uint32_t, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties) -> VkResult;
extern "system" fn dummy_vkEnumeratePhysicalDeviceGroupsKHR(_: VkInstance, _: *mut uint32_t, _: *mut VkPhysicalDeviceGroupProperties) -> VkResult {
	panic!("Vulkan function pointer of `vkEnumeratePhysicalDeviceGroupsKHR()` is NULL");
}
pub trait VK_KHR_device_group_creation: Debug {
	fn vkEnumeratePhysicalDeviceGroupsKHR(&self, instance: VkInstance, pPhysicalDeviceGroupCount: *mut uint32_t, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_device_group_creation {
	vk_enumerate_physical_device_groups_khr: PFN_vkEnumeratePhysicalDeviceGroupsKHR,
}
impl VK_KHR_device_group_creation for Vulkan_KHR_device_group_creation {
	fn vkEnumeratePhysicalDeviceGroupsKHR(&self, instance: VkInstance, pPhysicalDeviceGroupCount: *mut uint32_t, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties) -> VkResult {
		(self.vk_enumerate_physical_device_groups_khr)(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties)
	}
}
impl Default for Vulkan_KHR_device_group_creation {
	fn default() -> Self {
		Self {
			vk_enumerate_physical_device_groups_khr: dummy_vkEnumeratePhysicalDeviceGroupsKHR,
		}
	}
}
impl Vulkan_KHR_device_group_creation {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_enumerate_physical_device_groups_khr: {let proc = get_proc_address(instance, "vkEnumeratePhysicalDeviceGroupsKHR"); if proc == null() {dummy_vkEnumeratePhysicalDeviceGroupsKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub const VK_LUID_SIZE_KHR: u32 = 8u32;
pub type VkExternalMemoryHandleTypeFlagsKHR = VkExternalMemoryHandleTypeFlags;
pub type VkExternalMemoryHandleTypeFlagBitsKHR = VkExternalMemoryHandleTypeFlagBits;
pub type VkExternalMemoryFeatureFlagsKHR = VkExternalMemoryFeatureFlags;
pub type VkExternalMemoryFeatureFlagBitsKHR = VkExternalMemoryFeatureFlagBits;
pub type VkExternalMemoryPropertiesKHR = VkExternalMemoryProperties;
pub type VkPhysicalDeviceExternalImageFormatInfoKHR = VkPhysicalDeviceExternalImageFormatInfo;
pub type VkExternalImageFormatPropertiesKHR = VkExternalImageFormatProperties;
pub type VkPhysicalDeviceExternalBufferInfoKHR = VkPhysicalDeviceExternalBufferInfo;
pub type VkExternalBufferPropertiesKHR = VkExternalBufferProperties;
pub type VkPhysicalDeviceIDPropertiesKHR = VkPhysicalDeviceIDProperties;
type PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut VkExternalBufferProperties);
extern "system" fn dummy_vkGetPhysicalDeviceExternalBufferPropertiesKHR(_: VkPhysicalDevice, _: *const VkPhysicalDeviceExternalBufferInfo, _: *mut VkExternalBufferProperties) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceExternalBufferPropertiesKHR()` is NULL");
}
pub trait VK_KHR_external_memory_capabilities: Debug {
	fn vkGetPhysicalDeviceExternalBufferPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut VkExternalBufferProperties);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_memory_capabilities {
	vk_get_physical_device_external_buffer_properties_khr: PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR,
}
impl VK_KHR_external_memory_capabilities for Vulkan_KHR_external_memory_capabilities {
	fn vkGetPhysicalDeviceExternalBufferPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut VkExternalBufferProperties) {
		(self.vk_get_physical_device_external_buffer_properties_khr)(physicalDevice, pExternalBufferInfo, pExternalBufferProperties)
	}
}
impl Default for Vulkan_KHR_external_memory_capabilities {
	fn default() -> Self {
		Self {
			vk_get_physical_device_external_buffer_properties_khr: dummy_vkGetPhysicalDeviceExternalBufferPropertiesKHR,
		}
	}
}
impl Vulkan_KHR_external_memory_capabilities {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_external_buffer_properties_khr: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceExternalBufferPropertiesKHR"); if proc == null() {dummy_vkGetPhysicalDeviceExternalBufferPropertiesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub const VK_QUEUE_FAMILY_EXTERNAL_KHR: u32 = !1u32;
pub type VkExternalMemoryImageCreateInfoKHR = VkExternalMemoryImageCreateInfo;
pub type VkExternalMemoryBufferCreateInfoKHR = VkExternalMemoryBufferCreateInfo;
pub type VkExportMemoryAllocateInfoKHR = VkExportMemoryAllocateInfo;
pub trait VK_KHR_external_memory: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_memory {}
impl VK_KHR_external_memory for Vulkan_KHR_external_memory {}
impl Default for Vulkan_KHR_external_memory {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_external_memory {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImportMemoryFdInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleType: VkExternalMemoryHandleTypeFlagBits,
	pub fd: i32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryFdPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryTypeBits: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryGetFdInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub memory: VkDeviceMemory,
	pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
type PFN_vkGetMemoryFdKHR = extern "system" fn(device: VkDevice, pGetFdInfo: *const VkMemoryGetFdInfoKHR, pFd: *mut int) -> VkResult;
type PFN_vkGetMemoryFdPropertiesKHR = extern "system" fn(device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, fd: i32, pMemoryFdProperties: *mut VkMemoryFdPropertiesKHR) -> VkResult;
extern "system" fn dummy_vkGetMemoryFdKHR(_: VkDevice, _: *const VkMemoryGetFdInfoKHR, _: *mut int) -> VkResult {
	panic!("Vulkan function pointer of `vkGetMemoryFdKHR()` is NULL");
}
pub trait VK_KHR_external_memory_fd: Debug {
	fn vkGetMemoryFdKHR(&self, device: VkDevice, pGetFdInfo: *const VkMemoryGetFdInfoKHR, pFd: *mut int) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_memory_fd {
	vk_get_memory_fd_khr: PFN_vkGetMemoryFdKHR,
}
impl VK_KHR_external_memory_fd for Vulkan_KHR_external_memory_fd {
	fn vkGetMemoryFdKHR(&self, device: VkDevice, pGetFdInfo: *const VkMemoryGetFdInfoKHR, pFd: *mut int) -> VkResult {
		(self.vk_get_memory_fd_khr)(device, pGetFdInfo, pFd)
	}
}
impl Default for Vulkan_KHR_external_memory_fd {
	fn default() -> Self {
		Self {
			vk_get_memory_fd_khr: dummy_vkGetMemoryFdKHR,
		}
	}
}
impl Vulkan_KHR_external_memory_fd {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_memory_fd_khr: {let proc = get_proc_address(instance, "vkGetMemoryFdKHR"); if proc == null() {dummy_vkGetMemoryFdKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkExternalSemaphoreHandleTypeFlagsKHR = VkExternalSemaphoreHandleTypeFlags;
pub type VkExternalSemaphoreHandleTypeFlagBitsKHR = VkExternalSemaphoreHandleTypeFlagBits;
pub type VkExternalSemaphoreFeatureFlagsKHR = VkExternalSemaphoreFeatureFlags;
pub type VkExternalSemaphoreFeatureFlagBitsKHR = VkExternalSemaphoreFeatureFlagBits;
pub type VkPhysicalDeviceExternalSemaphoreInfoKHR = VkPhysicalDeviceExternalSemaphoreInfo;
pub type VkExternalSemaphorePropertiesKHR = VkExternalSemaphoreProperties;
type PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties);
extern "system" fn dummy_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(_: VkPhysicalDevice, _: *const VkPhysicalDeviceExternalSemaphoreInfo, _: *mut VkExternalSemaphoreProperties) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceExternalSemaphorePropertiesKHR()` is NULL");
}
pub trait VK_KHR_external_semaphore_capabilities: Debug {
	fn vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_semaphore_capabilities {
	vk_get_physical_device_external_semaphore_properties_khr: PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR,
}
impl VK_KHR_external_semaphore_capabilities for Vulkan_KHR_external_semaphore_capabilities {
	fn vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties) {
		(self.vk_get_physical_device_external_semaphore_properties_khr)(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties)
	}
}
impl Default for Vulkan_KHR_external_semaphore_capabilities {
	fn default() -> Self {
		Self {
			vk_get_physical_device_external_semaphore_properties_khr: dummy_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR,
		}
	}
}
impl Vulkan_KHR_external_semaphore_capabilities {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_external_semaphore_properties_khr: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"); if proc == null() {dummy_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkSemaphoreImportFlagsKHR = VkSemaphoreImportFlags;
pub type VkSemaphoreImportFlagBitsKHR = VkSemaphoreImportFlagBits;
pub type VkExportSemaphoreCreateInfoKHR = VkExportSemaphoreCreateInfo;
pub trait VK_KHR_external_semaphore: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_semaphore {}
impl VK_KHR_external_semaphore for Vulkan_KHR_external_semaphore {}
impl Default for Vulkan_KHR_external_semaphore {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_external_semaphore {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImportSemaphoreFdInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub semaphore: VkSemaphore,
	pub flags: VkSemaphoreImportFlags,
	pub handleType: VkExternalSemaphoreHandleTypeFlagBits,
	pub fd: i32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSemaphoreGetFdInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub semaphore: VkSemaphore,
	pub handleType: VkExternalSemaphoreHandleTypeFlagBits,
}
type PFN_vkImportSemaphoreFdKHR = extern "system" fn(device: VkDevice, pImportSemaphoreFdInfo: *const VkImportSemaphoreFdInfoKHR) -> VkResult;
type PFN_vkGetSemaphoreFdKHR = extern "system" fn(device: VkDevice, pGetFdInfo: *const VkSemaphoreGetFdInfoKHR, pFd: *mut int) -> VkResult;
extern "system" fn dummy_vkImportSemaphoreFdKHR(_: VkDevice, _: *const VkImportSemaphoreFdInfoKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkImportSemaphoreFdKHR()` is NULL");
}
pub trait VK_KHR_external_semaphore_fd: Debug {
	fn vkImportSemaphoreFdKHR(&self, device: VkDevice, pImportSemaphoreFdInfo: *const VkImportSemaphoreFdInfoKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_semaphore_fd {
	vk_import_semaphore_fd_khr: PFN_vkImportSemaphoreFdKHR,
}
impl VK_KHR_external_semaphore_fd for Vulkan_KHR_external_semaphore_fd {
	fn vkImportSemaphoreFdKHR(&self, device: VkDevice, pImportSemaphoreFdInfo: *const VkImportSemaphoreFdInfoKHR) -> VkResult {
		(self.vk_import_semaphore_fd_khr)(device, pImportSemaphoreFdInfo)
	}
}
impl Default for Vulkan_KHR_external_semaphore_fd {
	fn default() -> Self {
		Self {
			vk_import_semaphore_fd_khr: dummy_vkImportSemaphoreFdKHR,
		}
	}
}
impl Vulkan_KHR_external_semaphore_fd {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_import_semaphore_fd_khr: {let proc = get_proc_address(instance, "vkImportSemaphoreFdKHR"); if proc == null() {dummy_vkImportSemaphoreFdKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDevicePushDescriptorPropertiesKHR = VkPhysicalDevicePushDescriptorProperties;
type PFN_vkCmdPushDescriptorSetKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet);
type PFN_vkCmdPushDescriptorSetWithTemplateKHR = extern "system" fn(commandBuffer: VkCommandBuffer, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: u32, pData: *const c_void);
extern "system" fn dummy_vkCmdPushDescriptorSetKHR(_: VkCommandBuffer, _: VkPipelineBindPoint, _: VkPipelineLayout, _: u32, _: u32, _: *const VkWriteDescriptorSet) {
	panic!("Vulkan function pointer of `vkCmdPushDescriptorSetKHR()` is NULL");
}
pub trait VK_KHR_push_descriptor: Debug {
	fn vkCmdPushDescriptorSetKHR(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_push_descriptor {
	vk_cmd_push_descriptor_set_khr: PFN_vkCmdPushDescriptorSetKHR,
}
impl VK_KHR_push_descriptor for Vulkan_KHR_push_descriptor {
	fn vkCmdPushDescriptorSetKHR(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet) {
		(self.vk_cmd_push_descriptor_set_khr)(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites)
	}
}
impl Default for Vulkan_KHR_push_descriptor {
	fn default() -> Self {
		Self {
			vk_cmd_push_descriptor_set_khr: dummy_vkCmdPushDescriptorSetKHR,
		}
	}
}
impl Vulkan_KHR_push_descriptor {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_push_descriptor_set_khr: {let proc = get_proc_address(instance, "vkCmdPushDescriptorSetKHR"); if proc == null() {dummy_vkCmdPushDescriptorSetKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceShaderFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;
pub type VkPhysicalDeviceFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;
pub trait VK_KHR_shader_float16_int8: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_float16_int8 {}
impl VK_KHR_shader_float16_int8 for Vulkan_KHR_shader_float16_int8 {}
impl Default for Vulkan_KHR_shader_float16_int8 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_float16_int8 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDevice16BitStorageFeaturesKHR = VkPhysicalDevice16BitStorageFeatures;
pub trait VK_KHR_16bit_storage: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_16bit_storage {}
impl VK_KHR_16bit_storage for Vulkan_KHR_16bit_storage {}
impl Default for Vulkan_KHR_16bit_storage {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_16bit_storage {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRectLayerKHR {
	pub offset: VkOffset2D,
	pub extent: VkExtent2D,
	pub layer: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPresentRegionKHR {
	pub rectangleCount: u32,
	pub pRectangles: *const VkRectLayerKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPresentRegionsKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount: u32,
	pub pRegions: *const VkPresentRegionKHR,
}
pub trait VK_KHR_incremental_present: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_incremental_present {}
impl VK_KHR_incremental_present for Vulkan_KHR_incremental_present {}
impl Default for Vulkan_KHR_incremental_present {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_incremental_present {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkDescriptorUpdateTemplateKHR = VkDescriptorUpdateTemplate;
pub type VkDescriptorUpdateTemplateTypeKHR = VkDescriptorUpdateTemplateType;
pub type VkDescriptorUpdateTemplateCreateFlagsKHR = VkDescriptorUpdateTemplateCreateFlags;
pub type VkDescriptorUpdateTemplateEntryKHR = VkDescriptorUpdateTemplateEntry;
pub type VkDescriptorUpdateTemplateCreateInfoKHR = VkDescriptorUpdateTemplateCreateInfo;
type PFN_vkCreateDescriptorUpdateTemplateKHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate) -> VkResult;
type PFN_vkDestroyDescriptorUpdateTemplateKHR = extern "system" fn(device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *const VkAllocationCallbacks);
type PFN_vkUpdateDescriptorSetWithTemplateKHR = extern "system" fn(device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: *const c_void);
extern "system" fn dummy_vkCreateDescriptorUpdateTemplateKHR(_: VkDevice, _: *const VkDescriptorUpdateTemplateCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkDescriptorUpdateTemplate) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateDescriptorUpdateTemplateKHR()` is NULL");
}
pub trait VK_KHR_descriptor_update_template: Debug {
	fn vkCreateDescriptorUpdateTemplateKHR(&self, device: VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_descriptor_update_template {
	vk_create_descriptor_update_template_khr: PFN_vkCreateDescriptorUpdateTemplateKHR,
}
impl VK_KHR_descriptor_update_template for Vulkan_KHR_descriptor_update_template {
	fn vkCreateDescriptorUpdateTemplateKHR(&self, device: VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate) -> VkResult {
		(self.vk_create_descriptor_update_template_khr)(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate)
	}
}
impl Default for Vulkan_KHR_descriptor_update_template {
	fn default() -> Self {
		Self {
			vk_create_descriptor_update_template_khr: dummy_vkCreateDescriptorUpdateTemplateKHR,
		}
	}
}
impl Vulkan_KHR_descriptor_update_template {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_descriptor_update_template_khr: {let proc = get_proc_address(instance, "vkCreateDescriptorUpdateTemplateKHR"); if proc == null() {dummy_vkCreateDescriptorUpdateTemplateKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceImagelessFramebufferFeaturesKHR = VkPhysicalDeviceImagelessFramebufferFeatures;
pub type VkFramebufferAttachmentsCreateInfoKHR = VkFramebufferAttachmentsCreateInfo;
pub type VkFramebufferAttachmentImageInfoKHR = VkFramebufferAttachmentImageInfo;
pub type VkRenderPassAttachmentBeginInfoKHR = VkRenderPassAttachmentBeginInfo;
pub trait VK_KHR_imageless_framebuffer: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_imageless_framebuffer {}
impl VK_KHR_imageless_framebuffer for Vulkan_KHR_imageless_framebuffer {}
impl Default for Vulkan_KHR_imageless_framebuffer {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_imageless_framebuffer {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkRenderPassCreateInfo2KHR = VkRenderPassCreateInfo2;
pub type VkAttachmentDescription2KHR = VkAttachmentDescription2;
pub type VkAttachmentReference2KHR = VkAttachmentReference2;
pub type VkSubpassDescription2KHR = VkSubpassDescription2;
pub type VkSubpassDependency2KHR = VkSubpassDependency2;
pub type VkSubpassBeginInfoKHR = VkSubpassBeginInfo;
pub type VkSubpassEndInfoKHR = VkSubpassEndInfo;
type PFN_vkCreateRenderPass2KHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo2, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult;
type PFN_vkCmdBeginRenderPass2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, pSubpassBeginInfo: *const VkSubpassBeginInfo);
type PFN_vkCmdNextSubpass2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pSubpassBeginInfo: *const VkSubpassBeginInfo, pSubpassEndInfo: *const VkSubpassEndInfo);
type PFN_vkCmdEndRenderPass2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pSubpassEndInfo: *const VkSubpassEndInfo);
extern "system" fn dummy_vkCreateRenderPass2KHR(_: VkDevice, _: *const VkRenderPassCreateInfo2, _: *const VkAllocationCallbacks, _: *mut VkRenderPass) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateRenderPass2KHR()` is NULL");
}
pub trait VK_KHR_create_renderpass2: Debug {
	fn vkCreateRenderPass2KHR(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo2, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_create_renderpass2 {
	vk_create_render_pass2_khr: PFN_vkCreateRenderPass2KHR,
}
impl VK_KHR_create_renderpass2 for Vulkan_KHR_create_renderpass2 {
	fn vkCreateRenderPass2KHR(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo2, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult {
		(self.vk_create_render_pass2_khr)(device, pCreateInfo, pAllocator, pRenderPass)
	}
}
impl Default for Vulkan_KHR_create_renderpass2 {
	fn default() -> Self {
		Self {
			vk_create_render_pass2_khr: dummy_vkCreateRenderPass2KHR,
		}
	}
}
impl Vulkan_KHR_create_renderpass2 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_render_pass2_khr: {let proc = get_proc_address(instance, "vkCreateRenderPass2KHR"); if proc == null() {dummy_vkCreateRenderPass2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSharedPresentSurfaceCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub sharedPresentSupportedUsageFlags: VkImageUsageFlags,
}
type PFN_vkGetSwapchainStatusKHR = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR) -> VkResult;
extern "system" fn dummy_vkGetSwapchainStatusKHR(_: VkDevice, _: VkSwapchainKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkGetSwapchainStatusKHR()` is NULL");
}
pub trait VK_KHR_shared_presentable_image: Debug {
	fn vkGetSwapchainStatusKHR(&self, device: VkDevice, swapchain: VkSwapchainKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shared_presentable_image {
	vk_get_swapchain_status_khr: PFN_vkGetSwapchainStatusKHR,
}
impl VK_KHR_shared_presentable_image for Vulkan_KHR_shared_presentable_image {
	fn vkGetSwapchainStatusKHR(&self, device: VkDevice, swapchain: VkSwapchainKHR) -> VkResult {
		(self.vk_get_swapchain_status_khr)(device, swapchain)
	}
}
impl Default for Vulkan_KHR_shared_presentable_image {
	fn default() -> Self {
		Self {
			vk_get_swapchain_status_khr: dummy_vkGetSwapchainStatusKHR,
		}
	}
}
impl Vulkan_KHR_shared_presentable_image {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_swapchain_status_khr: {let proc = get_proc_address(instance, "vkGetSwapchainStatusKHR"); if proc == null() {dummy_vkGetSwapchainStatusKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkExternalFenceHandleTypeFlagsKHR = VkExternalFenceHandleTypeFlags;
pub type VkExternalFenceHandleTypeFlagBitsKHR = VkExternalFenceHandleTypeFlagBits;
pub type VkExternalFenceFeatureFlagsKHR = VkExternalFenceFeatureFlags;
pub type VkExternalFenceFeatureFlagBitsKHR = VkExternalFenceFeatureFlagBits;
pub type VkPhysicalDeviceExternalFenceInfoKHR = VkPhysicalDeviceExternalFenceInfo;
pub type VkExternalFencePropertiesKHR = VkExternalFenceProperties;
type PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut VkExternalFenceProperties);
extern "system" fn dummy_vkGetPhysicalDeviceExternalFencePropertiesKHR(_: VkPhysicalDevice, _: *const VkPhysicalDeviceExternalFenceInfo, _: *mut VkExternalFenceProperties) {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceExternalFencePropertiesKHR()` is NULL");
}
pub trait VK_KHR_external_fence_capabilities: Debug {
	fn vkGetPhysicalDeviceExternalFencePropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut VkExternalFenceProperties);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_fence_capabilities {
	vk_get_physical_device_external_fence_properties_khr: PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR,
}
impl VK_KHR_external_fence_capabilities for Vulkan_KHR_external_fence_capabilities {
	fn vkGetPhysicalDeviceExternalFencePropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut VkExternalFenceProperties) {
		(self.vk_get_physical_device_external_fence_properties_khr)(physicalDevice, pExternalFenceInfo, pExternalFenceProperties)
	}
}
impl Default for Vulkan_KHR_external_fence_capabilities {
	fn default() -> Self {
		Self {
			vk_get_physical_device_external_fence_properties_khr: dummy_vkGetPhysicalDeviceExternalFencePropertiesKHR,
		}
	}
}
impl Vulkan_KHR_external_fence_capabilities {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_external_fence_properties_khr: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceExternalFencePropertiesKHR"); if proc == null() {dummy_vkGetPhysicalDeviceExternalFencePropertiesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkFenceImportFlagsKHR = VkFenceImportFlags;
pub type VkFenceImportFlagBitsKHR = VkFenceImportFlagBits;
pub type VkExportFenceCreateInfoKHR = VkExportFenceCreateInfo;
pub trait VK_KHR_external_fence: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_fence {}
impl VK_KHR_external_fence for Vulkan_KHR_external_fence {}
impl Default for Vulkan_KHR_external_fence {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_external_fence {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImportFenceFdInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub fence: VkFence,
	pub flags: VkFenceImportFlags,
	pub handleType: VkExternalFenceHandleTypeFlagBits,
	pub fd: i32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkFenceGetFdInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub fence: VkFence,
	pub handleType: VkExternalFenceHandleTypeFlagBits,
}
type PFN_vkImportFenceFdKHR = extern "system" fn(device: VkDevice, pImportFenceFdInfo: *const VkImportFenceFdInfoKHR) -> VkResult;
type PFN_vkGetFenceFdKHR = extern "system" fn(device: VkDevice, pGetFdInfo: *const VkFenceGetFdInfoKHR, pFd: *mut int) -> VkResult;
extern "system" fn dummy_vkImportFenceFdKHR(_: VkDevice, _: *const VkImportFenceFdInfoKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkImportFenceFdKHR()` is NULL");
}
pub trait VK_KHR_external_fence_fd: Debug {
	fn vkImportFenceFdKHR(&self, device: VkDevice, pImportFenceFdInfo: *const VkImportFenceFdInfoKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_fence_fd {
	vk_import_fence_fd_khr: PFN_vkImportFenceFdKHR,
}
impl VK_KHR_external_fence_fd for Vulkan_KHR_external_fence_fd {
	fn vkImportFenceFdKHR(&self, device: VkDevice, pImportFenceFdInfo: *const VkImportFenceFdInfoKHR) -> VkResult {
		(self.vk_import_fence_fd_khr)(device, pImportFenceFdInfo)
	}
}
impl Default for Vulkan_KHR_external_fence_fd {
	fn default() -> Self {
		Self {
			vk_import_fence_fd_khr: dummy_vkImportFenceFdKHR,
		}
	}
}
impl Vulkan_KHR_external_fence_fd {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_import_fence_fd_khr: {let proc = get_proc_address(instance, "vkImportFenceFdKHR"); if proc == null() {dummy_vkImportFenceFdKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPerformanceCounterDescriptionFlagsKHR = VkFlags;
pub type VkAcquireProfilingLockFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPerformanceCounterUnitKHR {
	VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0,
	VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1,
	VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2,
	VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3,
	VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4,
	VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5,
	VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6,
	VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7,
	VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8,
	VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9,
	VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10,
	VK_PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPerformanceCounterScopeKHR {
	VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0,
	VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1,
	VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2,
	VK_PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkPerformanceCounterScopeKHR {
	pub const VK_QUERY_SCOPE_COMMAND_BUFFER_KHR: VkPerformanceCounterScopeKHR = VkPerformanceCounterScopeKHR::VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR;
	pub const VK_QUERY_SCOPE_RENDER_PASS_KHR: VkPerformanceCounterScopeKHR = VkPerformanceCounterScopeKHR::VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR;
	pub const VK_QUERY_SCOPE_COMMAND_KHR: VkPerformanceCounterScopeKHR = VkPerformanceCounterScopeKHR::VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPerformanceCounterStorageKHR {
	VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0,
	VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1,
	VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2,
	VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3,
	VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4,
	VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5,
	VK_PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPerformanceCounterDescriptionFlagBitsKHR {
	VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR = 0x00000001,
	VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR = 0x00000002,
	VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkPerformanceCounterDescriptionFlagBitsKHR {
	pub const VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR: VkPerformanceCounterDescriptionFlagBitsKHR = VkPerformanceCounterDescriptionFlagBitsKHR::VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR;
	pub const VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR: VkPerformanceCounterDescriptionFlagBitsKHR = VkPerformanceCounterDescriptionFlagBitsKHR::VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAcquireProfilingLockFlagBitsKHR {
	VK_ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkPerformanceCounterResultKHR {
	pub int32: i32,
	pub int64: i64,
	pub uint32: u32,
	pub uint64: u64,
	pub float32: f32,
	pub float64: f64,
}
impl Debug for VkPerformanceCounterResultKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceCounterResultKHR")
		.field("int32", unsafe {&self.int32})
		.field("int64", unsafe {&self.int64})
		.field("uint32", unsafe {&self.uint32})
		.field("uint64", unsafe {&self.uint64})
		.field("float32", unsafe {&self.float32})
		.field("float64", unsafe {&self.float64})
		.finish()
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePerformanceQueryFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub performanceCounterQueryPools: VkBool32,
	pub performanceCounterMultipleQueryPools: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePerformanceQueryPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub allowCommandBufferQueryCopies: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPerformanceCounterKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub unit: VkPerformanceCounterUnitKHR,
	pub scope: VkPerformanceCounterScopeKHR,
	pub storage: VkPerformanceCounterStorageKHR,
	pub uuid: [u8; VK_UUID_SIZE as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPerformanceCounterDescriptionKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkPerformanceCounterDescriptionFlagsKHR,
	pub name: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub category: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkQueryPoolPerformanceCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub queueFamilyIndex: u32,
	pub counterIndexCount: u32,
	pub pCounterIndices: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAcquireProfilingLockInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkAcquireProfilingLockFlagsKHR,
	pub timeout: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPerformanceQuerySubmitInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub counterPassIndex: u32,
}
type PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, pCounterCount: *mut uint32_t, pCounters: *mut VkPerformanceCounterKHR, pCounterDescriptions: *mut VkPerformanceCounterDescriptionKHR) -> VkResult;
type PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pPerformanceQueryCreateInfo: *const VkQueryPoolPerformanceCreateInfoKHR, pNumPasses: *mut uint32_t);
type PFN_vkAcquireProfilingLockKHR = extern "system" fn(device: VkDevice, pInfo: *const VkAcquireProfilingLockInfoKHR) -> VkResult;
type PFN_vkReleaseProfilingLockKHR = extern "system" fn(device: VkDevice);
extern "system" fn dummy_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(_: VkPhysicalDevice, _: u32, _: *mut uint32_t, _: *mut VkPerformanceCounterKHR, _: *mut VkPerformanceCounterDescriptionKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR()` is NULL");
}
pub trait VK_KHR_performance_query: Debug {
	fn vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(&self, physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, pCounterCount: *mut uint32_t, pCounters: *mut VkPerformanceCounterKHR, pCounterDescriptions: *mut VkPerformanceCounterDescriptionKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_performance_query {
	vk_enumerate_physical_device_queue_family_performance_query_counters_khr: PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR,
}
impl VK_KHR_performance_query for Vulkan_KHR_performance_query {
	fn vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(&self, physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, pCounterCount: *mut uint32_t, pCounters: *mut VkPerformanceCounterKHR, pCounterDescriptions: *mut VkPerformanceCounterDescriptionKHR) -> VkResult {
		(self.vk_enumerate_physical_device_queue_family_performance_query_counters_khr)(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions)
	}
}
impl Default for Vulkan_KHR_performance_query {
	fn default() -> Self {
		Self {
			vk_enumerate_physical_device_queue_family_performance_query_counters_khr: dummy_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR,
		}
	}
}
impl Vulkan_KHR_performance_query {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_enumerate_physical_device_queue_family_performance_query_counters_khr: {let proc = get_proc_address(instance, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR"); if proc == null() {dummy_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPointClippingBehaviorKHR = VkPointClippingBehavior;
pub type VkTessellationDomainOriginKHR = VkTessellationDomainOrigin;
pub type VkPhysicalDevicePointClippingPropertiesKHR = VkPhysicalDevicePointClippingProperties;
pub type VkRenderPassInputAttachmentAspectCreateInfoKHR = VkRenderPassInputAttachmentAspectCreateInfo;
pub type VkInputAttachmentAspectReferenceKHR = VkInputAttachmentAspectReference;
pub type VkImageViewUsageCreateInfoKHR = VkImageViewUsageCreateInfo;
pub type VkPipelineTessellationDomainOriginStateCreateInfoKHR = VkPipelineTessellationDomainOriginStateCreateInfo;
pub trait VK_KHR_maintenance2: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance2 {}
impl VK_KHR_maintenance2 for Vulkan_KHR_maintenance2 {}
impl Default for Vulkan_KHR_maintenance2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_maintenance2 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSurfaceInfo2KHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub surface: VkSurfaceKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSurfaceCapabilities2KHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub surfaceCapabilities: VkSurfaceCapabilitiesKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSurfaceFormat2KHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub surfaceFormat: VkSurfaceFormatKHR,
}
type PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2KHR) -> VkResult;
type PFN_vkGetPhysicalDeviceSurfaceFormats2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceFormatCount: *mut uint32_t, pSurfaceFormats: *mut VkSurfaceFormat2KHR) -> VkResult;
extern "system" fn dummy_vkGetPhysicalDeviceSurfaceCapabilities2KHR(_: VkPhysicalDevice, _: *const VkPhysicalDeviceSurfaceInfo2KHR, _: *mut VkSurfaceCapabilities2KHR) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceSurfaceCapabilities2KHR()` is NULL");
}
pub trait VK_KHR_get_surface_capabilities2: Debug {
	fn vkGetPhysicalDeviceSurfaceCapabilities2KHR(&self, physicalDevice: VkPhysicalDevice, pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2KHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_get_surface_capabilities2 {
	vk_get_physical_device_surface_capabilities2_khr: PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
}
impl VK_KHR_get_surface_capabilities2 for Vulkan_KHR_get_surface_capabilities2 {
	fn vkGetPhysicalDeviceSurfaceCapabilities2KHR(&self, physicalDevice: VkPhysicalDevice, pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2KHR) -> VkResult {
		(self.vk_get_physical_device_surface_capabilities2_khr)(physicalDevice, pSurfaceInfo, pSurfaceCapabilities)
	}
}
impl Default for Vulkan_KHR_get_surface_capabilities2 {
	fn default() -> Self {
		Self {
			vk_get_physical_device_surface_capabilities2_khr: dummy_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
		}
	}
}
impl Vulkan_KHR_get_surface_capabilities2 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_surface_capabilities2_khr: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceSurfaceCapabilities2KHR"); if proc == null() {dummy_vkGetPhysicalDeviceSurfaceCapabilities2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceVariablePointerFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;
pub type VkPhysicalDeviceVariablePointersFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;
pub trait VK_KHR_variable_pointers: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_variable_pointers {}
impl VK_KHR_variable_pointers for Vulkan_KHR_variable_pointers {}
impl Default for Vulkan_KHR_variable_pointers {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_variable_pointers {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplayProperties2KHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub displayProperties: VkDisplayPropertiesKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplayPlaneProperties2KHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub displayPlaneProperties: VkDisplayPlanePropertiesKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplayModeProperties2KHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub displayModeProperties: VkDisplayModePropertiesKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplayPlaneInfo2KHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub mode: VkDisplayModeKHR,
	pub planeIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplayPlaneCapabilities2KHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub capabilities: VkDisplayPlaneCapabilitiesKHR,
}
type PFN_vkGetPhysicalDeviceDisplayProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayProperties2KHR) -> VkResult;
type PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayPlaneProperties2KHR) -> VkResult;
type PFN_vkGetDisplayModeProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayModeProperties2KHR) -> VkResult;
type PFN_vkGetDisplayPlaneCapabilities2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pDisplayPlaneInfo: *const VkDisplayPlaneInfo2KHR, pCapabilities: *mut VkDisplayPlaneCapabilities2KHR) -> VkResult;
extern "system" fn dummy_vkGetPhysicalDeviceDisplayProperties2KHR(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkDisplayProperties2KHR) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceDisplayProperties2KHR()` is NULL");
}
pub trait VK_KHR_get_display_properties2: Debug {
	fn vkGetPhysicalDeviceDisplayProperties2KHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayProperties2KHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_get_display_properties2 {
	vk_get_physical_device_display_properties2_khr: PFN_vkGetPhysicalDeviceDisplayProperties2KHR,
}
impl VK_KHR_get_display_properties2 for Vulkan_KHR_get_display_properties2 {
	fn vkGetPhysicalDeviceDisplayProperties2KHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayProperties2KHR) -> VkResult {
		(self.vk_get_physical_device_display_properties2_khr)(physicalDevice, pPropertyCount, pProperties)
	}
}
impl Default for Vulkan_KHR_get_display_properties2 {
	fn default() -> Self {
		Self {
			vk_get_physical_device_display_properties2_khr: dummy_vkGetPhysicalDeviceDisplayProperties2KHR,
		}
	}
}
impl Vulkan_KHR_get_display_properties2 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_display_properties2_khr: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceDisplayProperties2KHR"); if proc == null() {dummy_vkGetPhysicalDeviceDisplayProperties2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkMemoryDedicatedRequirementsKHR = VkMemoryDedicatedRequirements;
pub type VkMemoryDedicatedAllocateInfoKHR = VkMemoryDedicatedAllocateInfo;
pub trait VK_KHR_dedicated_allocation: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_dedicated_allocation {}
impl VK_KHR_dedicated_allocation for Vulkan_KHR_dedicated_allocation {}
impl Default for Vulkan_KHR_dedicated_allocation {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_dedicated_allocation {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_KHR_storage_buffer_storage_class: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_storage_buffer_storage_class {}
impl VK_KHR_storage_buffer_storage_class for Vulkan_KHR_storage_buffer_storage_class {}
impl Default for Vulkan_KHR_storage_buffer_storage_class {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_storage_buffer_storage_class {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderBfloat16FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderBFloat16Type: VkBool32,
	pub shaderBFloat16DotProduct: VkBool32,
	pub shaderBFloat16CooperativeMatrix: VkBool32,
}
pub trait VK_KHR_shader_bfloat16: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_bfloat16 {}
impl VK_KHR_shader_bfloat16 for Vulkan_KHR_shader_bfloat16 {}
impl Default for Vulkan_KHR_shader_bfloat16 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_bfloat16 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_KHR_relaxed_block_layout: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_relaxed_block_layout {}
impl VK_KHR_relaxed_block_layout for Vulkan_KHR_relaxed_block_layout {}
impl Default for Vulkan_KHR_relaxed_block_layout {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_relaxed_block_layout {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkBufferMemoryRequirementsInfo2KHR = VkBufferMemoryRequirementsInfo2;
pub type VkImageMemoryRequirementsInfo2KHR = VkImageMemoryRequirementsInfo2;
pub type VkImageSparseMemoryRequirementsInfo2KHR = VkImageSparseMemoryRequirementsInfo2;
pub type VkMemoryRequirements2KHR = VkMemoryRequirements2;
pub type VkSparseImageMemoryRequirements2KHR = VkSparseImageMemoryRequirements2;
type PFN_vkGetImageMemoryRequirements2KHR = extern "system" fn(device: VkDevice, pInfo: *const VkImageMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2);
type PFN_vkGetBufferMemoryRequirements2KHR = extern "system" fn(device: VkDevice, pInfo: *const VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2);
type PFN_vkGetImageSparseMemoryRequirements2KHR = extern "system" fn(device: VkDevice, pInfo: *const VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2);
extern "system" fn dummy_vkGetImageMemoryRequirements2KHR(_: VkDevice, _: *const VkImageMemoryRequirementsInfo2, _: *mut VkMemoryRequirements2) {
	panic!("Vulkan function pointer of `vkGetImageMemoryRequirements2KHR()` is NULL");
}
pub trait VK_KHR_get_memory_requirements2: Debug {
	fn vkGetImageMemoryRequirements2KHR(&self, device: VkDevice, pInfo: *const VkImageMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_get_memory_requirements2 {
	vk_get_image_memory_requirements2_khr: PFN_vkGetImageMemoryRequirements2KHR,
}
impl VK_KHR_get_memory_requirements2 for Vulkan_KHR_get_memory_requirements2 {
	fn vkGetImageMemoryRequirements2KHR(&self, device: VkDevice, pInfo: *const VkImageMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_get_image_memory_requirements2_khr)(device, pInfo, pMemoryRequirements)
	}
}
impl Default for Vulkan_KHR_get_memory_requirements2 {
	fn default() -> Self {
		Self {
			vk_get_image_memory_requirements2_khr: dummy_vkGetImageMemoryRequirements2KHR,
		}
	}
}
impl Vulkan_KHR_get_memory_requirements2 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_image_memory_requirements2_khr: {let proc = get_proc_address(instance, "vkGetImageMemoryRequirements2KHR"); if proc == null() {dummy_vkGetImageMemoryRequirements2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkImageFormatListCreateInfoKHR = VkImageFormatListCreateInfo;
pub trait VK_KHR_image_format_list: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_image_format_list {}
impl VK_KHR_image_format_list for Vulkan_KHR_image_format_list {}
impl Default for Vulkan_KHR_image_format_list {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_image_format_list {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkSamplerYcbcrConversionKHR = VkSamplerYcbcrConversion;
pub type VkSamplerYcbcrModelConversionKHR = VkSamplerYcbcrModelConversion;
pub type VkSamplerYcbcrRangeKHR = VkSamplerYcbcrRange;
pub type VkChromaLocationKHR = VkChromaLocation;
pub type VkSamplerYcbcrConversionCreateInfoKHR = VkSamplerYcbcrConversionCreateInfo;
pub type VkSamplerYcbcrConversionInfoKHR = VkSamplerYcbcrConversionInfo;
pub type VkBindImagePlaneMemoryInfoKHR = VkBindImagePlaneMemoryInfo;
pub type VkImagePlaneMemoryRequirementsInfoKHR = VkImagePlaneMemoryRequirementsInfo;
pub type VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR = VkPhysicalDeviceSamplerYcbcrConversionFeatures;
pub type VkSamplerYcbcrConversionImageFormatPropertiesKHR = VkSamplerYcbcrConversionImageFormatProperties;
type PFN_vkCreateSamplerYcbcrConversionKHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo, pAllocator: *const VkAllocationCallbacks, pYcbcrConversion: *mut VkSamplerYcbcrConversion) -> VkResult;
type PFN_vkDestroySamplerYcbcrConversionKHR = extern "system" fn(device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *const VkAllocationCallbacks);
extern "system" fn dummy_vkCreateSamplerYcbcrConversionKHR(_: VkDevice, _: *const VkSamplerYcbcrConversionCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkSamplerYcbcrConversion) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateSamplerYcbcrConversionKHR()` is NULL");
}
pub trait VK_KHR_sampler_ycbcr_conversion: Debug {
	fn vkCreateSamplerYcbcrConversionKHR(&self, device: VkDevice, pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo, pAllocator: *const VkAllocationCallbacks, pYcbcrConversion: *mut VkSamplerYcbcrConversion) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_sampler_ycbcr_conversion {
	vk_create_sampler_ycbcr_conversion_khr: PFN_vkCreateSamplerYcbcrConversionKHR,
}
impl VK_KHR_sampler_ycbcr_conversion for Vulkan_KHR_sampler_ycbcr_conversion {
	fn vkCreateSamplerYcbcrConversionKHR(&self, device: VkDevice, pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo, pAllocator: *const VkAllocationCallbacks, pYcbcrConversion: *mut VkSamplerYcbcrConversion) -> VkResult {
		(self.vk_create_sampler_ycbcr_conversion_khr)(device, pCreateInfo, pAllocator, pYcbcrConversion)
	}
}
impl Default for Vulkan_KHR_sampler_ycbcr_conversion {
	fn default() -> Self {
		Self {
			vk_create_sampler_ycbcr_conversion_khr: dummy_vkCreateSamplerYcbcrConversionKHR,
		}
	}
}
impl Vulkan_KHR_sampler_ycbcr_conversion {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_sampler_ycbcr_conversion_khr: {let proc = get_proc_address(instance, "vkCreateSamplerYcbcrConversionKHR"); if proc == null() {dummy_vkCreateSamplerYcbcrConversionKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkBindBufferMemoryInfoKHR = VkBindBufferMemoryInfo;
pub type VkBindImageMemoryInfoKHR = VkBindImageMemoryInfo;
type PFN_vkBindBufferMemory2KHR = extern "system" fn(device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindBufferMemoryInfo) -> VkResult;
type PFN_vkBindImageMemory2KHR = extern "system" fn(device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindImageMemoryInfo) -> VkResult;
extern "system" fn dummy_vkBindBufferMemory2KHR(_: VkDevice, _: u32, _: *const VkBindBufferMemoryInfo) -> VkResult {
	panic!("Vulkan function pointer of `vkBindBufferMemory2KHR()` is NULL");
}
pub trait VK_KHR_bind_memory2: Debug {
	fn vkBindBufferMemory2KHR(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindBufferMemoryInfo) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_bind_memory2 {
	vk_bind_buffer_memory2_khr: PFN_vkBindBufferMemory2KHR,
}
impl VK_KHR_bind_memory2 for Vulkan_KHR_bind_memory2 {
	fn vkBindBufferMemory2KHR(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindBufferMemoryInfo) -> VkResult {
		(self.vk_bind_buffer_memory2_khr)(device, bindInfoCount, pBindInfos)
	}
}
impl Default for Vulkan_KHR_bind_memory2 {
	fn default() -> Self {
		Self {
			vk_bind_buffer_memory2_khr: dummy_vkBindBufferMemory2KHR,
		}
	}
}
impl Vulkan_KHR_bind_memory2 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_bind_buffer_memory2_khr: {let proc = get_proc_address(instance, "vkBindBufferMemory2KHR"); if proc == null() {dummy_vkBindBufferMemory2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceMaintenance3PropertiesKHR = VkPhysicalDeviceMaintenance3Properties;
pub type VkDescriptorSetLayoutSupportKHR = VkDescriptorSetLayoutSupport;
type PFN_vkGetDescriptorSetLayoutSupportKHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pSupport: *mut VkDescriptorSetLayoutSupport);
extern "system" fn dummy_vkGetDescriptorSetLayoutSupportKHR(_: VkDevice, _: *const VkDescriptorSetLayoutCreateInfo, _: *mut VkDescriptorSetLayoutSupport) {
	panic!("Vulkan function pointer of `vkGetDescriptorSetLayoutSupportKHR()` is NULL");
}
pub trait VK_KHR_maintenance3: Debug {
	fn vkGetDescriptorSetLayoutSupportKHR(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pSupport: *mut VkDescriptorSetLayoutSupport);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance3 {
	vk_get_descriptor_set_layout_support_khr: PFN_vkGetDescriptorSetLayoutSupportKHR,
}
impl VK_KHR_maintenance3 for Vulkan_KHR_maintenance3 {
	fn vkGetDescriptorSetLayoutSupportKHR(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pSupport: *mut VkDescriptorSetLayoutSupport) {
		(self.vk_get_descriptor_set_layout_support_khr)(device, pCreateInfo, pSupport)
	}
}
impl Default for Vulkan_KHR_maintenance3 {
	fn default() -> Self {
		Self {
			vk_get_descriptor_set_layout_support_khr: dummy_vkGetDescriptorSetLayoutSupportKHR,
		}
	}
}
impl Vulkan_KHR_maintenance3 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_descriptor_set_layout_support_khr: {let proc = get_proc_address(instance, "vkGetDescriptorSetLayoutSupportKHR"); if proc == null() {dummy_vkGetDescriptorSetLayoutSupportKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
type PFN_vkCmdDrawIndirectCountKHR = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
type PFN_vkCmdDrawIndexedIndirectCountKHR = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
extern "system" fn dummy_vkCmdDrawIndirectCountKHR(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkBuffer, _: VkDeviceSize, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdDrawIndirectCountKHR()` is NULL");
}
pub trait VK_KHR_draw_indirect_count: Debug {
	fn vkCmdDrawIndirectCountKHR(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_draw_indirect_count {
	vk_cmd_draw_indirect_count_khr: PFN_vkCmdDrawIndirectCountKHR,
}
impl VK_KHR_draw_indirect_count for Vulkan_KHR_draw_indirect_count {
	fn vkCmdDrawIndirectCountKHR(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) {
		(self.vk_cmd_draw_indirect_count_khr)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	}
}
impl Default for Vulkan_KHR_draw_indirect_count {
	fn default() -> Self {
		Self {
			vk_cmd_draw_indirect_count_khr: dummy_vkCmdDrawIndirectCountKHR,
		}
	}
}
impl Vulkan_KHR_draw_indirect_count {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_draw_indirect_count_khr: {let proc = get_proc_address(instance, "vkCmdDrawIndirectCountKHR"); if proc == null() {dummy_vkCmdDrawIndirectCountKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;
pub trait VK_KHR_shader_subgroup_extended_types: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_subgroup_extended_types {}
impl VK_KHR_shader_subgroup_extended_types for Vulkan_KHR_shader_subgroup_extended_types {}
impl Default for Vulkan_KHR_shader_subgroup_extended_types {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_subgroup_extended_types {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDevice8BitStorageFeaturesKHR = VkPhysicalDevice8BitStorageFeatures;
pub trait VK_KHR_8bit_storage: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_8bit_storage {}
impl VK_KHR_8bit_storage for Vulkan_KHR_8bit_storage {}
impl Default for Vulkan_KHR_8bit_storage {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_8bit_storage {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceShaderAtomicInt64FeaturesKHR = VkPhysicalDeviceShaderAtomicInt64Features;
pub trait VK_KHR_shader_atomic_int64: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_atomic_int64 {}
impl VK_KHR_shader_atomic_int64 for Vulkan_KHR_shader_atomic_int64 {}
impl Default for Vulkan_KHR_shader_atomic_int64 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_atomic_int64 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderClockFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderSubgroupClock: VkBool32,
	pub shaderDeviceClock: VkBool32,
}
pub trait VK_KHR_shader_clock: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_clock {}
impl VK_KHR_shader_clock for Vulkan_KHR_shader_clock {}
impl Default for Vulkan_KHR_shader_clock {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_clock {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeH265ProfileInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdProfileIdc: StdVideoH265ProfileIdc,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeH265CapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxLevelIdc: StdVideoH265LevelIdc,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeH265SessionParametersAddInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdVPSCount: u32,
	pub pStdVPSs: *const StdVideoH265VideoParameterSet,
	pub stdSPSCount: u32,
	pub pStdSPSs: *const StdVideoH265SequenceParameterSet,
	pub stdPPSCount: u32,
	pub pStdPPSs: *const StdVideoH265PictureParameterSet,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeH265SessionParametersCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maxStdVPSCount: u32,
	pub maxStdSPSCount: u32,
	pub maxStdPPSCount: u32,
	pub pParametersAddInfo: *const VkVideoDecodeH265SessionParametersAddInfoKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeH265PictureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdPictureInfo: *const StdVideoDecodeH265PictureInfo,
	pub sliceSegmentCount: u32,
	pub pSliceSegmentOffsets: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeH265DpbSlotInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdReferenceInfo: *const StdVideoDecodeH265ReferenceInfo,
}
pub trait VK_KHR_video_decode_h265: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_decode_h265 {}
impl VK_KHR_video_decode_h265 for Vulkan_KHR_video_decode_h265 {}
impl Default for Vulkan_KHR_video_decode_h265 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_decode_h265 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_API_VERSION_1_0_0: u32 = 0x400000;
pub const STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE: u32 = 8u32;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoDecodeH265PictureInfoFlags {
	/// Bitfield: IrapPicFlag: u32 in 1 bits
	/// Bitfield: IdrPicFlag: u32 in 1 bits
	/// Bitfield: IsReference: u32 in 1 bits
	/// Bitfield: short_term_ref_pic_set_sps_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoDecodeH265PictureInfoFlags {
	pub fn get_IrapPicFlag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_IrapPicFlag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_IdrPicFlag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_IdrPicFlag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_IsReference(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_IsReference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_short_term_ref_pic_set_sps_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_short_term_ref_pic_set_sps_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoDecodeH265PictureInfo {
	pub flags: StdVideoDecodeH265PictureInfoFlags,
	pub sps_video_parameter_set_id: u8,
	pub pps_seq_parameter_set_id: u8,
	pub pps_pic_parameter_set_id: u8,
	pub NumDeltaPocsOfRefRpsIdx: u8,
	pub PicOrderCntVal: i32,
	pub NumBitsForSTRefPicSetInSlice: u16,
	pub reserved: u16,
	pub RefPicSetStCurrBefore: [u8; STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE as usize],
	pub RefPicSetStCurrAfter: [u8; STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE as usize],
	pub RefPicSetLtCurr: [u8; STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoDecodeH265ReferenceInfoFlags {
	/// Bitfield: used_for_long_term_reference: u32 in 1 bits
	/// Bitfield: unused_for_reference: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoDecodeH265ReferenceInfoFlags {
	pub fn get_used_for_long_term_reference(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_used_for_long_term_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_unused_for_reference(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_unused_for_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoDecodeH265ReferenceInfo {
	pub flags: StdVideoDecodeH265ReferenceInfoFlags,
	pub PicOrderCntVal: i32,
}
pub trait vulkan_video_codec_h265std_decode: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_h265std_decode {}
impl vulkan_video_codec_h265std_decode for Vulkan_video_codec_h265std_decode {}
impl Default for Vulkan_video_codec_h265std_decode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_h265std_decode {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const VK_MAX_GLOBAL_PRIORITY_SIZE_KHR: u32 = 16u32;
pub type VkQueueGlobalPriorityKHR = VkQueueGlobalPriority;
pub type VkDeviceQueueGlobalPriorityCreateInfoKHR = VkDeviceQueueGlobalPriorityCreateInfo;
pub type VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR = VkPhysicalDeviceGlobalPriorityQueryFeatures;
pub type VkQueueFamilyGlobalPriorityPropertiesKHR = VkQueueFamilyGlobalPriorityProperties;
pub trait VK_KHR_global_priority: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_global_priority {}
impl VK_KHR_global_priority for Vulkan_KHR_global_priority {}
impl Default for Vulkan_KHR_global_priority {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_global_priority {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const VK_MAX_DRIVER_NAME_SIZE_KHR: u32 = 256u32;
pub const VK_MAX_DRIVER_INFO_SIZE_KHR: u32 = 256u32;
pub type VkDriverIdKHR = VkDriverId;
pub type VkConformanceVersionKHR = VkConformanceVersion;
pub type VkPhysicalDeviceDriverPropertiesKHR = VkPhysicalDeviceDriverProperties;
pub trait VK_KHR_driver_properties: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_driver_properties {}
impl VK_KHR_driver_properties for Vulkan_KHR_driver_properties {}
impl Default for Vulkan_KHR_driver_properties {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_driver_properties {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkShaderFloatControlsIndependenceKHR = VkShaderFloatControlsIndependence;
pub type VkPhysicalDeviceFloatControlsPropertiesKHR = VkPhysicalDeviceFloatControlsProperties;
pub trait VK_KHR_shader_float_controls: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_float_controls {}
impl VK_KHR_shader_float_controls for Vulkan_KHR_shader_float_controls {}
impl Default for Vulkan_KHR_shader_float_controls {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_float_controls {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkResolveModeFlagBitsKHR = VkResolveModeFlagBits;
pub type VkResolveModeFlagsKHR = VkResolveModeFlags;
pub type VkSubpassDescriptionDepthStencilResolveKHR = VkSubpassDescriptionDepthStencilResolve;
pub type VkPhysicalDeviceDepthStencilResolvePropertiesKHR = VkPhysicalDeviceDepthStencilResolveProperties;
pub trait VK_KHR_depth_stencil_resolve: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_depth_stencil_resolve {}
impl VK_KHR_depth_stencil_resolve for Vulkan_KHR_depth_stencil_resolve {}
impl Default for Vulkan_KHR_depth_stencil_resolve {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_depth_stencil_resolve {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_KHR_swapchain_mutable_format: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_swapchain_mutable_format {}
impl VK_KHR_swapchain_mutable_format for Vulkan_KHR_swapchain_mutable_format {}
impl Default for Vulkan_KHR_swapchain_mutable_format {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_swapchain_mutable_format {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkSemaphoreTypeKHR = VkSemaphoreType;
pub type VkSemaphoreWaitFlagBitsKHR = VkSemaphoreWaitFlagBits;
pub type VkSemaphoreWaitFlagsKHR = VkSemaphoreWaitFlags;
pub type VkPhysicalDeviceTimelineSemaphoreFeaturesKHR = VkPhysicalDeviceTimelineSemaphoreFeatures;
pub type VkPhysicalDeviceTimelineSemaphorePropertiesKHR = VkPhysicalDeviceTimelineSemaphoreProperties;
pub type VkSemaphoreTypeCreateInfoKHR = VkSemaphoreTypeCreateInfo;
pub type VkTimelineSemaphoreSubmitInfoKHR = VkTimelineSemaphoreSubmitInfo;
pub type VkSemaphoreWaitInfoKHR = VkSemaphoreWaitInfo;
pub type VkSemaphoreSignalInfoKHR = VkSemaphoreSignalInfo;
type PFN_vkGetSemaphoreCounterValueKHR = extern "system" fn(device: VkDevice, semaphore: VkSemaphore, pValue: *mut uint64_t) -> VkResult;
type PFN_vkWaitSemaphoresKHR = extern "system" fn(device: VkDevice, pWaitInfo: *const VkSemaphoreWaitInfo, timeout: u64) -> VkResult;
type PFN_vkSignalSemaphoreKHR = extern "system" fn(device: VkDevice, pSignalInfo: *const VkSemaphoreSignalInfo) -> VkResult;
extern "system" fn dummy_vkGetSemaphoreCounterValueKHR(_: VkDevice, _: VkSemaphore, _: *mut uint64_t) -> VkResult {
	panic!("Vulkan function pointer of `vkGetSemaphoreCounterValueKHR()` is NULL");
}
pub trait VK_KHR_timeline_semaphore: Debug {
	fn vkGetSemaphoreCounterValueKHR(&self, device: VkDevice, semaphore: VkSemaphore, pValue: *mut uint64_t) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_timeline_semaphore {
	vk_get_semaphore_counter_value_khr: PFN_vkGetSemaphoreCounterValueKHR,
}
impl VK_KHR_timeline_semaphore for Vulkan_KHR_timeline_semaphore {
	fn vkGetSemaphoreCounterValueKHR(&self, device: VkDevice, semaphore: VkSemaphore, pValue: *mut uint64_t) -> VkResult {
		(self.vk_get_semaphore_counter_value_khr)(device, semaphore, pValue)
	}
}
impl Default for Vulkan_KHR_timeline_semaphore {
	fn default() -> Self {
		Self {
			vk_get_semaphore_counter_value_khr: dummy_vkGetSemaphoreCounterValueKHR,
		}
	}
}
impl Vulkan_KHR_timeline_semaphore {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_semaphore_counter_value_khr: {let proc = get_proc_address(instance, "vkGetSemaphoreCounterValueKHR"); if proc == null() {dummy_vkGetSemaphoreCounterValueKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceVulkanMemoryModelFeaturesKHR = VkPhysicalDeviceVulkanMemoryModelFeatures;
pub trait VK_KHR_vulkan_memory_model: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_vulkan_memory_model {}
impl VK_KHR_vulkan_memory_model for Vulkan_KHR_vulkan_memory_model {}
impl Default for Vulkan_KHR_vulkan_memory_model {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_vulkan_memory_model {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR = VkPhysicalDeviceShaderTerminateInvocationFeatures;
pub trait VK_KHR_shader_terminate_invocation: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_terminate_invocation {}
impl VK_KHR_shader_terminate_invocation for Vulkan_KHR_shader_terminate_invocation {}
impl Default for Vulkan_KHR_shader_terminate_invocation {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_terminate_invocation {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFragmentShadingRateCombinerOpKHR {
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR = 0,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR = 1,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR = 2,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR = 3,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR = 4,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkFragmentShadingRateAttachmentInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pFragmentShadingRateAttachment: *const VkAttachmentReference2,
	pub shadingRateAttachmentTexelSize: VkExtent2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineFragmentShadingRateStateCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub fragmentSize: VkExtent2D,
	pub combinerOps: [VkFragmentShadingRateCombinerOpKHR; 2 as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFragmentShadingRateFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineFragmentShadingRate: VkBool32,
	pub primitiveFragmentShadingRate: VkBool32,
	pub attachmentFragmentShadingRate: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFragmentShadingRatePropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minFragmentShadingRateAttachmentTexelSize: VkExtent2D,
	pub maxFragmentShadingRateAttachmentTexelSize: VkExtent2D,
	pub maxFragmentShadingRateAttachmentTexelSizeAspectRatio: u32,
	pub primitiveFragmentShadingRateWithMultipleViewports: VkBool32,
	pub layeredShadingRateAttachments: VkBool32,
	pub fragmentShadingRateNonTrivialCombinerOps: VkBool32,
	pub maxFragmentSize: VkExtent2D,
	pub maxFragmentSizeAspectRatio: u32,
	pub maxFragmentShadingRateCoverageSamples: u32,
	pub maxFragmentShadingRateRasterizationSamples: VkSampleCountFlagBits,
	pub fragmentShadingRateWithShaderDepthStencilWrites: VkBool32,
	pub fragmentShadingRateWithSampleMask: VkBool32,
	pub fragmentShadingRateWithShaderSampleMask: VkBool32,
	pub fragmentShadingRateWithConservativeRasterization: VkBool32,
	pub fragmentShadingRateWithFragmentShaderInterlock: VkBool32,
	pub fragmentShadingRateWithCustomSampleLocations: VkBool32,
	pub fragmentShadingRateStrictMultiplyCombiner: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFragmentShadingRateKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub sampleCounts: VkSampleCountFlags,
	pub fragmentSize: VkExtent2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderingFragmentShadingRateAttachmentInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub imageView: VkImageView,
	pub imageLayout: VkImageLayout,
	pub shadingRateAttachmentTexelSize: VkExtent2D,
}
type PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pFragmentShadingRateCount: *mut uint32_t, pFragmentShadingRates: *mut VkPhysicalDeviceFragmentShadingRateKHR) -> VkResult;
type PFN_vkCmdSetFragmentShadingRateKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pFragmentSize: *const VkExtent2D, combinerOps: &[VkFragmentShadingRateCombinerOpKHR; 2 as usize]);
extern "system" fn dummy_vkGetPhysicalDeviceFragmentShadingRatesKHR(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkPhysicalDeviceFragmentShadingRateKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceFragmentShadingRatesKHR()` is NULL");
}
pub trait VK_KHR_fragment_shading_rate: Debug {
	fn vkGetPhysicalDeviceFragmentShadingRatesKHR(&self, physicalDevice: VkPhysicalDevice, pFragmentShadingRateCount: *mut uint32_t, pFragmentShadingRates: *mut VkPhysicalDeviceFragmentShadingRateKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_fragment_shading_rate {
	vk_get_physical_device_fragment_shading_rates_khr: PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR,
}
impl VK_KHR_fragment_shading_rate for Vulkan_KHR_fragment_shading_rate {
	fn vkGetPhysicalDeviceFragmentShadingRatesKHR(&self, physicalDevice: VkPhysicalDevice, pFragmentShadingRateCount: *mut uint32_t, pFragmentShadingRates: *mut VkPhysicalDeviceFragmentShadingRateKHR) -> VkResult {
		(self.vk_get_physical_device_fragment_shading_rates_khr)(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates)
	}
}
impl Default for Vulkan_KHR_fragment_shading_rate {
	fn default() -> Self {
		Self {
			vk_get_physical_device_fragment_shading_rates_khr: dummy_vkGetPhysicalDeviceFragmentShadingRatesKHR,
		}
	}
}
impl Vulkan_KHR_fragment_shading_rate {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_fragment_shading_rates_khr: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceFragmentShadingRatesKHR"); if proc == null() {dummy_vkGetPhysicalDeviceFragmentShadingRatesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR = VkPhysicalDeviceDynamicRenderingLocalReadFeatures;
pub type VkRenderingAttachmentLocationInfoKHR = VkRenderingAttachmentLocationInfo;
pub type VkRenderingInputAttachmentIndexInfoKHR = VkRenderingInputAttachmentIndexInfo;
type PFN_vkCmdSetRenderingAttachmentLocationsKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pLocationInfo: *const VkRenderingAttachmentLocationInfo);
type PFN_vkCmdSetRenderingInputAttachmentIndicesKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pInputAttachmentIndexInfo: *const VkRenderingInputAttachmentIndexInfo);
extern "system" fn dummy_vkCmdSetRenderingAttachmentLocationsKHR(_: VkCommandBuffer, _: *const VkRenderingAttachmentLocationInfo) {
	panic!("Vulkan function pointer of `vkCmdSetRenderingAttachmentLocationsKHR()` is NULL");
}
pub trait VK_KHR_dynamic_rendering_local_read: Debug {
	fn vkCmdSetRenderingAttachmentLocationsKHR(&self, commandBuffer: VkCommandBuffer, pLocationInfo: *const VkRenderingAttachmentLocationInfo);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_dynamic_rendering_local_read {
	vk_cmd_set_rendering_attachment_locations_khr: PFN_vkCmdSetRenderingAttachmentLocationsKHR,
}
impl VK_KHR_dynamic_rendering_local_read for Vulkan_KHR_dynamic_rendering_local_read {
	fn vkCmdSetRenderingAttachmentLocationsKHR(&self, commandBuffer: VkCommandBuffer, pLocationInfo: *const VkRenderingAttachmentLocationInfo) {
		(self.vk_cmd_set_rendering_attachment_locations_khr)(commandBuffer, pLocationInfo)
	}
}
impl Default for Vulkan_KHR_dynamic_rendering_local_read {
	fn default() -> Self {
		Self {
			vk_cmd_set_rendering_attachment_locations_khr: dummy_vkCmdSetRenderingAttachmentLocationsKHR,
		}
	}
}
impl Vulkan_KHR_dynamic_rendering_local_read {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_rendering_attachment_locations_khr: {let proc = get_proc_address(instance, "vkCmdSetRenderingAttachmentLocationsKHR"); if proc == null() {dummy_vkCmdSetRenderingAttachmentLocationsKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderQuadControlFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderQuadControl: VkBool32,
}
pub trait VK_KHR_shader_quad_control: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_quad_control {}
impl VK_KHR_shader_quad_control for Vulkan_KHR_shader_quad_control {}
impl Default for Vulkan_KHR_shader_quad_control {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_quad_control {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_KHR_spirv_1_4: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_spirv_1_4 {}
impl VK_KHR_spirv_1_4 for Vulkan_KHR_spirv_1_4 {}
impl Default for Vulkan_KHR_spirv_1_4 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_spirv_1_4 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSurfaceProtectedCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub supportsProtected: VkBool32,
}
pub trait VK_KHR_surface_protected_capabilities: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_surface_protected_capabilities {}
impl VK_KHR_surface_protected_capabilities for Vulkan_KHR_surface_protected_capabilities {}
impl Default for Vulkan_KHR_surface_protected_capabilities {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_surface_protected_capabilities {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;
pub type VkAttachmentReferenceStencilLayoutKHR = VkAttachmentReferenceStencilLayout;
pub type VkAttachmentDescriptionStencilLayoutKHR = VkAttachmentDescriptionStencilLayout;
pub trait VK_KHR_separate_depth_stencil_layouts: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_separate_depth_stencil_layouts {}
impl VK_KHR_separate_depth_stencil_layouts for Vulkan_KHR_separate_depth_stencil_layouts {}
impl Default for Vulkan_KHR_separate_depth_stencil_layouts {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_separate_depth_stencil_layouts {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePresentWaitFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentWait: VkBool32,
}
type PFN_vkWaitForPresentKHR = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, presentId: u64, timeout: u64) -> VkResult;
extern "system" fn dummy_vkWaitForPresentKHR(_: VkDevice, _: VkSwapchainKHR, _: u64, _: u64) -> VkResult {
	panic!("Vulkan function pointer of `vkWaitForPresentKHR()` is NULL");
}
pub trait VK_KHR_present_wait: Debug {
	fn vkWaitForPresentKHR(&self, device: VkDevice, swapchain: VkSwapchainKHR, presentId: u64, timeout: u64) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_present_wait {
	vk_wait_for_present_khr: PFN_vkWaitForPresentKHR,
}
impl VK_KHR_present_wait for Vulkan_KHR_present_wait {
	fn vkWaitForPresentKHR(&self, device: VkDevice, swapchain: VkSwapchainKHR, presentId: u64, timeout: u64) -> VkResult {
		(self.vk_wait_for_present_khr)(device, swapchain, presentId, timeout)
	}
}
impl Default for Vulkan_KHR_present_wait {
	fn default() -> Self {
		Self {
			vk_wait_for_present_khr: dummy_vkWaitForPresentKHR,
		}
	}
}
impl Vulkan_KHR_present_wait {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_wait_for_present_khr: {let proc = get_proc_address(instance, "vkWaitForPresentKHR"); if proc == null() {dummy_vkWaitForPresentKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = VkPhysicalDeviceUniformBufferStandardLayoutFeatures;
pub trait VK_KHR_uniform_buffer_standard_layout: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_uniform_buffer_standard_layout {}
impl VK_KHR_uniform_buffer_standard_layout for Vulkan_KHR_uniform_buffer_standard_layout {}
impl Default for Vulkan_KHR_uniform_buffer_standard_layout {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_uniform_buffer_standard_layout {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceBufferDeviceAddressFeaturesKHR = VkPhysicalDeviceBufferDeviceAddressFeatures;
pub type VkBufferDeviceAddressInfoKHR = VkBufferDeviceAddressInfo;
pub type VkBufferOpaqueCaptureAddressCreateInfoKHR = VkBufferOpaqueCaptureAddressCreateInfo;
pub type VkMemoryOpaqueCaptureAddressAllocateInfoKHR = VkMemoryOpaqueCaptureAddressAllocateInfo;
pub type VkDeviceMemoryOpaqueCaptureAddressInfoKHR = VkDeviceMemoryOpaqueCaptureAddressInfo;
type PFN_vkGetBufferDeviceAddressKHR = extern "system" fn(device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress;
type PFN_vkGetBufferOpaqueCaptureAddressKHR = extern "system" fn(device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> u64;
type PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo) -> u64;
extern "system" fn dummy_vkGetBufferDeviceAddressKHR(_: VkDevice, _: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress {
	panic!("Vulkan function pointer of `vkGetBufferDeviceAddressKHR()` is NULL");
}
pub trait VK_KHR_buffer_device_address: Debug {
	fn vkGetBufferDeviceAddressKHR(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_buffer_device_address {
	vk_get_buffer_device_address_khr: PFN_vkGetBufferDeviceAddressKHR,
}
impl VK_KHR_buffer_device_address for Vulkan_KHR_buffer_device_address {
	fn vkGetBufferDeviceAddressKHR(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress {
		(self.vk_get_buffer_device_address_khr)(device, pInfo)
	}
}
impl Default for Vulkan_KHR_buffer_device_address {
	fn default() -> Self {
		Self {
			vk_get_buffer_device_address_khr: dummy_vkGetBufferDeviceAddressKHR,
		}
	}
}
impl Vulkan_KHR_buffer_device_address {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_buffer_device_address_khr: {let proc = get_proc_address(instance, "vkGetBufferDeviceAddressKHR"); if proc == null() {dummy_vkGetBufferDeviceAddressKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
// Define non-dispatchable handle `VkDeferredOperationKHR`
#[cfg(target_pointer_width = "32")] pub type VkDeferredOperationKHR = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkDeferredOperationKHR_T {}
#[cfg(target_pointer_width = "64")] pub type VkDeferredOperationKHR = *const VkDeferredOperationKHR_T;
type PFN_vkCreateDeferredOperationKHR = extern "system" fn(device: VkDevice, pAllocator: *const VkAllocationCallbacks, pDeferredOperation: *mut VkDeferredOperationKHR) -> VkResult;
type PFN_vkDestroyDeferredOperationKHR = extern "system" fn(device: VkDevice, operation: VkDeferredOperationKHR, pAllocator: *const VkAllocationCallbacks);
type PFN_vkGetDeferredOperationMaxConcurrencyKHR = extern "system" fn(device: VkDevice, operation: VkDeferredOperationKHR) -> u32;
type PFN_vkGetDeferredOperationResultKHR = extern "system" fn(device: VkDevice, operation: VkDeferredOperationKHR) -> VkResult;
type PFN_vkDeferredOperationJoinKHR = extern "system" fn(device: VkDevice, operation: VkDeferredOperationKHR) -> VkResult;
extern "system" fn dummy_vkCreateDeferredOperationKHR(_: VkDevice, _: *const VkAllocationCallbacks, _: *mut VkDeferredOperationKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateDeferredOperationKHR()` is NULL");
}
pub trait VK_KHR_deferred_host_operations: Debug {
	fn vkCreateDeferredOperationKHR(&self, device: VkDevice, pAllocator: *const VkAllocationCallbacks, pDeferredOperation: *mut VkDeferredOperationKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_deferred_host_operations {
	vk_create_deferred_operation_khr: PFN_vkCreateDeferredOperationKHR,
}
impl VK_KHR_deferred_host_operations for Vulkan_KHR_deferred_host_operations {
	fn vkCreateDeferredOperationKHR(&self, device: VkDevice, pAllocator: *const VkAllocationCallbacks, pDeferredOperation: *mut VkDeferredOperationKHR) -> VkResult {
		(self.vk_create_deferred_operation_khr)(device, pAllocator, pDeferredOperation)
	}
}
impl Default for Vulkan_KHR_deferred_host_operations {
	fn default() -> Self {
		Self {
			vk_create_deferred_operation_khr: dummy_vkCreateDeferredOperationKHR,
		}
	}
}
impl Vulkan_KHR_deferred_host_operations {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_deferred_operation_khr: {let proc = get_proc_address(instance, "vkCreateDeferredOperationKHR"); if proc == null() {dummy_vkCreateDeferredOperationKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineExecutableStatisticFormatKHR {
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkPipelineExecutableStatisticValueKHR {
	pub b32: VkBool32,
	pub i64: i64,
	pub u64: u64,
	pub f64: f64,
}
impl Debug for VkPipelineExecutableStatisticValueKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineExecutableStatisticValueKHR")
		.field("b32", unsafe {&self.b32})
		.field("i64", unsafe {&self.i64})
		.field("u64", unsafe {&self.u64})
		.field("f64", unsafe {&self.f64})
		.finish()
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineExecutableInfo: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pipeline: VkPipeline,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineExecutablePropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub stages: VkShaderStageFlags,
	pub name: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub subgroupSize: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineExecutableInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pipeline: VkPipeline,
	pub executableIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineExecutableStatisticKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub name: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub format: VkPipelineExecutableStatisticFormatKHR,
	pub value: VkPipelineExecutableStatisticValueKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineExecutableInternalRepresentationKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub name: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub isText: VkBool32,
	pub dataSize: usize,
	pub pData: *mut c_void,
}
type PFN_vkGetPipelineExecutablePropertiesKHR = extern "system" fn(device: VkDevice, pPipelineInfo: *const VkPipelineInfoKHR, pExecutableCount: *mut uint32_t, pProperties: *mut VkPipelineExecutablePropertiesKHR) -> VkResult;
type PFN_vkGetPipelineExecutableStatisticsKHR = extern "system" fn(device: VkDevice, pExecutableInfo: *const VkPipelineExecutableInfoKHR, pStatisticCount: *mut uint32_t, pStatistics: *mut VkPipelineExecutableStatisticKHR) -> VkResult;
type PFN_vkGetPipelineExecutableInternalRepresentationsKHR = extern "system" fn(device: VkDevice, pExecutableInfo: *const VkPipelineExecutableInfoKHR, pInternalRepresentationCount: *mut uint32_t, pInternalRepresentations: *mut VkPipelineExecutableInternalRepresentationKHR) -> VkResult;
extern "system" fn dummy_vkGetPipelineExecutablePropertiesKHR(_: VkDevice, _: *const VkPipelineInfoKHR, _: *mut uint32_t, _: *mut VkPipelineExecutablePropertiesKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPipelineExecutablePropertiesKHR()` is NULL");
}
pub trait VK_KHR_pipeline_executable_properties: Debug {
	fn vkGetPipelineExecutablePropertiesKHR(&self, device: VkDevice, pPipelineInfo: *const VkPipelineInfoKHR, pExecutableCount: *mut uint32_t, pProperties: *mut VkPipelineExecutablePropertiesKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_pipeline_executable_properties {
	vk_get_pipeline_executable_properties_khr: PFN_vkGetPipelineExecutablePropertiesKHR,
}
impl VK_KHR_pipeline_executable_properties for Vulkan_KHR_pipeline_executable_properties {
	fn vkGetPipelineExecutablePropertiesKHR(&self, device: VkDevice, pPipelineInfo: *const VkPipelineInfoKHR, pExecutableCount: *mut uint32_t, pProperties: *mut VkPipelineExecutablePropertiesKHR) -> VkResult {
		(self.vk_get_pipeline_executable_properties_khr)(device, pPipelineInfo, pExecutableCount, pProperties)
	}
}
impl Default for Vulkan_KHR_pipeline_executable_properties {
	fn default() -> Self {
		Self {
			vk_get_pipeline_executable_properties_khr: dummy_vkGetPipelineExecutablePropertiesKHR,
		}
	}
}
impl Vulkan_KHR_pipeline_executable_properties {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_pipeline_executable_properties_khr: {let proc = get_proc_address(instance, "vkGetPipelineExecutablePropertiesKHR"); if proc == null() {dummy_vkGetPipelineExecutablePropertiesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkMemoryUnmapFlagBitsKHR = VkMemoryUnmapFlagBits;
pub type VkMemoryUnmapFlagsKHR = VkMemoryUnmapFlags;
pub type VkMemoryMapInfoKHR = VkMemoryMapInfo;
pub type VkMemoryUnmapInfoKHR = VkMemoryUnmapInfo;
type PFN_vkMapMemory2KHR = extern "system" fn(device: VkDevice, pMemoryMapInfo: *const VkMemoryMapInfo, ppData: *mut *mut c_void) -> VkResult;
type PFN_vkUnmapMemory2KHR = extern "system" fn(device: VkDevice, pMemoryUnmapInfo: *const VkMemoryUnmapInfo) -> VkResult;
extern "system" fn dummy_vkMapMemory2KHR(_: VkDevice, _: *const VkMemoryMapInfo, _: *mut *mut c_void) -> VkResult {
	panic!("Vulkan function pointer of `vkMapMemory2KHR()` is NULL");
}
pub trait VK_KHR_map_memory2: Debug {
	fn vkMapMemory2KHR(&self, device: VkDevice, pMemoryMapInfo: *const VkMemoryMapInfo, ppData: *mut *mut c_void) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_map_memory2 {
	vk_map_memory2_khr: PFN_vkMapMemory2KHR,
}
impl VK_KHR_map_memory2 for Vulkan_KHR_map_memory2 {
	fn vkMapMemory2KHR(&self, device: VkDevice, pMemoryMapInfo: *const VkMemoryMapInfo, ppData: *mut *mut c_void) -> VkResult {
		(self.vk_map_memory2_khr)(device, pMemoryMapInfo, ppData)
	}
}
impl Default for Vulkan_KHR_map_memory2 {
	fn default() -> Self {
		Self {
			vk_map_memory2_khr: dummy_vkMapMemory2KHR,
		}
	}
}
impl Vulkan_KHR_map_memory2 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_map_memory2_khr: {let proc = get_proc_address(instance, "vkMapMemory2KHR"); if proc == null() {dummy_vkMapMemory2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR = VkPhysicalDeviceShaderIntegerDotProductFeatures;
pub type VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR = VkPhysicalDeviceShaderIntegerDotProductProperties;
pub trait VK_KHR_shader_integer_dot_product: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_integer_dot_product {}
impl VK_KHR_shader_integer_dot_product for Vulkan_KHR_shader_integer_dot_product {}
impl Default for Vulkan_KHR_shader_integer_dot_product {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_integer_dot_product {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineLibraryCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub libraryCount: u32,
	pub pLibraries: *const VkPipeline,
}
pub trait VK_KHR_pipeline_library: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_pipeline_library {}
impl VK_KHR_pipeline_library for Vulkan_KHR_pipeline_library {}
impl Default for Vulkan_KHR_pipeline_library {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_pipeline_library {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_KHR_shader_non_semantic_info: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_non_semantic_info {}
impl VK_KHR_shader_non_semantic_info for Vulkan_KHR_shader_non_semantic_info {}
impl Default for Vulkan_KHR_shader_non_semantic_info {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_non_semantic_info {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPresentIdKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount: u32,
	pub pPresentIds: *const uint64_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePresentIdFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentId: VkBool32,
}
pub trait VK_KHR_present_id: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_present_id {}
impl VK_KHR_present_id for Vulkan_KHR_present_id {}
impl Default for Vulkan_KHR_present_id {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_present_id {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkVideoEncodeFlagsKHR = VkFlags;
pub type VkVideoEncodeCapabilityFlagsKHR = VkFlags;
pub type VkVideoEncodeRateControlModeFlagsKHR = VkFlags;
pub type VkVideoEncodeFeedbackFlagsKHR = VkFlags;
pub type VkVideoEncodeUsageFlagsKHR = VkFlags;
pub type VkVideoEncodeContentFlagsKHR = VkFlags;
pub type VkVideoEncodeRateControlFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeTuningModeKHR {
	VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR = 1,
	VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR = 2,
	VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR = 3,
	VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR = 4,
	VK_VIDEO_ENCODE_TUNING_MODE_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeFlagBitsKHR {
	VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeCapabilityFlagBitsKHR {
	VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeRateControlModeFlagBitsKHR {
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeFeedbackFlagBitsKHR {
	VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_FEEDBACK_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeUsageFlagBitsKHR {
	VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_USAGE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeContentFlagBitsKHR {
	VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_CONTENT_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoEncodeFlagsKHR,
	pub dstBuffer: VkBuffer,
	pub dstBufferOffset: VkDeviceSize,
	pub dstBufferRange: VkDeviceSize,
	pub srcPictureResource: VkVideoPictureResourceInfoKHR,
	pub pSetupReferenceSlot: *const VkVideoReferenceSlotInfoKHR,
	pub referenceSlotCount: u32,
	pub pReferenceSlots: *const VkVideoReferenceSlotInfoKHR,
	pub precedingExternallyEncodedBytes: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkVideoEncodeCapabilityFlagsKHR,
	pub rateControlModes: VkVideoEncodeRateControlModeFlagsKHR,
	pub maxRateControlLayers: u32,
	pub maxBitrate: u64,
	pub maxQualityLevels: u32,
	pub encodeInputPictureGranularity: VkExtent2D,
	pub supportedEncodeFeedbackFlags: VkVideoEncodeFeedbackFlagsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkQueryPoolVideoEncodeFeedbackCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub encodeFeedbackFlags: VkVideoEncodeFeedbackFlagsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeUsageInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub videoUsageHints: VkVideoEncodeUsageFlagsKHR,
	pub videoContentHints: VkVideoEncodeContentFlagsKHR,
	pub tuningMode: VkVideoEncodeTuningModeKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeRateControlLayerInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub averageBitrate: u64,
	pub maxBitrate: u64,
	pub frameRateNumerator: u32,
	pub frameRateDenominator: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeRateControlInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoEncodeRateControlFlagsKHR,
	pub rateControlMode: VkVideoEncodeRateControlModeFlagBitsKHR,
	pub layerCount: u32,
	pub pLayers: *const VkVideoEncodeRateControlLayerInfoKHR,
	pub virtualBufferSizeInMs: u32,
	pub initialVirtualBufferSizeInMs: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pVideoProfile: *const VkVideoProfileInfoKHR,
	pub qualityLevel: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeQualityLevelPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub preferredRateControlMode: VkVideoEncodeRateControlModeFlagBitsKHR,
	pub preferredRateControlLayerCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeQualityLevelInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub qualityLevel: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeSessionParametersGetInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub videoSessionParameters: VkVideoSessionParametersKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeSessionParametersFeedbackInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub hasOverrides: VkBool32,
}
type PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pQualityLevelInfo: *const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, pQualityLevelProperties: *mut VkVideoEncodeQualityLevelPropertiesKHR) -> VkResult;
type PFN_vkGetEncodedVideoSessionParametersKHR = extern "system" fn(device: VkDevice, pVideoSessionParametersInfo: *const VkVideoEncodeSessionParametersGetInfoKHR, pFeedbackInfo: *mut VkVideoEncodeSessionParametersFeedbackInfoKHR, pDataSize: *mut size_t, pData: *mut c_void) -> VkResult;
type PFN_vkCmdEncodeVideoKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pEncodeInfo: *const VkVideoEncodeInfoKHR);
extern "system" fn dummy_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(_: VkPhysicalDevice, _: *const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, _: *mut VkVideoEncodeQualityLevelPropertiesKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR()` is NULL");
}
pub trait VK_KHR_video_encode_queue: Debug {
	fn vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pQualityLevelInfo: *const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, pQualityLevelProperties: *mut VkVideoEncodeQualityLevelPropertiesKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_encode_queue {
	vk_get_physical_device_video_encode_quality_level_properties_khr: PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR,
}
impl VK_KHR_video_encode_queue for Vulkan_KHR_video_encode_queue {
	fn vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pQualityLevelInfo: *const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, pQualityLevelProperties: *mut VkVideoEncodeQualityLevelPropertiesKHR) -> VkResult {
		(self.vk_get_physical_device_video_encode_quality_level_properties_khr)(physicalDevice, pQualityLevelInfo, pQualityLevelProperties)
	}
}
impl Default for Vulkan_KHR_video_encode_queue {
	fn default() -> Self {
		Self {
			vk_get_physical_device_video_encode_quality_level_properties_khr: dummy_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR,
		}
	}
}
impl Vulkan_KHR_video_encode_queue {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_video_encode_quality_level_properties_khr: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR"); if proc == null() {dummy_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPipelineStageFlags2KHR = VkPipelineStageFlags2;
pub type VkPipelineStageFlagBits2KHR = VkPipelineStageFlagBits2;
pub type VkAccessFlags2KHR = VkAccessFlags2;
pub type VkAccessFlagBits2KHR = VkAccessFlagBits2;
pub type VkSubmitFlagBitsKHR = VkSubmitFlagBits;
pub type VkSubmitFlagsKHR = VkSubmitFlags;
pub type VkMemoryBarrier2KHR = VkMemoryBarrier2;
pub type VkBufferMemoryBarrier2KHR = VkBufferMemoryBarrier2;
pub type VkImageMemoryBarrier2KHR = VkImageMemoryBarrier2;
pub type VkDependencyInfoKHR = VkDependencyInfo;
pub type VkSubmitInfo2KHR = VkSubmitInfo2;
pub type VkSemaphoreSubmitInfoKHR = VkSemaphoreSubmitInfo;
pub type VkCommandBufferSubmitInfoKHR = VkCommandBufferSubmitInfo;
pub type VkPhysicalDeviceSynchronization2FeaturesKHR = VkPhysicalDeviceSynchronization2Features;
type PFN_vkCmdSetEvent2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *const VkDependencyInfo);
type PFN_vkCmdResetEvent2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2);
type PFN_vkCmdWaitEvents2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, pDependencyInfos: *const VkDependencyInfo);
type PFN_vkCmdPipelineBarrier2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pDependencyInfo: *const VkDependencyInfo);
type PFN_vkCmdWriteTimestamp2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: u32);
type PFN_vkQueueSubmit2KHR = extern "system" fn(queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo2, fence: VkFence) -> VkResult;
extern "system" fn dummy_vkCmdSetEvent2KHR(_: VkCommandBuffer, _: VkEvent, _: *const VkDependencyInfo) {
	panic!("Vulkan function pointer of `vkCmdSetEvent2KHR()` is NULL");
}
pub trait VK_KHR_synchronization2: Debug {
	fn vkCmdSetEvent2KHR(&self, commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *const VkDependencyInfo);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_synchronization2 {
	vk_cmd_set_event2_khr: PFN_vkCmdSetEvent2KHR,
}
impl VK_KHR_synchronization2 for Vulkan_KHR_synchronization2 {
	fn vkCmdSetEvent2KHR(&self, commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *const VkDependencyInfo) {
		(self.vk_cmd_set_event2_khr)(commandBuffer, event, pDependencyInfo)
	}
}
impl Default for Vulkan_KHR_synchronization2 {
	fn default() -> Self {
		Self {
			vk_cmd_set_event2_khr: dummy_vkCmdSetEvent2KHR,
		}
	}
}
impl Vulkan_KHR_synchronization2 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_event2_khr: {let proc = get_proc_address(instance, "vkCmdSetEvent2KHR"); if proc == null() {dummy_vkCmdSetEvent2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub fragmentShaderBarycentric: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub triStripVertexOrderIndependentOfProvokingVertex: VkBool32,
}
pub trait VK_KHR_fragment_shader_barycentric: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_fragment_shader_barycentric {}
impl VK_KHR_fragment_shader_barycentric for Vulkan_KHR_fragment_shader_barycentric {}
impl Default for Vulkan_KHR_fragment_shader_barycentric {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_fragment_shader_barycentric {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderSubgroupUniformControlFlow: VkBool32,
}
pub trait VK_KHR_shader_subgroup_uniform_control_flow: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_subgroup_uniform_control_flow {}
impl VK_KHR_shader_subgroup_uniform_control_flow for Vulkan_KHR_shader_subgroup_uniform_control_flow {}
impl Default for Vulkan_KHR_shader_subgroup_uniform_control_flow {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_subgroup_uniform_control_flow {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
pub trait VK_KHR_zero_initialize_workgroup_memory: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_zero_initialize_workgroup_memory {}
impl VK_KHR_zero_initialize_workgroup_memory for Vulkan_KHR_zero_initialize_workgroup_memory {}
impl Default for Vulkan_KHR_zero_initialize_workgroup_memory {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_zero_initialize_workgroup_memory {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub workgroupMemoryExplicitLayout: VkBool32,
	pub workgroupMemoryExplicitLayoutScalarBlockLayout: VkBool32,
	pub workgroupMemoryExplicitLayout8BitAccess: VkBool32,
	pub workgroupMemoryExplicitLayout16BitAccess: VkBool32,
}
pub trait VK_KHR_workgroup_memory_explicit_layout: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_workgroup_memory_explicit_layout {}
impl VK_KHR_workgroup_memory_explicit_layout for Vulkan_KHR_workgroup_memory_explicit_layout {}
impl Default for Vulkan_KHR_workgroup_memory_explicit_layout {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_workgroup_memory_explicit_layout {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkCopyBufferInfo2KHR = VkCopyBufferInfo2;
pub type VkCopyImageInfo2KHR = VkCopyImageInfo2;
pub type VkCopyBufferToImageInfo2KHR = VkCopyBufferToImageInfo2;
pub type VkCopyImageToBufferInfo2KHR = VkCopyImageToBufferInfo2;
pub type VkBlitImageInfo2KHR = VkBlitImageInfo2;
pub type VkResolveImageInfo2KHR = VkResolveImageInfo2;
pub type VkBufferCopy2KHR = VkBufferCopy2;
pub type VkImageCopy2KHR = VkImageCopy2;
pub type VkImageBlit2KHR = VkImageBlit2;
pub type VkBufferImageCopy2KHR = VkBufferImageCopy2;
pub type VkImageResolve2KHR = VkImageResolve2;
type PFN_vkCmdCopyBuffer2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2);
type PFN_vkCmdCopyImage2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyImageInfo: *const VkCopyImageInfo2);
type PFN_vkCmdCopyBufferToImage2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: *const VkCopyBufferToImageInfo2);
type PFN_vkCmdCopyImageToBuffer2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: *const VkCopyImageToBufferInfo2);
type PFN_vkCmdBlitImage2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pBlitImageInfo: *const VkBlitImageInfo2);
type PFN_vkCmdResolveImage2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pResolveImageInfo: *const VkResolveImageInfo2);
extern "system" fn dummy_vkCmdCopyBuffer2KHR(_: VkCommandBuffer, _: *const VkCopyBufferInfo2) {
	panic!("Vulkan function pointer of `vkCmdCopyBuffer2KHR()` is NULL");
}
pub trait VK_KHR_copy_commands2: Debug {
	fn vkCmdCopyBuffer2KHR(&self, commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_copy_commands2 {
	vk_cmd_copy_buffer2_khr: PFN_vkCmdCopyBuffer2KHR,
}
impl VK_KHR_copy_commands2 for Vulkan_KHR_copy_commands2 {
	fn vkCmdCopyBuffer2KHR(&self, commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2) {
		(self.vk_cmd_copy_buffer2_khr)(commandBuffer, pCopyBufferInfo)
	}
}
impl Default for Vulkan_KHR_copy_commands2 {
	fn default() -> Self {
		Self {
			vk_cmd_copy_buffer2_khr: dummy_vkCmdCopyBuffer2KHR,
		}
	}
}
impl Vulkan_KHR_copy_commands2 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_copy_buffer2_khr: {let proc = get_proc_address(instance, "vkCmdCopyBuffer2KHR"); if proc == null() {dummy_vkCmdCopyBuffer2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkFormatFeatureFlags2KHR = VkFormatFeatureFlags2;
pub type VkFormatFeatureFlagBits2KHR = VkFormatFeatureFlagBits2;
pub type VkFormatProperties3KHR = VkFormatProperties3;
pub trait VK_KHR_format_feature_flags2: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_format_feature_flags2 {}
impl VK_KHR_format_feature_flags2 for Vulkan_KHR_format_feature_flags2 {}
impl Default for Vulkan_KHR_format_feature_flags2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_format_feature_flags2 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rayTracingMaintenance1: VkBool32,
	pub rayTracingPipelineTraceRaysIndirect2: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTraceRaysIndirectCommand2KHR {
	pub raygenShaderRecordAddress: VkDeviceAddress,
	pub raygenShaderRecordSize: VkDeviceSize,
	pub missShaderBindingTableAddress: VkDeviceAddress,
	pub missShaderBindingTableSize: VkDeviceSize,
	pub missShaderBindingTableStride: VkDeviceSize,
	pub hitShaderBindingTableAddress: VkDeviceAddress,
	pub hitShaderBindingTableSize: VkDeviceSize,
	pub hitShaderBindingTableStride: VkDeviceSize,
	pub callableShaderBindingTableAddress: VkDeviceAddress,
	pub callableShaderBindingTableSize: VkDeviceSize,
	pub callableShaderBindingTableStride: VkDeviceSize,
	pub width: u32,
	pub height: u32,
	pub depth: u32,
}
type PFN_vkCmdTraceRaysIndirect2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, indirectDeviceAddress: VkDeviceAddress);
extern "system" fn dummy_vkCmdTraceRaysIndirect2KHR(_: VkCommandBuffer, _: VkDeviceAddress) {
	panic!("Vulkan function pointer of `vkCmdTraceRaysIndirect2KHR()` is NULL");
}
pub trait VK_KHR_ray_tracing_maintenance1: Debug {
	fn vkCmdTraceRaysIndirect2KHR(&self, commandBuffer: VkCommandBuffer, indirectDeviceAddress: VkDeviceAddress);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_ray_tracing_maintenance1 {
	vk_cmd_trace_rays_indirect2_khr: PFN_vkCmdTraceRaysIndirect2KHR,
}
impl VK_KHR_ray_tracing_maintenance1 for Vulkan_KHR_ray_tracing_maintenance1 {
	fn vkCmdTraceRaysIndirect2KHR(&self, commandBuffer: VkCommandBuffer, indirectDeviceAddress: VkDeviceAddress) {
		(self.vk_cmd_trace_rays_indirect2_khr)(commandBuffer, indirectDeviceAddress)
	}
}
impl Default for Vulkan_KHR_ray_tracing_maintenance1 {
	fn default() -> Self {
		Self {
			vk_cmd_trace_rays_indirect2_khr: dummy_vkCmdTraceRaysIndirect2KHR,
		}
	}
}
impl Vulkan_KHR_ray_tracing_maintenance1 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_trace_rays_indirect2_khr: {let proc = get_proc_address(instance, "vkCmdTraceRaysIndirect2KHR"); if proc == null() {dummy_vkCmdTraceRaysIndirect2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub trait VK_KHR_portability_enumeration: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_portability_enumeration {}
impl VK_KHR_portability_enumeration for Vulkan_KHR_portability_enumeration {}
impl Default for Vulkan_KHR_portability_enumeration {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_portability_enumeration {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceMaintenance4FeaturesKHR = VkPhysicalDeviceMaintenance4Features;
pub type VkPhysicalDeviceMaintenance4PropertiesKHR = VkPhysicalDeviceMaintenance4Properties;
pub type VkDeviceBufferMemoryRequirementsKHR = VkDeviceBufferMemoryRequirements;
pub type VkDeviceImageMemoryRequirementsKHR = VkDeviceImageMemoryRequirements;
type PFN_vkGetDeviceBufferMemoryRequirementsKHR = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceBufferMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2);
type PFN_vkGetDeviceImageMemoryRequirementsKHR = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2);
type PFN_vkGetDeviceImageSparseMemoryRequirementsKHR = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2);
extern "system" fn dummy_vkGetDeviceBufferMemoryRequirementsKHR(_: VkDevice, _: *const VkDeviceBufferMemoryRequirements, _: *mut VkMemoryRequirements2) {
	panic!("Vulkan function pointer of `vkGetDeviceBufferMemoryRequirementsKHR()` is NULL");
}
pub trait VK_KHR_maintenance4: Debug {
	fn vkGetDeviceBufferMemoryRequirementsKHR(&self, device: VkDevice, pInfo: *const VkDeviceBufferMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance4 {
	vk_get_device_buffer_memory_requirements_khr: PFN_vkGetDeviceBufferMemoryRequirementsKHR,
}
impl VK_KHR_maintenance4 for Vulkan_KHR_maintenance4 {
	fn vkGetDeviceBufferMemoryRequirementsKHR(&self, device: VkDevice, pInfo: *const VkDeviceBufferMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_get_device_buffer_memory_requirements_khr)(device, pInfo, pMemoryRequirements)
	}
}
impl Default for Vulkan_KHR_maintenance4 {
	fn default() -> Self {
		Self {
			vk_get_device_buffer_memory_requirements_khr: dummy_vkGetDeviceBufferMemoryRequirementsKHR,
		}
	}
}
impl Vulkan_KHR_maintenance4 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_device_buffer_memory_requirements_khr: {let proc = get_proc_address(instance, "vkGetDeviceBufferMemoryRequirementsKHR"); if proc == null() {dummy_vkGetDeviceBufferMemoryRequirementsKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR = VkPhysicalDeviceShaderSubgroupRotateFeatures;
pub trait VK_KHR_shader_subgroup_rotate: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_subgroup_rotate {}
impl VK_KHR_shader_subgroup_rotate for Vulkan_KHR_shader_subgroup_rotate {}
impl Default for Vulkan_KHR_shader_subgroup_rotate {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_subgroup_rotate {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderMaximalReconvergence: VkBool32,
}
pub trait VK_KHR_shader_maximal_reconvergence: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_maximal_reconvergence {}
impl VK_KHR_shader_maximal_reconvergence for Vulkan_KHR_shader_maximal_reconvergence {}
impl Default for Vulkan_KHR_shader_maximal_reconvergence {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_maximal_reconvergence {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPipelineCreateFlags2KHR = VkPipelineCreateFlags2;
pub type VkPipelineCreateFlagBits2KHR = VkPipelineCreateFlagBits2;
pub type VkBufferUsageFlags2KHR = VkBufferUsageFlags2;
pub type VkBufferUsageFlagBits2KHR = VkBufferUsageFlagBits2;
pub type VkPhysicalDeviceMaintenance5FeaturesKHR = VkPhysicalDeviceMaintenance5Features;
pub type VkPhysicalDeviceMaintenance5PropertiesKHR = VkPhysicalDeviceMaintenance5Properties;
pub type VkRenderingAreaInfoKHR = VkRenderingAreaInfo;
pub type VkDeviceImageSubresourceInfoKHR = VkDeviceImageSubresourceInfo;
pub type VkImageSubresource2KHR = VkImageSubresource2;
pub type VkSubresourceLayout2KHR = VkSubresourceLayout2;
pub type VkPipelineCreateFlags2CreateInfoKHR = VkPipelineCreateFlags2CreateInfo;
pub type VkBufferUsageFlags2CreateInfoKHR = VkBufferUsageFlags2CreateInfo;
type PFN_vkCmdBindIndexBuffer2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType);
type PFN_vkGetRenderingAreaGranularityKHR = extern "system" fn(device: VkDevice, pRenderingAreaInfo: *const VkRenderingAreaInfo, pGranularity: *mut VkExtent2D);
type PFN_vkGetDeviceImageSubresourceLayoutKHR = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceImageSubresourceInfo, pLayout: *mut VkSubresourceLayout2);
type PFN_vkGetImageSubresourceLayout2KHR = extern "system" fn(device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource2, pLayout: *mut VkSubresourceLayout2);
extern "system" fn dummy_vkCmdBindIndexBuffer2KHR(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkDeviceSize, _: VkIndexType) {
	panic!("Vulkan function pointer of `vkCmdBindIndexBuffer2KHR()` is NULL");
}
pub trait VK_KHR_maintenance5: Debug {
	fn vkCmdBindIndexBuffer2KHR(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance5 {
	vk_cmd_bind_index_buffer2_khr: PFN_vkCmdBindIndexBuffer2KHR,
}
impl VK_KHR_maintenance5 for Vulkan_KHR_maintenance5 {
	fn vkCmdBindIndexBuffer2KHR(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType) {
		(self.vk_cmd_bind_index_buffer2_khr)(commandBuffer, buffer, offset, size, indexType)
	}
}
impl Default for Vulkan_KHR_maintenance5 {
	fn default() -> Self {
		Self {
			vk_cmd_bind_index_buffer2_khr: dummy_vkCmdBindIndexBuffer2KHR,
		}
	}
}
impl Vulkan_KHR_maintenance5 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_bind_index_buffer2_khr: {let proc = get_proc_address(instance, "vkCmdBindIndexBuffer2KHR"); if proc == null() {dummy_vkCmdBindIndexBuffer2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSurfaceCapabilitiesPresentId2KHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentId2Supported: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPresentId2KHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount: u32,
	pub pPresentIds: *const uint64_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePresentId2FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentId2: VkBool32,
}
pub trait VK_KHR_present_id2: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_present_id2 {}
impl VK_KHR_present_id2 for Vulkan_KHR_present_id2 {}
impl Default for Vulkan_KHR_present_id2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_present_id2 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSurfaceCapabilitiesPresentWait2KHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentWait2Supported: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePresentWait2FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentWait2: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPresentWait2InfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub presentId: u64,
	pub timeout: u64,
}
type PFN_vkWaitForPresent2KHR = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pPresentWait2Info: *const VkPresentWait2InfoKHR) -> VkResult;
extern "system" fn dummy_vkWaitForPresent2KHR(_: VkDevice, _: VkSwapchainKHR, _: *const VkPresentWait2InfoKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkWaitForPresent2KHR()` is NULL");
}
pub trait VK_KHR_present_wait2: Debug {
	fn vkWaitForPresent2KHR(&self, device: VkDevice, swapchain: VkSwapchainKHR, pPresentWait2Info: *const VkPresentWait2InfoKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_present_wait2 {
	vk_wait_for_present2_khr: PFN_vkWaitForPresent2KHR,
}
impl VK_KHR_present_wait2 for Vulkan_KHR_present_wait2 {
	fn vkWaitForPresent2KHR(&self, device: VkDevice, swapchain: VkSwapchainKHR, pPresentWait2Info: *const VkPresentWait2InfoKHR) -> VkResult {
		(self.vk_wait_for_present2_khr)(device, swapchain, pPresentWait2Info)
	}
}
impl Default for Vulkan_KHR_present_wait2 {
	fn default() -> Self {
		Self {
			vk_wait_for_present2_khr: dummy_vkWaitForPresent2KHR,
		}
	}
}
impl Vulkan_KHR_present_wait2 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_wait_for_present2_khr: {let proc = get_proc_address(instance, "vkWaitForPresent2KHR"); if proc == null() {dummy_vkWaitForPresent2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rayTracingPositionFetch: VkBool32,
}
pub trait VK_KHR_ray_tracing_position_fetch: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_ray_tracing_position_fetch {}
impl VK_KHR_ray_tracing_position_fetch for Vulkan_KHR_ray_tracing_position_fetch {}
impl Default for Vulkan_KHR_ray_tracing_position_fetch {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_ray_tracing_position_fetch {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR: u32 = 32u32;
// Define non-dispatchable handle `VkPipelineBinaryKHR`
#[cfg(target_pointer_width = "32")] pub type VkPipelineBinaryKHR = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkPipelineBinaryKHR_T {}
#[cfg(target_pointer_width = "64")] pub type VkPipelineBinaryKHR = *const VkPipelineBinaryKHR_T;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePipelineBinaryFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineBinaries: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePipelineBinaryPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineBinaryInternalCache: VkBool32,
	pub pipelineBinaryInternalCacheControl: VkBool32,
	pub pipelineBinaryPrefersInternalCache: VkBool32,
	pub pipelineBinaryPrecompiledInternalCache: VkBool32,
	pub pipelineBinaryCompressedData: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDevicePipelineBinaryInternalCacheControlKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub disableInternalCache: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineBinaryKeyKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub keySize: u32,
	pub key: [u8; VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineBinaryDataKHR {
	pub dataSize: usize,
	pub pData: *mut c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineBinaryKeysAndDataKHR {
	pub binaryCount: u32,
	pub pPipelineBinaryKeys: *const VkPipelineBinaryKeyKHR,
	pub pPipelineBinaryData: *const VkPipelineBinaryDataKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineBinaryCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pKeysAndDataInfo: *const VkPipelineBinaryKeysAndDataKHR,
	pub pipeline: VkPipeline,
	pub pPipelineCreateInfo: *const VkPipelineCreateInfoKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineBinaryInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub binaryCount: u32,
	pub pPipelineBinaries: *const VkPipelineBinaryKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkReleaseCapturedPipelineDataInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipeline: VkPipeline,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineBinaryDataInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineBinary: VkPipelineBinaryKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineBinaryHandlesInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pipelineBinaryCount: u32,
	pub pPipelineBinaries: *mut VkPipelineBinaryKHR,
}
type PFN_vkCreatePipelineBinariesKHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkPipelineBinaryCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pBinaries: *mut VkPipelineBinaryHandlesInfoKHR) -> VkResult;
type PFN_vkDestroyPipelineBinaryKHR = extern "system" fn(device: VkDevice, pipelineBinary: VkPipelineBinaryKHR, pAllocator: *const VkAllocationCallbacks);
type PFN_vkGetPipelineKeyKHR = extern "system" fn(device: VkDevice, pPipelineCreateInfo: *const VkPipelineCreateInfoKHR, pPipelineKey: *mut VkPipelineBinaryKeyKHR) -> VkResult;
type PFN_vkGetPipelineBinaryDataKHR = extern "system" fn(device: VkDevice, pInfo: *const VkPipelineBinaryDataInfoKHR, pPipelineBinaryKey: *mut VkPipelineBinaryKeyKHR, pPipelineBinaryDataSize: *mut size_t, pPipelineBinaryData: *mut c_void) -> VkResult;
type PFN_vkReleaseCapturedPipelineDataKHR = extern "system" fn(device: VkDevice, pInfo: *const VkReleaseCapturedPipelineDataInfoKHR, pAllocator: *const VkAllocationCallbacks) -> VkResult;
extern "system" fn dummy_vkCreatePipelineBinariesKHR(_: VkDevice, _: *const VkPipelineBinaryCreateInfoKHR, _: *const VkAllocationCallbacks, _: *mut VkPipelineBinaryHandlesInfoKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkCreatePipelineBinariesKHR()` is NULL");
}
pub trait VK_KHR_pipeline_binary: Debug {
	fn vkCreatePipelineBinariesKHR(&self, device: VkDevice, pCreateInfo: *const VkPipelineBinaryCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pBinaries: *mut VkPipelineBinaryHandlesInfoKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_pipeline_binary {
	vk_create_pipeline_binaries_khr: PFN_vkCreatePipelineBinariesKHR,
}
impl VK_KHR_pipeline_binary for Vulkan_KHR_pipeline_binary {
	fn vkCreatePipelineBinariesKHR(&self, device: VkDevice, pCreateInfo: *const VkPipelineBinaryCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pBinaries: *mut VkPipelineBinaryHandlesInfoKHR) -> VkResult {
		(self.vk_create_pipeline_binaries_khr)(device, pCreateInfo, pAllocator, pBinaries)
	}
}
impl Default for Vulkan_KHR_pipeline_binary {
	fn default() -> Self {
		Self {
			vk_create_pipeline_binaries_khr: dummy_vkCreatePipelineBinariesKHR,
		}
	}
}
impl Vulkan_KHR_pipeline_binary {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_pipeline_binaries_khr: {let proc = get_proc_address(instance, "vkCreatePipelineBinariesKHR"); if proc == null() {dummy_vkCreatePipelineBinariesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPresentScalingFlagsKHR = VkFlags;
pub type VkPresentGravityFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPresentScalingFlagBitsKHR {
	VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR = 0x00000001,
	VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR = 0x00000002,
	VK_PRESENT_SCALING_STRETCH_BIT_KHR = 0x00000004,
	VK_PRESENT_SCALING_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkPresentScalingFlagBitsKHR {
	pub const VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT: VkPresentScalingFlagBitsKHR = VkPresentScalingFlagBitsKHR::VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR;
	pub const VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT: VkPresentScalingFlagBitsKHR = VkPresentScalingFlagBitsKHR::VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR;
	pub const VK_PRESENT_SCALING_STRETCH_BIT_EXT: VkPresentScalingFlagBitsKHR = VkPresentScalingFlagBitsKHR::VK_PRESENT_SCALING_STRETCH_BIT_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPresentGravityFlagBitsKHR {
	VK_PRESENT_GRAVITY_MIN_BIT_KHR = 0x00000001,
	VK_PRESENT_GRAVITY_MAX_BIT_KHR = 0x00000002,
	VK_PRESENT_GRAVITY_CENTERED_BIT_KHR = 0x00000004,
	VK_PRESENT_GRAVITY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkPresentGravityFlagBitsKHR {
	pub const VK_PRESENT_GRAVITY_MIN_BIT_EXT: VkPresentGravityFlagBitsKHR = VkPresentGravityFlagBitsKHR::VK_PRESENT_GRAVITY_MIN_BIT_KHR;
	pub const VK_PRESENT_GRAVITY_MAX_BIT_EXT: VkPresentGravityFlagBitsKHR = VkPresentGravityFlagBitsKHR::VK_PRESENT_GRAVITY_MAX_BIT_KHR;
	pub const VK_PRESENT_GRAVITY_CENTERED_BIT_EXT: VkPresentGravityFlagBitsKHR = VkPresentGravityFlagBitsKHR::VK_PRESENT_GRAVITY_CENTERED_BIT_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSurfacePresentModeKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentMode: VkPresentModeKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSurfacePresentScalingCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub supportedPresentScaling: VkPresentScalingFlagsKHR,
	pub supportedPresentGravityX: VkPresentGravityFlagsKHR,
	pub supportedPresentGravityY: VkPresentGravityFlagsKHR,
	pub minScaledImageExtent: VkExtent2D,
	pub maxScaledImageExtent: VkExtent2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSurfacePresentModeCompatibilityKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentModeCount: u32,
	pub pPresentModes: *mut VkPresentModeKHR,
}
pub trait VK_KHR_surface_maintenance1: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_surface_maintenance1 {}
impl VK_KHR_surface_maintenance1 for Vulkan_KHR_surface_maintenance1 {}
impl Default for Vulkan_KHR_surface_maintenance1 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_surface_maintenance1 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub swapchainMaintenance1: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSwapchainPresentFenceInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount: u32,
	pub pFences: *const VkFence,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSwapchainPresentModesCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub presentModeCount: u32,
	pub pPresentModes: *const VkPresentModeKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSwapchainPresentModeInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount: u32,
	pub pPresentModes: *const VkPresentModeKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSwapchainPresentScalingCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub scalingBehavior: VkPresentScalingFlagsKHR,
	pub presentGravityX: VkPresentGravityFlagsKHR,
	pub presentGravityY: VkPresentGravityFlagsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkReleaseSwapchainImagesInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchain: VkSwapchainKHR,
	pub imageIndexCount: u32,
	pub pImageIndices: *const uint32_t,
}
type PFN_vkReleaseSwapchainImagesKHR = extern "system" fn(device: VkDevice, pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR) -> VkResult;
extern "system" fn dummy_vkReleaseSwapchainImagesKHR(_: VkDevice, _: *const VkReleaseSwapchainImagesInfoKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkReleaseSwapchainImagesKHR()` is NULL");
}
pub trait VK_KHR_swapchain_maintenance1: Debug {
	fn vkReleaseSwapchainImagesKHR(&self, device: VkDevice, pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_swapchain_maintenance1 {
	vk_release_swapchain_images_khr: PFN_vkReleaseSwapchainImagesKHR,
}
impl VK_KHR_swapchain_maintenance1 for Vulkan_KHR_swapchain_maintenance1 {
	fn vkReleaseSwapchainImagesKHR(&self, device: VkDevice, pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR) -> VkResult {
		(self.vk_release_swapchain_images_khr)(device, pReleaseInfo)
	}
}
impl Default for Vulkan_KHR_swapchain_maintenance1 {
	fn default() -> Self {
		Self {
			vk_release_swapchain_images_khr: dummy_vkReleaseSwapchainImagesKHR,
		}
	}
}
impl Vulkan_KHR_swapchain_maintenance1 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_release_swapchain_images_khr: {let proc = get_proc_address(instance, "vkReleaseSwapchainImagesKHR"); if proc == null() {dummy_vkReleaseSwapchainImagesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkComponentTypeKHR {
	VK_COMPONENT_TYPE_FLOAT16_KHR = 0,
	VK_COMPONENT_TYPE_FLOAT32_KHR = 1,
	VK_COMPONENT_TYPE_FLOAT64_KHR = 2,
	VK_COMPONENT_TYPE_SINT8_KHR = 3,
	VK_COMPONENT_TYPE_SINT16_KHR = 4,
	VK_COMPONENT_TYPE_SINT32_KHR = 5,
	VK_COMPONENT_TYPE_SINT64_KHR = 6,
	VK_COMPONENT_TYPE_UINT8_KHR = 7,
	VK_COMPONENT_TYPE_UINT16_KHR = 8,
	VK_COMPONENT_TYPE_UINT32_KHR = 9,
	VK_COMPONENT_TYPE_UINT64_KHR = 10,
	VK_COMPONENT_TYPE_BFLOAT16_KHR = 1000141000,
	VK_COMPONENT_TYPE_SINT8_PACKED_NV = 1000491000,
	VK_COMPONENT_TYPE_UINT8_PACKED_NV = 1000491001,
	VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT = 1000491002,
	VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT = 1000491003,
	VK_COMPONENT_TYPE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkComponentTypeKHR {
	pub const VK_COMPONENT_TYPE_FLOAT16_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_FLOAT16_KHR;
	pub const VK_COMPONENT_TYPE_FLOAT32_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_FLOAT32_KHR;
	pub const VK_COMPONENT_TYPE_FLOAT64_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_FLOAT64_KHR;
	pub const VK_COMPONENT_TYPE_SINT8_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_SINT8_KHR;
	pub const VK_COMPONENT_TYPE_SINT16_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_SINT16_KHR;
	pub const VK_COMPONENT_TYPE_SINT32_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_SINT32_KHR;
	pub const VK_COMPONENT_TYPE_SINT64_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_SINT64_KHR;
	pub const VK_COMPONENT_TYPE_UINT8_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_UINT8_KHR;
	pub const VK_COMPONENT_TYPE_UINT16_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_UINT16_KHR;
	pub const VK_COMPONENT_TYPE_UINT32_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_UINT32_KHR;
	pub const VK_COMPONENT_TYPE_UINT64_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_UINT64_KHR;
	pub const VK_COMPONENT_TYPE_FLOAT_E4M3_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT;
	pub const VK_COMPONENT_TYPE_FLOAT_E5M2_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkScopeKHR {
	VK_SCOPE_DEVICE_KHR = 1,
	VK_SCOPE_WORKGROUP_KHR = 2,
	VK_SCOPE_SUBGROUP_KHR = 3,
	VK_SCOPE_QUEUE_FAMILY_KHR = 5,
	VK_SCOPE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkScopeKHR {
	pub const VK_SCOPE_DEVICE_NV: VkScopeKHR = VkScopeKHR::VK_SCOPE_DEVICE_KHR;
	pub const VK_SCOPE_WORKGROUP_NV: VkScopeKHR = VkScopeKHR::VK_SCOPE_WORKGROUP_KHR;
	pub const VK_SCOPE_SUBGROUP_NV: VkScopeKHR = VkScopeKHR::VK_SCOPE_SUBGROUP_KHR;
	pub const VK_SCOPE_QUEUE_FAMILY_NV: VkScopeKHR = VkScopeKHR::VK_SCOPE_QUEUE_FAMILY_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCooperativeMatrixPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub MSize: u32,
	pub NSize: u32,
	pub KSize: u32,
	pub AType: VkComponentTypeKHR,
	pub BType: VkComponentTypeKHR,
	pub CType: VkComponentTypeKHR,
	pub ResultType: VkComponentTypeKHR,
	pub saturatingAccumulation: VkBool32,
	pub scope: VkScopeKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCooperativeMatrixFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cooperativeMatrix: VkBool32,
	pub cooperativeMatrixRobustBufferAccess: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCooperativeMatrixPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cooperativeMatrixSupportedStages: VkShaderStageFlags,
}
type PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixPropertiesKHR) -> VkResult;
extern "system" fn dummy_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkCooperativeMatrixPropertiesKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR()` is NULL");
}
pub trait VK_KHR_cooperative_matrix: Debug {
	fn vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixPropertiesKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_cooperative_matrix {
	vk_get_physical_device_cooperative_matrix_properties_khr: PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR,
}
impl VK_KHR_cooperative_matrix for Vulkan_KHR_cooperative_matrix {
	fn vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixPropertiesKHR) -> VkResult {
		(self.vk_get_physical_device_cooperative_matrix_properties_khr)(physicalDevice, pPropertyCount, pProperties)
	}
}
impl Default for Vulkan_KHR_cooperative_matrix {
	fn default() -> Self {
		Self {
			vk_get_physical_device_cooperative_matrix_properties_khr: dummy_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR,
		}
	}
}
impl Vulkan_KHR_cooperative_matrix {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_cooperative_matrix_properties_khr: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR"); if proc == null() {dummy_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub computeDerivativeGroupQuads: VkBool32,
	pub computeDerivativeGroupLinear: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub meshAndTaskShaderDerivatives: VkBool32,
}
pub trait VK_KHR_compute_shader_derivatives: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_compute_shader_derivatives {}
impl VK_KHR_compute_shader_derivatives for Vulkan_KHR_compute_shader_derivatives {}
impl Default for Vulkan_KHR_compute_shader_derivatives {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_compute_shader_derivatives {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR: u32 = 7u32;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeAV1ProfileInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdProfile: StdVideoAV1Profile,
	pub filmGrainSupport: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeAV1CapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxLevel: StdVideoAV1Level,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeAV1SessionParametersCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdSequenceHeader: *const StdVideoAV1SequenceHeader,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeAV1PictureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdPictureInfo: *const StdVideoDecodeAV1PictureInfo,
	pub referenceNameSlotIndices: [i32; VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR as usize],
	pub frameHeaderOffset: u32,
	pub tileCount: u32,
	pub pTileOffsets: *const uint32_t,
	pub pTileSizes: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeAV1DpbSlotInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdReferenceInfo: *const StdVideoDecodeAV1ReferenceInfo,
}
pub trait VK_KHR_video_decode_av1: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_decode_av1 {}
impl VK_KHR_video_decode_av1 for Vulkan_KHR_video_decode_av1 {}
impl Default for Vulkan_KHR_video_decode_av1 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_decode_av1 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const STD_VIDEO_AV1_NUM_REF_FRAMES: u32 = 8u32;
pub const STD_VIDEO_AV1_REFS_PER_FRAME: u32 = 7u32;
pub const STD_VIDEO_AV1_TOTAL_REFS_PER_FRAME: u32 = 8u32;
pub const STD_VIDEO_AV1_MAX_TILE_COLS: u32 = 64u32;
pub const STD_VIDEO_AV1_MAX_TILE_ROWS: u32 = 64u32;
pub const STD_VIDEO_AV1_MAX_SEGMENTS: u32 = 8u32;
pub const STD_VIDEO_AV1_SEG_LVL_MAX: u32 = 8u32;
pub const STD_VIDEO_AV1_PRIMARY_REF_NONE: u32 = 7u32;
pub const STD_VIDEO_AV1_SELECT_INTEGER_MV: u32 = 2u32;
pub const STD_VIDEO_AV1_SELECT_SCREEN_CONTENT_TOOLS: u32 = 2u32;
pub const STD_VIDEO_AV1_SKIP_MODE_FRAMES: u32 = 2u32;
pub const STD_VIDEO_AV1_MAX_LOOP_FILTER_STRENGTHS: u32 = 4u32;
pub const STD_VIDEO_AV1_LOOP_FILTER_ADJUSTMENTS: u32 = 2u32;
pub const STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS: u32 = 8u32;
pub const STD_VIDEO_AV1_MAX_NUM_PLANES: u32 = 3u32;
pub const STD_VIDEO_AV1_GLOBAL_MOTION_PARAMS: u32 = 6u32;
pub const STD_VIDEO_AV1_MAX_NUM_Y_POINTS: u32 = 14u32;
pub const STD_VIDEO_AV1_MAX_NUM_CB_POINTS: u32 = 10u32;
pub const STD_VIDEO_AV1_MAX_NUM_CR_POINTS: u32 = 10u32;
pub const STD_VIDEO_AV1_MAX_NUM_POS_LUMA: u32 = 24u32;
pub const STD_VIDEO_AV1_MAX_NUM_POS_CHROMA: u32 = 25u32;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1Profile {
	STD_VIDEO_AV1_PROFILE_MAIN = 0,
	STD_VIDEO_AV1_PROFILE_HIGH = 1,
	STD_VIDEO_AV1_PROFILE_PROFESSIONAL = 2,
	STD_VIDEO_AV1_PROFILE_INVALID = 0x7fffffff,
}
impl StdVideoAV1Profile {
	pub const STD_VIDEO_AV1_PROFILE_MAX_ENUM: StdVideoAV1Profile = StdVideoAV1Profile::STD_VIDEO_AV1_PROFILE_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1Level {
	STD_VIDEO_AV1_LEVEL_2_0 = 0,
	STD_VIDEO_AV1_LEVEL_2_1 = 1,
	STD_VIDEO_AV1_LEVEL_2_2 = 2,
	STD_VIDEO_AV1_LEVEL_2_3 = 3,
	STD_VIDEO_AV1_LEVEL_3_0 = 4,
	STD_VIDEO_AV1_LEVEL_3_1 = 5,
	STD_VIDEO_AV1_LEVEL_3_2 = 6,
	STD_VIDEO_AV1_LEVEL_3_3 = 7,
	STD_VIDEO_AV1_LEVEL_4_0 = 8,
	STD_VIDEO_AV1_LEVEL_4_1 = 9,
	STD_VIDEO_AV1_LEVEL_4_2 = 10,
	STD_VIDEO_AV1_LEVEL_4_3 = 11,
	STD_VIDEO_AV1_LEVEL_5_0 = 12,
	STD_VIDEO_AV1_LEVEL_5_1 = 13,
	STD_VIDEO_AV1_LEVEL_5_2 = 14,
	STD_VIDEO_AV1_LEVEL_5_3 = 15,
	STD_VIDEO_AV1_LEVEL_6_0 = 16,
	STD_VIDEO_AV1_LEVEL_6_1 = 17,
	STD_VIDEO_AV1_LEVEL_6_2 = 18,
	STD_VIDEO_AV1_LEVEL_6_3 = 19,
	STD_VIDEO_AV1_LEVEL_7_0 = 20,
	STD_VIDEO_AV1_LEVEL_7_1 = 21,
	STD_VIDEO_AV1_LEVEL_7_2 = 22,
	STD_VIDEO_AV1_LEVEL_7_3 = 23,
	STD_VIDEO_AV1_LEVEL_INVALID = 0x7fffffff,
}
impl StdVideoAV1Level {
	pub const STD_VIDEO_AV1_LEVEL_MAX_ENUM: StdVideoAV1Level = StdVideoAV1Level::STD_VIDEO_AV1_LEVEL_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1FrameType {
	STD_VIDEO_AV1_FRAME_TYPE_KEY = 0,
	STD_VIDEO_AV1_FRAME_TYPE_INTER = 1,
	STD_VIDEO_AV1_FRAME_TYPE_INTRA_ONLY = 2,
	STD_VIDEO_AV1_FRAME_TYPE_SWITCH = 3,
	STD_VIDEO_AV1_FRAME_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoAV1FrameType {
	pub const STD_VIDEO_AV1_FRAME_TYPE_MAX_ENUM: StdVideoAV1FrameType = StdVideoAV1FrameType::STD_VIDEO_AV1_FRAME_TYPE_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1ReferenceName {
	STD_VIDEO_AV1_REFERENCE_NAME_INTRA_FRAME = 0,
	STD_VIDEO_AV1_REFERENCE_NAME_LAST_FRAME = 1,
	STD_VIDEO_AV1_REFERENCE_NAME_LAST2_FRAME = 2,
	STD_VIDEO_AV1_REFERENCE_NAME_LAST3_FRAME = 3,
	STD_VIDEO_AV1_REFERENCE_NAME_GOLDEN_FRAME = 4,
	STD_VIDEO_AV1_REFERENCE_NAME_BWDREF_FRAME = 5,
	STD_VIDEO_AV1_REFERENCE_NAME_ALTREF2_FRAME = 6,
	STD_VIDEO_AV1_REFERENCE_NAME_ALTREF_FRAME = 7,
	STD_VIDEO_AV1_REFERENCE_NAME_INVALID = 0x7fffffff,
}
impl StdVideoAV1ReferenceName {
	pub const STD_VIDEO_AV1_REFERENCE_NAME_MAX_ENUM: StdVideoAV1ReferenceName = StdVideoAV1ReferenceName::STD_VIDEO_AV1_REFERENCE_NAME_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1InterpolationFilter {
	STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP = 0,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH = 1,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP_SHARP = 2,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_BILINEAR = 3,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_SWITCHABLE = 4,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_INVALID = 0x7fffffff,
}
impl StdVideoAV1InterpolationFilter {
	pub const STD_VIDEO_AV1_INTERPOLATION_FILTER_MAX_ENUM: StdVideoAV1InterpolationFilter = StdVideoAV1InterpolationFilter::STD_VIDEO_AV1_INTERPOLATION_FILTER_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1TxMode {
	STD_VIDEO_AV1_TX_MODE_ONLY_4X4 = 0,
	STD_VIDEO_AV1_TX_MODE_LARGEST = 1,
	STD_VIDEO_AV1_TX_MODE_SELECT = 2,
	STD_VIDEO_AV1_TX_MODE_INVALID = 0x7fffffff,
}
impl StdVideoAV1TxMode {
	pub const STD_VIDEO_AV1_TX_MODE_MAX_ENUM: StdVideoAV1TxMode = StdVideoAV1TxMode::STD_VIDEO_AV1_TX_MODE_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1FrameRestorationType {
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_NONE = 0,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_WIENER = 1,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_SGRPROJ = 2,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_SWITCHABLE = 3,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoAV1FrameRestorationType {
	pub const STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_MAX_ENUM: StdVideoAV1FrameRestorationType = StdVideoAV1FrameRestorationType::STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1ColorPrimaries {
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_709 = 1,
	STD_VIDEO_AV1_COLOR_PRIMARIES_UNSPECIFIED = 2,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_470_M = 4,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_470_B_G = 5,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_601 = 6,
	STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_240 = 7,
	STD_VIDEO_AV1_COLOR_PRIMARIES_GENERIC_FILM = 8,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_2020 = 9,
	STD_VIDEO_AV1_COLOR_PRIMARIES_XYZ = 10,
	STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_431 = 11,
	STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_432 = 12,
	STD_VIDEO_AV1_COLOR_PRIMARIES_EBU_3213 = 22,
	STD_VIDEO_AV1_COLOR_PRIMARIES_INVALID = 0x7fffffff,
}
impl StdVideoAV1ColorPrimaries {
	pub const STD_VIDEO_AV1_COLOR_PRIMARIES_BT_UNSPECIFIED: StdVideoAV1ColorPrimaries = StdVideoAV1ColorPrimaries::STD_VIDEO_AV1_COLOR_PRIMARIES_UNSPECIFIED;
	pub const STD_VIDEO_AV1_COLOR_PRIMARIES_MAX_ENUM: StdVideoAV1ColorPrimaries = StdVideoAV1ColorPrimaries::STD_VIDEO_AV1_COLOR_PRIMARIES_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1TransferCharacteristics {
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_RESERVED_0 = 0,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_709 = 1,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_UNSPECIFIED = 2,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_RESERVED_3 = 3,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_470_M = 4,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_470_B_G = 5,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_601 = 6,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_240 = 7,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LINEAR = 8,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LOG_100 = 9,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LOG_100_SQRT10 = 10,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_IEC_61966 = 11,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_1361 = 12,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SRGB = 13,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_2020_10_BIT = 14,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_2020_12_BIT = 15,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_2084 = 16,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_428 = 17,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_HLG = 18,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_INVALID = 0x7fffffff,
}
impl StdVideoAV1TransferCharacteristics {
	pub const STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_MAX_ENUM: StdVideoAV1TransferCharacteristics = StdVideoAV1TransferCharacteristics::STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1MatrixCoefficients {
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_IDENTITY = 0,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_709 = 1,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_UNSPECIFIED = 2,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_RESERVED_3 = 3,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_FCC = 4,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_470_B_G = 5,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_601 = 6,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_240 = 7,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_YCGCO = 8,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_2020_NCL = 9,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_2020_CL = 10,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_2085 = 11,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_CHROMAT_NCL = 12,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_CHROMAT_CL = 13,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_ICTCP = 14,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_INVALID = 0x7fffffff,
}
impl StdVideoAV1MatrixCoefficients {
	pub const STD_VIDEO_AV1_MATRIX_COEFFICIENTS_MAX_ENUM: StdVideoAV1MatrixCoefficients = StdVideoAV1MatrixCoefficients::STD_VIDEO_AV1_MATRIX_COEFFICIENTS_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1ChromaSamplePosition {
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_UNKNOWN = 0,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_VERTICAL = 1,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_COLOCATED = 2,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_RESERVED = 3,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_INVALID = 0x7fffffff,
}
impl StdVideoAV1ChromaSamplePosition {
	pub const STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_MAX_ENUM: StdVideoAV1ChromaSamplePosition = StdVideoAV1ChromaSamplePosition::STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1ColorConfigFlags {
	/// Bitfield: mono_chrome: u32 in 1 bits
	/// Bitfield: color_range: u32 in 1 bits
	/// Bitfield: separate_uv_delta_q: u32 in 1 bits
	/// Bitfield: color_description_present_flag: u32 in 1 bits
	/// Bitfield: reserved: u32 in 28 bits
	bitfield1: u32,
}
impl StdVideoAV1ColorConfigFlags {
	pub fn get_mono_chrome(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_mono_chrome(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_color_range(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_color_range(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_separate_uv_delta_q(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_separate_uv_delta_q(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_color_description_present_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_color_description_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 4) & 0xfffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0xfffffff) << 4;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1ColorConfig {
	pub flags: StdVideoAV1ColorConfigFlags,
	pub BitDepth: u8,
	pub subsampling_x: u8,
	pub subsampling_y: u8,
	pub reserved1: u8,
	pub color_primaries: StdVideoAV1ColorPrimaries,
	pub transfer_characteristics: StdVideoAV1TransferCharacteristics,
	pub matrix_coefficients: StdVideoAV1MatrixCoefficients,
	pub chroma_sample_position: StdVideoAV1ChromaSamplePosition,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1TimingInfoFlags {
	/// Bitfield: equal_picture_interval: u32 in 1 bits
	/// Bitfield: reserved: u32 in 31 bits
	bitfield1: u32,
}
impl StdVideoAV1TimingInfoFlags {
	pub fn get_equal_picture_interval(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_equal_picture_interval(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x7fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7fffffff) << 1;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1TimingInfo {
	pub flags: StdVideoAV1TimingInfoFlags,
	pub num_units_in_display_tick: u32,
	pub time_scale: u32,
	pub num_ticks_per_picture_minus_1: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1LoopFilterFlags {
	/// Bitfield: loop_filter_delta_enabled: u32 in 1 bits
	/// Bitfield: loop_filter_delta_update: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoAV1LoopFilterFlags {
	pub fn get_loop_filter_delta_enabled(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_loop_filter_delta_enabled(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_loop_filter_delta_update(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_loop_filter_delta_update(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1LoopFilter {
	pub flags: StdVideoAV1LoopFilterFlags,
	pub loop_filter_level: [u8; STD_VIDEO_AV1_MAX_LOOP_FILTER_STRENGTHS as usize],
	pub loop_filter_sharpness: u8,
	pub update_ref_delta: u8,
	pub loop_filter_ref_deltas: [i8; STD_VIDEO_AV1_TOTAL_REFS_PER_FRAME as usize],
	pub update_mode_delta: u8,
	pub loop_filter_mode_deltas: [i8; STD_VIDEO_AV1_LOOP_FILTER_ADJUSTMENTS as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1QuantizationFlags {
	/// Bitfield: using_qmatrix: u32 in 1 bits
	/// Bitfield: diff_uv_delta: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoAV1QuantizationFlags {
	pub fn get_using_qmatrix(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_using_qmatrix(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_diff_uv_delta(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_diff_uv_delta(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1Quantization {
	pub flags: StdVideoAV1QuantizationFlags,
	pub base_q_idx: u8,
	pub DeltaQYDc: i8,
	pub DeltaQUDc: i8,
	pub DeltaQUAc: i8,
	pub DeltaQVDc: i8,
	pub DeltaQVAc: i8,
	pub qm_y: u8,
	pub qm_u: u8,
	pub qm_v: u8,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1Segmentation {
	pub FeatureEnabled: [u8; STD_VIDEO_AV1_MAX_SEGMENTS as usize],
	pub FeatureData: [i16; STD_VIDEO_AV1_MAX_SEGMENTS as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1TileInfoFlags {
	/// Bitfield: uniform_tile_spacing_flag: u32 in 1 bits
	/// Bitfield: reserved: u32 in 31 bits
	bitfield1: u32,
}
impl StdVideoAV1TileInfoFlags {
	pub fn get_uniform_tile_spacing_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_uniform_tile_spacing_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x7fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7fffffff) << 1;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1TileInfo {
	pub flags: StdVideoAV1TileInfoFlags,
	pub TileCols: u8,
	pub TileRows: u8,
	pub context_update_tile_id: u16,
	pub tile_size_bytes_minus_1: u8,
	pub reserved1: [u8; 7 as usize],
	pub pMiColStarts: *const uint16_t,
	pub pMiRowStarts: *const uint16_t,
	pub pWidthInSbsMinus1: *const uint16_t,
	pub pHeightInSbsMinus1: *const uint16_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1CDEF {
	pub cdef_damping_minus_3: u8,
	pub cdef_bits: u8,
	pub cdef_y_pri_strength: [u8; STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS as usize],
	pub cdef_y_sec_strength: [u8; STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS as usize],
	pub cdef_uv_pri_strength: [u8; STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS as usize],
	pub cdef_uv_sec_strength: [u8; STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1LoopRestoration {
	pub FrameRestorationType: [StdVideoAV1FrameRestorationType; STD_VIDEO_AV1_MAX_NUM_PLANES as usize],
	pub LoopRestorationSize: [u16; STD_VIDEO_AV1_MAX_NUM_PLANES as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1GlobalMotion {
	pub GmType: [u8; STD_VIDEO_AV1_NUM_REF_FRAMES as usize],
	pub gm_params: [i32; STD_VIDEO_AV1_NUM_REF_FRAMES as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1FilmGrainFlags {
	/// Bitfield: chroma_scaling_from_luma: u32 in 1 bits
	/// Bitfield: overlap_flag: u32 in 1 bits
	/// Bitfield: clip_to_restricted_range: u32 in 1 bits
	/// Bitfield: update_grain: u32 in 1 bits
	/// Bitfield: reserved: u32 in 28 bits
	bitfield1: u32,
}
impl StdVideoAV1FilmGrainFlags {
	pub fn get_chroma_scaling_from_luma(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_chroma_scaling_from_luma(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_overlap_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_overlap_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_clip_to_restricted_range(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_clip_to_restricted_range(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_update_grain(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_update_grain(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 4) & 0xfffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0xfffffff) << 4;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1FilmGrain {
	pub flags: StdVideoAV1FilmGrainFlags,
	pub grain_scaling_minus_8: u8,
	pub ar_coeff_lag: u8,
	pub ar_coeff_shift_minus_6: u8,
	pub grain_scale_shift: u8,
	pub grain_seed: u16,
	pub film_grain_params_ref_idx: u8,
	pub num_y_points: u8,
	pub point_y_value: [u8; STD_VIDEO_AV1_MAX_NUM_Y_POINTS as usize],
	pub point_y_scaling: [u8; STD_VIDEO_AV1_MAX_NUM_Y_POINTS as usize],
	pub num_cb_points: u8,
	pub point_cb_value: [u8; STD_VIDEO_AV1_MAX_NUM_CB_POINTS as usize],
	pub point_cb_scaling: [u8; STD_VIDEO_AV1_MAX_NUM_CB_POINTS as usize],
	pub num_cr_points: u8,
	pub point_cr_value: [u8; STD_VIDEO_AV1_MAX_NUM_CR_POINTS as usize],
	pub point_cr_scaling: [u8; STD_VIDEO_AV1_MAX_NUM_CR_POINTS as usize],
	pub ar_coeffs_y_plus_128: [i8; STD_VIDEO_AV1_MAX_NUM_POS_LUMA as usize],
	pub ar_coeffs_cb_plus_128: [i8; STD_VIDEO_AV1_MAX_NUM_POS_CHROMA as usize],
	pub ar_coeffs_cr_plus_128: [i8; STD_VIDEO_AV1_MAX_NUM_POS_CHROMA as usize],
	pub cb_mult: u8,
	pub cb_luma_mult: u8,
	pub cb_offset: u16,
	pub cr_mult: u8,
	pub cr_luma_mult: u8,
	pub cr_offset: u16,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1SequenceHeaderFlags {
	/// Bitfield: still_picture: u32 in 1 bits
	/// Bitfield: reduced_still_picture_header: u32 in 1 bits
	/// Bitfield: use_128x128_superblock: u32 in 1 bits
	/// Bitfield: enable_filter_intra: u32 in 1 bits
	/// Bitfield: enable_intra_edge_filter: u32 in 1 bits
	/// Bitfield: enable_interintra_compound: u32 in 1 bits
	/// Bitfield: enable_masked_compound: u32 in 1 bits
	/// Bitfield: enable_warped_motion: u32 in 1 bits
	/// Bitfield: enable_dual_filter: u32 in 1 bits
	/// Bitfield: enable_order_hint: u32 in 1 bits
	/// Bitfield: enable_jnt_comp: u32 in 1 bits
	/// Bitfield: enable_ref_frame_mvs: u32 in 1 bits
	/// Bitfield: frame_id_numbers_present_flag: u32 in 1 bits
	/// Bitfield: enable_superres: u32 in 1 bits
	/// Bitfield: enable_cdef: u32 in 1 bits
	/// Bitfield: enable_restoration: u32 in 1 bits
	/// Bitfield: film_grain_params_present: u32 in 1 bits
	/// Bitfield: timing_info_present_flag: u32 in 1 bits
	/// Bitfield: initial_display_delay_present_flag: u32 in 1 bits
	/// Bitfield: reserved: u32 in 13 bits
	bitfield1: u32,
}
impl StdVideoAV1SequenceHeaderFlags {
	pub fn get_still_picture(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_still_picture(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_reduced_still_picture_header(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_reduced_still_picture_header(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_use_128x128_superblock(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_use_128x128_superblock(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_enable_filter_intra(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_enable_filter_intra(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_enable_intra_edge_filter(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_enable_intra_edge_filter(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_enable_interintra_compound(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_enable_interintra_compound(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_enable_masked_compound(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_enable_masked_compound(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_enable_warped_motion(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_enable_warped_motion(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_enable_dual_filter(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_enable_dual_filter(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_enable_order_hint(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_enable_order_hint(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_enable_jnt_comp(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_enable_jnt_comp(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_enable_ref_frame_mvs(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_enable_ref_frame_mvs(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
	pub fn get_frame_id_numbers_present_flag(&self) -> u32 {
		(self.bitfield1 >> 12) & 0x1
	}
	pub fn set_frame_id_numbers_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 12;
	}
	pub fn get_enable_superres(&self) -> u32 {
		(self.bitfield1 >> 13) & 0x1
	}
	pub fn set_enable_superres(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 13;
	}
	pub fn get_enable_cdef(&self) -> u32 {
		(self.bitfield1 >> 14) & 0x1
	}
	pub fn set_enable_cdef(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 14;
	}
	pub fn get_enable_restoration(&self) -> u32 {
		(self.bitfield1 >> 15) & 0x1
	}
	pub fn set_enable_restoration(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 15;
	}
	pub fn get_film_grain_params_present(&self) -> u32 {
		(self.bitfield1 >> 16) & 0x1
	}
	pub fn set_film_grain_params_present(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 16;
	}
	pub fn get_timing_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 17) & 0x1
	}
	pub fn set_timing_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 17;
	}
	pub fn get_initial_display_delay_present_flag(&self) -> u32 {
		(self.bitfield1 >> 18) & 0x1
	}
	pub fn set_initial_display_delay_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 18;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 19) & 0x1fff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1fff) << 19;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoAV1SequenceHeader {
	pub flags: StdVideoAV1SequenceHeaderFlags,
	pub seq_profile: StdVideoAV1Profile,
	pub frame_width_bits_minus_1: u8,
	pub frame_height_bits_minus_1: u8,
	pub max_frame_width_minus_1: u16,
	pub max_frame_height_minus_1: u16,
	pub delta_frame_id_length_minus_2: u8,
	pub additional_frame_id_length_minus_1: u8,
	pub order_hint_bits_minus_1: u8,
	pub seq_force_integer_mv: u8,
	pub seq_force_screen_content_tools: u8,
	pub reserved1: [u8; 5 as usize],
	pub pColorConfig: *const StdVideoAV1ColorConfig,
	pub pTimingInfo: *const StdVideoAV1TimingInfo,
}
pub trait vulkan_video_codec_av1std: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_av1std {}
impl vulkan_video_codec_av1std for Vulkan_video_codec_av1std {}
impl Default for Vulkan_video_codec_av1std {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_av1std {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_API_VERSION_1_0_0: u32 = 0x400000;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoDecodeAV1PictureInfoFlags {
	/// Bitfield: error_resilient_mode: u32 in 1 bits
	/// Bitfield: disable_cdf_update: u32 in 1 bits
	/// Bitfield: use_superres: u32 in 1 bits
	/// Bitfield: render_and_frame_size_different: u32 in 1 bits
	/// Bitfield: allow_screen_content_tools: u32 in 1 bits
	/// Bitfield: is_filter_switchable: u32 in 1 bits
	/// Bitfield: force_integer_mv: u32 in 1 bits
	/// Bitfield: frame_size_override_flag: u32 in 1 bits
	/// Bitfield: buffer_removal_time_present_flag: u32 in 1 bits
	/// Bitfield: allow_intrabc: u32 in 1 bits
	/// Bitfield: frame_refs_short_signaling: u32 in 1 bits
	/// Bitfield: allow_high_precision_mv: u32 in 1 bits
	/// Bitfield: is_motion_mode_switchable: u32 in 1 bits
	/// Bitfield: use_ref_frame_mvs: u32 in 1 bits
	/// Bitfield: disable_frame_end_update_cdf: u32 in 1 bits
	/// Bitfield: allow_warped_motion: u32 in 1 bits
	/// Bitfield: reduced_tx_set: u32 in 1 bits
	/// Bitfield: reference_select: u32 in 1 bits
	/// Bitfield: skip_mode_present: u32 in 1 bits
	/// Bitfield: delta_q_present: u32 in 1 bits
	/// Bitfield: delta_lf_present: u32 in 1 bits
	/// Bitfield: delta_lf_multi: u32 in 1 bits
	/// Bitfield: segmentation_enabled: u32 in 1 bits
	/// Bitfield: segmentation_update_map: u32 in 1 bits
	/// Bitfield: segmentation_temporal_update: u32 in 1 bits
	/// Bitfield: segmentation_update_data: u32 in 1 bits
	/// Bitfield: UsesLr: u32 in 1 bits
	/// Bitfield: usesChromaLr: u32 in 1 bits
	/// Bitfield: apply_grain: u32 in 1 bits
	/// Bitfield: reserved: u32 in 3 bits
	bitfield1: u32,
}
impl StdVideoDecodeAV1PictureInfoFlags {
	pub fn get_error_resilient_mode(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_error_resilient_mode(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_disable_cdf_update(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_disable_cdf_update(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_use_superres(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_use_superres(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_render_and_frame_size_different(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_render_and_frame_size_different(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_allow_screen_content_tools(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_allow_screen_content_tools(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_is_filter_switchable(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_is_filter_switchable(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_force_integer_mv(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_force_integer_mv(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_frame_size_override_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_frame_size_override_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_buffer_removal_time_present_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_buffer_removal_time_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_allow_intrabc(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_allow_intrabc(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_frame_refs_short_signaling(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_frame_refs_short_signaling(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_allow_high_precision_mv(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_allow_high_precision_mv(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
	pub fn get_is_motion_mode_switchable(&self) -> u32 {
		(self.bitfield1 >> 12) & 0x1
	}
	pub fn set_is_motion_mode_switchable(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 12;
	}
	pub fn get_use_ref_frame_mvs(&self) -> u32 {
		(self.bitfield1 >> 13) & 0x1
	}
	pub fn set_use_ref_frame_mvs(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 13;
	}
	pub fn get_disable_frame_end_update_cdf(&self) -> u32 {
		(self.bitfield1 >> 14) & 0x1
	}
	pub fn set_disable_frame_end_update_cdf(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 14;
	}
	pub fn get_allow_warped_motion(&self) -> u32 {
		(self.bitfield1 >> 15) & 0x1
	}
	pub fn set_allow_warped_motion(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 15;
	}
	pub fn get_reduced_tx_set(&self) -> u32 {
		(self.bitfield1 >> 16) & 0x1
	}
	pub fn set_reduced_tx_set(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 16;
	}
	pub fn get_reference_select(&self) -> u32 {
		(self.bitfield1 >> 17) & 0x1
	}
	pub fn set_reference_select(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 17;
	}
	pub fn get_skip_mode_present(&self) -> u32 {
		(self.bitfield1 >> 18) & 0x1
	}
	pub fn set_skip_mode_present(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 18;
	}
	pub fn get_delta_q_present(&self) -> u32 {
		(self.bitfield1 >> 19) & 0x1
	}
	pub fn set_delta_q_present(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 19;
	}
	pub fn get_delta_lf_present(&self) -> u32 {
		(self.bitfield1 >> 20) & 0x1
	}
	pub fn set_delta_lf_present(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 20;
	}
	pub fn get_delta_lf_multi(&self) -> u32 {
		(self.bitfield1 >> 21) & 0x1
	}
	pub fn set_delta_lf_multi(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 21;
	}
	pub fn get_segmentation_enabled(&self) -> u32 {
		(self.bitfield1 >> 22) & 0x1
	}
	pub fn set_segmentation_enabled(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 22;
	}
	pub fn get_segmentation_update_map(&self) -> u32 {
		(self.bitfield1 >> 23) & 0x1
	}
	pub fn set_segmentation_update_map(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 23;
	}
	pub fn get_segmentation_temporal_update(&self) -> u32 {
		(self.bitfield1 >> 24) & 0x1
	}
	pub fn set_segmentation_temporal_update(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 24;
	}
	pub fn get_segmentation_update_data(&self) -> u32 {
		(self.bitfield1 >> 25) & 0x1
	}
	pub fn set_segmentation_update_data(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 25;
	}
	pub fn get_UsesLr(&self) -> u32 {
		(self.bitfield1 >> 26) & 0x1
	}
	pub fn set_UsesLr(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 26;
	}
	pub fn get_usesChromaLr(&self) -> u32 {
		(self.bitfield1 >> 27) & 0x1
	}
	pub fn set_usesChromaLr(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 27;
	}
	pub fn get_apply_grain(&self) -> u32 {
		(self.bitfield1 >> 28) & 0x1
	}
	pub fn set_apply_grain(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 28;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 29) & 0x7
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7) << 29;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoDecodeAV1PictureInfo {
	pub flags: StdVideoDecodeAV1PictureInfoFlags,
	pub frame_type: StdVideoAV1FrameType,
	pub current_frame_id: u32,
	pub OrderHint: u8,
	pub primary_ref_frame: u8,
	pub refresh_frame_flags: u8,
	pub reserved1: u8,
	pub interpolation_filter: StdVideoAV1InterpolationFilter,
	pub TxMode: StdVideoAV1TxMode,
	pub delta_q_res: u8,
	pub delta_lf_res: u8,
	pub SkipModeFrame: [u8; STD_VIDEO_AV1_SKIP_MODE_FRAMES as usize],
	pub coded_denom: u8,
	pub reserved2: [u8; 3 as usize],
	pub OrderHints: [u8; STD_VIDEO_AV1_NUM_REF_FRAMES as usize],
	pub expectedFrameId: [u32; STD_VIDEO_AV1_NUM_REF_FRAMES as usize],
	pub pTileInfo: *const StdVideoAV1TileInfo,
	pub pQuantization: *const StdVideoAV1Quantization,
	pub pSegmentation: *const StdVideoAV1Segmentation,
	pub pLoopFilter: *const StdVideoAV1LoopFilter,
	pub pCDEF: *const StdVideoAV1CDEF,
	pub pLoopRestoration: *const StdVideoAV1LoopRestoration,
	pub pGlobalMotion: *const StdVideoAV1GlobalMotion,
	pub pFilmGrain: *const StdVideoAV1FilmGrain,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoDecodeAV1ReferenceInfoFlags {
	/// Bitfield: disable_frame_end_update_cdf: u32 in 1 bits
	/// Bitfield: segmentation_enabled: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoDecodeAV1ReferenceInfoFlags {
	pub fn get_disable_frame_end_update_cdf(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_disable_frame_end_update_cdf(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_segmentation_enabled(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_segmentation_enabled(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoDecodeAV1ReferenceInfo {
	pub flags: StdVideoDecodeAV1ReferenceInfoFlags,
	pub frame_type: u8,
	pub RefFrameSignBias: u8,
	pub OrderHint: u8,
	pub SavedOrderHints: [u8; STD_VIDEO_AV1_NUM_REF_FRAMES as usize],
}
pub trait vulkan_video_codec_av1std_decode: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_av1std_decode {}
impl vulkan_video_codec_av1std_decode for Vulkan_video_codec_av1std_decode {}
impl Default for Vulkan_video_codec_av1std_decode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_av1std_decode {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkVideoEncodeAV1CapabilityFlagsKHR = VkFlags;
pub type VkVideoEncodeAV1StdFlagsKHR = VkFlags;
pub type VkVideoEncodeAV1SuperblockSizeFlagsKHR = VkFlags;
pub type VkVideoEncodeAV1RateControlFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeAV1PredictionModeKHR {
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR = 0,
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR = 1,
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR = 2,
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR = 3,
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeAV1RateControlGroupKHR {
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR = 0,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR = 1,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR = 2,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeAV1CapabilityFlagBitsKHR {
	VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_COMPOUND_PREDICTION_INTRA_REFRESH_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeAV1StdFlagBitsKHR {
	VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_AV1_STD_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeAV1SuperblockSizeFlagBitsKHR {
	VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeAV1RateControlFlagBitsKHR {
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVideoEncodeAV1FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub videoEncodeAV1: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeAV1CapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkVideoEncodeAV1CapabilityFlagsKHR,
	pub maxLevel: StdVideoAV1Level,
	pub codedPictureAlignment: VkExtent2D,
	pub maxTiles: VkExtent2D,
	pub minTileSize: VkExtent2D,
	pub maxTileSize: VkExtent2D,
	pub superblockSizes: VkVideoEncodeAV1SuperblockSizeFlagsKHR,
	pub maxSingleReferenceCount: u32,
	pub singleReferenceNameMask: u32,
	pub maxUnidirectionalCompoundReferenceCount: u32,
	pub maxUnidirectionalCompoundGroup1ReferenceCount: u32,
	pub unidirectionalCompoundReferenceNameMask: u32,
	pub maxBidirectionalCompoundReferenceCount: u32,
	pub maxBidirectionalCompoundGroup1ReferenceCount: u32,
	pub maxBidirectionalCompoundGroup2ReferenceCount: u32,
	pub bidirectionalCompoundReferenceNameMask: u32,
	pub maxTemporalLayerCount: u32,
	pub maxSpatialLayerCount: u32,
	pub maxOperatingPoints: u32,
	pub minQIndex: u32,
	pub maxQIndex: u32,
	pub prefersGopRemainingFrames: VkBool32,
	pub requiresGopRemainingFrames: VkBool32,
	pub stdSyntaxFlags: VkVideoEncodeAV1StdFlagsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeAV1QIndexKHR {
	pub intraQIndex: u32,
	pub predictiveQIndex: u32,
	pub bipredictiveQIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeAV1QualityLevelPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub preferredRateControlFlags: VkVideoEncodeAV1RateControlFlagsKHR,
	pub preferredGopFrameCount: u32,
	pub preferredKeyFramePeriod: u32,
	pub preferredConsecutiveBipredictiveFrameCount: u32,
	pub preferredTemporalLayerCount: u32,
	pub preferredConstantQIndex: VkVideoEncodeAV1QIndexKHR,
	pub preferredMaxSingleReferenceCount: u32,
	pub preferredSingleReferenceNameMask: u32,
	pub preferredMaxUnidirectionalCompoundReferenceCount: u32,
	pub preferredMaxUnidirectionalCompoundGroup1ReferenceCount: u32,
	pub preferredUnidirectionalCompoundReferenceNameMask: u32,
	pub preferredMaxBidirectionalCompoundReferenceCount: u32,
	pub preferredMaxBidirectionalCompoundGroup1ReferenceCount: u32,
	pub preferredMaxBidirectionalCompoundGroup2ReferenceCount: u32,
	pub preferredBidirectionalCompoundReferenceNameMask: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeAV1SessionCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useMaxLevel: VkBool32,
	pub maxLevel: StdVideoAV1Level,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeAV1SessionParametersCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdSequenceHeader: *const StdVideoAV1SequenceHeader,
	pub pStdDecoderModelInfo: *const StdVideoEncodeAV1DecoderModelInfo,
	pub stdOperatingPointCount: u32,
	pub pStdOperatingPoints: *const StdVideoEncodeAV1OperatingPointInfo,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeAV1PictureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub predictionMode: VkVideoEncodeAV1PredictionModeKHR,
	pub rateControlGroup: VkVideoEncodeAV1RateControlGroupKHR,
	pub constantQIndex: u32,
	pub pStdPictureInfo: *const StdVideoEncodeAV1PictureInfo,
	pub referenceNameSlotIndices: [i32; VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR as usize],
	pub primaryReferenceCdfOnly: VkBool32,
	pub generateObuExtensionHeader: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeAV1DpbSlotInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdReferenceInfo: *const StdVideoEncodeAV1ReferenceInfo,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeAV1ProfileInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdProfile: StdVideoAV1Profile,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeAV1FrameSizeKHR {
	pub intraFrameSize: u32,
	pub predictiveFrameSize: u32,
	pub bipredictiveFrameSize: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeAV1GopRemainingFrameInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useGopRemainingFrames: VkBool32,
	pub gopRemainingIntra: u32,
	pub gopRemainingPredictive: u32,
	pub gopRemainingBipredictive: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeAV1RateControlInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoEncodeAV1RateControlFlagsKHR,
	pub gopFrameCount: u32,
	pub keyFramePeriod: u32,
	pub consecutiveBipredictiveFrameCount: u32,
	pub temporalLayerCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeAV1RateControlLayerInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useMinQIndex: VkBool32,
	pub minQIndex: VkVideoEncodeAV1QIndexKHR,
	pub useMaxQIndex: VkBool32,
	pub maxQIndex: VkVideoEncodeAV1QIndexKHR,
	pub useMaxFrameSize: VkBool32,
	pub maxFrameSize: VkVideoEncodeAV1FrameSizeKHR,
}
pub trait VK_KHR_video_encode_av1: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_encode_av1 {}
impl VK_KHR_video_encode_av1 for Vulkan_KHR_video_encode_av1 {}
impl Default for Vulkan_KHR_video_encode_av1 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_encode_av1 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_API_VERSION_1_0_0: u32 = 0x400000;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeAV1DecoderModelInfo {
	pub buffer_delay_length_minus_1: u8,
	pub buffer_removal_time_length_minus_1: u8,
	pub frame_presentation_time_length_minus_1: u8,
	pub reserved1: u8,
	pub num_units_in_decoding_tick: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeAV1ExtensionHeader {
	pub temporal_id: u8,
	pub spatial_id: u8,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeAV1OperatingPointInfoFlags {
	/// Bitfield: decoder_model_present_for_this_op: u32 in 1 bits
	/// Bitfield: low_delay_mode_flag: u32 in 1 bits
	/// Bitfield: initial_display_delay_present_for_this_op: u32 in 1 bits
	/// Bitfield: reserved: u32 in 29 bits
	bitfield1: u32,
}
impl StdVideoEncodeAV1OperatingPointInfoFlags {
	pub fn get_decoder_model_present_for_this_op(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_decoder_model_present_for_this_op(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_low_delay_mode_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_low_delay_mode_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_initial_display_delay_present_for_this_op(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_initial_display_delay_present_for_this_op(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1fffffff) << 3;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeAV1OperatingPointInfo {
	pub flags: StdVideoEncodeAV1OperatingPointInfoFlags,
	pub operating_point_idc: u16,
	pub seq_level_idx: u8,
	pub seq_tier: u8,
	pub decoder_buffer_delay: u32,
	pub encoder_buffer_delay: u32,
	pub initial_display_delay_minus_1: u8,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeAV1PictureInfoFlags {
	/// Bitfield: error_resilient_mode: u32 in 1 bits
	/// Bitfield: disable_cdf_update: u32 in 1 bits
	/// Bitfield: use_superres: u32 in 1 bits
	/// Bitfield: render_and_frame_size_different: u32 in 1 bits
	/// Bitfield: allow_screen_content_tools: u32 in 1 bits
	/// Bitfield: is_filter_switchable: u32 in 1 bits
	/// Bitfield: force_integer_mv: u32 in 1 bits
	/// Bitfield: frame_size_override_flag: u32 in 1 bits
	/// Bitfield: buffer_removal_time_present_flag: u32 in 1 bits
	/// Bitfield: allow_intrabc: u32 in 1 bits
	/// Bitfield: frame_refs_short_signaling: u32 in 1 bits
	/// Bitfield: allow_high_precision_mv: u32 in 1 bits
	/// Bitfield: is_motion_mode_switchable: u32 in 1 bits
	/// Bitfield: use_ref_frame_mvs: u32 in 1 bits
	/// Bitfield: disable_frame_end_update_cdf: u32 in 1 bits
	/// Bitfield: allow_warped_motion: u32 in 1 bits
	/// Bitfield: reduced_tx_set: u32 in 1 bits
	/// Bitfield: skip_mode_present: u32 in 1 bits
	/// Bitfield: delta_q_present: u32 in 1 bits
	/// Bitfield: delta_lf_present: u32 in 1 bits
	/// Bitfield: delta_lf_multi: u32 in 1 bits
	/// Bitfield: segmentation_enabled: u32 in 1 bits
	/// Bitfield: segmentation_update_map: u32 in 1 bits
	/// Bitfield: segmentation_temporal_update: u32 in 1 bits
	/// Bitfield: segmentation_update_data: u32 in 1 bits
	/// Bitfield: UsesLr: u32 in 1 bits
	/// Bitfield: usesChromaLr: u32 in 1 bits
	/// Bitfield: show_frame: u32 in 1 bits
	/// Bitfield: showable_frame: u32 in 1 bits
	/// Bitfield: reserved: u32 in 3 bits
	bitfield1: u32,
}
impl StdVideoEncodeAV1PictureInfoFlags {
	pub fn get_error_resilient_mode(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_error_resilient_mode(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_disable_cdf_update(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_disable_cdf_update(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_use_superres(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_use_superres(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_render_and_frame_size_different(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_render_and_frame_size_different(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_allow_screen_content_tools(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_allow_screen_content_tools(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_is_filter_switchable(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_is_filter_switchable(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_force_integer_mv(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_force_integer_mv(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_frame_size_override_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_frame_size_override_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_buffer_removal_time_present_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_buffer_removal_time_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_allow_intrabc(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_allow_intrabc(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_frame_refs_short_signaling(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_frame_refs_short_signaling(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_allow_high_precision_mv(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_allow_high_precision_mv(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
	pub fn get_is_motion_mode_switchable(&self) -> u32 {
		(self.bitfield1 >> 12) & 0x1
	}
	pub fn set_is_motion_mode_switchable(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 12;
	}
	pub fn get_use_ref_frame_mvs(&self) -> u32 {
		(self.bitfield1 >> 13) & 0x1
	}
	pub fn set_use_ref_frame_mvs(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 13;
	}
	pub fn get_disable_frame_end_update_cdf(&self) -> u32 {
		(self.bitfield1 >> 14) & 0x1
	}
	pub fn set_disable_frame_end_update_cdf(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 14;
	}
	pub fn get_allow_warped_motion(&self) -> u32 {
		(self.bitfield1 >> 15) & 0x1
	}
	pub fn set_allow_warped_motion(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 15;
	}
	pub fn get_reduced_tx_set(&self) -> u32 {
		(self.bitfield1 >> 16) & 0x1
	}
	pub fn set_reduced_tx_set(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 16;
	}
	pub fn get_skip_mode_present(&self) -> u32 {
		(self.bitfield1 >> 17) & 0x1
	}
	pub fn set_skip_mode_present(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 17;
	}
	pub fn get_delta_q_present(&self) -> u32 {
		(self.bitfield1 >> 18) & 0x1
	}
	pub fn set_delta_q_present(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 18;
	}
	pub fn get_delta_lf_present(&self) -> u32 {
		(self.bitfield1 >> 19) & 0x1
	}
	pub fn set_delta_lf_present(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 19;
	}
	pub fn get_delta_lf_multi(&self) -> u32 {
		(self.bitfield1 >> 20) & 0x1
	}
	pub fn set_delta_lf_multi(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 20;
	}
	pub fn get_segmentation_enabled(&self) -> u32 {
		(self.bitfield1 >> 21) & 0x1
	}
	pub fn set_segmentation_enabled(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 21;
	}
	pub fn get_segmentation_update_map(&self) -> u32 {
		(self.bitfield1 >> 22) & 0x1
	}
	pub fn set_segmentation_update_map(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 22;
	}
	pub fn get_segmentation_temporal_update(&self) -> u32 {
		(self.bitfield1 >> 23) & 0x1
	}
	pub fn set_segmentation_temporal_update(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 23;
	}
	pub fn get_segmentation_update_data(&self) -> u32 {
		(self.bitfield1 >> 24) & 0x1
	}
	pub fn set_segmentation_update_data(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 24;
	}
	pub fn get_UsesLr(&self) -> u32 {
		(self.bitfield1 >> 25) & 0x1
	}
	pub fn set_UsesLr(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 25;
	}
	pub fn get_usesChromaLr(&self) -> u32 {
		(self.bitfield1 >> 26) & 0x1
	}
	pub fn set_usesChromaLr(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 26;
	}
	pub fn get_show_frame(&self) -> u32 {
		(self.bitfield1 >> 27) & 0x1
	}
	pub fn set_show_frame(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 27;
	}
	pub fn get_showable_frame(&self) -> u32 {
		(self.bitfield1 >> 28) & 0x1
	}
	pub fn set_showable_frame(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 28;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 29) & 0x7
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7) << 29;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeAV1PictureInfo {
	pub flags: StdVideoEncodeAV1PictureInfoFlags,
	pub frame_type: StdVideoAV1FrameType,
	pub frame_presentation_time: u32,
	pub current_frame_id: u32,
	pub order_hint: u8,
	pub primary_ref_frame: u8,
	pub refresh_frame_flags: u8,
	pub coded_denom: u8,
	pub render_width_minus_1: u16,
	pub render_height_minus_1: u16,
	pub interpolation_filter: StdVideoAV1InterpolationFilter,
	pub TxMode: StdVideoAV1TxMode,
	pub delta_q_res: u8,
	pub delta_lf_res: u8,
	pub ref_order_hint: [u8; STD_VIDEO_AV1_NUM_REF_FRAMES as usize],
	pub ref_frame_idx: [i8; STD_VIDEO_AV1_REFS_PER_FRAME as usize],
	pub reserved1: [u8; 3 as usize],
	pub delta_frame_id_minus_1: [u32; STD_VIDEO_AV1_REFS_PER_FRAME as usize],
	pub pTileInfo: *const StdVideoAV1TileInfo,
	pub pQuantization: *const StdVideoAV1Quantization,
	pub pSegmentation: *const StdVideoAV1Segmentation,
	pub pLoopFilter: *const StdVideoAV1LoopFilter,
	pub pCDEF: *const StdVideoAV1CDEF,
	pub pLoopRestoration: *const StdVideoAV1LoopRestoration,
	pub pGlobalMotion: *const StdVideoAV1GlobalMotion,
	pub pExtensionHeader: *const StdVideoEncodeAV1ExtensionHeader,
	pub pBufferRemovalTimes: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeAV1ReferenceInfoFlags {
	/// Bitfield: disable_frame_end_update_cdf: u32 in 1 bits
	/// Bitfield: segmentation_enabled: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoEncodeAV1ReferenceInfoFlags {
	pub fn get_disable_frame_end_update_cdf(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_disable_frame_end_update_cdf(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_segmentation_enabled(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_segmentation_enabled(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoEncodeAV1ReferenceInfo {
	pub flags: StdVideoEncodeAV1ReferenceInfoFlags,
	pub RefFrameId: u32,
	pub frame_type: StdVideoAV1FrameType,
	pub OrderHint: u8,
	pub reserved1: [u8; 3 as usize],
	pub pExtensionHeader: *const StdVideoEncodeAV1ExtensionHeader,
}
pub trait vulkan_video_codec_av1std_encode: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_av1std_encode {}
impl vulkan_video_codec_av1std_encode for Vulkan_video_codec_av1std_encode {}
impl Default for Vulkan_video_codec_av1std_encode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_av1std_encode {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR: u32 = 3u32;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVideoDecodeVP9FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub videoDecodeVP9: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeVP9ProfileInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdProfile: StdVideoVP9Profile,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeVP9CapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxLevel: StdVideoVP9Level,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeVP9PictureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdPictureInfo: *const StdVideoDecodeVP9PictureInfo,
	pub referenceNameSlotIndices: [i32; VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR as usize],
	pub uncompressedHeaderOffset: u32,
	pub compressedHeaderOffset: u32,
	pub tilesOffset: u32,
}
pub trait VK_KHR_video_decode_vp9: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_decode_vp9 {}
impl VK_KHR_video_decode_vp9 for Vulkan_KHR_video_decode_vp9 {}
impl Default for Vulkan_KHR_video_decode_vp9 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_decode_vp9 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const STD_VIDEO_VP9_NUM_REF_FRAMES: u32 = 8u32;
pub const STD_VIDEO_VP9_REFS_PER_FRAME: u32 = 3u32;
pub const STD_VIDEO_VP9_MAX_REF_FRAMES: u32 = 4u32;
pub const STD_VIDEO_VP9_LOOP_FILTER_ADJUSTMENTS: u32 = 2u32;
pub const STD_VIDEO_VP9_MAX_SEGMENTS: u32 = 8u32;
pub const STD_VIDEO_VP9_SEG_LVL_MAX: u32 = 4u32;
pub const STD_VIDEO_VP9_MAX_SEGMENTATION_TREE_PROBS: u32 = 7u32;
pub const STD_VIDEO_VP9_MAX_SEGMENTATION_PRED_PROB: u32 = 3u32;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoVP9Profile {
	STD_VIDEO_VP9_PROFILE_0 = 0,
	STD_VIDEO_VP9_PROFILE_1 = 1,
	STD_VIDEO_VP9_PROFILE_2 = 2,
	STD_VIDEO_VP9_PROFILE_3 = 3,
	STD_VIDEO_VP9_PROFILE_INVALID = 0x7fffffff,
}
impl StdVideoVP9Profile {
	pub const STD_VIDEO_VP9_PROFILE_MAX_ENUM: StdVideoVP9Profile = StdVideoVP9Profile::STD_VIDEO_VP9_PROFILE_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoVP9Level {
	STD_VIDEO_VP9_LEVEL_1_0 = 0,
	STD_VIDEO_VP9_LEVEL_1_1 = 1,
	STD_VIDEO_VP9_LEVEL_2_0 = 2,
	STD_VIDEO_VP9_LEVEL_2_1 = 3,
	STD_VIDEO_VP9_LEVEL_3_0 = 4,
	STD_VIDEO_VP9_LEVEL_3_1 = 5,
	STD_VIDEO_VP9_LEVEL_4_0 = 6,
	STD_VIDEO_VP9_LEVEL_4_1 = 7,
	STD_VIDEO_VP9_LEVEL_5_0 = 8,
	STD_VIDEO_VP9_LEVEL_5_1 = 9,
	STD_VIDEO_VP9_LEVEL_5_2 = 10,
	STD_VIDEO_VP9_LEVEL_6_0 = 11,
	STD_VIDEO_VP9_LEVEL_6_1 = 12,
	STD_VIDEO_VP9_LEVEL_6_2 = 13,
	STD_VIDEO_VP9_LEVEL_INVALID = 0x7fffffff,
}
impl StdVideoVP9Level {
	pub const STD_VIDEO_VP9_LEVEL_MAX_ENUM: StdVideoVP9Level = StdVideoVP9Level::STD_VIDEO_VP9_LEVEL_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoVP9FrameType {
	STD_VIDEO_VP9_FRAME_TYPE_KEY = 0,
	STD_VIDEO_VP9_FRAME_TYPE_NON_KEY = 1,
	STD_VIDEO_VP9_FRAME_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoVP9FrameType {
	pub const STD_VIDEO_VP9_FRAME_TYPE_MAX_ENUM: StdVideoVP9FrameType = StdVideoVP9FrameType::STD_VIDEO_VP9_FRAME_TYPE_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoVP9ReferenceName {
	STD_VIDEO_VP9_REFERENCE_NAME_INTRA_FRAME = 0,
	STD_VIDEO_VP9_REFERENCE_NAME_LAST_FRAME = 1,
	STD_VIDEO_VP9_REFERENCE_NAME_GOLDEN_FRAME = 2,
	STD_VIDEO_VP9_REFERENCE_NAME_ALTREF_FRAME = 3,
	STD_VIDEO_VP9_REFERENCE_NAME_INVALID = 0x7fffffff,
}
impl StdVideoVP9ReferenceName {
	pub const STD_VIDEO_VP9_REFERENCE_NAME_MAX_ENUM: StdVideoVP9ReferenceName = StdVideoVP9ReferenceName::STD_VIDEO_VP9_REFERENCE_NAME_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoVP9InterpolationFilter {
	STD_VIDEO_VP9_INTERPOLATION_FILTER_EIGHTTAP = 0,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH = 1,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_EIGHTTAP_SHARP = 2,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_BILINEAR = 3,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_SWITCHABLE = 4,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_INVALID = 0x7fffffff,
}
impl StdVideoVP9InterpolationFilter {
	pub const STD_VIDEO_VP9_INTERPOLATION_FILTER_MAX_ENUM: StdVideoVP9InterpolationFilter = StdVideoVP9InterpolationFilter::STD_VIDEO_VP9_INTERPOLATION_FILTER_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoVP9ColorSpace {
	STD_VIDEO_VP9_COLOR_SPACE_UNKNOWN = 0,
	STD_VIDEO_VP9_COLOR_SPACE_BT_601 = 1,
	STD_VIDEO_VP9_COLOR_SPACE_BT_709 = 2,
	STD_VIDEO_VP9_COLOR_SPACE_SMPTE_170 = 3,
	STD_VIDEO_VP9_COLOR_SPACE_SMPTE_240 = 4,
	STD_VIDEO_VP9_COLOR_SPACE_BT_2020 = 5,
	STD_VIDEO_VP9_COLOR_SPACE_RESERVED = 6,
	STD_VIDEO_VP9_COLOR_SPACE_RGB = 7,
	STD_VIDEO_VP9_COLOR_SPACE_INVALID = 0x7fffffff,
}
impl StdVideoVP9ColorSpace {
	pub const STD_VIDEO_VP9_COLOR_SPACE_MAX_ENUM: StdVideoVP9ColorSpace = StdVideoVP9ColorSpace::STD_VIDEO_VP9_COLOR_SPACE_INVALID;
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoVP9ColorConfigFlags {
	/// Bitfield: color_range: u32 in 1 bits
	/// Bitfield: reserved: u32 in 31 bits
	bitfield1: u32,
}
impl StdVideoVP9ColorConfigFlags {
	pub fn get_color_range(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_color_range(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x7fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7fffffff) << 1;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoVP9ColorConfig {
	pub flags: StdVideoVP9ColorConfigFlags,
	pub BitDepth: u8,
	pub subsampling_x: u8,
	pub subsampling_y: u8,
	pub reserved1: u8,
	pub color_space: StdVideoVP9ColorSpace,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoVP9LoopFilterFlags {
	/// Bitfield: loop_filter_delta_enabled: u32 in 1 bits
	/// Bitfield: loop_filter_delta_update: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoVP9LoopFilterFlags {
	pub fn get_loop_filter_delta_enabled(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_loop_filter_delta_enabled(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_loop_filter_delta_update(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_loop_filter_delta_update(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoVP9LoopFilter {
	pub flags: StdVideoVP9LoopFilterFlags,
	pub loop_filter_level: u8,
	pub loop_filter_sharpness: u8,
	pub update_ref_delta: u8,
	pub loop_filter_ref_deltas: [i8; STD_VIDEO_VP9_MAX_REF_FRAMES as usize],
	pub update_mode_delta: u8,
	pub loop_filter_mode_deltas: [i8; STD_VIDEO_VP9_LOOP_FILTER_ADJUSTMENTS as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoVP9SegmentationFlags {
	/// Bitfield: segmentation_update_map: u32 in 1 bits
	/// Bitfield: segmentation_temporal_update: u32 in 1 bits
	/// Bitfield: segmentation_update_data: u32 in 1 bits
	/// Bitfield: segmentation_abs_or_delta_update: u32 in 1 bits
	/// Bitfield: reserved: u32 in 28 bits
	bitfield1: u32,
}
impl StdVideoVP9SegmentationFlags {
	pub fn get_segmentation_update_map(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_segmentation_update_map(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_segmentation_temporal_update(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_segmentation_temporal_update(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_segmentation_update_data(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_segmentation_update_data(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_segmentation_abs_or_delta_update(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_segmentation_abs_or_delta_update(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 4) & 0xfffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0xfffffff) << 4;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoVP9Segmentation {
	pub flags: StdVideoVP9SegmentationFlags,
	pub segmentation_tree_probs: [u8; STD_VIDEO_VP9_MAX_SEGMENTATION_TREE_PROBS as usize],
	pub segmentation_pred_prob: [u8; STD_VIDEO_VP9_MAX_SEGMENTATION_PRED_PROB as usize],
	pub FeatureEnabled: [u8; STD_VIDEO_VP9_MAX_SEGMENTS as usize],
	pub FeatureData: [i16; STD_VIDEO_VP9_MAX_SEGMENTS as usize],
}
pub trait vulkan_video_codec_vp9std: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_vp9std {}
impl vulkan_video_codec_vp9std for Vulkan_video_codec_vp9std {}
impl Default for Vulkan_video_codec_vp9std {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_vp9std {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_API_VERSION_1_0_0: u32 = 0x400000;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoDecodeVP9PictureInfoFlags {
	/// Bitfield: error_resilient_mode: u32 in 1 bits
	/// Bitfield: intra_only: u32 in 1 bits
	/// Bitfield: allow_high_precision_mv: u32 in 1 bits
	/// Bitfield: refresh_frame_context: u32 in 1 bits
	/// Bitfield: frame_parallel_decoding_mode: u32 in 1 bits
	/// Bitfield: segmentation_enabled: u32 in 1 bits
	/// Bitfield: show_frame: u32 in 1 bits
	/// Bitfield: UsePrevFrameMvs: u32 in 1 bits
	/// Bitfield: reserved: u32 in 24 bits
	bitfield1: u32,
}
impl StdVideoDecodeVP9PictureInfoFlags {
	pub fn get_error_resilient_mode(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_error_resilient_mode(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_intra_only(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_intra_only(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_allow_high_precision_mv(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_allow_high_precision_mv(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_refresh_frame_context(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_refresh_frame_context(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_frame_parallel_decoding_mode(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_frame_parallel_decoding_mode(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_segmentation_enabled(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_segmentation_enabled(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_show_frame(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_show_frame(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_UsePrevFrameMvs(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_UsePrevFrameMvs(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 8) & 0xffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0xffffff) << 8;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StdVideoDecodeVP9PictureInfo {
	pub flags: StdVideoDecodeVP9PictureInfoFlags,
	pub profile: StdVideoVP9Profile,
	pub frame_type: StdVideoVP9FrameType,
	pub frame_context_idx: u8,
	pub reset_frame_context: u8,
	pub refresh_frame_flags: u8,
	pub ref_frame_sign_bias_mask: u8,
	pub interpolation_filter: StdVideoVP9InterpolationFilter,
	pub base_q_idx: u8,
	pub delta_q_y_dc: i8,
	pub delta_q_uv_dc: i8,
	pub delta_q_uv_ac: i8,
	pub tile_cols_log2: u8,
	pub tile_rows_log2: u8,
	pub reserved1: [u16; 3 as usize],
	pub pColorConfig: *const StdVideoVP9ColorConfig,
	pub pLoopFilter: *const StdVideoVP9LoopFilter,
	pub pSegmentation: *const StdVideoVP9Segmentation,
}
pub trait vulkan_video_codec_vp9std_decode: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_vp9std_decode {}
impl vulkan_video_codec_vp9std_decode for Vulkan_video_codec_vp9std_decode {}
impl Default for Vulkan_video_codec_vp9std_decode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_vp9std_decode {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVideoMaintenance1FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub videoMaintenance1: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoInlineQueryInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub queryPool: VkQueryPool,
	pub firstQuery: u32,
	pub queryCount: u32,
}
pub trait VK_KHR_video_maintenance1: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_maintenance1 {}
impl VK_KHR_video_maintenance1 for Vulkan_KHR_video_maintenance1 {}
impl Default for Vulkan_KHR_video_maintenance1 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_maintenance1 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR = VkPhysicalDeviceVertexAttributeDivisorProperties;
pub type VkVertexInputBindingDivisorDescriptionKHR = VkVertexInputBindingDivisorDescription;
pub type VkPipelineVertexInputDivisorStateCreateInfoKHR = VkPipelineVertexInputDivisorStateCreateInfo;
pub type VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR = VkPhysicalDeviceVertexAttributeDivisorFeatures;
pub trait VK_KHR_vertex_attribute_divisor: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_vertex_attribute_divisor {}
impl VK_KHR_vertex_attribute_divisor for Vulkan_KHR_vertex_attribute_divisor {}
impl Default for Vulkan_KHR_vertex_attribute_divisor {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_vertex_attribute_divisor {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_KHR_load_store_op_none: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_load_store_op_none {}
impl VK_KHR_load_store_op_none for Vulkan_KHR_load_store_op_none {}
impl Default for Vulkan_KHR_load_store_op_none {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_load_store_op_none {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub unifiedImageLayouts: VkBool32,
	pub unifiedImageLayoutsVideo: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAttachmentFeedbackLoopInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub feedbackLoopEnable: VkBool32,
}
pub trait VK_KHR_unified_image_layouts: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_unified_image_layouts {}
impl VK_KHR_unified_image_layouts for Vulkan_KHR_unified_image_layouts {}
impl Default for Vulkan_KHR_unified_image_layouts {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_unified_image_layouts {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceShaderFloatControls2FeaturesKHR = VkPhysicalDeviceShaderFloatControls2Features;
pub trait VK_KHR_shader_float_controls2: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_float_controls2 {}
impl VK_KHR_shader_float_controls2 for Vulkan_KHR_shader_float_controls2 {}
impl Default for Vulkan_KHR_shader_float_controls2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_float_controls2 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceIndexTypeUint8FeaturesKHR = VkPhysicalDeviceIndexTypeUint8Features;
pub trait VK_KHR_index_type_uint8: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_index_type_uint8 {}
impl VK_KHR_index_type_uint8 for Vulkan_KHR_index_type_uint8 {}
impl Default for Vulkan_KHR_index_type_uint8 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_index_type_uint8 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkLineRasterizationModeKHR = VkLineRasterizationMode;
pub type VkPhysicalDeviceLineRasterizationFeaturesKHR = VkPhysicalDeviceLineRasterizationFeatures;
pub type VkPhysicalDeviceLineRasterizationPropertiesKHR = VkPhysicalDeviceLineRasterizationProperties;
pub type VkPipelineRasterizationLineStateCreateInfoKHR = VkPipelineRasterizationLineStateCreateInfo;
type PFN_vkCmdSetLineStippleKHR = extern "system" fn(commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16);
extern "system" fn dummy_vkCmdSetLineStippleKHR(_: VkCommandBuffer, _: u32, _: u16) {
	panic!("Vulkan function pointer of `vkCmdSetLineStippleKHR()` is NULL");
}
pub trait VK_KHR_line_rasterization: Debug {
	fn vkCmdSetLineStippleKHR(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_line_rasterization {
	vk_cmd_set_line_stipple_khr: PFN_vkCmdSetLineStippleKHR,
}
impl VK_KHR_line_rasterization for Vulkan_KHR_line_rasterization {
	fn vkCmdSetLineStippleKHR(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) {
		(self.vk_cmd_set_line_stipple_khr)(commandBuffer, lineStippleFactor, lineStipplePattern)
	}
}
impl Default for Vulkan_KHR_line_rasterization {
	fn default() -> Self {
		Self {
			vk_cmd_set_line_stipple_khr: dummy_vkCmdSetLineStippleKHR,
		}
	}
}
impl Vulkan_KHR_line_rasterization {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_line_stipple_khr: {let proc = get_proc_address(instance, "vkCmdSetLineStippleKHR"); if proc == null() {dummy_vkCmdSetLineStippleKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkTimeDomainKHR {
	VK_TIME_DOMAIN_DEVICE_KHR = 0,
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR = 1,
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR = 2,
	VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR = 3,
	VK_TIME_DOMAIN_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkTimeDomainKHR {
	pub const VK_TIME_DOMAIN_DEVICE_EXT: VkTimeDomainKHR = VkTimeDomainKHR::VK_TIME_DOMAIN_DEVICE_KHR;
	pub const VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT: VkTimeDomainKHR = VkTimeDomainKHR::VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR;
	pub const VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT: VkTimeDomainKHR = VkTimeDomainKHR::VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR;
	pub const VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT: VkTimeDomainKHR = VkTimeDomainKHR::VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCalibratedTimestampInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub timeDomain: VkTimeDomainKHR,
}
type PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pTimeDomainCount: *mut uint32_t, pTimeDomains: *mut VkTimeDomainKHR) -> VkResult;
type PFN_vkGetCalibratedTimestampsKHR = extern "system" fn(device: VkDevice, timestampCount: u32, pTimestampInfos: *const VkCalibratedTimestampInfoKHR, pTimestamps: *mut uint64_t, pMaxDeviation: *mut uint64_t) -> VkResult;
extern "system" fn dummy_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkTimeDomainKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceCalibrateableTimeDomainsKHR()` is NULL");
}
pub trait VK_KHR_calibrated_timestamps: Debug {
	fn vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(&self, physicalDevice: VkPhysicalDevice, pTimeDomainCount: *mut uint32_t, pTimeDomains: *mut VkTimeDomainKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_calibrated_timestamps {
	vk_get_physical_device_calibrateable_time_domains_khr: PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR,
}
impl VK_KHR_calibrated_timestamps for Vulkan_KHR_calibrated_timestamps {
	fn vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(&self, physicalDevice: VkPhysicalDevice, pTimeDomainCount: *mut uint32_t, pTimeDomains: *mut VkTimeDomainKHR) -> VkResult {
		(self.vk_get_physical_device_calibrateable_time_domains_khr)(physicalDevice, pTimeDomainCount, pTimeDomains)
	}
}
impl Default for Vulkan_KHR_calibrated_timestamps {
	fn default() -> Self {
		Self {
			vk_get_physical_device_calibrateable_time_domains_khr: dummy_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR,
		}
	}
}
impl Vulkan_KHR_calibrated_timestamps {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_calibrateable_time_domains_khr: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceCalibrateableTimeDomainsKHR"); if proc == null() {dummy_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceShaderExpectAssumeFeaturesKHR = VkPhysicalDeviceShaderExpectAssumeFeatures;
pub trait VK_KHR_shader_expect_assume: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_expect_assume {}
impl VK_KHR_shader_expect_assume for Vulkan_KHR_shader_expect_assume {}
impl Default for Vulkan_KHR_shader_expect_assume {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_expect_assume {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceMaintenance6FeaturesKHR = VkPhysicalDeviceMaintenance6Features;
pub type VkPhysicalDeviceMaintenance6PropertiesKHR = VkPhysicalDeviceMaintenance6Properties;
pub type VkBindMemoryStatusKHR = VkBindMemoryStatus;
pub type VkBindDescriptorSetsInfoKHR = VkBindDescriptorSetsInfo;
pub type VkPushConstantsInfoKHR = VkPushConstantsInfo;
pub type VkPushDescriptorSetInfoKHR = VkPushDescriptorSetInfo;
pub type VkPushDescriptorSetWithTemplateInfoKHR = VkPushDescriptorSetWithTemplateInfo;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSetDescriptorBufferOffsetsInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stageFlags: VkShaderStageFlags,
	pub layout: VkPipelineLayout,
	pub firstSet: u32,
	pub setCount: u32,
	pub pBufferIndices: *const uint32_t,
	pub pOffsets: *const VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindDescriptorBufferEmbeddedSamplersInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stageFlags: VkShaderStageFlags,
	pub layout: VkPipelineLayout,
	pub set: u32,
}
type PFN_vkCmdBindDescriptorSets2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo);
type PFN_vkCmdPushConstants2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pPushConstantsInfo: *const VkPushConstantsInfo);
type PFN_vkCmdPushDescriptorSet2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pPushDescriptorSetInfo: *const VkPushDescriptorSetInfo);
type PFN_vkCmdPushDescriptorSetWithTemplate2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pPushDescriptorSetWithTemplateInfo: *const VkPushDescriptorSetWithTemplateInfo);
type PFN_vkCmdSetDescriptorBufferOffsets2EXT = extern "system" fn(commandBuffer: VkCommandBuffer, pSetDescriptorBufferOffsetsInfo: *const VkSetDescriptorBufferOffsetsInfoEXT);
type PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT = extern "system" fn(commandBuffer: VkCommandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo: *const VkBindDescriptorBufferEmbeddedSamplersInfoEXT);
extern "system" fn dummy_vkCmdBindDescriptorSets2KHR(_: VkCommandBuffer, _: *const VkBindDescriptorSetsInfo) {
	panic!("Vulkan function pointer of `vkCmdBindDescriptorSets2KHR()` is NULL");
}
pub trait VK_KHR_maintenance6: Debug {
	fn vkCmdBindDescriptorSets2KHR(&self, commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance6 {
	vk_cmd_bind_descriptor_sets2_khr: PFN_vkCmdBindDescriptorSets2KHR,
}
impl VK_KHR_maintenance6 for Vulkan_KHR_maintenance6 {
	fn vkCmdBindDescriptorSets2KHR(&self, commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo) {
		(self.vk_cmd_bind_descriptor_sets2_khr)(commandBuffer, pBindDescriptorSetsInfo)
	}
}
impl Default for Vulkan_KHR_maintenance6 {
	fn default() -> Self {
		Self {
			vk_cmd_bind_descriptor_sets2_khr: dummy_vkCmdBindDescriptorSets2KHR,
		}
	}
}
impl Vulkan_KHR_maintenance6 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_bind_descriptor_sets2_khr: {let proc = get_proc_address(instance, "vkCmdBindDescriptorSets2KHR"); if proc == null() {dummy_vkCmdBindDescriptorSets2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkVideoEncodeIntraRefreshModeFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeIntraRefreshModeFlagBitsKHR {
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_NONE_KHR = 0,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_PER_PICTURE_PARTITION_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_BASED_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_ROW_BASED_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_COLUMN_BASED_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeIntraRefreshCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub intraRefreshModes: VkVideoEncodeIntraRefreshModeFlagsKHR,
	pub maxIntraRefreshCycleDuration: u32,
	pub maxIntraRefreshActiveReferencePictures: u32,
	pub partitionIndependentIntraRefreshRegions: VkBool32,
	pub nonRectangularIntraRefreshRegions: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeSessionIntraRefreshCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub intraRefreshMode: VkVideoEncodeIntraRefreshModeFlagBitsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeIntraRefreshInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub intraRefreshCycleDuration: u32,
	pub intraRefreshIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoReferenceIntraRefreshInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dirtyIntraRefreshRegions: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub videoEncodeIntraRefresh: VkBool32,
}
pub trait VK_KHR_video_encode_intra_refresh: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_encode_intra_refresh {}
impl VK_KHR_video_encode_intra_refresh for Vulkan_KHR_video_encode_intra_refresh {}
impl Default for Vulkan_KHR_video_encode_intra_refresh {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_encode_intra_refresh {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeQuantizationMapCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxQuantizationMapExtent: VkExtent2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoFormatQuantizationMapPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub quantizationMapTexelSize: VkExtent2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeQuantizationMapInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub quantizationMap: VkImageView,
	pub quantizationMapExtent: VkExtent2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub quantizationMapTexelSize: VkExtent2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub videoEncodeQuantizationMap: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH264QuantizationMapCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minQpDelta: i32,
	pub maxQpDelta: i32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeH265QuantizationMapCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minQpDelta: i32,
	pub maxQpDelta: i32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoFormatH265QuantizationMapPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub compatibleCtbSizes: VkVideoEncodeH265CtbSizeFlagsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoEncodeAV1QuantizationMapCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minQIndexDelta: i32,
	pub maxQIndexDelta: i32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoFormatAV1QuantizationMapPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub compatibleSuperblockSizes: VkVideoEncodeAV1SuperblockSizeFlagsKHR,
}
pub trait VK_KHR_video_encode_quantization_map: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_encode_quantization_map {}
impl VK_KHR_video_encode_quantization_map for Vulkan_KHR_video_encode_quantization_map {}
impl Default for Vulkan_KHR_video_encode_quantization_map {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_encode_quantization_map {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderRelaxedExtendedInstruction: VkBool32,
}
pub trait VK_KHR_shader_relaxed_extended_instruction: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_relaxed_extended_instruction {}
impl VK_KHR_shader_relaxed_extended_instruction for Vulkan_KHR_shader_relaxed_extended_instruction {}
impl Default for Vulkan_KHR_shader_relaxed_extended_instruction {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_relaxed_extended_instruction {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPhysicalDeviceLayeredApiKHR {
	VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR = 0,
	VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR = 1,
	VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR = 2,
	VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR = 3,
	VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR = 4,
	VK_PHYSICAL_DEVICE_LAYERED_API_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance7FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maintenance7: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance7PropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub robustFragmentShadingRateAttachmentAccess: VkBool32,
	pub separateDepthStencilAttachmentAccess: VkBool32,
	pub maxDescriptorSetTotalUniformBuffersDynamic: u32,
	pub maxDescriptorSetTotalStorageBuffersDynamic: u32,
	pub maxDescriptorSetTotalBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindTotalBuffersDynamic: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceLayeredApiPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub vendorID: u32,
	pub deviceID: u32,
	pub layeredAPI: VkPhysicalDeviceLayeredApiKHR,
	pub deviceName: [i8; VK_MAX_PHYSICAL_DEVICE_NAME_SIZE as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceLayeredApiPropertiesListKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub layeredApiCount: u32,
	pub pLayeredApis: *mut VkPhysicalDeviceLayeredApiPropertiesKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceLayeredApiVulkanPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub properties: VkPhysicalDeviceProperties2,
}
pub trait VK_KHR_maintenance7: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance7 {}
impl VK_KHR_maintenance7 for Vulkan_KHR_maintenance7 {}
impl Default for Vulkan_KHR_maintenance7 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_maintenance7 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkAccessFlags3KHR = VkFlags64;
pub type VkAccessFlagBits3KHR = VkFlags64;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryBarrierAccessFlags3KHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcAccessMask3: VkAccessFlags3KHR,
	pub dstAccessMask3: VkAccessFlags3KHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance8FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maintenance8: VkBool32,
}
pub trait VK_KHR_maintenance8: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance8 {}
impl VK_KHR_maintenance8 for Vulkan_KHR_maintenance8 {}
impl Default for Vulkan_KHR_maintenance8 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_maintenance8 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDefaultVertexAttributeValueKHR {
	VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR = 0,
	VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR = 1,
	VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance9FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maintenance9: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance9PropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub image2DViewOf3DSparse: VkBool32,
	pub defaultVertexAttributeValue: VkDefaultVertexAttributeValueKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkQueueFamilyOwnershipTransferPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub optimalImageTransferToQueueFamilies: u32,
}
pub trait VK_KHR_maintenance9: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance9 {}
impl VK_KHR_maintenance9 for Vulkan_KHR_maintenance9 {}
impl Default for Vulkan_KHR_maintenance9 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_maintenance9 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVideoMaintenance2FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub videoMaintenance2: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeH264InlineSessionParametersInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdSPS: *const StdVideoH264SequenceParameterSet,
	pub pStdPPS: *const StdVideoH264PictureParameterSet,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeH265InlineSessionParametersInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdVPS: *const StdVideoH265VideoParameterSet,
	pub pStdSPS: *const StdVideoH265SequenceParameterSet,
	pub pStdPPS: *const StdVideoH265PictureParameterSet,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVideoDecodeAV1InlineSessionParametersInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdSequenceHeader: *const StdVideoAV1SequenceHeader,
}
pub trait VK_KHR_video_maintenance2: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_maintenance2 {}
impl VK_KHR_video_maintenance2 for Vulkan_KHR_video_maintenance2 {}
impl Default for Vulkan_KHR_video_maintenance2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_maintenance2 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDepthClampZeroOneFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub depthClampZeroOne: VkBool32,
}
pub trait VK_KHR_depth_clamp_zero_one: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_depth_clamp_zero_one {}
impl VK_KHR_depth_clamp_zero_one for Vulkan_KHR_depth_clamp_zero_one {}
impl Default for Vulkan_KHR_depth_clamp_zero_one {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_depth_clamp_zero_one {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRobustness2FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub robustBufferAccess2: VkBool32,
	pub robustImageAccess2: VkBool32,
	pub nullDescriptor: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRobustness2PropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub robustStorageBufferAccessSizeAlignment: VkDeviceSize,
	pub robustUniformBufferAccessSizeAlignment: VkDeviceSize,
}
pub trait VK_KHR_robustness2: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_robustness2 {}
impl VK_KHR_robustness2 for Vulkan_KHR_robustness2 {}
impl Default for Vulkan_KHR_robustness2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_robustness2 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentModeFifoLatestReady: VkBool32,
}
pub trait VK_KHR_present_mode_fifo_latest_ready: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_present_mode_fifo_latest_ready {}
impl VK_KHR_present_mode_fifo_latest_ready for Vulkan_KHR_present_mode_fifo_latest_ready {}
impl Default for Vulkan_KHR_present_mode_fifo_latest_ready {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_present_mode_fifo_latest_ready {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkDebugReportFlagsEXT = VkFlags;
// Define non-dispatchable handle `VkDebugReportCallbackEXT`
#[cfg(target_pointer_width = "32")] pub type VkDebugReportCallbackEXT = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkDebugReportCallbackEXT_T {}
#[cfg(target_pointer_width = "64")] pub type VkDebugReportCallbackEXT = *const VkDebugReportCallbackEXT_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDebugReportObjectTypeEXT {
	VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
	VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
	VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
	VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
	VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
	VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
	VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
	VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
	VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
	VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
	VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
	VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
	VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
	VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT = 1000029000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT = 1000029001,
	VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT = 1000150000,
	VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT = 1000307000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT = 1000307001,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT = 1000366000,
	VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
impl VkDebugReportObjectTypeEXT {
	pub const VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT: VkDebugReportObjectTypeEXT = VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT;
	pub const VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT: VkDebugReportObjectTypeEXT = VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT;
	pub const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT: VkDebugReportObjectTypeEXT = VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT;
	pub const VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT: VkDebugReportObjectTypeEXT = VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDebugReportFlagBitsEXT {
	VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001,
	VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002,
	VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
	VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008,
	VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010,
	VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDebugReportCallbackCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDebugReportFlagsEXT,
	pub pfnCallback: PFN_vkDebugReportCallbackEXT,
	pub pUserData: *mut c_void,
}
type PFN_vkDebugReportCallbackEXT = extern "system" fn(flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT, object: u64, location: usize, messageCode: i32, pLayerPrefix: *const i8, pMessage: *const i8, pUserData: *mut c_void) -> VkBool32;
type PFN_vkCreateDebugReportCallbackEXT = extern "system" fn(instance: VkInstance, pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pCallback: *mut VkDebugReportCallbackEXT) -> VkResult;
type PFN_vkDestroyDebugReportCallbackEXT = extern "system" fn(instance: VkInstance, callback: VkDebugReportCallbackEXT, pAllocator: *const VkAllocationCallbacks);
type PFN_vkDebugReportMessageEXT = extern "system" fn(instance: VkInstance, flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT, object: u64, location: usize, messageCode: i32, pLayerPrefix: *const i8, pMessage: *const i8);
extern "system" fn dummy_vkCreateDebugReportCallbackEXT(_: VkInstance, _: *const VkDebugReportCallbackCreateInfoEXT, _: *const VkAllocationCallbacks, _: *mut VkDebugReportCallbackEXT) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateDebugReportCallbackEXT()` is NULL");
}
pub trait VK_EXT_debug_report: Debug {
	fn vkCreateDebugReportCallbackEXT(&self, instance: VkInstance, pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pCallback: *mut VkDebugReportCallbackEXT) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_debug_report {
	vk_create_debug_report_callback_ext: PFN_vkCreateDebugReportCallbackEXT,
}
impl VK_EXT_debug_report for Vulkan_EXT_debug_report {
	fn vkCreateDebugReportCallbackEXT(&self, instance: VkInstance, pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pCallback: *mut VkDebugReportCallbackEXT) -> VkResult {
		(self.vk_create_debug_report_callback_ext)(instance, pCreateInfo, pAllocator, pCallback)
	}
}
impl Default for Vulkan_EXT_debug_report {
	fn default() -> Self {
		Self {
			vk_create_debug_report_callback_ext: dummy_vkCreateDebugReportCallbackEXT,
		}
	}
}
impl Vulkan_EXT_debug_report {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_debug_report_callback_ext: {let proc = get_proc_address(instance, "vkCreateDebugReportCallbackEXT"); if proc == null() {dummy_vkCreateDebugReportCallbackEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub trait VK_NV_glsl_shader: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_glsl_shader {}
impl VK_NV_glsl_shader for Vulkan_NV_glsl_shader {}
impl Default for Vulkan_NV_glsl_shader {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_glsl_shader {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_EXT_depth_range_unrestricted: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_depth_range_unrestricted {}
impl VK_EXT_depth_range_unrestricted for Vulkan_EXT_depth_range_unrestricted {}
impl Default for Vulkan_EXT_depth_range_unrestricted {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_depth_range_unrestricted {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_IMG_filter_cubic: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_IMG_filter_cubic {}
impl VK_IMG_filter_cubic for Vulkan_IMG_filter_cubic {}
impl Default for Vulkan_IMG_filter_cubic {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_IMG_filter_cubic {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkRasterizationOrderAMD {
	VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
	VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
	VK_RASTERIZATION_ORDER_MAX_ENUM_AMD = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineRasterizationStateRasterizationOrderAMD {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub rasterizationOrder: VkRasterizationOrderAMD,
}
pub trait VK_AMD_rasterization_order: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_rasterization_order {}
impl VK_AMD_rasterization_order for Vulkan_AMD_rasterization_order {}
impl Default for Vulkan_AMD_rasterization_order {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_rasterization_order {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_AMD_shader_trinary_minmax: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_trinary_minmax {}
impl VK_AMD_shader_trinary_minmax for Vulkan_AMD_shader_trinary_minmax {}
impl Default for Vulkan_AMD_shader_trinary_minmax {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_shader_trinary_minmax {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_AMD_shader_explicit_vertex_parameter: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_explicit_vertex_parameter {}
impl VK_AMD_shader_explicit_vertex_parameter for Vulkan_AMD_shader_explicit_vertex_parameter {}
impl Default for Vulkan_AMD_shader_explicit_vertex_parameter {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_shader_explicit_vertex_parameter {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDebugMarkerObjectNameInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub objectType: VkDebugReportObjectTypeEXT,
	pub object: u64,
	pub pObjectName: *const i8,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDebugMarkerObjectTagInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub objectType: VkDebugReportObjectTypeEXT,
	pub object: u64,
	pub tagName: u64,
	pub tagSize: usize,
	pub pTag: *const c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDebugMarkerMarkerInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pMarkerName: *const i8,
	pub color: [f32; 4 as usize],
}
type PFN_vkDebugMarkerSetObjectTagEXT = extern "system" fn(device: VkDevice, pTagInfo: *const VkDebugMarkerObjectTagInfoEXT) -> VkResult;
type PFN_vkDebugMarkerSetObjectNameEXT = extern "system" fn(device: VkDevice, pNameInfo: *const VkDebugMarkerObjectNameInfoEXT) -> VkResult;
type PFN_vkCmdDebugMarkerBeginEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pMarkerInfo: *const VkDebugMarkerMarkerInfoEXT);
type PFN_vkCmdDebugMarkerEndEXT = extern "system" fn(commandBuffer: VkCommandBuffer);
type PFN_vkCmdDebugMarkerInsertEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pMarkerInfo: *const VkDebugMarkerMarkerInfoEXT);
extern "system" fn dummy_vkDebugMarkerSetObjectTagEXT(_: VkDevice, _: *const VkDebugMarkerObjectTagInfoEXT) -> VkResult {
	panic!("Vulkan function pointer of `vkDebugMarkerSetObjectTagEXT()` is NULL");
}
pub trait VK_EXT_debug_marker: Debug {
	fn vkDebugMarkerSetObjectTagEXT(&self, device: VkDevice, pTagInfo: *const VkDebugMarkerObjectTagInfoEXT) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_debug_marker {
	vk_debug_marker_set_object_tag_ext: PFN_vkDebugMarkerSetObjectTagEXT,
}
impl VK_EXT_debug_marker for Vulkan_EXT_debug_marker {
	fn vkDebugMarkerSetObjectTagEXT(&self, device: VkDevice, pTagInfo: *const VkDebugMarkerObjectTagInfoEXT) -> VkResult {
		(self.vk_debug_marker_set_object_tag_ext)(device, pTagInfo)
	}
}
impl Default for Vulkan_EXT_debug_marker {
	fn default() -> Self {
		Self {
			vk_debug_marker_set_object_tag_ext: dummy_vkDebugMarkerSetObjectTagEXT,
		}
	}
}
impl Vulkan_EXT_debug_marker {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_debug_marker_set_object_tag_ext: {let proc = get_proc_address(instance, "vkDebugMarkerSetObjectTagEXT"); if proc == null() {dummy_vkDebugMarkerSetObjectTagEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub trait VK_AMD_gcn_shader: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_gcn_shader {}
impl VK_AMD_gcn_shader for Vulkan_AMD_gcn_shader {}
impl Default for Vulkan_AMD_gcn_shader {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_gcn_shader {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDedicatedAllocationImageCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dedicatedAllocation: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDedicatedAllocationBufferCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dedicatedAllocation: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDedicatedAllocationMemoryAllocateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub image: VkImage,
	pub buffer: VkBuffer,
}
pub trait VK_NV_dedicated_allocation: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_dedicated_allocation {}
impl VK_NV_dedicated_allocation for Vulkan_NV_dedicated_allocation {}
impl Default for Vulkan_NV_dedicated_allocation {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_dedicated_allocation {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPipelineRasterizationStateStreamCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceTransformFeedbackFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub transformFeedback: VkBool32,
	pub geometryStreams: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceTransformFeedbackPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxTransformFeedbackStreams: u32,
	pub maxTransformFeedbackBuffers: u32,
	pub maxTransformFeedbackBufferSize: VkDeviceSize,
	pub maxTransformFeedbackStreamDataSize: u32,
	pub maxTransformFeedbackBufferDataSize: u32,
	pub maxTransformFeedbackBufferDataStride: u32,
	pub transformFeedbackQueries: VkBool32,
	pub transformFeedbackStreamsLinesTriangles: VkBool32,
	pub transformFeedbackRasterizationStreamSelect: VkBool32,
	pub transformFeedbackDraw: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineRasterizationStateStreamCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineRasterizationStateStreamCreateFlagsEXT,
	pub rasterizationStream: u32,
}
type PFN_vkCmdBindTransformFeedbackBuffersEXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize);
type PFN_vkCmdBeginTransformFeedbackEXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *const VkBuffer, pCounterBufferOffsets: *const VkDeviceSize);
type PFN_vkCmdEndTransformFeedbackEXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *const VkBuffer, pCounterBufferOffsets: *const VkDeviceSize);
type PFN_vkCmdBeginQueryIndexedEXT = extern "system" fn(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags, index: u32);
type PFN_vkCmdEndQueryIndexedEXT = extern "system" fn(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, index: u32);
type PFN_vkCmdDrawIndirectByteCountEXT = extern "system" fn(commandBuffer: VkCommandBuffer, instanceCount: u32, firstInstance: u32, counterBuffer: VkBuffer, counterBufferOffset: VkDeviceSize, counterOffset: u32, vertexStride: u32);
extern "system" fn dummy_vkCmdBindTransformFeedbackBuffersEXT(_: VkCommandBuffer, _: u32, _: u32, _: *const VkBuffer, _: *const VkDeviceSize, _: *const VkDeviceSize) {
	panic!("Vulkan function pointer of `vkCmdBindTransformFeedbackBuffersEXT()` is NULL");
}
pub trait VK_EXT_transform_feedback: Debug {
	fn vkCmdBindTransformFeedbackBuffersEXT(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_transform_feedback {
	vk_cmd_bind_transform_feedback_buffers_ext: PFN_vkCmdBindTransformFeedbackBuffersEXT,
}
impl VK_EXT_transform_feedback for Vulkan_EXT_transform_feedback {
	fn vkCmdBindTransformFeedbackBuffersEXT(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize) {
		(self.vk_cmd_bind_transform_feedback_buffers_ext)(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes)
	}
}
impl Default for Vulkan_EXT_transform_feedback {
	fn default() -> Self {
		Self {
			vk_cmd_bind_transform_feedback_buffers_ext: dummy_vkCmdBindTransformFeedbackBuffersEXT,
		}
	}
}
impl Vulkan_EXT_transform_feedback {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_bind_transform_feedback_buffers_ext: {let proc = get_proc_address(instance, "vkCmdBindTransformFeedbackBuffersEXT"); if proc == null() {dummy_vkCmdBindTransformFeedbackBuffersEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
// Define non-dispatchable handle `VkCuModuleNVX`
#[cfg(target_pointer_width = "32")] pub type VkCuModuleNVX = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkCuModuleNVX_T {}
#[cfg(target_pointer_width = "64")] pub type VkCuModuleNVX = *const VkCuModuleNVX_T;
// Define non-dispatchable handle `VkCuFunctionNVX`
#[cfg(target_pointer_width = "32")] pub type VkCuFunctionNVX = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkCuFunctionNVX_T {}
#[cfg(target_pointer_width = "64")] pub type VkCuFunctionNVX = *const VkCuFunctionNVX_T;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCuModuleCreateInfoNVX {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dataSize: usize,
	pub pData: *const c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCuModuleTexturingModeCreateInfoNVX {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub use64bitTexturing: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCuFunctionCreateInfoNVX {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub module: VkCuModuleNVX,
	pub pName: *const i8,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCuLaunchInfoNVX {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub function: VkCuFunctionNVX,
	pub gridDimX: u32,
	pub gridDimY: u32,
	pub gridDimZ: u32,
	pub blockDimX: u32,
	pub blockDimY: u32,
	pub blockDimZ: u32,
	pub sharedMemBytes: u32,
	pub paramCount: usize,
	pub pParams: *const *const c_void,
	pub extraCount: usize,
	pub pExtras: *const *const c_void,
}
type PFN_vkCreateCuModuleNVX = extern "system" fn(device: VkDevice, pCreateInfo: *const VkCuModuleCreateInfoNVX, pAllocator: *const VkAllocationCallbacks, pModule: *mut VkCuModuleNVX) -> VkResult;
type PFN_vkCreateCuFunctionNVX = extern "system" fn(device: VkDevice, pCreateInfo: *const VkCuFunctionCreateInfoNVX, pAllocator: *const VkAllocationCallbacks, pFunction: *mut VkCuFunctionNVX) -> VkResult;
type PFN_vkDestroyCuModuleNVX = extern "system" fn(device: VkDevice, module: VkCuModuleNVX, pAllocator: *const VkAllocationCallbacks);
type PFN_vkDestroyCuFunctionNVX = extern "system" fn(device: VkDevice, function: VkCuFunctionNVX, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCmdCuLaunchKernelNVX = extern "system" fn(commandBuffer: VkCommandBuffer, pLaunchInfo: *const VkCuLaunchInfoNVX);
extern "system" fn dummy_vkCreateCuModuleNVX(_: VkDevice, _: *const VkCuModuleCreateInfoNVX, _: *const VkAllocationCallbacks, _: *mut VkCuModuleNVX) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateCuModuleNVX()` is NULL");
}
pub trait VK_NVX_binary_import: Debug {
	fn vkCreateCuModuleNVX(&self, device: VkDevice, pCreateInfo: *const VkCuModuleCreateInfoNVX, pAllocator: *const VkAllocationCallbacks, pModule: *mut VkCuModuleNVX) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NVX_binary_import {
	vk_create_cu_module_nvx: PFN_vkCreateCuModuleNVX,
}
impl VK_NVX_binary_import for Vulkan_NVX_binary_import {
	fn vkCreateCuModuleNVX(&self, device: VkDevice, pCreateInfo: *const VkCuModuleCreateInfoNVX, pAllocator: *const VkAllocationCallbacks, pModule: *mut VkCuModuleNVX) -> VkResult {
		(self.vk_create_cu_module_nvx)(device, pCreateInfo, pAllocator, pModule)
	}
}
impl Default for Vulkan_NVX_binary_import {
	fn default() -> Self {
		Self {
			vk_create_cu_module_nvx: dummy_vkCreateCuModuleNVX,
		}
	}
}
impl Vulkan_NVX_binary_import {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_cu_module_nvx: {let proc = get_proc_address(instance, "vkCreateCuModuleNVX"); if proc == null() {dummy_vkCreateCuModuleNVX} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageViewHandleInfoNVX {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub imageView: VkImageView,
	pub descriptorType: VkDescriptorType,
	pub sampler: VkSampler,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageViewAddressPropertiesNVX {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceAddress: VkDeviceAddress,
	pub size: VkDeviceSize,
}
type PFN_vkGetImageViewHandleNVX = extern "system" fn(device: VkDevice, pInfo: *const VkImageViewHandleInfoNVX) -> u32;
type PFN_vkGetImageViewHandle64NVX = extern "system" fn(device: VkDevice, pInfo: *const VkImageViewHandleInfoNVX) -> u64;
type PFN_vkGetImageViewAddressNVX = extern "system" fn(device: VkDevice, imageView: VkImageView, pProperties: *mut VkImageViewAddressPropertiesNVX) -> VkResult;
extern "system" fn dummy_vkGetImageViewHandleNVX(_: VkDevice, _: *const VkImageViewHandleInfoNVX) -> u32 {
	panic!("Vulkan function pointer of `vkGetImageViewHandleNVX()` is NULL");
}
pub trait VK_NVX_image_view_handle: Debug {
	fn vkGetImageViewHandleNVX(&self, device: VkDevice, pInfo: *const VkImageViewHandleInfoNVX) -> u32;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NVX_image_view_handle {
	vk_get_image_view_handle_nvx: PFN_vkGetImageViewHandleNVX,
}
impl VK_NVX_image_view_handle for Vulkan_NVX_image_view_handle {
	fn vkGetImageViewHandleNVX(&self, device: VkDevice, pInfo: *const VkImageViewHandleInfoNVX) -> u32 {
		(self.vk_get_image_view_handle_nvx)(device, pInfo)
	}
}
impl Default for Vulkan_NVX_image_view_handle {
	fn default() -> Self {
		Self {
			vk_get_image_view_handle_nvx: dummy_vkGetImageViewHandleNVX,
		}
	}
}
impl Vulkan_NVX_image_view_handle {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_image_view_handle_nvx: {let proc = get_proc_address(instance, "vkGetImageViewHandleNVX"); if proc == null() {dummy_vkGetImageViewHandleNVX} else {unsafe {transmute(proc)}}},
		}
	}
}
type PFN_vkCmdDrawIndirectCountAMD = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
type PFN_vkCmdDrawIndexedIndirectCountAMD = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
extern "system" fn dummy_vkCmdDrawIndirectCountAMD(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkBuffer, _: VkDeviceSize, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdDrawIndirectCountAMD()` is NULL");
}
pub trait VK_AMD_draw_indirect_count: Debug {
	fn vkCmdDrawIndirectCountAMD(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_draw_indirect_count {
	vk_cmd_draw_indirect_count_amd: PFN_vkCmdDrawIndirectCountAMD,
}
impl VK_AMD_draw_indirect_count for Vulkan_AMD_draw_indirect_count {
	fn vkCmdDrawIndirectCountAMD(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) {
		(self.vk_cmd_draw_indirect_count_amd)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	}
}
impl Default for Vulkan_AMD_draw_indirect_count {
	fn default() -> Self {
		Self {
			vk_cmd_draw_indirect_count_amd: dummy_vkCmdDrawIndirectCountAMD,
		}
	}
}
impl Vulkan_AMD_draw_indirect_count {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_draw_indirect_count_amd: {let proc = get_proc_address(instance, "vkCmdDrawIndirectCountAMD"); if proc == null() {dummy_vkCmdDrawIndirectCountAMD} else {unsafe {transmute(proc)}}},
		}
	}
}
pub trait VK_AMD_negative_viewport_height: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_negative_viewport_height {}
impl VK_AMD_negative_viewport_height for Vulkan_AMD_negative_viewport_height {}
impl Default for Vulkan_AMD_negative_viewport_height {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_negative_viewport_height {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_AMD_gpu_shader_half_float: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_gpu_shader_half_float {}
impl VK_AMD_gpu_shader_half_float for Vulkan_AMD_gpu_shader_half_float {}
impl Default for Vulkan_AMD_gpu_shader_half_float {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_gpu_shader_half_float {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_AMD_shader_ballot: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_ballot {}
impl VK_AMD_shader_ballot for Vulkan_AMD_shader_ballot {}
impl Default for Vulkan_AMD_shader_ballot {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_shader_ballot {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTextureLODGatherFormatPropertiesAMD {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub supportsTextureGatherLODBiasAMD: VkBool32,
}
pub trait VK_AMD_texture_gather_bias_lod: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_texture_gather_bias_lod {}
impl VK_AMD_texture_gather_bias_lod for Vulkan_AMD_texture_gather_bias_lod {}
impl Default for Vulkan_AMD_texture_gather_bias_lod {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_texture_gather_bias_lod {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkShaderInfoTypeAMD {
	VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0,
	VK_SHADER_INFO_TYPE_BINARY_AMD = 1,
	VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2,
	VK_SHADER_INFO_TYPE_MAX_ENUM_AMD = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkShaderResourceUsageAMD {
	pub numUsedVgprs: u32,
	pub numUsedSgprs: u32,
	pub ldsSizePerLocalWorkGroup: u32,
	pub ldsUsageSizeInBytes: usize,
	pub scratchMemUsageInBytes: usize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkShaderStatisticsInfoAMD {
	pub shaderStageMask: VkShaderStageFlags,
	pub resourceUsage: VkShaderResourceUsageAMD,
	pub numPhysicalVgprs: u32,
	pub numPhysicalSgprs: u32,
	pub numAvailableVgprs: u32,
	pub numAvailableSgprs: u32,
	pub computeWorkGroupSize: [u32; 3 as usize],
}
type PFN_vkGetShaderInfoAMD = extern "system" fn(device: VkDevice, pipeline: VkPipeline, shaderStage: VkShaderStageFlagBits, infoType: VkShaderInfoTypeAMD, pInfoSize: *mut size_t, pInfo: *mut c_void) -> VkResult;
extern "system" fn dummy_vkGetShaderInfoAMD(_: VkDevice, _: VkPipeline, _: VkShaderStageFlagBits, _: VkShaderInfoTypeAMD, _: *mut size_t, _: *mut c_void) -> VkResult {
	panic!("Vulkan function pointer of `vkGetShaderInfoAMD()` is NULL");
}
pub trait VK_AMD_shader_info: Debug {
	fn vkGetShaderInfoAMD(&self, device: VkDevice, pipeline: VkPipeline, shaderStage: VkShaderStageFlagBits, infoType: VkShaderInfoTypeAMD, pInfoSize: *mut size_t, pInfo: *mut c_void) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_info {
	vk_get_shader_info_amd: PFN_vkGetShaderInfoAMD,
}
impl VK_AMD_shader_info for Vulkan_AMD_shader_info {
	fn vkGetShaderInfoAMD(&self, device: VkDevice, pipeline: VkPipeline, shaderStage: VkShaderStageFlagBits, infoType: VkShaderInfoTypeAMD, pInfoSize: *mut size_t, pInfo: *mut c_void) -> VkResult {
		(self.vk_get_shader_info_amd)(device, pipeline, shaderStage, infoType, pInfoSize, pInfo)
	}
}
impl Default for Vulkan_AMD_shader_info {
	fn default() -> Self {
		Self {
			vk_get_shader_info_amd: dummy_vkGetShaderInfoAMD,
		}
	}
}
impl Vulkan_AMD_shader_info {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_shader_info_amd: {let proc = get_proc_address(instance, "vkGetShaderInfoAMD"); if proc == null() {dummy_vkGetShaderInfoAMD} else {unsafe {transmute(proc)}}},
		}
	}
}
pub trait VK_AMD_shader_image_load_store_lod: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_image_load_store_lod {}
impl VK_AMD_shader_image_load_store_lod for Vulkan_AMD_shader_image_load_store_lod {}
impl Default for Vulkan_AMD_shader_image_load_store_lod {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_shader_image_load_store_lod {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCornerSampledImageFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cornerSampledImage: VkBool32,
}
pub trait VK_NV_corner_sampled_image: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_corner_sampled_image {}
impl VK_NV_corner_sampled_image for Vulkan_NV_corner_sampled_image {}
impl Default for Vulkan_NV_corner_sampled_image {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_corner_sampled_image {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_IMG_format_pvrtc: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_IMG_format_pvrtc {}
impl VK_IMG_format_pvrtc for Vulkan_IMG_format_pvrtc {}
impl Default for Vulkan_IMG_format_pvrtc {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_IMG_format_pvrtc {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkExternalMemoryHandleTypeFlagsNV = VkFlags;
pub type VkExternalMemoryFeatureFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkExternalMemoryHandleTypeFlagBitsNV {
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x00000001,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x00000004,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x00000008,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkExternalMemoryFeatureFlagBitsNV {
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x00000001,
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x00000002,
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x00000004,
	VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExternalImageFormatPropertiesNV {
	pub imageFormatProperties: VkImageFormatProperties,
	pub externalMemoryFeatures: VkExternalMemoryFeatureFlagsNV,
	pub exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagsNV,
	pub compatibleHandleTypes: VkExternalMemoryHandleTypeFlagsNV,
}
type PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = extern "system" fn(physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, externalHandleType: VkExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *mut VkExternalImageFormatPropertiesNV) -> VkResult;
extern "system" fn dummy_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(_: VkPhysicalDevice, _: VkFormat, _: VkImageType, _: VkImageTiling, _: VkImageUsageFlags, _: VkImageCreateFlags, _: VkExternalMemoryHandleTypeFlagsNV, _: *mut VkExternalImageFormatPropertiesNV) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceExternalImageFormatPropertiesNV()` is NULL");
}
pub trait VK_NV_external_memory_capabilities: Debug {
	fn vkGetPhysicalDeviceExternalImageFormatPropertiesNV(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, externalHandleType: VkExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *mut VkExternalImageFormatPropertiesNV) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_external_memory_capabilities {
	vk_get_physical_device_external_image_format_properties_nv: PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV,
}
impl VK_NV_external_memory_capabilities for Vulkan_NV_external_memory_capabilities {
	fn vkGetPhysicalDeviceExternalImageFormatPropertiesNV(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, externalHandleType: VkExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *mut VkExternalImageFormatPropertiesNV) -> VkResult {
		(self.vk_get_physical_device_external_image_format_properties_nv)(physicalDevice, format, type_, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties)
	}
}
impl Default for Vulkan_NV_external_memory_capabilities {
	fn default() -> Self {
		Self {
			vk_get_physical_device_external_image_format_properties_nv: dummy_vkGetPhysicalDeviceExternalImageFormatPropertiesNV,
		}
	}
}
impl Vulkan_NV_external_memory_capabilities {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_external_image_format_properties_nv: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV"); if proc == null() {dummy_vkGetPhysicalDeviceExternalImageFormatPropertiesNV} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExternalMemoryImageCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes: VkExternalMemoryHandleTypeFlagsNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExportMemoryAllocateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes: VkExternalMemoryHandleTypeFlagsNV,
}
pub trait VK_NV_external_memory: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_external_memory {}
impl VK_NV_external_memory for Vulkan_NV_external_memory {}
impl Default for Vulkan_NV_external_memory {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_external_memory {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkValidationCheckEXT {
	VK_VALIDATION_CHECK_ALL_EXT = 0,
	VK_VALIDATION_CHECK_SHADERS_EXT = 1,
	VK_VALIDATION_CHECK_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkValidationFlagsEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub disabledValidationCheckCount: u32,
	pub pDisabledValidationChecks: *const VkValidationCheckEXT,
}
pub trait VK_EXT_validation_flags: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_validation_flags {}
impl VK_EXT_validation_flags for Vulkan_EXT_validation_flags {}
impl Default for Vulkan_EXT_validation_flags {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_validation_flags {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_EXT_shader_subgroup_ballot: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_subgroup_ballot {}
impl VK_EXT_shader_subgroup_ballot for Vulkan_EXT_shader_subgroup_ballot {}
impl Default for Vulkan_EXT_shader_subgroup_ballot {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_subgroup_ballot {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_EXT_shader_subgroup_vote: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_subgroup_vote {}
impl VK_EXT_shader_subgroup_vote for Vulkan_EXT_shader_subgroup_vote {}
impl Default for Vulkan_EXT_shader_subgroup_vote {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_subgroup_vote {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = VkPhysicalDeviceTextureCompressionASTCHDRFeatures;
pub trait VK_EXT_texture_compression_astc_hdr: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_texture_compression_astc_hdr {}
impl VK_EXT_texture_compression_astc_hdr for Vulkan_EXT_texture_compression_astc_hdr {}
impl Default for Vulkan_EXT_texture_compression_astc_hdr {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_texture_compression_astc_hdr {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageViewASTCDecodeModeEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub decodeMode: VkFormat,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceASTCDecodeFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub decodeModeSharedExponent: VkBool32,
}
pub trait VK_EXT_astc_decode_mode: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_astc_decode_mode {}
impl VK_EXT_astc_decode_mode for Vulkan_EXT_astc_decode_mode {}
impl Default for Vulkan_EXT_astc_decode_mode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_astc_decode_mode {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPipelineRobustnessBufferBehaviorEXT = VkPipelineRobustnessBufferBehavior;
pub type VkPipelineRobustnessImageBehaviorEXT = VkPipelineRobustnessImageBehavior;
pub type VkPhysicalDevicePipelineRobustnessFeaturesEXT = VkPhysicalDevicePipelineRobustnessFeatures;
pub type VkPhysicalDevicePipelineRobustnessPropertiesEXT = VkPhysicalDevicePipelineRobustnessProperties;
pub type VkPipelineRobustnessCreateInfoEXT = VkPipelineRobustnessCreateInfo;
pub trait VK_EXT_pipeline_robustness: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_pipeline_robustness {}
impl VK_EXT_pipeline_robustness for Vulkan_EXT_pipeline_robustness {}
impl Default for Vulkan_EXT_pipeline_robustness {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_pipeline_robustness {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkConditionalRenderingFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkConditionalRenderingFlagBitsEXT {
	VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 0x00000001,
	VK_CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkConditionalRenderingBeginInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub buffer: VkBuffer,
	pub offset: VkDeviceSize,
	pub flags: VkConditionalRenderingFlagsEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceConditionalRenderingFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub conditionalRendering: VkBool32,
	pub inheritedConditionalRendering: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCommandBufferInheritanceConditionalRenderingInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub conditionalRenderingEnable: VkBool32,
}
type PFN_vkCmdBeginConditionalRenderingEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pConditionalRenderingBegin: *const VkConditionalRenderingBeginInfoEXT);
type PFN_vkCmdEndConditionalRenderingEXT = extern "system" fn(commandBuffer: VkCommandBuffer);
extern "system" fn dummy_vkCmdBeginConditionalRenderingEXT(_: VkCommandBuffer, _: *const VkConditionalRenderingBeginInfoEXT) {
	panic!("Vulkan function pointer of `vkCmdBeginConditionalRenderingEXT()` is NULL");
}
pub trait VK_EXT_conditional_rendering: Debug {
	fn vkCmdBeginConditionalRenderingEXT(&self, commandBuffer: VkCommandBuffer, pConditionalRenderingBegin: *const VkConditionalRenderingBeginInfoEXT);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_conditional_rendering {
	vk_cmd_begin_conditional_rendering_ext: PFN_vkCmdBeginConditionalRenderingEXT,
}
impl VK_EXT_conditional_rendering for Vulkan_EXT_conditional_rendering {
	fn vkCmdBeginConditionalRenderingEXT(&self, commandBuffer: VkCommandBuffer, pConditionalRenderingBegin: *const VkConditionalRenderingBeginInfoEXT) {
		(self.vk_cmd_begin_conditional_rendering_ext)(commandBuffer, pConditionalRenderingBegin)
	}
}
impl Default for Vulkan_EXT_conditional_rendering {
	fn default() -> Self {
		Self {
			vk_cmd_begin_conditional_rendering_ext: dummy_vkCmdBeginConditionalRenderingEXT,
		}
	}
}
impl Vulkan_EXT_conditional_rendering {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_begin_conditional_rendering_ext: {let proc = get_proc_address(instance, "vkCmdBeginConditionalRenderingEXT"); if proc == null() {dummy_vkCmdBeginConditionalRenderingEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkViewportWScalingNV {
	pub xcoeff: f32,
	pub ycoeff: f32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineViewportWScalingStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub viewportWScalingEnable: VkBool32,
	pub viewportCount: u32,
	pub pViewportWScalings: *const VkViewportWScalingNV,
}
type PFN_vkCmdSetViewportWScalingNV = extern "system" fn(commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportWScalings: *const VkViewportWScalingNV);
extern "system" fn dummy_vkCmdSetViewportWScalingNV(_: VkCommandBuffer, _: u32, _: u32, _: *const VkViewportWScalingNV) {
	panic!("Vulkan function pointer of `vkCmdSetViewportWScalingNV()` is NULL");
}
pub trait VK_NV_clip_space_w_scaling: Debug {
	fn vkCmdSetViewportWScalingNV(&self, commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportWScalings: *const VkViewportWScalingNV);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_clip_space_w_scaling {
	vk_cmd_set_viewport_wscaling_nv: PFN_vkCmdSetViewportWScalingNV,
}
impl VK_NV_clip_space_w_scaling for Vulkan_NV_clip_space_w_scaling {
	fn vkCmdSetViewportWScalingNV(&self, commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportWScalings: *const VkViewportWScalingNV) {
		(self.vk_cmd_set_viewport_wscaling_nv)(commandBuffer, firstViewport, viewportCount, pViewportWScalings)
	}
}
impl Default for Vulkan_NV_clip_space_w_scaling {
	fn default() -> Self {
		Self {
			vk_cmd_set_viewport_wscaling_nv: dummy_vkCmdSetViewportWScalingNV,
		}
	}
}
impl Vulkan_NV_clip_space_w_scaling {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_viewport_wscaling_nv: {let proc = get_proc_address(instance, "vkCmdSetViewportWScalingNV"); if proc == null() {dummy_vkCmdSetViewportWScalingNV} else {unsafe {transmute(proc)}}},
		}
	}
}
type PFN_vkReleaseDisplayEXT = extern "system" fn(physicalDevice: VkPhysicalDevice, display: VkDisplayKHR) -> VkResult;
extern "system" fn dummy_vkReleaseDisplayEXT(_: VkPhysicalDevice, _: VkDisplayKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkReleaseDisplayEXT()` is NULL");
}
pub trait VK_EXT_direct_mode_display: Debug {
	fn vkReleaseDisplayEXT(&self, physicalDevice: VkPhysicalDevice, display: VkDisplayKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_direct_mode_display {
	vk_release_display_ext: PFN_vkReleaseDisplayEXT,
}
impl VK_EXT_direct_mode_display for Vulkan_EXT_direct_mode_display {
	fn vkReleaseDisplayEXT(&self, physicalDevice: VkPhysicalDevice, display: VkDisplayKHR) -> VkResult {
		(self.vk_release_display_ext)(physicalDevice, display)
	}
}
impl Default for Vulkan_EXT_direct_mode_display {
	fn default() -> Self {
		Self {
			vk_release_display_ext: dummy_vkReleaseDisplayEXT,
		}
	}
}
impl Vulkan_EXT_direct_mode_display {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_release_display_ext: {let proc = get_proc_address(instance, "vkReleaseDisplayEXT"); if proc == null() {dummy_vkReleaseDisplayEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkSurfaceCounterFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSurfaceCounterFlagBitsEXT {
	VK_SURFACE_COUNTER_VBLANK_BIT_EXT = 0x00000001,
	VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
impl VkSurfaceCounterFlagBitsEXT {
	pub const VK_SURFACE_COUNTER_VBLANK_EXT: VkSurfaceCounterFlagBitsEXT = VkSurfaceCounterFlagBitsEXT::VK_SURFACE_COUNTER_VBLANK_BIT_EXT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSurfaceCapabilities2EXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minImageCount: u32,
	pub maxImageCount: u32,
	pub currentExtent: VkExtent2D,
	pub minImageExtent: VkExtent2D,
	pub maxImageExtent: VkExtent2D,
	pub maxImageArrayLayers: u32,
	pub supportedTransforms: VkSurfaceTransformFlagsKHR,
	pub currentTransform: VkSurfaceTransformFlagBitsKHR,
	pub supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
	pub supportedUsageFlags: VkImageUsageFlags,
	pub supportedSurfaceCounters: VkSurfaceCounterFlagsEXT,
}
type PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT = extern "system" fn(physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2EXT) -> VkResult;
extern "system" fn dummy_vkGetPhysicalDeviceSurfaceCapabilities2EXT(_: VkPhysicalDevice, _: VkSurfaceKHR, _: *mut VkSurfaceCapabilities2EXT) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceSurfaceCapabilities2EXT()` is NULL");
}
pub trait VK_EXT_display_surface_counter: Debug {
	fn vkGetPhysicalDeviceSurfaceCapabilities2EXT(&self, physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2EXT) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_display_surface_counter {
	vk_get_physical_device_surface_capabilities2_ext: PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT,
}
impl VK_EXT_display_surface_counter for Vulkan_EXT_display_surface_counter {
	fn vkGetPhysicalDeviceSurfaceCapabilities2EXT(&self, physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2EXT) -> VkResult {
		(self.vk_get_physical_device_surface_capabilities2_ext)(physicalDevice, surface, pSurfaceCapabilities)
	}
}
impl Default for Vulkan_EXT_display_surface_counter {
	fn default() -> Self {
		Self {
			vk_get_physical_device_surface_capabilities2_ext: dummy_vkGetPhysicalDeviceSurfaceCapabilities2EXT,
		}
	}
}
impl Vulkan_EXT_display_surface_counter {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_surface_capabilities2_ext: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceSurfaceCapabilities2EXT"); if proc == null() {dummy_vkGetPhysicalDeviceSurfaceCapabilities2EXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDisplayPowerStateEXT {
	VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
	VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
	VK_DISPLAY_POWER_STATE_ON_EXT = 2,
	VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceEventTypeEXT {
	VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,
	VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDisplayEventTypeEXT {
	VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,
	VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplayPowerInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub powerState: VkDisplayPowerStateEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceEventInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub deviceEvent: VkDeviceEventTypeEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplayEventInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub displayEvent: VkDisplayEventTypeEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSwapchainCounterCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub surfaceCounters: VkSurfaceCounterFlagsEXT,
}
type PFN_vkDisplayPowerControlEXT = extern "system" fn(device: VkDevice, display: VkDisplayKHR, pDisplayPowerInfo: *const VkDisplayPowerInfoEXT) -> VkResult;
type PFN_vkRegisterDeviceEventEXT = extern "system" fn(device: VkDevice, pDeviceEventInfo: *const VkDeviceEventInfoEXT, pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence) -> VkResult;
type PFN_vkRegisterDisplayEventEXT = extern "system" fn(device: VkDevice, display: VkDisplayKHR, pDisplayEventInfo: *const VkDisplayEventInfoEXT, pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence) -> VkResult;
type PFN_vkGetSwapchainCounterEXT = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, counter: VkSurfaceCounterFlagBitsEXT, pCounterValue: *mut uint64_t) -> VkResult;
extern "system" fn dummy_vkDisplayPowerControlEXT(_: VkDevice, _: VkDisplayKHR, _: *const VkDisplayPowerInfoEXT) -> VkResult {
	panic!("Vulkan function pointer of `vkDisplayPowerControlEXT()` is NULL");
}
pub trait VK_EXT_display_control: Debug {
	fn vkDisplayPowerControlEXT(&self, device: VkDevice, display: VkDisplayKHR, pDisplayPowerInfo: *const VkDisplayPowerInfoEXT) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_display_control {
	vk_display_power_control_ext: PFN_vkDisplayPowerControlEXT,
}
impl VK_EXT_display_control for Vulkan_EXT_display_control {
	fn vkDisplayPowerControlEXT(&self, device: VkDevice, display: VkDisplayKHR, pDisplayPowerInfo: *const VkDisplayPowerInfoEXT) -> VkResult {
		(self.vk_display_power_control_ext)(device, display, pDisplayPowerInfo)
	}
}
impl Default for Vulkan_EXT_display_control {
	fn default() -> Self {
		Self {
			vk_display_power_control_ext: dummy_vkDisplayPowerControlEXT,
		}
	}
}
impl Vulkan_EXT_display_control {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_display_power_control_ext: {let proc = get_proc_address(instance, "vkDisplayPowerControlEXT"); if proc == null() {dummy_vkDisplayPowerControlEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRefreshCycleDurationGOOGLE {
	pub refreshDuration: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPastPresentationTimingGOOGLE {
	pub presentID: u32,
	pub desiredPresentTime: u64,
	pub actualPresentTime: u64,
	pub earliestPresentTime: u64,
	pub presentMargin: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPresentTimeGOOGLE {
	pub presentID: u32,
	pub desiredPresentTime: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPresentTimesInfoGOOGLE {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount: u32,
	pub pTimes: *const VkPresentTimeGOOGLE,
}
type PFN_vkGetRefreshCycleDurationGOOGLE = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pDisplayTimingProperties: *mut VkRefreshCycleDurationGOOGLE) -> VkResult;
type PFN_vkGetPastPresentationTimingGOOGLE = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pPresentationTimingCount: *mut uint32_t, pPresentationTimings: *mut VkPastPresentationTimingGOOGLE) -> VkResult;
extern "system" fn dummy_vkGetRefreshCycleDurationGOOGLE(_: VkDevice, _: VkSwapchainKHR, _: *mut VkRefreshCycleDurationGOOGLE) -> VkResult {
	panic!("Vulkan function pointer of `vkGetRefreshCycleDurationGOOGLE()` is NULL");
}
pub trait VK_GOOGLE_display_timing: Debug {
	fn vkGetRefreshCycleDurationGOOGLE(&self, device: VkDevice, swapchain: VkSwapchainKHR, pDisplayTimingProperties: *mut VkRefreshCycleDurationGOOGLE) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_GOOGLE_display_timing {
	vk_get_refresh_cycle_duration_google: PFN_vkGetRefreshCycleDurationGOOGLE,
}
impl VK_GOOGLE_display_timing for Vulkan_GOOGLE_display_timing {
	fn vkGetRefreshCycleDurationGOOGLE(&self, device: VkDevice, swapchain: VkSwapchainKHR, pDisplayTimingProperties: *mut VkRefreshCycleDurationGOOGLE) -> VkResult {
		(self.vk_get_refresh_cycle_duration_google)(device, swapchain, pDisplayTimingProperties)
	}
}
impl Default for Vulkan_GOOGLE_display_timing {
	fn default() -> Self {
		Self {
			vk_get_refresh_cycle_duration_google: dummy_vkGetRefreshCycleDurationGOOGLE,
		}
	}
}
impl Vulkan_GOOGLE_display_timing {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_refresh_cycle_duration_google: {let proc = get_proc_address(instance, "vkGetRefreshCycleDurationGOOGLE"); if proc == null() {dummy_vkGetRefreshCycleDurationGOOGLE} else {unsafe {transmute(proc)}}},
		}
	}
}
pub trait VK_NV_sample_mask_override_coverage: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_sample_mask_override_coverage {}
impl VK_NV_sample_mask_override_coverage for Vulkan_NV_sample_mask_override_coverage {}
impl Default for Vulkan_NV_sample_mask_override_coverage {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_sample_mask_override_coverage {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_NV_geometry_shader_passthrough: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_geometry_shader_passthrough {}
impl VK_NV_geometry_shader_passthrough for Vulkan_NV_geometry_shader_passthrough {}
impl Default for Vulkan_NV_geometry_shader_passthrough {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_geometry_shader_passthrough {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_NV_viewport_array2: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_viewport_array2 {}
impl VK_NV_viewport_array2 for Vulkan_NV_viewport_array2 {}
impl Default for Vulkan_NV_viewport_array2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_viewport_array2 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub perViewPositionAllComponents: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMultiviewPerViewAttributesInfoNVX {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub perViewAttributes: VkBool32,
	pub perViewAttributesPositionXOnly: VkBool32,
}
pub trait VK_NVX_multiview_per_view_attributes: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NVX_multiview_per_view_attributes {}
impl VK_NVX_multiview_per_view_attributes for Vulkan_NVX_multiview_per_view_attributes {}
impl Default for Vulkan_NVX_multiview_per_view_attributes {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NVX_multiview_per_view_attributes {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPipelineViewportSwizzleStateCreateFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkViewportCoordinateSwizzleNV {
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7,
	VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkViewportSwizzleNV {
	pub x: VkViewportCoordinateSwizzleNV,
	pub y: VkViewportCoordinateSwizzleNV,
	pub z: VkViewportCoordinateSwizzleNV,
	pub w: VkViewportCoordinateSwizzleNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineViewportSwizzleStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineViewportSwizzleStateCreateFlagsNV,
	pub viewportCount: u32,
	pub pViewportSwizzles: *const VkViewportSwizzleNV,
}
pub trait VK_NV_viewport_swizzle: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_viewport_swizzle {}
impl VK_NV_viewport_swizzle for Vulkan_NV_viewport_swizzle {}
impl Default for Vulkan_NV_viewport_swizzle {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_viewport_swizzle {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPipelineDiscardRectangleStateCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDiscardRectangleModeEXT {
	VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
	VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,
	VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDiscardRectanglePropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxDiscardRectangles: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineDiscardRectangleStateCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineDiscardRectangleStateCreateFlagsEXT,
	pub discardRectangleMode: VkDiscardRectangleModeEXT,
	pub discardRectangleCount: u32,
	pub pDiscardRectangles: *const VkRect2D,
}
type PFN_vkCmdSetDiscardRectangleEXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstDiscardRectangle: u32, discardRectangleCount: u32, pDiscardRectangles: *const VkRect2D);
type PFN_vkCmdSetDiscardRectangleEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, discardRectangleEnable: VkBool32);
type PFN_vkCmdSetDiscardRectangleModeEXT = extern "system" fn(commandBuffer: VkCommandBuffer, discardRectangleMode: VkDiscardRectangleModeEXT);
extern "system" fn dummy_vkCmdSetDiscardRectangleEXT(_: VkCommandBuffer, _: u32, _: u32, _: *const VkRect2D) {
	panic!("Vulkan function pointer of `vkCmdSetDiscardRectangleEXT()` is NULL");
}
pub trait VK_EXT_discard_rectangles: Debug {
	fn vkCmdSetDiscardRectangleEXT(&self, commandBuffer: VkCommandBuffer, firstDiscardRectangle: u32, discardRectangleCount: u32, pDiscardRectangles: *const VkRect2D);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_discard_rectangles {
	vk_cmd_set_discard_rectangle_ext: PFN_vkCmdSetDiscardRectangleEXT,
}
impl VK_EXT_discard_rectangles for Vulkan_EXT_discard_rectangles {
	fn vkCmdSetDiscardRectangleEXT(&self, commandBuffer: VkCommandBuffer, firstDiscardRectangle: u32, discardRectangleCount: u32, pDiscardRectangles: *const VkRect2D) {
		(self.vk_cmd_set_discard_rectangle_ext)(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles)
	}
}
impl Default for Vulkan_EXT_discard_rectangles {
	fn default() -> Self {
		Self {
			vk_cmd_set_discard_rectangle_ext: dummy_vkCmdSetDiscardRectangleEXT,
		}
	}
}
impl Vulkan_EXT_discard_rectangles {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_discard_rectangle_ext: {let proc = get_proc_address(instance, "vkCmdSetDiscardRectangleEXT"); if proc == null() {dummy_vkCmdSetDiscardRectangleEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPipelineRasterizationConservativeStateCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkConservativeRasterizationModeEXT {
	VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0,
	VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1,
	VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2,
	VK_CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub primitiveOverestimationSize: f32,
	pub maxExtraPrimitiveOverestimationSize: f32,
	pub extraPrimitiveOverestimationSizeGranularity: f32,
	pub primitiveUnderestimation: VkBool32,
	pub conservativePointAndLineRasterization: VkBool32,
	pub degenerateTrianglesRasterized: VkBool32,
	pub degenerateLinesRasterized: VkBool32,
	pub fullyCoveredFragmentShaderInputVariable: VkBool32,
	pub conservativeRasterizationPostDepthCoverage: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineRasterizationConservativeStateCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineRasterizationConservativeStateCreateFlagsEXT,
	pub conservativeRasterizationMode: VkConservativeRasterizationModeEXT,
	pub extraPrimitiveOverestimationSize: f32,
}
pub trait VK_EXT_conservative_rasterization: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_conservative_rasterization {}
impl VK_EXT_conservative_rasterization for Vulkan_EXT_conservative_rasterization {}
impl Default for Vulkan_EXT_conservative_rasterization {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_conservative_rasterization {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPipelineRasterizationDepthClipStateCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDepthClipEnableFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub depthClipEnable: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineRasterizationDepthClipStateCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineRasterizationDepthClipStateCreateFlagsEXT,
	pub depthClipEnable: VkBool32,
}
pub trait VK_EXT_depth_clip_enable: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_depth_clip_enable {}
impl VK_EXT_depth_clip_enable for Vulkan_EXT_depth_clip_enable {}
impl Default for Vulkan_EXT_depth_clip_enable {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_depth_clip_enable {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_EXT_swapchain_colorspace: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_swapchain_colorspace {}
impl VK_EXT_swapchain_colorspace for Vulkan_EXT_swapchain_colorspace {}
impl Default for Vulkan_EXT_swapchain_colorspace {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_swapchain_colorspace {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkXYColorEXT {
	pub x: f32,
	pub y: f32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkHdrMetadataEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub displayPrimaryRed: VkXYColorEXT,
	pub displayPrimaryGreen: VkXYColorEXT,
	pub displayPrimaryBlue: VkXYColorEXT,
	pub whitePoint: VkXYColorEXT,
	pub maxLuminance: f32,
	pub minLuminance: f32,
	pub maxContentLightLevel: f32,
	pub maxFrameAverageLightLevel: f32,
}
type PFN_vkSetHdrMetadataEXT = extern "system" fn(device: VkDevice, swapchainCount: u32, pSwapchains: *const VkSwapchainKHR, pMetadata: *const VkHdrMetadataEXT);
extern "system" fn dummy_vkSetHdrMetadataEXT(_: VkDevice, _: u32, _: *const VkSwapchainKHR, _: *const VkHdrMetadataEXT) {
	panic!("Vulkan function pointer of `vkSetHdrMetadataEXT()` is NULL");
}
pub trait VK_EXT_hdr_metadata: Debug {
	fn vkSetHdrMetadataEXT(&self, device: VkDevice, swapchainCount: u32, pSwapchains: *const VkSwapchainKHR, pMetadata: *const VkHdrMetadataEXT);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_hdr_metadata {
	vk_set_hdr_metadata_ext: PFN_vkSetHdrMetadataEXT,
}
impl VK_EXT_hdr_metadata for Vulkan_EXT_hdr_metadata {
	fn vkSetHdrMetadataEXT(&self, device: VkDevice, swapchainCount: u32, pSwapchains: *const VkSwapchainKHR, pMetadata: *const VkHdrMetadataEXT) {
		(self.vk_set_hdr_metadata_ext)(device, swapchainCount, pSwapchains, pMetadata)
	}
}
impl Default for Vulkan_EXT_hdr_metadata {
	fn default() -> Self {
		Self {
			vk_set_hdr_metadata_ext: dummy_vkSetHdrMetadataEXT,
		}
	}
}
impl Vulkan_EXT_hdr_metadata {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_set_hdr_metadata_ext: {let proc = get_proc_address(instance, "vkSetHdrMetadataEXT"); if proc == null() {dummy_vkSetHdrMetadataEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub relaxedLineRasterization: VkBool32,
}
pub trait VK_IMG_relaxed_line_rasterization: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_IMG_relaxed_line_rasterization {}
impl VK_IMG_relaxed_line_rasterization for Vulkan_IMG_relaxed_line_rasterization {}
impl Default for Vulkan_IMG_relaxed_line_rasterization {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_IMG_relaxed_line_rasterization {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_EXT_external_memory_dma_buf: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_external_memory_dma_buf {}
impl VK_EXT_external_memory_dma_buf for Vulkan_EXT_external_memory_dma_buf {}
impl Default for Vulkan_EXT_external_memory_dma_buf {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_external_memory_dma_buf {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const VK_QUEUE_FAMILY_FOREIGN_EXT: u32 = !2u32;
pub trait VK_EXT_queue_family_foreign: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_queue_family_foreign {}
impl VK_EXT_queue_family_foreign for Vulkan_EXT_queue_family_foreign {}
impl Default for Vulkan_EXT_queue_family_foreign {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_queue_family_foreign {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkDebugUtilsMessengerCallbackDataFlagsEXT = VkFlags;
pub type VkDebugUtilsMessageTypeFlagsEXT = VkFlags;
pub type VkDebugUtilsMessageSeverityFlagsEXT = VkFlags;
pub type VkDebugUtilsMessengerCreateFlagsEXT = VkFlags;
// Define non-dispatchable handle `VkDebugUtilsMessengerEXT`
#[cfg(target_pointer_width = "32")] pub type VkDebugUtilsMessengerEXT = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkDebugUtilsMessengerEXT_T {}
#[cfg(target_pointer_width = "64")] pub type VkDebugUtilsMessengerEXT = *const VkDebugUtilsMessengerEXT_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDebugUtilsMessageSeverityFlagBitsEXT {
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 0x00000001,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 0x00000010,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 0x00000100,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 0x00001000,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDebugUtilsMessageTypeFlagBitsEXT {
	VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 0x00000001,
	VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 0x00000002,
	VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 0x00000004,
	VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT = 0x00000008,
	VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDebugUtilsLabelEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pLabelName: *const i8,
	pub color: [f32; 4 as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDebugUtilsObjectNameInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub objectType: VkObjectType,
	pub objectHandle: u64,
	pub pObjectName: *const i8,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDebugUtilsMessengerCallbackDataEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDebugUtilsMessengerCallbackDataFlagsEXT,
	pub pMessageIdName: *const i8,
	pub messageIdNumber: i32,
	pub pMessage: *const i8,
	pub queueLabelCount: u32,
	pub pQueueLabels: *const VkDebugUtilsLabelEXT,
	pub cmdBufLabelCount: u32,
	pub pCmdBufLabels: *const VkDebugUtilsLabelEXT,
	pub objectCount: u32,
	pub pObjects: *const VkDebugUtilsObjectNameInfoEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDebugUtilsMessengerCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDebugUtilsMessengerCreateFlagsEXT,
	pub messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT,
	pub messageType: VkDebugUtilsMessageTypeFlagsEXT,
	pub pfnUserCallback: PFN_vkDebugUtilsMessengerCallbackEXT,
	pub pUserData: *mut c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDebugUtilsObjectTagInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub objectType: VkObjectType,
	pub objectHandle: u64,
	pub tagName: u64,
	pub tagSize: usize,
	pub pTag: *const c_void,
}
type PFN_vkDebugUtilsMessengerCallbackEXT = extern "system" fn(messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT, messageTypes: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: *const VkDebugUtilsMessengerCallbackDataEXT, pUserData: *mut c_void) -> VkBool32;
type PFN_vkSetDebugUtilsObjectNameEXT = extern "system" fn(device: VkDevice, pNameInfo: *const VkDebugUtilsObjectNameInfoEXT) -> VkResult;
type PFN_vkSetDebugUtilsObjectTagEXT = extern "system" fn(device: VkDevice, pTagInfo: *const VkDebugUtilsObjectTagInfoEXT) -> VkResult;
type PFN_vkQueueBeginDebugUtilsLabelEXT = extern "system" fn(queue: VkQueue, pLabelInfo: *const VkDebugUtilsLabelEXT);
type PFN_vkQueueEndDebugUtilsLabelEXT = extern "system" fn(queue: VkQueue);
type PFN_vkQueueInsertDebugUtilsLabelEXT = extern "system" fn(queue: VkQueue, pLabelInfo: *const VkDebugUtilsLabelEXT);
type PFN_vkCmdBeginDebugUtilsLabelEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pLabelInfo: *const VkDebugUtilsLabelEXT);
type PFN_vkCmdEndDebugUtilsLabelEXT = extern "system" fn(commandBuffer: VkCommandBuffer);
type PFN_vkCmdInsertDebugUtilsLabelEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pLabelInfo: *const VkDebugUtilsLabelEXT);
type PFN_vkCreateDebugUtilsMessengerEXT = extern "system" fn(instance: VkInstance, pCreateInfo: *const VkDebugUtilsMessengerCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pMessenger: *mut VkDebugUtilsMessengerEXT) -> VkResult;
type PFN_vkDestroyDebugUtilsMessengerEXT = extern "system" fn(instance: VkInstance, messenger: VkDebugUtilsMessengerEXT, pAllocator: *const VkAllocationCallbacks);
type PFN_vkSubmitDebugUtilsMessageEXT = extern "system" fn(instance: VkInstance, messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT, messageTypes: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: *const VkDebugUtilsMessengerCallbackDataEXT);
extern "system" fn dummy_vkSetDebugUtilsObjectNameEXT(_: VkDevice, _: *const VkDebugUtilsObjectNameInfoEXT) -> VkResult {
	panic!("Vulkan function pointer of `vkSetDebugUtilsObjectNameEXT()` is NULL");
}
pub trait VK_EXT_debug_utils: Debug {
	fn vkSetDebugUtilsObjectNameEXT(&self, device: VkDevice, pNameInfo: *const VkDebugUtilsObjectNameInfoEXT) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_debug_utils {
	vk_set_debug_utils_object_name_ext: PFN_vkSetDebugUtilsObjectNameEXT,
}
impl VK_EXT_debug_utils for Vulkan_EXT_debug_utils {
	fn vkSetDebugUtilsObjectNameEXT(&self, device: VkDevice, pNameInfo: *const VkDebugUtilsObjectNameInfoEXT) -> VkResult {
		(self.vk_set_debug_utils_object_name_ext)(device, pNameInfo)
	}
}
impl Default for Vulkan_EXT_debug_utils {
	fn default() -> Self {
		Self {
			vk_set_debug_utils_object_name_ext: dummy_vkSetDebugUtilsObjectNameEXT,
		}
	}
}
impl Vulkan_EXT_debug_utils {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_set_debug_utils_object_name_ext: {let proc = get_proc_address(instance, "vkSetDebugUtilsObjectNameEXT"); if proc == null() {dummy_vkSetDebugUtilsObjectNameEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkSamplerReductionModeEXT = VkSamplerReductionMode;
pub type VkSamplerReductionModeCreateInfoEXT = VkSamplerReductionModeCreateInfo;
pub type VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT = VkPhysicalDeviceSamplerFilterMinmaxProperties;
pub trait VK_EXT_sampler_filter_minmax: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_sampler_filter_minmax {}
impl VK_EXT_sampler_filter_minmax for Vulkan_EXT_sampler_filter_minmax {}
impl Default for Vulkan_EXT_sampler_filter_minmax {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_sampler_filter_minmax {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_AMD_gpu_shader_int16: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_gpu_shader_int16 {}
impl VK_AMD_gpu_shader_int16 for Vulkan_AMD_gpu_shader_int16 {}
impl Default for Vulkan_AMD_gpu_shader_int16 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_gpu_shader_int16 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAttachmentSampleCountInfoAMD {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub colorAttachmentCount: u32,
	pub pColorAttachmentSamples: *const VkSampleCountFlagBits,
	pub depthStencilAttachmentSamples: VkSampleCountFlagBits,
}
pub trait VK_AMD_mixed_attachment_samples: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_mixed_attachment_samples {}
impl VK_AMD_mixed_attachment_samples for Vulkan_AMD_mixed_attachment_samples {}
impl Default for Vulkan_AMD_mixed_attachment_samples {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_mixed_attachment_samples {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_AMD_shader_fragment_mask: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_fragment_mask {}
impl VK_AMD_shader_fragment_mask for Vulkan_AMD_shader_fragment_mask {}
impl Default for Vulkan_AMD_shader_fragment_mask {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_shader_fragment_mask {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceInlineUniformBlockFeaturesEXT = VkPhysicalDeviceInlineUniformBlockFeatures;
pub type VkPhysicalDeviceInlineUniformBlockPropertiesEXT = VkPhysicalDeviceInlineUniformBlockProperties;
pub type VkWriteDescriptorSetInlineUniformBlockEXT = VkWriteDescriptorSetInlineUniformBlock;
pub type VkDescriptorPoolInlineUniformBlockCreateInfoEXT = VkDescriptorPoolInlineUniformBlockCreateInfo;
pub trait VK_EXT_inline_uniform_block: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_inline_uniform_block {}
impl VK_EXT_inline_uniform_block for Vulkan_EXT_inline_uniform_block {}
impl Default for Vulkan_EXT_inline_uniform_block {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_inline_uniform_block {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_EXT_shader_stencil_export: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_stencil_export {}
impl VK_EXT_shader_stencil_export for Vulkan_EXT_shader_stencil_export {}
impl Default for Vulkan_EXT_shader_stencil_export {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_stencil_export {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSampleLocationEXT {
	pub x: f32,
	pub y: f32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSampleLocationsInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub sampleLocationsPerPixel: VkSampleCountFlagBits,
	pub sampleLocationGridSize: VkExtent2D,
	pub sampleLocationsCount: u32,
	pub pSampleLocations: *const VkSampleLocationEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAttachmentSampleLocationsEXT {
	pub attachmentIndex: u32,
	pub sampleLocationsInfo: VkSampleLocationsInfoEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSubpassSampleLocationsEXT {
	pub subpassIndex: u32,
	pub sampleLocationsInfo: VkSampleLocationsInfoEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassSampleLocationsBeginInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub attachmentInitialSampleLocationsCount: u32,
	pub pAttachmentInitialSampleLocations: *const VkAttachmentSampleLocationsEXT,
	pub postSubpassSampleLocationsCount: u32,
	pub pPostSubpassSampleLocations: *const VkSubpassSampleLocationsEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineSampleLocationsStateCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub sampleLocationsEnable: VkBool32,
	pub sampleLocationsInfo: VkSampleLocationsInfoEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSampleLocationsPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub sampleLocationSampleCounts: VkSampleCountFlags,
	pub maxSampleLocationGridSize: VkExtent2D,
	pub sampleLocationCoordinateRange: [f32; 2 as usize],
	pub sampleLocationSubPixelBits: u32,
	pub variableSampleLocations: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMultisamplePropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxSampleLocationGridSize: VkExtent2D,
}
type PFN_vkCmdSetSampleLocationsEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pSampleLocationsInfo: *const VkSampleLocationsInfoEXT);
type PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT = extern "system" fn(physicalDevice: VkPhysicalDevice, samples: VkSampleCountFlagBits, pMultisampleProperties: *mut VkMultisamplePropertiesEXT);
extern "system" fn dummy_vkCmdSetSampleLocationsEXT(_: VkCommandBuffer, _: *const VkSampleLocationsInfoEXT) {
	panic!("Vulkan function pointer of `vkCmdSetSampleLocationsEXT()` is NULL");
}
pub trait VK_EXT_sample_locations: Debug {
	fn vkCmdSetSampleLocationsEXT(&self, commandBuffer: VkCommandBuffer, pSampleLocationsInfo: *const VkSampleLocationsInfoEXT);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_sample_locations {
	vk_cmd_set_sample_locations_ext: PFN_vkCmdSetSampleLocationsEXT,
}
impl VK_EXT_sample_locations for Vulkan_EXT_sample_locations {
	fn vkCmdSetSampleLocationsEXT(&self, commandBuffer: VkCommandBuffer, pSampleLocationsInfo: *const VkSampleLocationsInfoEXT) {
		(self.vk_cmd_set_sample_locations_ext)(commandBuffer, pSampleLocationsInfo)
	}
}
impl Default for Vulkan_EXT_sample_locations {
	fn default() -> Self {
		Self {
			vk_cmd_set_sample_locations_ext: dummy_vkCmdSetSampleLocationsEXT,
		}
	}
}
impl Vulkan_EXT_sample_locations {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_sample_locations_ext: {let proc = get_proc_address(instance, "vkCmdSetSampleLocationsEXT"); if proc == null() {dummy_vkCmdSetSampleLocationsEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBlendOverlapEXT {
	VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0,
	VK_BLEND_OVERLAP_DISJOINT_EXT = 1,
	VK_BLEND_OVERLAP_CONJOINT_EXT = 2,
	VK_BLEND_OVERLAP_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub advancedBlendCoherentOperations: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub advancedBlendMaxColorAttachments: u32,
	pub advancedBlendIndependentBlend: VkBool32,
	pub advancedBlendNonPremultipliedSrcColor: VkBool32,
	pub advancedBlendNonPremultipliedDstColor: VkBool32,
	pub advancedBlendCorrelatedOverlap: VkBool32,
	pub advancedBlendAllOperations: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineColorBlendAdvancedStateCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcPremultiplied: VkBool32,
	pub dstPremultiplied: VkBool32,
	pub blendOverlap: VkBlendOverlapEXT,
}
pub trait VK_EXT_blend_operation_advanced: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_blend_operation_advanced {}
impl VK_EXT_blend_operation_advanced for Vulkan_EXT_blend_operation_advanced {}
impl Default for Vulkan_EXT_blend_operation_advanced {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_blend_operation_advanced {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPipelineCoverageToColorStateCreateFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineCoverageToColorStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCoverageToColorStateCreateFlagsNV,
	pub coverageToColorEnable: VkBool32,
	pub coverageToColorLocation: u32,
}
pub trait VK_NV_fragment_coverage_to_color: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_fragment_coverage_to_color {}
impl VK_NV_fragment_coverage_to_color for Vulkan_NV_fragment_coverage_to_color {}
impl Default for Vulkan_NV_fragment_coverage_to_color {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_fragment_coverage_to_color {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPipelineCoverageModulationStateCreateFlagsNV = VkFlags;
pub type VkAttachmentSampleCountInfoNV = VkAttachmentSampleCountInfoAMD;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCoverageModulationModeNV {
	VK_COVERAGE_MODULATION_MODE_NONE_NV = 0,
	VK_COVERAGE_MODULATION_MODE_RGB_NV = 1,
	VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 2,
	VK_COVERAGE_MODULATION_MODE_RGBA_NV = 3,
	VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineCoverageModulationStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCoverageModulationStateCreateFlagsNV,
	pub coverageModulationMode: VkCoverageModulationModeNV,
	pub coverageModulationTableEnable: VkBool32,
	pub coverageModulationTableCount: u32,
	pub pCoverageModulationTable: *const float,
}
pub trait VK_NV_framebuffer_mixed_samples: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_framebuffer_mixed_samples {}
impl VK_NV_framebuffer_mixed_samples for Vulkan_NV_framebuffer_mixed_samples {}
impl Default for Vulkan_NV_framebuffer_mixed_samples {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_framebuffer_mixed_samples {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_NV_fill_rectangle: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_fill_rectangle {}
impl VK_NV_fill_rectangle for Vulkan_NV_fill_rectangle {}
impl Default for Vulkan_NV_fill_rectangle {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_fill_rectangle {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderSMBuiltinsPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderSMCount: u32,
	pub shaderWarpsPerSM: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderSMBuiltinsFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderSMBuiltins: VkBool32,
}
pub trait VK_NV_shader_sm_builtins: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_shader_sm_builtins {}
impl VK_NV_shader_sm_builtins for Vulkan_NV_shader_sm_builtins {}
impl Default for Vulkan_NV_shader_sm_builtins {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_shader_sm_builtins {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_EXT_post_depth_coverage: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_post_depth_coverage {}
impl VK_EXT_post_depth_coverage for Vulkan_EXT_post_depth_coverage {}
impl Default for Vulkan_EXT_post_depth_coverage {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_post_depth_coverage {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDrmFormatModifierPropertiesEXT {
	pub drmFormatModifier: u64,
	pub drmFormatModifierPlaneCount: u32,
	pub drmFormatModifierTilingFeatures: VkFormatFeatureFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDrmFormatModifierPropertiesListEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub drmFormatModifierCount: u32,
	pub pDrmFormatModifierProperties: *mut VkDrmFormatModifierPropertiesEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub drmFormatModifier: u64,
	pub sharingMode: VkSharingMode,
	pub queueFamilyIndexCount: u32,
	pub pQueueFamilyIndices: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageDrmFormatModifierListCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub drmFormatModifierCount: u32,
	pub pDrmFormatModifiers: *const uint64_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageDrmFormatModifierExplicitCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub drmFormatModifier: u64,
	pub drmFormatModifierPlaneCount: u32,
	pub pPlaneLayouts: *const VkSubresourceLayout,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageDrmFormatModifierPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub drmFormatModifier: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDrmFormatModifierProperties2EXT {
	pub drmFormatModifier: u64,
	pub drmFormatModifierPlaneCount: u32,
	pub drmFormatModifierTilingFeatures: VkFormatFeatureFlags2,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDrmFormatModifierPropertiesList2EXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub drmFormatModifierCount: u32,
	pub pDrmFormatModifierProperties: *mut VkDrmFormatModifierProperties2EXT,
}
type PFN_vkGetImageDrmFormatModifierPropertiesEXT = extern "system" fn(device: VkDevice, image: VkImage, pProperties: *mut VkImageDrmFormatModifierPropertiesEXT) -> VkResult;
extern "system" fn dummy_vkGetImageDrmFormatModifierPropertiesEXT(_: VkDevice, _: VkImage, _: *mut VkImageDrmFormatModifierPropertiesEXT) -> VkResult {
	panic!("Vulkan function pointer of `vkGetImageDrmFormatModifierPropertiesEXT()` is NULL");
}
pub trait VK_EXT_image_drm_format_modifier: Debug {
	fn vkGetImageDrmFormatModifierPropertiesEXT(&self, device: VkDevice, image: VkImage, pProperties: *mut VkImageDrmFormatModifierPropertiesEXT) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_image_drm_format_modifier {
	vk_get_image_drm_format_modifier_properties_ext: PFN_vkGetImageDrmFormatModifierPropertiesEXT,
}
impl VK_EXT_image_drm_format_modifier for Vulkan_EXT_image_drm_format_modifier {
	fn vkGetImageDrmFormatModifierPropertiesEXT(&self, device: VkDevice, image: VkImage, pProperties: *mut VkImageDrmFormatModifierPropertiesEXT) -> VkResult {
		(self.vk_get_image_drm_format_modifier_properties_ext)(device, image, pProperties)
	}
}
impl Default for Vulkan_EXT_image_drm_format_modifier {
	fn default() -> Self {
		Self {
			vk_get_image_drm_format_modifier_properties_ext: dummy_vkGetImageDrmFormatModifierPropertiesEXT,
		}
	}
}
impl Vulkan_EXT_image_drm_format_modifier {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_image_drm_format_modifier_properties_ext: {let proc = get_proc_address(instance, "vkGetImageDrmFormatModifierPropertiesEXT"); if proc == null() {dummy_vkGetImageDrmFormatModifierPropertiesEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkValidationCacheCreateFlagsEXT = VkFlags;
// Define non-dispatchable handle `VkValidationCacheEXT`
#[cfg(target_pointer_width = "32")] pub type VkValidationCacheEXT = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkValidationCacheEXT_T {}
#[cfg(target_pointer_width = "64")] pub type VkValidationCacheEXT = *const VkValidationCacheEXT_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkValidationCacheHeaderVersionEXT {
	VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1,
	VK_VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkValidationCacheCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkValidationCacheCreateFlagsEXT,
	pub initialDataSize: usize,
	pub pInitialData: *const c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkShaderModuleValidationCacheCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub validationCache: VkValidationCacheEXT,
}
type PFN_vkCreateValidationCacheEXT = extern "system" fn(device: VkDevice, pCreateInfo: *const VkValidationCacheCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pValidationCache: *mut VkValidationCacheEXT) -> VkResult;
type PFN_vkDestroyValidationCacheEXT = extern "system" fn(device: VkDevice, validationCache: VkValidationCacheEXT, pAllocator: *const VkAllocationCallbacks);
type PFN_vkMergeValidationCachesEXT = extern "system" fn(device: VkDevice, dstCache: VkValidationCacheEXT, srcCacheCount: u32, pSrcCaches: *const VkValidationCacheEXT) -> VkResult;
type PFN_vkGetValidationCacheDataEXT = extern "system" fn(device: VkDevice, validationCache: VkValidationCacheEXT, pDataSize: *mut size_t, pData: *mut c_void) -> VkResult;
extern "system" fn dummy_vkCreateValidationCacheEXT(_: VkDevice, _: *const VkValidationCacheCreateInfoEXT, _: *const VkAllocationCallbacks, _: *mut VkValidationCacheEXT) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateValidationCacheEXT()` is NULL");
}
pub trait VK_EXT_validation_cache: Debug {
	fn vkCreateValidationCacheEXT(&self, device: VkDevice, pCreateInfo: *const VkValidationCacheCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pValidationCache: *mut VkValidationCacheEXT) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_validation_cache {
	vk_create_validation_cache_ext: PFN_vkCreateValidationCacheEXT,
}
impl VK_EXT_validation_cache for Vulkan_EXT_validation_cache {
	fn vkCreateValidationCacheEXT(&self, device: VkDevice, pCreateInfo: *const VkValidationCacheCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pValidationCache: *mut VkValidationCacheEXT) -> VkResult {
		(self.vk_create_validation_cache_ext)(device, pCreateInfo, pAllocator, pValidationCache)
	}
}
impl Default for Vulkan_EXT_validation_cache {
	fn default() -> Self {
		Self {
			vk_create_validation_cache_ext: dummy_vkCreateValidationCacheEXT,
		}
	}
}
impl Vulkan_EXT_validation_cache {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_validation_cache_ext: {let proc = get_proc_address(instance, "vkCreateValidationCacheEXT"); if proc == null() {dummy_vkCreateValidationCacheEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkDescriptorBindingFlagBitsEXT = VkDescriptorBindingFlagBits;
pub type VkDescriptorBindingFlagsEXT = VkDescriptorBindingFlags;
pub type VkDescriptorSetLayoutBindingFlagsCreateInfoEXT = VkDescriptorSetLayoutBindingFlagsCreateInfo;
pub type VkPhysicalDeviceDescriptorIndexingFeaturesEXT = VkPhysicalDeviceDescriptorIndexingFeatures;
pub type VkPhysicalDeviceDescriptorIndexingPropertiesEXT = VkPhysicalDeviceDescriptorIndexingProperties;
pub type VkDescriptorSetVariableDescriptorCountAllocateInfoEXT = VkDescriptorSetVariableDescriptorCountAllocateInfo;
pub type VkDescriptorSetVariableDescriptorCountLayoutSupportEXT = VkDescriptorSetVariableDescriptorCountLayoutSupport;
pub trait VK_EXT_descriptor_indexing: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_descriptor_indexing {}
impl VK_EXT_descriptor_indexing for Vulkan_EXT_descriptor_indexing {}
impl Default for Vulkan_EXT_descriptor_indexing {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_descriptor_indexing {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_EXT_shader_viewport_index_layer: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_viewport_index_layer {}
impl VK_EXT_shader_viewport_index_layer for Vulkan_EXT_shader_viewport_index_layer {}
impl Default for Vulkan_EXT_shader_viewport_index_layer {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_viewport_index_layer {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkShadingRatePaletteEntryNV {
	VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0,
	VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 1,
	VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 2,
	VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 3,
	VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 4,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 5,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 6,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 7,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 8,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 10,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 11,
	VK_SHADING_RATE_PALETTE_ENTRY_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCoarseSampleOrderTypeNV {
	VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0,
	VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 1,
	VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 2,
	VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 3,
	VK_COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkShadingRatePaletteNV {
	pub shadingRatePaletteEntryCount: u32,
	pub pShadingRatePaletteEntries: *const VkShadingRatePaletteEntryNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineViewportShadingRateImageStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub shadingRateImageEnable: VkBool32,
	pub viewportCount: u32,
	pub pShadingRatePalettes: *const VkShadingRatePaletteNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShadingRateImageFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shadingRateImage: VkBool32,
	pub shadingRateCoarseSampleOrder: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShadingRateImagePropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shadingRateTexelSize: VkExtent2D,
	pub shadingRatePaletteSize: u32,
	pub shadingRateMaxCoarseSamples: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCoarseSampleLocationNV {
	pub pixelX: u32,
	pub pixelY: u32,
	pub sample: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCoarseSampleOrderCustomNV {
	pub shadingRate: VkShadingRatePaletteEntryNV,
	pub sampleCount: u32,
	pub sampleLocationCount: u32,
	pub pSampleLocations: *const VkCoarseSampleLocationNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub sampleOrderType: VkCoarseSampleOrderTypeNV,
	pub customSampleOrderCount: u32,
	pub pCustomSampleOrders: *const VkCoarseSampleOrderCustomNV,
}
type PFN_vkCmdBindShadingRateImageNV = extern "system" fn(commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout);
type PFN_vkCmdSetViewportShadingRatePaletteNV = extern "system" fn(commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pShadingRatePalettes: *const VkShadingRatePaletteNV);
type PFN_vkCmdSetCoarseSampleOrderNV = extern "system" fn(commandBuffer: VkCommandBuffer, sampleOrderType: VkCoarseSampleOrderTypeNV, customSampleOrderCount: u32, pCustomSampleOrders: *const VkCoarseSampleOrderCustomNV);
extern "system" fn dummy_vkCmdBindShadingRateImageNV(_: VkCommandBuffer, _: VkImageView, _: VkImageLayout) {
	panic!("Vulkan function pointer of `vkCmdBindShadingRateImageNV()` is NULL");
}
pub trait VK_NV_shading_rate_image: Debug {
	fn vkCmdBindShadingRateImageNV(&self, commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_shading_rate_image {
	vk_cmd_bind_shading_rate_image_nv: PFN_vkCmdBindShadingRateImageNV,
}
impl VK_NV_shading_rate_image for Vulkan_NV_shading_rate_image {
	fn vkCmdBindShadingRateImageNV(&self, commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) {
		(self.vk_cmd_bind_shading_rate_image_nv)(commandBuffer, imageView, imageLayout)
	}
}
impl Default for Vulkan_NV_shading_rate_image {
	fn default() -> Self {
		Self {
			vk_cmd_bind_shading_rate_image_nv: dummy_vkCmdBindShadingRateImageNV,
		}
	}
}
impl Vulkan_NV_shading_rate_image {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_bind_shading_rate_image_nv: {let proc = get_proc_address(instance, "vkCmdBindShadingRateImageNV"); if proc == null() {dummy_vkCmdBindShadingRateImageNV} else {unsafe {transmute(proc)}}},
		}
	}
}
pub const VK_SHADER_UNUSED_KHR: u32 = !0u32;
pub const VK_SHADER_UNUSED_NV: u32 = !0u32;
pub type VkRayTracingShaderGroupTypeNV = VkRayTracingShaderGroupTypeKHR;
pub type VkGeometryTypeNV = VkGeometryTypeKHR;
pub type VkAccelerationStructureTypeNV = VkAccelerationStructureTypeKHR;
pub type VkCopyAccelerationStructureModeNV = VkCopyAccelerationStructureModeKHR;
pub type VkGeometryFlagsKHR = VkFlags;
pub type VkGeometryFlagsNV = VkGeometryFlagsKHR;
pub type VkGeometryFlagBitsNV = VkGeometryFlagBitsKHR;
pub type VkGeometryInstanceFlagsKHR = VkFlags;
pub type VkGeometryInstanceFlagsNV = VkGeometryInstanceFlagsKHR;
pub type VkGeometryInstanceFlagBitsNV = VkGeometryInstanceFlagBitsKHR;
pub type VkBuildAccelerationStructureFlagsKHR = VkFlags;
pub type VkBuildAccelerationStructureFlagsNV = VkBuildAccelerationStructureFlagsKHR;
pub type VkBuildAccelerationStructureFlagBitsNV = VkBuildAccelerationStructureFlagBitsKHR;
pub type VkTransformMatrixNV = VkTransformMatrixKHR;
pub type VkAabbPositionsNV = VkAabbPositionsKHR;
pub type VkAccelerationStructureInstanceNV = VkAccelerationStructureInstanceKHR;
// Define non-dispatchable handle `VkAccelerationStructureNV`
#[cfg(target_pointer_width = "32")] pub type VkAccelerationStructureNV = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkAccelerationStructureNV_T {}
#[cfg(target_pointer_width = "64")] pub type VkAccelerationStructureNV = *const VkAccelerationStructureNV_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkRayTracingShaderGroupTypeKHR {
	VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR = 0,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR = 1,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR = 2,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkRayTracingShaderGroupTypeKHR {
	pub const VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV: VkRayTracingShaderGroupTypeKHR = VkRayTracingShaderGroupTypeKHR::VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR;
	pub const VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV: VkRayTracingShaderGroupTypeKHR = VkRayTracingShaderGroupTypeKHR::VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR;
	pub const VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV: VkRayTracingShaderGroupTypeKHR = VkRayTracingShaderGroupTypeKHR::VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkGeometryTypeKHR {
	VK_GEOMETRY_TYPE_TRIANGLES_KHR = 0,
	VK_GEOMETRY_TYPE_AABBS_KHR = 1,
	VK_GEOMETRY_TYPE_INSTANCES_KHR = 2,
	VK_GEOMETRY_TYPE_SPHERES_NV = 1000429004,
	VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV = 1000429005,
	VK_GEOMETRY_TYPE_DENSE_GEOMETRY_FORMAT_TRIANGLES_AMDX = 1000478000,
	VK_GEOMETRY_TYPE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkGeometryTypeKHR {
	pub const VK_GEOMETRY_TYPE_TRIANGLES_NV: VkGeometryTypeKHR = VkGeometryTypeKHR::VK_GEOMETRY_TYPE_TRIANGLES_KHR;
	pub const VK_GEOMETRY_TYPE_AABBS_NV: VkGeometryTypeKHR = VkGeometryTypeKHR::VK_GEOMETRY_TYPE_AABBS_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAccelerationStructureTypeKHR {
	VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR = 0,
	VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR = 1,
	VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR = 2,
	VK_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkAccelerationStructureTypeKHR {
	pub const VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV: VkAccelerationStructureTypeKHR = VkAccelerationStructureTypeKHR::VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;
	pub const VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV: VkAccelerationStructureTypeKHR = VkAccelerationStructureTypeKHR::VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCopyAccelerationStructureModeKHR {
	VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR = 0,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR = 1,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR = 2,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR = 3,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkCopyAccelerationStructureModeKHR {
	pub const VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV: VkCopyAccelerationStructureModeKHR = VkCopyAccelerationStructureModeKHR::VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR;
	pub const VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV: VkCopyAccelerationStructureModeKHR = VkCopyAccelerationStructureModeKHR::VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAccelerationStructureMemoryRequirementsTypeNV {
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0,
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1,
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2,
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkGeometryFlagBitsKHR {
	VK_GEOMETRY_OPAQUE_BIT_KHR = 0x00000001,
	VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR = 0x00000002,
	VK_GEOMETRY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkGeometryFlagBitsKHR {
	pub const VK_GEOMETRY_OPAQUE_BIT_NV: VkGeometryFlagBitsKHR = VkGeometryFlagBitsKHR::VK_GEOMETRY_OPAQUE_BIT_KHR;
	pub const VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV: VkGeometryFlagBitsKHR = VkGeometryFlagBitsKHR::VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkGeometryInstanceFlagBitsKHR {
	VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR = 0x00000001,
	VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR = 0x00000002,
	VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR = 0x00000004,
	VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR = 0x00000008,
	VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT = 0x00000010,
	VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT = 0x00000020,
	VK_GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkGeometryInstanceFlagBitsKHR {
	pub const VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR: VkGeometryInstanceFlagBitsKHR = VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR;
	pub const VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV: VkGeometryInstanceFlagBitsKHR = VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR;
	pub const VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV: VkGeometryInstanceFlagBitsKHR = VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR;
	pub const VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV: VkGeometryInstanceFlagBitsKHR = VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR;
	pub const VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV: VkGeometryInstanceFlagBitsKHR = VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR;
	pub const VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT: VkGeometryInstanceFlagBitsKHR = VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT;
	pub const VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT: VkGeometryInstanceFlagBitsKHR = VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT;
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBuildAccelerationStructureFlagBitsKHR {
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR = 0x00000001,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR = 0x00000002,
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR = 0x00000004,
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR = 0x00000008,
	VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR = 0x00000010,
	VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV = 0x00000020,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT = 0x00000040,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT = 0x00000080,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT = 0x00000100,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_BIT_NV = 0x00000200,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR = 0x00000800,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_CLUSTER_OPACITY_MICROMAPS_BIT_NV = 0x00001000,
	VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkBuildAccelerationStructureFlagBitsKHR {
	pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_BIT_NV;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR;
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRayTracingShaderGroupCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkRayTracingShaderGroupTypeKHR,
	pub generalShader: u32,
	pub closestHitShader: u32,
	pub anyHitShader: u32,
	pub intersectionShader: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRayTracingPipelineCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCreateFlags,
	pub stageCount: u32,
	pub pStages: *const VkPipelineShaderStageCreateInfo,
	pub groupCount: u32,
	pub pGroups: *const VkRayTracingShaderGroupCreateInfoNV,
	pub maxRecursionDepth: u32,
	pub layout: VkPipelineLayout,
	pub basePipelineHandle: VkPipeline,
	pub basePipelineIndex: i32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkGeometryTrianglesNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub vertexData: VkBuffer,
	pub vertexOffset: VkDeviceSize,
	pub vertexCount: u32,
	pub vertexStride: VkDeviceSize,
	pub vertexFormat: VkFormat,
	pub indexData: VkBuffer,
	pub indexOffset: VkDeviceSize,
	pub indexCount: u32,
	pub indexType: VkIndexType,
	pub transformData: VkBuffer,
	pub transformOffset: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkGeometryAABBNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub aabbData: VkBuffer,
	pub numAABBs: u32,
	pub stride: u32,
	pub offset: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkGeometryDataNV {
	pub triangles: VkGeometryTrianglesNV,
	pub aabbs: VkGeometryAABBNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkGeometryNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub geometryType: VkGeometryTypeKHR,
	pub geometry: VkGeometryDataNV,
	pub flags: VkGeometryFlagsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkAccelerationStructureTypeNV,
	pub flags: VkBuildAccelerationStructureFlagsNV,
	pub instanceCount: u32,
	pub geometryCount: u32,
	pub pGeometries: *const VkGeometryNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub compactedSize: VkDeviceSize,
	pub info: VkAccelerationStructureInfoNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindAccelerationStructureMemoryInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub accelerationStructure: VkAccelerationStructureNV,
	pub memory: VkDeviceMemory,
	pub memoryOffset: VkDeviceSize,
	pub deviceIndexCount: u32,
	pub pDeviceIndices: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkWriteDescriptorSetAccelerationStructureNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub accelerationStructureCount: u32,
	pub pAccelerationStructures: *const VkAccelerationStructureNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureMemoryRequirementsInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkAccelerationStructureMemoryRequirementsTypeNV,
	pub accelerationStructure: VkAccelerationStructureNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderGroupHandleSize: u32,
	pub maxRecursionDepth: u32,
	pub maxShaderGroupStride: u32,
	pub shaderGroupBaseAlignment: u32,
	pub maxGeometryCount: u64,
	pub maxInstanceCount: u64,
	pub maxTriangleCount: u64,
	pub maxDescriptorSetAccelerationStructures: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTransformMatrixKHR {
	pub matrix: [f32; 3 as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAabbPositionsKHR {
	pub minX: f32,
	pub minY: f32,
	pub minZ: f32,
	pub maxX: f32,
	pub maxY: f32,
	pub maxZ: f32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureInstanceKHR {
	pub transform: VkTransformMatrixKHR,
	/// Bitfield: instanceCustomIndex: u32 in 24 bits
	/// Bitfield: mask: u32 in 8 bits
	bitfield1: u32,
	/// Bitfield: instanceShaderBindingTableRecordOffset: u32 in 24 bits
	/// Bitfield: flags: VkGeometryInstanceFlagsKHR in 8 bits
	bitfield2: u32,
	pub accelerationStructureReference: u64,
}
impl VkAccelerationStructureInstanceKHR {
	pub fn get_instanceCustomIndex(&self) -> u32 {
		(self.bitfield1 >> 0) & 0xffffff
	}
	pub fn set_instanceCustomIndex(&mut self, value: u32) {
		self.bitfield1 = (value & 0xffffff) << 0;
	}
	pub fn get_mask(&self) -> u32 {
		(self.bitfield1 >> 24) & 0xff
	}
	pub fn set_mask(&mut self, value: u32) {
		self.bitfield1 = (value & 0xff) << 24;
	}
	pub fn get_instanceShaderBindingTableRecordOffset(&self) -> u32 {
		(self.bitfield2 >> 0) & 0xffffff
	}
	pub fn set_instanceShaderBindingTableRecordOffset(&mut self, value: u32) {
		self.bitfield2 = (value & 0xffffff) << 0;
	}
	pub fn get_flags(&self) -> u32 {
		(self.bitfield2 >> 24) & 0xff
	}
	pub fn set_flags(&mut self, value: u32) {
		self.bitfield2 = (value & 0xff) << 24;
	}
}
type PFN_vkCreateAccelerationStructureNV = extern "system" fn(device: VkDevice, pCreateInfo: *const VkAccelerationStructureCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pAccelerationStructure: *mut VkAccelerationStructureNV) -> VkResult;
type PFN_vkDestroyAccelerationStructureNV = extern "system" fn(device: VkDevice, accelerationStructure: VkAccelerationStructureNV, pAllocator: *const VkAllocationCallbacks);
type PFN_vkGetAccelerationStructureMemoryRequirementsNV = extern "system" fn(device: VkDevice, pInfo: *const VkAccelerationStructureMemoryRequirementsInfoNV, pMemoryRequirements: *mut VkMemoryRequirements2KHR);
type PFN_vkBindAccelerationStructureMemoryNV = extern "system" fn(device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindAccelerationStructureMemoryInfoNV) -> VkResult;
type PFN_vkCmdBuildAccelerationStructureNV = extern "system" fn(commandBuffer: VkCommandBuffer, pInfo: *const VkAccelerationStructureInfoNV, instanceData: VkBuffer, instanceOffset: VkDeviceSize, update: VkBool32, dst: VkAccelerationStructureNV, src: VkAccelerationStructureNV, scratch: VkBuffer, scratchOffset: VkDeviceSize);
type PFN_vkCmdCopyAccelerationStructureNV = extern "system" fn(commandBuffer: VkCommandBuffer, dst: VkAccelerationStructureNV, src: VkAccelerationStructureNV, mode: VkCopyAccelerationStructureModeKHR);
type PFN_vkCmdTraceRaysNV = extern "system" fn(commandBuffer: VkCommandBuffer, raygenShaderBindingTableBuffer: VkBuffer, raygenShaderBindingOffset: VkDeviceSize, missShaderBindingTableBuffer: VkBuffer, missShaderBindingOffset: VkDeviceSize, missShaderBindingStride: VkDeviceSize, hitShaderBindingTableBuffer: VkBuffer, hitShaderBindingOffset: VkDeviceSize, hitShaderBindingStride: VkDeviceSize, callableShaderBindingTableBuffer: VkBuffer, callableShaderBindingOffset: VkDeviceSize, callableShaderBindingStride: VkDeviceSize, width: u32, height: u32, depth: u32);
type PFN_vkCreateRayTracingPipelinesNV = extern "system" fn(device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkRayTracingPipelineCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult;
type PFN_vkGetRayTracingShaderGroupHandlesKHR = extern "system" fn(device: VkDevice, pipeline: VkPipeline, firstGroup: u32, groupCount: u32, dataSize: usize, pData: *mut c_void) -> VkResult;
type PFN_vkGetRayTracingShaderGroupHandlesNV = extern "system" fn(device: VkDevice, pipeline: VkPipeline, firstGroup: u32, groupCount: u32, dataSize: usize, pData: *mut c_void) -> VkResult;
type PFN_vkGetAccelerationStructureHandleNV = extern "system" fn(device: VkDevice, accelerationStructure: VkAccelerationStructureNV, dataSize: usize, pData: *mut c_void) -> VkResult;
type PFN_vkCmdWriteAccelerationStructuresPropertiesNV = extern "system" fn(commandBuffer: VkCommandBuffer, accelerationStructureCount: u32, pAccelerationStructures: *const VkAccelerationStructureNV, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: u32);
type PFN_vkCompileDeferredNV = extern "system" fn(device: VkDevice, pipeline: VkPipeline, shader: u32) -> VkResult;
extern "system" fn dummy_vkCreateAccelerationStructureNV(_: VkDevice, _: *const VkAccelerationStructureCreateInfoNV, _: *const VkAllocationCallbacks, _: *mut VkAccelerationStructureNV) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateAccelerationStructureNV()` is NULL");
}
pub trait VK_NV_ray_tracing: Debug {
	fn vkCreateAccelerationStructureNV(&self, device: VkDevice, pCreateInfo: *const VkAccelerationStructureCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pAccelerationStructure: *mut VkAccelerationStructureNV) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_ray_tracing {
	vk_create_acceleration_structure_nv: PFN_vkCreateAccelerationStructureNV,
}
impl VK_NV_ray_tracing for Vulkan_NV_ray_tracing {
	fn vkCreateAccelerationStructureNV(&self, device: VkDevice, pCreateInfo: *const VkAccelerationStructureCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pAccelerationStructure: *mut VkAccelerationStructureNV) -> VkResult {
		(self.vk_create_acceleration_structure_nv)(device, pCreateInfo, pAllocator, pAccelerationStructure)
	}
}
impl Default for Vulkan_NV_ray_tracing {
	fn default() -> Self {
		Self {
			vk_create_acceleration_structure_nv: dummy_vkCreateAccelerationStructureNV,
		}
	}
}
impl Vulkan_NV_ray_tracing {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_acceleration_structure_nv: {let proc = get_proc_address(instance, "vkCreateAccelerationStructureNV"); if proc == null() {dummy_vkCreateAccelerationStructureNV} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub representativeFragmentTest: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub representativeFragmentTestEnable: VkBool32,
}
pub trait VK_NV_representative_fragment_test: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_representative_fragment_test {}
impl VK_NV_representative_fragment_test for Vulkan_NV_representative_fragment_test {}
impl Default for Vulkan_NV_representative_fragment_test {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_representative_fragment_test {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceImageViewImageFormatInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageViewType: VkImageViewType,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkFilterCubicImageViewImageFormatPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub filterCubic: VkBool32,
	pub filterCubicMinmax: VkBool32,
}
pub trait VK_EXT_filter_cubic: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_filter_cubic {}
impl VK_EXT_filter_cubic for Vulkan_EXT_filter_cubic {}
impl Default for Vulkan_EXT_filter_cubic {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_filter_cubic {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_QCOM_render_pass_shader_resolve: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_render_pass_shader_resolve {}
impl VK_QCOM_render_pass_shader_resolve for Vulkan_QCOM_render_pass_shader_resolve {}
impl Default for Vulkan_QCOM_render_pass_shader_resolve {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_render_pass_shader_resolve {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkQueueGlobalPriorityEXT = VkQueueGlobalPriority;
pub type VkDeviceQueueGlobalPriorityCreateInfoEXT = VkDeviceQueueGlobalPriorityCreateInfo;
pub trait VK_EXT_global_priority: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_global_priority {}
impl VK_EXT_global_priority for Vulkan_EXT_global_priority {}
impl Default for Vulkan_EXT_global_priority {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_global_priority {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImportMemoryHostPointerInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleType: VkExternalMemoryHandleTypeFlagBits,
	pub pHostPointer: *mut c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryHostPointerPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryTypeBits: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minImportedHostPointerAlignment: VkDeviceSize,
}
type PFN_vkGetMemoryHostPointerPropertiesEXT = extern "system" fn(device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHostPointer: *const c_void, pMemoryHostPointerProperties: *mut VkMemoryHostPointerPropertiesEXT) -> VkResult;
extern "system" fn dummy_vkGetMemoryHostPointerPropertiesEXT(_: VkDevice, _: VkExternalMemoryHandleTypeFlagBits, _: *const c_void, _: *mut VkMemoryHostPointerPropertiesEXT) -> VkResult {
	panic!("Vulkan function pointer of `vkGetMemoryHostPointerPropertiesEXT()` is NULL");
}
pub trait VK_EXT_external_memory_host: Debug {
	fn vkGetMemoryHostPointerPropertiesEXT(&self, device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHostPointer: *const c_void, pMemoryHostPointerProperties: *mut VkMemoryHostPointerPropertiesEXT) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_external_memory_host {
	vk_get_memory_host_pointer_properties_ext: PFN_vkGetMemoryHostPointerPropertiesEXT,
}
impl VK_EXT_external_memory_host for Vulkan_EXT_external_memory_host {
	fn vkGetMemoryHostPointerPropertiesEXT(&self, device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHostPointer: *const c_void, pMemoryHostPointerProperties: *mut VkMemoryHostPointerPropertiesEXT) -> VkResult {
		(self.vk_get_memory_host_pointer_properties_ext)(device, handleType, pHostPointer, pMemoryHostPointerProperties)
	}
}
impl Default for Vulkan_EXT_external_memory_host {
	fn default() -> Self {
		Self {
			vk_get_memory_host_pointer_properties_ext: dummy_vkGetMemoryHostPointerPropertiesEXT,
		}
	}
}
impl Vulkan_EXT_external_memory_host {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_memory_host_pointer_properties_ext: {let proc = get_proc_address(instance, "vkGetMemoryHostPointerPropertiesEXT"); if proc == null() {dummy_vkGetMemoryHostPointerPropertiesEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
type PFN_vkCmdWriteBufferMarkerAMD = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32);
type PFN_vkCmdWriteBufferMarker2AMD = extern "system" fn(commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32);
extern "system" fn dummy_vkCmdWriteBufferMarkerAMD(_: VkCommandBuffer, _: VkPipelineStageFlagBits, _: VkBuffer, _: VkDeviceSize, _: u32) {
	panic!("Vulkan function pointer of `vkCmdWriteBufferMarkerAMD()` is NULL");
}
pub trait VK_AMD_buffer_marker: Debug {
	fn vkCmdWriteBufferMarkerAMD(&self, commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_buffer_marker {
	vk_cmd_write_buffer_marker_amd: PFN_vkCmdWriteBufferMarkerAMD,
}
impl VK_AMD_buffer_marker for Vulkan_AMD_buffer_marker {
	fn vkCmdWriteBufferMarkerAMD(&self, commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32) {
		(self.vk_cmd_write_buffer_marker_amd)(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker)
	}
}
impl Default for Vulkan_AMD_buffer_marker {
	fn default() -> Self {
		Self {
			vk_cmd_write_buffer_marker_amd: dummy_vkCmdWriteBufferMarkerAMD,
		}
	}
}
impl Vulkan_AMD_buffer_marker {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_write_buffer_marker_amd: {let proc = get_proc_address(instance, "vkCmdWriteBufferMarkerAMD"); if proc == null() {dummy_vkCmdWriteBufferMarkerAMD} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPipelineCompilerControlFlagsAMD = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineCompilerControlFlagBitsAMD {
	VK_PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineCompilerControlCreateInfoAMD {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub compilerControlFlags: VkPipelineCompilerControlFlagsAMD,
}
pub trait VK_AMD_pipeline_compiler_control: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_pipeline_compiler_control {}
impl VK_AMD_pipeline_compiler_control for Vulkan_AMD_pipeline_compiler_control {}
impl Default for Vulkan_AMD_pipeline_compiler_control {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_pipeline_compiler_control {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkTimeDomainEXT = VkTimeDomainKHR;
pub type VkCalibratedTimestampInfoEXT = VkCalibratedTimestampInfoKHR;
type PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = extern "system" fn(physicalDevice: VkPhysicalDevice, pTimeDomainCount: *mut uint32_t, pTimeDomains: *mut VkTimeDomainKHR) -> VkResult;
type PFN_vkGetCalibratedTimestampsEXT = extern "system" fn(device: VkDevice, timestampCount: u32, pTimestampInfos: *const VkCalibratedTimestampInfoKHR, pTimestamps: *mut uint64_t, pMaxDeviation: *mut uint64_t) -> VkResult;
extern "system" fn dummy_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkTimeDomainKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceCalibrateableTimeDomainsEXT()` is NULL");
}
pub trait VK_EXT_calibrated_timestamps: Debug {
	fn vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(&self, physicalDevice: VkPhysicalDevice, pTimeDomainCount: *mut uint32_t, pTimeDomains: *mut VkTimeDomainKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_calibrated_timestamps {
	vk_get_physical_device_calibrateable_time_domains_ext: PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT,
}
impl VK_EXT_calibrated_timestamps for Vulkan_EXT_calibrated_timestamps {
	fn vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(&self, physicalDevice: VkPhysicalDevice, pTimeDomainCount: *mut uint32_t, pTimeDomains: *mut VkTimeDomainKHR) -> VkResult {
		(self.vk_get_physical_device_calibrateable_time_domains_ext)(physicalDevice, pTimeDomainCount, pTimeDomains)
	}
}
impl Default for Vulkan_EXT_calibrated_timestamps {
	fn default() -> Self {
		Self {
			vk_get_physical_device_calibrateable_time_domains_ext: dummy_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT,
		}
	}
}
impl Vulkan_EXT_calibrated_timestamps {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_calibrateable_time_domains_ext: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT"); if proc == null() {dummy_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderCorePropertiesAMD {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderEngineCount: u32,
	pub shaderArraysPerEngineCount: u32,
	pub computeUnitsPerShaderArray: u32,
	pub simdPerComputeUnit: u32,
	pub wavefrontsPerSimd: u32,
	pub wavefrontSize: u32,
	pub sgprsPerSimd: u32,
	pub minSgprAllocation: u32,
	pub maxSgprAllocation: u32,
	pub sgprAllocationGranularity: u32,
	pub vgprsPerSimd: u32,
	pub minVgprAllocation: u32,
	pub maxVgprAllocation: u32,
	pub vgprAllocationGranularity: u32,
}
pub trait VK_AMD_shader_core_properties: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_core_properties {}
impl VK_AMD_shader_core_properties for Vulkan_AMD_shader_core_properties {}
impl Default for Vulkan_AMD_shader_core_properties {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_shader_core_properties {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkMemoryOverallocationBehaviorAMD {
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0,
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1,
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2,
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceMemoryOverallocationCreateInfoAMD {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub overallocationBehavior: VkMemoryOverallocationBehaviorAMD,
}
pub trait VK_AMD_memory_overallocation_behavior: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_memory_overallocation_behavior {}
impl VK_AMD_memory_overallocation_behavior for Vulkan_AMD_memory_overallocation_behavior {}
impl Default for Vulkan_AMD_memory_overallocation_behavior {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_memory_overallocation_behavior {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkVertexInputBindingDivisorDescriptionEXT = VkVertexInputBindingDivisorDescription;
pub type VkPipelineVertexInputDivisorStateCreateInfoEXT = VkPipelineVertexInputDivisorStateCreateInfo;
pub type VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT = VkPhysicalDeviceVertexAttributeDivisorFeatures;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxVertexAttribDivisor: u32,
}
pub trait VK_EXT_vertex_attribute_divisor: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_vertex_attribute_divisor {}
impl VK_EXT_vertex_attribute_divisor for Vulkan_EXT_vertex_attribute_divisor {}
impl Default for Vulkan_EXT_vertex_attribute_divisor {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_vertex_attribute_divisor {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPipelineCreationFeedbackFlagBitsEXT = VkPipelineCreationFeedbackFlagBits;
pub type VkPipelineCreationFeedbackFlagsEXT = VkPipelineCreationFeedbackFlags;
pub type VkPipelineCreationFeedbackCreateInfoEXT = VkPipelineCreationFeedbackCreateInfo;
pub type VkPipelineCreationFeedbackEXT = VkPipelineCreationFeedback;
pub trait VK_EXT_pipeline_creation_feedback: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_pipeline_creation_feedback {}
impl VK_EXT_pipeline_creation_feedback for Vulkan_EXT_pipeline_creation_feedback {}
impl Default for Vulkan_EXT_pipeline_creation_feedback {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_pipeline_creation_feedback {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_NV_shader_subgroup_partitioned: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_shader_subgroup_partitioned {}
impl VK_NV_shader_subgroup_partitioned for Vulkan_NV_shader_subgroup_partitioned {}
impl Default for Vulkan_NV_shader_subgroup_partitioned {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_shader_subgroup_partitioned {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceComputeShaderDerivativesFeaturesNV = VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR;
pub trait VK_NV_compute_shader_derivatives: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_compute_shader_derivatives {}
impl VK_NV_compute_shader_derivatives for Vulkan_NV_compute_shader_derivatives {}
impl Default for Vulkan_NV_compute_shader_derivatives {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_compute_shader_derivatives {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMeshShaderFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub taskShader: VkBool32,
	pub meshShader: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMeshShaderPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxDrawMeshTasksCount: u32,
	pub maxTaskWorkGroupInvocations: u32,
	pub maxTaskWorkGroupSize: [u32; 3 as usize],
	pub maxTaskTotalMemorySize: u32,
	pub maxTaskOutputCount: u32,
	pub maxMeshWorkGroupInvocations: u32,
	pub maxMeshWorkGroupSize: [u32; 3 as usize],
	pub maxMeshTotalMemorySize: u32,
	pub maxMeshOutputVertices: u32,
	pub maxMeshOutputPrimitives: u32,
	pub maxMeshMultiviewViewCount: u32,
	pub meshOutputPerVertexGranularity: u32,
	pub meshOutputPerPrimitiveGranularity: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDrawMeshTasksIndirectCommandNV {
	pub taskCount: u32,
	pub firstTask: u32,
}
type PFN_vkCmdDrawMeshTasksNV = extern "system" fn(commandBuffer: VkCommandBuffer, taskCount: u32, firstTask: u32);
type PFN_vkCmdDrawMeshTasksIndirectNV = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32);
type PFN_vkCmdDrawMeshTasksIndirectCountNV = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
extern "system" fn dummy_vkCmdDrawMeshTasksNV(_: VkCommandBuffer, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdDrawMeshTasksNV()` is NULL");
}
pub trait VK_NV_mesh_shader: Debug {
	fn vkCmdDrawMeshTasksNV(&self, commandBuffer: VkCommandBuffer, taskCount: u32, firstTask: u32);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_mesh_shader {
	vk_cmd_draw_mesh_tasks_nv: PFN_vkCmdDrawMeshTasksNV,
}
impl VK_NV_mesh_shader for Vulkan_NV_mesh_shader {
	fn vkCmdDrawMeshTasksNV(&self, commandBuffer: VkCommandBuffer, taskCount: u32, firstTask: u32) {
		(self.vk_cmd_draw_mesh_tasks_nv)(commandBuffer, taskCount, firstTask)
	}
}
impl Default for Vulkan_NV_mesh_shader {
	fn default() -> Self {
		Self {
			vk_cmd_draw_mesh_tasks_nv: dummy_vkCmdDrawMeshTasksNV,
		}
	}
}
impl Vulkan_NV_mesh_shader {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_draw_mesh_tasks_nv: {let proc = get_proc_address(instance, "vkCmdDrawMeshTasksNV"); if proc == null() {dummy_vkCmdDrawMeshTasksNV} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV = VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
pub trait VK_NV_fragment_shader_barycentric: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_fragment_shader_barycentric {}
impl VK_NV_fragment_shader_barycentric for Vulkan_NV_fragment_shader_barycentric {}
impl Default for Vulkan_NV_fragment_shader_barycentric {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_fragment_shader_barycentric {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderImageFootprintFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageFootprint: VkBool32,
}
pub trait VK_NV_shader_image_footprint: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_shader_image_footprint {}
impl VK_NV_shader_image_footprint for Vulkan_NV_shader_image_footprint {}
impl Default for Vulkan_NV_shader_image_footprint {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_shader_image_footprint {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineViewportExclusiveScissorStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub exclusiveScissorCount: u32,
	pub pExclusiveScissors: *const VkRect2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceExclusiveScissorFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub exclusiveScissor: VkBool32,
}
type PFN_vkCmdSetExclusiveScissorEnableNV = extern "system" fn(commandBuffer: VkCommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissorEnables: *const VkBool32);
type PFN_vkCmdSetExclusiveScissorNV = extern "system" fn(commandBuffer: VkCommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissors: *const VkRect2D);
extern "system" fn dummy_vkCmdSetExclusiveScissorEnableNV(_: VkCommandBuffer, _: u32, _: u32, _: *const VkBool32) {
	panic!("Vulkan function pointer of `vkCmdSetExclusiveScissorEnableNV()` is NULL");
}
pub trait VK_NV_scissor_exclusive: Debug {
	fn vkCmdSetExclusiveScissorEnableNV(&self, commandBuffer: VkCommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissorEnables: *const VkBool32);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_scissor_exclusive {
	vk_cmd_set_exclusive_scissor_enable_nv: PFN_vkCmdSetExclusiveScissorEnableNV,
}
impl VK_NV_scissor_exclusive for Vulkan_NV_scissor_exclusive {
	fn vkCmdSetExclusiveScissorEnableNV(&self, commandBuffer: VkCommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissorEnables: *const VkBool32) {
		(self.vk_cmd_set_exclusive_scissor_enable_nv)(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables)
	}
}
impl Default for Vulkan_NV_scissor_exclusive {
	fn default() -> Self {
		Self {
			vk_cmd_set_exclusive_scissor_enable_nv: dummy_vkCmdSetExclusiveScissorEnableNV,
		}
	}
}
impl Vulkan_NV_scissor_exclusive {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_exclusive_scissor_enable_nv: {let proc = get_proc_address(instance, "vkCmdSetExclusiveScissorEnableNV"); if proc == null() {dummy_vkCmdSetExclusiveScissorEnableNV} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkQueueFamilyCheckpointPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub checkpointExecutionStageMask: VkPipelineStageFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCheckpointDataNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub stage: VkPipelineStageFlagBits,
	pub pCheckpointMarker: *mut c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkQueueFamilyCheckpointProperties2NV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub checkpointExecutionStageMask: VkPipelineStageFlags2,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCheckpointData2NV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub stage: VkPipelineStageFlags2,
	pub pCheckpointMarker: *mut c_void,
}
type PFN_vkCmdSetCheckpointNV = extern "system" fn(commandBuffer: VkCommandBuffer, pCheckpointMarker: *const c_void);
type PFN_vkGetQueueCheckpointDataNV = extern "system" fn(queue: VkQueue, pCheckpointDataCount: *mut uint32_t, pCheckpointData: *mut VkCheckpointDataNV);
type PFN_vkGetQueueCheckpointData2NV = extern "system" fn(queue: VkQueue, pCheckpointDataCount: *mut uint32_t, pCheckpointData: *mut VkCheckpointData2NV);
extern "system" fn dummy_vkCmdSetCheckpointNV(_: VkCommandBuffer, _: *const c_void) {
	panic!("Vulkan function pointer of `vkCmdSetCheckpointNV()` is NULL");
}
pub trait VK_NV_device_diagnostic_checkpoints: Debug {
	fn vkCmdSetCheckpointNV(&self, commandBuffer: VkCommandBuffer, pCheckpointMarker: *const c_void);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_device_diagnostic_checkpoints {
	vk_cmd_set_checkpoint_nv: PFN_vkCmdSetCheckpointNV,
}
impl VK_NV_device_diagnostic_checkpoints for Vulkan_NV_device_diagnostic_checkpoints {
	fn vkCmdSetCheckpointNV(&self, commandBuffer: VkCommandBuffer, pCheckpointMarker: *const c_void) {
		(self.vk_cmd_set_checkpoint_nv)(commandBuffer, pCheckpointMarker)
	}
}
impl Default for Vulkan_NV_device_diagnostic_checkpoints {
	fn default() -> Self {
		Self {
			vk_cmd_set_checkpoint_nv: dummy_vkCmdSetCheckpointNV,
		}
	}
}
impl Vulkan_NV_device_diagnostic_checkpoints {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_checkpoint_nv: {let proc = get_proc_address(instance, "vkCmdSetCheckpointNV"); if proc == null() {dummy_vkCmdSetCheckpointNV} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderIntegerFunctions2: VkBool32,
}
pub trait VK_INTEL_shader_integer_functions2: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_INTEL_shader_integer_functions2 {}
impl VK_INTEL_shader_integer_functions2 for Vulkan_INTEL_shader_integer_functions2 {}
impl Default for Vulkan_INTEL_shader_integer_functions2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_INTEL_shader_integer_functions2 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkQueryPoolCreateInfoINTEL = VkQueryPoolPerformanceQueryCreateInfoINTEL;
// Define non-dispatchable handle `VkPerformanceConfigurationINTEL`
#[cfg(target_pointer_width = "32")] pub type VkPerformanceConfigurationINTEL = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkPerformanceConfigurationINTEL_T {}
#[cfg(target_pointer_width = "64")] pub type VkPerformanceConfigurationINTEL = *const VkPerformanceConfigurationINTEL_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPerformanceConfigurationTypeINTEL {
	VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0,
	VK_PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueryPoolSamplingModeINTEL {
	VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0,
	VK_QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPerformanceOverrideTypeINTEL {
	VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0,
	VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 1,
	VK_PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPerformanceParameterTypeINTEL {
	VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0,
	VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 1,
	VK_PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPerformanceValueTypeINTEL {
	VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0,
	VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 1,
	VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 2,
	VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 3,
	VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL = 4,
	VK_PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL = 0x7fffffff,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkPerformanceValueDataINTEL {
	pub value32: u32,
	pub value64: u64,
	pub valueFloat: f32,
	pub valueBool: VkBool32,
	pub valueString: *const i8,
}
impl Debug for VkPerformanceValueDataINTEL {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceValueDataINTEL")
		.field("value32", unsafe {&self.value32})
		.field("value64", unsafe {&self.value64})
		.field("valueFloat", unsafe {&self.valueFloat})
		.field("valueBool", unsafe {&self.valueBool})
		.field("valueString", unsafe {&self.valueString})
		.finish()
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPerformanceValueINTEL {
	pub type_: VkPerformanceValueTypeINTEL,
	pub data: VkPerformanceValueDataINTEL,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkInitializePerformanceApiInfoINTEL {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pUserData: *mut c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkQueryPoolPerformanceQueryCreateInfoINTEL {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub performanceCountersSampling: VkQueryPoolSamplingModeINTEL,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPerformanceMarkerInfoINTEL {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub marker: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPerformanceStreamMarkerInfoINTEL {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub marker: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPerformanceOverrideInfoINTEL {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkPerformanceOverrideTypeINTEL,
	pub enable: VkBool32,
	pub parameter: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPerformanceConfigurationAcquireInfoINTEL {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkPerformanceConfigurationTypeINTEL,
}
type PFN_vkInitializePerformanceApiINTEL = extern "system" fn(device: VkDevice, pInitializeInfo: *const VkInitializePerformanceApiInfoINTEL) -> VkResult;
type PFN_vkUninitializePerformanceApiINTEL = extern "system" fn(device: VkDevice);
type PFN_vkCmdSetPerformanceMarkerINTEL = extern "system" fn(commandBuffer: VkCommandBuffer, pMarkerInfo: *const VkPerformanceMarkerInfoINTEL) -> VkResult;
type PFN_vkCmdSetPerformanceStreamMarkerINTEL = extern "system" fn(commandBuffer: VkCommandBuffer, pMarkerInfo: *const VkPerformanceStreamMarkerInfoINTEL) -> VkResult;
type PFN_vkCmdSetPerformanceOverrideINTEL = extern "system" fn(commandBuffer: VkCommandBuffer, pOverrideInfo: *const VkPerformanceOverrideInfoINTEL) -> VkResult;
type PFN_vkAcquirePerformanceConfigurationINTEL = extern "system" fn(device: VkDevice, pAcquireInfo: *const VkPerformanceConfigurationAcquireInfoINTEL, pConfiguration: *mut VkPerformanceConfigurationINTEL) -> VkResult;
type PFN_vkReleasePerformanceConfigurationINTEL = extern "system" fn(device: VkDevice, configuration: VkPerformanceConfigurationINTEL) -> VkResult;
type PFN_vkQueueSetPerformanceConfigurationINTEL = extern "system" fn(queue: VkQueue, configuration: VkPerformanceConfigurationINTEL) -> VkResult;
type PFN_vkGetPerformanceParameterINTEL = extern "system" fn(device: VkDevice, parameter: VkPerformanceParameterTypeINTEL, pValue: *mut VkPerformanceValueINTEL) -> VkResult;
extern "system" fn dummy_vkInitializePerformanceApiINTEL(_: VkDevice, _: *const VkInitializePerformanceApiInfoINTEL) -> VkResult {
	panic!("Vulkan function pointer of `vkInitializePerformanceApiINTEL()` is NULL");
}
pub trait VK_INTEL_performance_query: Debug {
	fn vkInitializePerformanceApiINTEL(&self, device: VkDevice, pInitializeInfo: *const VkInitializePerformanceApiInfoINTEL) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_INTEL_performance_query {
	vk_initialize_performance_api_intel: PFN_vkInitializePerformanceApiINTEL,
}
impl VK_INTEL_performance_query for Vulkan_INTEL_performance_query {
	fn vkInitializePerformanceApiINTEL(&self, device: VkDevice, pInitializeInfo: *const VkInitializePerformanceApiInfoINTEL) -> VkResult {
		(self.vk_initialize_performance_api_intel)(device, pInitializeInfo)
	}
}
impl Default for Vulkan_INTEL_performance_query {
	fn default() -> Self {
		Self {
			vk_initialize_performance_api_intel: dummy_vkInitializePerformanceApiINTEL,
		}
	}
}
impl Vulkan_INTEL_performance_query {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_initialize_performance_api_intel: {let proc = get_proc_address(instance, "vkInitializePerformanceApiINTEL"); if proc == null() {dummy_vkInitializePerformanceApiINTEL} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePCIBusInfoPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pciDomain: u32,
	pub pciBus: u32,
	pub pciDevice: u32,
	pub pciFunction: u32,
}
pub trait VK_EXT_pci_bus_info: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_pci_bus_info {}
impl VK_EXT_pci_bus_info for Vulkan_EXT_pci_bus_info {}
impl Default for Vulkan_EXT_pci_bus_info {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_pci_bus_info {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplayNativeHdrSurfaceCapabilitiesAMD {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub localDimmingSupport: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSwapchainDisplayNativeHdrCreateInfoAMD {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub localDimmingEnable: VkBool32,
}
type PFN_vkSetLocalDimmingAMD = extern "system" fn(device: VkDevice, swapChain: VkSwapchainKHR, localDimmingEnable: VkBool32);
extern "system" fn dummy_vkSetLocalDimmingAMD(_: VkDevice, _: VkSwapchainKHR, _: VkBool32) {
	panic!("Vulkan function pointer of `vkSetLocalDimmingAMD()` is NULL");
}
pub trait VK_AMD_display_native_hdr: Debug {
	fn vkSetLocalDimmingAMD(&self, device: VkDevice, swapChain: VkSwapchainKHR, localDimmingEnable: VkBool32);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_display_native_hdr {
	vk_set_local_dimming_amd: PFN_vkSetLocalDimmingAMD,
}
impl VK_AMD_display_native_hdr for Vulkan_AMD_display_native_hdr {
	fn vkSetLocalDimmingAMD(&self, device: VkDevice, swapChain: VkSwapchainKHR, localDimmingEnable: VkBool32) {
		(self.vk_set_local_dimming_amd)(device, swapChain, localDimmingEnable)
	}
}
impl Default for Vulkan_AMD_display_native_hdr {
	fn default() -> Self {
		Self {
			vk_set_local_dimming_amd: dummy_vkSetLocalDimmingAMD,
		}
	}
}
impl Vulkan_AMD_display_native_hdr {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_set_local_dimming_amd: {let proc = get_proc_address(instance, "vkSetLocalDimmingAMD"); if proc == null() {dummy_vkSetLocalDimmingAMD} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub fragmentDensityMap: VkBool32,
	pub fragmentDensityMapDynamic: VkBool32,
	pub fragmentDensityMapNonSubsampledImages: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minFragmentDensityTexelSize: VkExtent2D,
	pub maxFragmentDensityTexelSize: VkExtent2D,
	pub fragmentDensityInvocations: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassFragmentDensityMapCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub fragmentDensityMapAttachment: VkAttachmentReference,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderingFragmentDensityMapAttachmentInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub imageView: VkImageView,
	pub imageLayout: VkImageLayout,
}
pub trait VK_EXT_fragment_density_map: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_fragment_density_map {}
impl VK_EXT_fragment_density_map for Vulkan_EXT_fragment_density_map {}
impl Default for Vulkan_EXT_fragment_density_map {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_fragment_density_map {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = VkPhysicalDeviceScalarBlockLayoutFeatures;
pub trait VK_EXT_scalar_block_layout: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_scalar_block_layout {}
impl VK_EXT_scalar_block_layout for Vulkan_EXT_scalar_block_layout {}
impl Default for Vulkan_EXT_scalar_block_layout {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_scalar_block_layout {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_GOOGLE_hlsl_functionality1: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_GOOGLE_hlsl_functionality1 {}
impl VK_GOOGLE_hlsl_functionality1 for Vulkan_GOOGLE_hlsl_functionality1 {}
impl Default for Vulkan_GOOGLE_hlsl_functionality1 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_GOOGLE_hlsl_functionality1 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_GOOGLE_decorate_string: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_GOOGLE_decorate_string {}
impl VK_GOOGLE_decorate_string for Vulkan_GOOGLE_decorate_string {}
impl Default for Vulkan_GOOGLE_decorate_string {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_GOOGLE_decorate_string {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceSubgroupSizeControlFeaturesEXT = VkPhysicalDeviceSubgroupSizeControlFeatures;
pub type VkPhysicalDeviceSubgroupSizeControlPropertiesEXT = VkPhysicalDeviceSubgroupSizeControlProperties;
pub type VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;
pub trait VK_EXT_subgroup_size_control: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_subgroup_size_control {}
impl VK_EXT_subgroup_size_control for Vulkan_EXT_subgroup_size_control {}
impl Default for Vulkan_EXT_subgroup_size_control {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_subgroup_size_control {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkShaderCorePropertiesFlagsAMD = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkShaderCorePropertiesFlagBitsAMD {
	VK_SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderCoreProperties2AMD {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderCoreFeatures: VkShaderCorePropertiesFlagsAMD,
	pub activeComputeUnitCount: u32,
}
pub trait VK_AMD_shader_core_properties2: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_core_properties2 {}
impl VK_AMD_shader_core_properties2 for Vulkan_AMD_shader_core_properties2 {}
impl Default for Vulkan_AMD_shader_core_properties2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_shader_core_properties2 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCoherentMemoryFeaturesAMD {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceCoherentMemory: VkBool32,
}
pub trait VK_AMD_device_coherent_memory: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_device_coherent_memory {}
impl VK_AMD_device_coherent_memory for Vulkan_AMD_device_coherent_memory {}
impl Default for Vulkan_AMD_device_coherent_memory {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_device_coherent_memory {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderImageInt64Atomics: VkBool32,
	pub sparseImageInt64Atomics: VkBool32,
}
pub trait VK_EXT_shader_image_atomic_int64: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_image_atomic_int64 {}
impl VK_EXT_shader_image_atomic_int64 for Vulkan_EXT_shader_image_atomic_int64 {}
impl Default for Vulkan_EXT_shader_image_atomic_int64 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_image_atomic_int64 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMemoryBudgetPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub heapBudget: [VkDeviceSize; VK_MAX_MEMORY_HEAPS as usize],
	pub heapUsage: [VkDeviceSize; VK_MAX_MEMORY_HEAPS as usize],
}
pub trait VK_EXT_memory_budget: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_memory_budget {}
impl VK_EXT_memory_budget for Vulkan_EXT_memory_budget {}
impl Default for Vulkan_EXT_memory_budget {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_memory_budget {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMemoryPriorityFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryPriority: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryPriorityAllocateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub priority: f32,
}
pub trait VK_EXT_memory_priority: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_memory_priority {}
impl VK_EXT_memory_priority for Vulkan_EXT_memory_priority {}
impl Default for Vulkan_EXT_memory_priority {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_memory_priority {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub dedicatedAllocationImageAliasing: VkBool32,
}
pub trait VK_NV_dedicated_allocation_image_aliasing: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_dedicated_allocation_image_aliasing {}
impl VK_NV_dedicated_allocation_image_aliasing for Vulkan_NV_dedicated_allocation_image_aliasing {}
impl Default for Vulkan_NV_dedicated_allocation_image_aliasing {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_dedicated_allocation_image_aliasing {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceBufferAddressFeaturesEXT = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;
pub type VkBufferDeviceAddressInfoEXT = VkBufferDeviceAddressInfo;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub bufferDeviceAddress: VkBool32,
	pub bufferDeviceAddressCaptureReplay: VkBool32,
	pub bufferDeviceAddressMultiDevice: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBufferDeviceAddressCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub deviceAddress: VkDeviceAddress,
}
type PFN_vkGetBufferDeviceAddressEXT = extern "system" fn(device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress;
extern "system" fn dummy_vkGetBufferDeviceAddressEXT(_: VkDevice, _: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress {
	panic!("Vulkan function pointer of `vkGetBufferDeviceAddressEXT()` is NULL");
}
pub trait VK_EXT_buffer_device_address: Debug {
	fn vkGetBufferDeviceAddressEXT(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_buffer_device_address {
	vk_get_buffer_device_address_ext: PFN_vkGetBufferDeviceAddressEXT,
}
impl VK_EXT_buffer_device_address for Vulkan_EXT_buffer_device_address {
	fn vkGetBufferDeviceAddressEXT(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress {
		(self.vk_get_buffer_device_address_ext)(device, pInfo)
	}
}
impl Default for Vulkan_EXT_buffer_device_address {
	fn default() -> Self {
		Self {
			vk_get_buffer_device_address_ext: dummy_vkGetBufferDeviceAddressEXT,
		}
	}
}
impl Vulkan_EXT_buffer_device_address {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_buffer_device_address_ext: {let proc = get_proc_address(instance, "vkGetBufferDeviceAddressEXT"); if proc == null() {dummy_vkGetBufferDeviceAddressEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkToolPurposeFlagBitsEXT = VkToolPurposeFlagBits;
pub type VkToolPurposeFlagsEXT = VkToolPurposeFlags;
pub type VkPhysicalDeviceToolPropertiesEXT = VkPhysicalDeviceToolProperties;
type PFN_vkGetPhysicalDeviceToolPropertiesEXT = extern "system" fn(physicalDevice: VkPhysicalDevice, pToolCount: *mut uint32_t, pToolProperties: *mut VkPhysicalDeviceToolProperties) -> VkResult;
extern "system" fn dummy_vkGetPhysicalDeviceToolPropertiesEXT(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkPhysicalDeviceToolProperties) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceToolPropertiesEXT()` is NULL");
}
pub trait VK_EXT_tooling_info: Debug {
	fn vkGetPhysicalDeviceToolPropertiesEXT(&self, physicalDevice: VkPhysicalDevice, pToolCount: *mut uint32_t, pToolProperties: *mut VkPhysicalDeviceToolProperties) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_tooling_info {
	vk_get_physical_device_tool_properties_ext: PFN_vkGetPhysicalDeviceToolPropertiesEXT,
}
impl VK_EXT_tooling_info for Vulkan_EXT_tooling_info {
	fn vkGetPhysicalDeviceToolPropertiesEXT(&self, physicalDevice: VkPhysicalDevice, pToolCount: *mut uint32_t, pToolProperties: *mut VkPhysicalDeviceToolProperties) -> VkResult {
		(self.vk_get_physical_device_tool_properties_ext)(physicalDevice, pToolCount, pToolProperties)
	}
}
impl Default for Vulkan_EXT_tooling_info {
	fn default() -> Self {
		Self {
			vk_get_physical_device_tool_properties_ext: dummy_vkGetPhysicalDeviceToolPropertiesEXT,
		}
	}
}
impl Vulkan_EXT_tooling_info {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_tool_properties_ext: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceToolPropertiesEXT"); if proc == null() {dummy_vkGetPhysicalDeviceToolPropertiesEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkImageStencilUsageCreateInfoEXT = VkImageStencilUsageCreateInfo;
pub trait VK_EXT_separate_stencil_usage: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_separate_stencil_usage {}
impl VK_EXT_separate_stencil_usage for Vulkan_EXT_separate_stencil_usage {}
impl Default for Vulkan_EXT_separate_stencil_usage {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_separate_stencil_usage {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkValidationFeatureEnableEXT {
	VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0,
	VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1,
	VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2,
	VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT = 3,
	VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 4,
	VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkValidationFeatureDisableEXT {
	VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0,
	VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1,
	VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2,
	VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3,
	VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4,
	VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5,
	VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6,
	VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = 7,
	VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkValidationFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub enabledValidationFeatureCount: u32,
	pub pEnabledValidationFeatures: *const VkValidationFeatureEnableEXT,
	pub disabledValidationFeatureCount: u32,
	pub pDisabledValidationFeatures: *const VkValidationFeatureDisableEXT,
}
pub trait VK_EXT_validation_features: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_validation_features {}
impl VK_EXT_validation_features for Vulkan_EXT_validation_features {}
impl Default for Vulkan_EXT_validation_features {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_validation_features {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkComponentTypeNV = VkComponentTypeKHR;
pub type VkScopeNV = VkScopeKHR;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCooperativeMatrixPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub MSize: u32,
	pub NSize: u32,
	pub KSize: u32,
	pub AType: VkComponentTypeNV,
	pub BType: VkComponentTypeNV,
	pub CType: VkComponentTypeNV,
	pub DType: VkComponentTypeNV,
	pub scope: VkScopeNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCooperativeMatrixFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cooperativeMatrix: VkBool32,
	pub cooperativeMatrixRobustBufferAccess: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCooperativeMatrixPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cooperativeMatrixSupportedStages: VkShaderStageFlags,
}
type PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixPropertiesNV) -> VkResult;
extern "system" fn dummy_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkCooperativeMatrixPropertiesNV) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceCooperativeMatrixPropertiesNV()` is NULL");
}
pub trait VK_NV_cooperative_matrix: Debug {
	fn vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixPropertiesNV) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_cooperative_matrix {
	vk_get_physical_device_cooperative_matrix_properties_nv: PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV,
}
impl VK_NV_cooperative_matrix for Vulkan_NV_cooperative_matrix {
	fn vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixPropertiesNV) -> VkResult {
		(self.vk_get_physical_device_cooperative_matrix_properties_nv)(physicalDevice, pPropertyCount, pProperties)
	}
}
impl Default for Vulkan_NV_cooperative_matrix {
	fn default() -> Self {
		Self {
			vk_get_physical_device_cooperative_matrix_properties_nv: dummy_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV,
		}
	}
}
impl Vulkan_NV_cooperative_matrix {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_cooperative_matrix_properties_nv: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV"); if proc == null() {dummy_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPipelineCoverageReductionStateCreateFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCoverageReductionModeNV {
	VK_COVERAGE_REDUCTION_MODE_MERGE_NV = 0,
	VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1,
	VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCoverageReductionModeFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub coverageReductionMode: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineCoverageReductionStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCoverageReductionStateCreateFlagsNV,
	pub coverageReductionMode: VkCoverageReductionModeNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkFramebufferMixedSamplesCombinationNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub coverageReductionMode: VkCoverageReductionModeNV,
	pub rasterizationSamples: VkSampleCountFlagBits,
	pub depthStencilSamples: VkSampleCountFlags,
	pub colorSamples: VkSampleCountFlags,
}
type PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = extern "system" fn(physicalDevice: VkPhysicalDevice, pCombinationCount: *mut uint32_t, pCombinations: *mut VkFramebufferMixedSamplesCombinationNV) -> VkResult;
extern "system" fn dummy_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkFramebufferMixedSamplesCombinationNV) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV()` is NULL");
}
pub trait VK_NV_coverage_reduction_mode: Debug {
	fn vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(&self, physicalDevice: VkPhysicalDevice, pCombinationCount: *mut uint32_t, pCombinations: *mut VkFramebufferMixedSamplesCombinationNV) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_coverage_reduction_mode {
	vk_get_physical_device_supported_framebuffer_mixed_samples_combinations_nv: PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV,
}
impl VK_NV_coverage_reduction_mode for Vulkan_NV_coverage_reduction_mode {
	fn vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(&self, physicalDevice: VkPhysicalDevice, pCombinationCount: *mut uint32_t, pCombinations: *mut VkFramebufferMixedSamplesCombinationNV) -> VkResult {
		(self.vk_get_physical_device_supported_framebuffer_mixed_samples_combinations_nv)(physicalDevice, pCombinationCount, pCombinations)
	}
}
impl Default for Vulkan_NV_coverage_reduction_mode {
	fn default() -> Self {
		Self {
			vk_get_physical_device_supported_framebuffer_mixed_samples_combinations_nv: dummy_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV,
		}
	}
}
impl Vulkan_NV_coverage_reduction_mode {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_supported_framebuffer_mixed_samples_combinations_nv: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV"); if proc == null() {dummy_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub fragmentShaderSampleInterlock: VkBool32,
	pub fragmentShaderPixelInterlock: VkBool32,
	pub fragmentShaderShadingRateInterlock: VkBool32,
}
pub trait VK_EXT_fragment_shader_interlock: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_fragment_shader_interlock {}
impl VK_EXT_fragment_shader_interlock for Vulkan_EXT_fragment_shader_interlock {}
impl Default for Vulkan_EXT_fragment_shader_interlock {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_fragment_shader_interlock {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub ycbcrImageArrays: VkBool32,
}
pub trait VK_EXT_ycbcr_image_arrays: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_ycbcr_image_arrays {}
impl VK_EXT_ycbcr_image_arrays for Vulkan_EXT_ycbcr_image_arrays {}
impl Default for Vulkan_EXT_ycbcr_image_arrays {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_ycbcr_image_arrays {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkProvokingVertexModeEXT {
	VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = 0,
	VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = 1,
	VK_PROVOKING_VERTEX_MODE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceProvokingVertexFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub provokingVertexLast: VkBool32,
	pub transformFeedbackPreservesProvokingVertex: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceProvokingVertexPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub provokingVertexModePerPipeline: VkBool32,
	pub transformFeedbackPreservesTriangleFanProvokingVertex: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineRasterizationProvokingVertexStateCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub provokingVertexMode: VkProvokingVertexModeEXT,
}
pub trait VK_EXT_provoking_vertex: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_provoking_vertex {}
impl VK_EXT_provoking_vertex for Vulkan_EXT_provoking_vertex {}
impl Default for Vulkan_EXT_provoking_vertex {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_provoking_vertex {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkHeadlessSurfaceCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkHeadlessSurfaceCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkHeadlessSurfaceCreateFlagsEXT,
}
type PFN_vkCreateHeadlessSurfaceEXT = extern "system" fn(instance: VkInstance, pCreateInfo: *const VkHeadlessSurfaceCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR) -> VkResult;
extern "system" fn dummy_vkCreateHeadlessSurfaceEXT(_: VkInstance, _: *const VkHeadlessSurfaceCreateInfoEXT, _: *const VkAllocationCallbacks, _: *mut VkSurfaceKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateHeadlessSurfaceEXT()` is NULL");
}
pub trait VK_EXT_headless_surface: Debug {
	fn vkCreateHeadlessSurfaceEXT(&self, instance: VkInstance, pCreateInfo: *const VkHeadlessSurfaceCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_headless_surface {
	vk_create_headless_surface_ext: PFN_vkCreateHeadlessSurfaceEXT,
}
impl VK_EXT_headless_surface for Vulkan_EXT_headless_surface {
	fn vkCreateHeadlessSurfaceEXT(&self, instance: VkInstance, pCreateInfo: *const VkHeadlessSurfaceCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR) -> VkResult {
		(self.vk_create_headless_surface_ext)(instance, pCreateInfo, pAllocator, pSurface)
	}
}
impl Default for Vulkan_EXT_headless_surface {
	fn default() -> Self {
		Self {
			vk_create_headless_surface_ext: dummy_vkCreateHeadlessSurfaceEXT,
		}
	}
}
impl Vulkan_EXT_headless_surface {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_headless_surface_ext: {let proc = get_proc_address(instance, "vkCreateHeadlessSurfaceEXT"); if proc == null() {dummy_vkCreateHeadlessSurfaceEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkLineRasterizationModeEXT = VkLineRasterizationMode;
pub type VkPhysicalDeviceLineRasterizationFeaturesEXT = VkPhysicalDeviceLineRasterizationFeatures;
pub type VkPhysicalDeviceLineRasterizationPropertiesEXT = VkPhysicalDeviceLineRasterizationProperties;
pub type VkPipelineRasterizationLineStateCreateInfoEXT = VkPipelineRasterizationLineStateCreateInfo;
type PFN_vkCmdSetLineStippleEXT = extern "system" fn(commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16);
extern "system" fn dummy_vkCmdSetLineStippleEXT(_: VkCommandBuffer, _: u32, _: u16) {
	panic!("Vulkan function pointer of `vkCmdSetLineStippleEXT()` is NULL");
}
pub trait VK_EXT_line_rasterization: Debug {
	fn vkCmdSetLineStippleEXT(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_line_rasterization {
	vk_cmd_set_line_stipple_ext: PFN_vkCmdSetLineStippleEXT,
}
impl VK_EXT_line_rasterization for Vulkan_EXT_line_rasterization {
	fn vkCmdSetLineStippleEXT(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) {
		(self.vk_cmd_set_line_stipple_ext)(commandBuffer, lineStippleFactor, lineStipplePattern)
	}
}
impl Default for Vulkan_EXT_line_rasterization {
	fn default() -> Self {
		Self {
			vk_cmd_set_line_stipple_ext: dummy_vkCmdSetLineStippleEXT,
		}
	}
}
impl Vulkan_EXT_line_rasterization {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_line_stipple_ext: {let proc = get_proc_address(instance, "vkCmdSetLineStippleEXT"); if proc == null() {dummy_vkCmdSetLineStippleEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderBufferFloat32Atomics: VkBool32,
	pub shaderBufferFloat32AtomicAdd: VkBool32,
	pub shaderBufferFloat64Atomics: VkBool32,
	pub shaderBufferFloat64AtomicAdd: VkBool32,
	pub shaderSharedFloat32Atomics: VkBool32,
	pub shaderSharedFloat32AtomicAdd: VkBool32,
	pub shaderSharedFloat64Atomics: VkBool32,
	pub shaderSharedFloat64AtomicAdd: VkBool32,
	pub shaderImageFloat32Atomics: VkBool32,
	pub shaderImageFloat32AtomicAdd: VkBool32,
	pub sparseImageFloat32Atomics: VkBool32,
	pub sparseImageFloat32AtomicAdd: VkBool32,
}
pub trait VK_EXT_shader_atomic_float: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_atomic_float {}
impl VK_EXT_shader_atomic_float for Vulkan_EXT_shader_atomic_float {}
impl Default for Vulkan_EXT_shader_atomic_float {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_atomic_float {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceHostQueryResetFeaturesEXT = VkPhysicalDeviceHostQueryResetFeatures;
type PFN_vkResetQueryPoolEXT = extern "system" fn(device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32);
extern "system" fn dummy_vkResetQueryPoolEXT(_: VkDevice, _: VkQueryPool, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkResetQueryPoolEXT()` is NULL");
}
pub trait VK_EXT_host_query_reset: Debug {
	fn vkResetQueryPoolEXT(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_host_query_reset {
	vk_reset_query_pool_ext: PFN_vkResetQueryPoolEXT,
}
impl VK_EXT_host_query_reset for Vulkan_EXT_host_query_reset {
	fn vkResetQueryPoolEXT(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) {
		(self.vk_reset_query_pool_ext)(device, queryPool, firstQuery, queryCount)
	}
}
impl Default for Vulkan_EXT_host_query_reset {
	fn default() -> Self {
		Self {
			vk_reset_query_pool_ext: dummy_vkResetQueryPoolEXT,
		}
	}
}
impl Vulkan_EXT_host_query_reset {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_reset_query_pool_ext: {let proc = get_proc_address(instance, "vkResetQueryPoolEXT"); if proc == null() {dummy_vkResetQueryPoolEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceIndexTypeUint8FeaturesEXT = VkPhysicalDeviceIndexTypeUint8Features;
pub trait VK_EXT_index_type_uint8: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_index_type_uint8 {}
impl VK_EXT_index_type_uint8 for Vulkan_EXT_index_type_uint8 {}
impl Default for Vulkan_EXT_index_type_uint8 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_index_type_uint8 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceExtendedDynamicStateFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub extendedDynamicState: VkBool32,
}
type PFN_vkCmdSetCullModeEXT = extern "system" fn(commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags);
type PFN_vkCmdSetFrontFaceEXT = extern "system" fn(commandBuffer: VkCommandBuffer, frontFace: VkFrontFace);
type PFN_vkCmdSetPrimitiveTopologyEXT = extern "system" fn(commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology);
type PFN_vkCmdSetViewportWithCountEXT = extern "system" fn(commandBuffer: VkCommandBuffer, viewportCount: u32, pViewports: *const VkViewport);
type PFN_vkCmdSetScissorWithCountEXT = extern "system" fn(commandBuffer: VkCommandBuffer, scissorCount: u32, pScissors: *const VkRect2D);
type PFN_vkCmdBindVertexBuffers2EXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize, pStrides: *const VkDeviceSize);
type PFN_vkCmdSetDepthTestEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32);
type PFN_vkCmdSetDepthWriteEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32);
type PFN_vkCmdSetDepthCompareOpEXT = extern "system" fn(commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp);
type PFN_vkCmdSetDepthBoundsTestEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32);
type PFN_vkCmdSetStencilTestEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32);
type PFN_vkCmdSetStencilOpEXT = extern "system" fn(commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp);
extern "system" fn dummy_vkCmdSetCullModeEXT(_: VkCommandBuffer, _: VkCullModeFlags) {
	panic!("Vulkan function pointer of `vkCmdSetCullModeEXT()` is NULL");
}
pub trait VK_EXT_extended_dynamic_state: Debug {
	fn vkCmdSetCullModeEXT(&self, commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_extended_dynamic_state {
	vk_cmd_set_cull_mode_ext: PFN_vkCmdSetCullModeEXT,
}
impl VK_EXT_extended_dynamic_state for Vulkan_EXT_extended_dynamic_state {
	fn vkCmdSetCullModeEXT(&self, commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) {
		(self.vk_cmd_set_cull_mode_ext)(commandBuffer, cullMode)
	}
}
impl Default for Vulkan_EXT_extended_dynamic_state {
	fn default() -> Self {
		Self {
			vk_cmd_set_cull_mode_ext: dummy_vkCmdSetCullModeEXT,
		}
	}
}
impl Vulkan_EXT_extended_dynamic_state {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_cull_mode_ext: {let proc = get_proc_address(instance, "vkCmdSetCullModeEXT"); if proc == null() {dummy_vkCmdSetCullModeEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkHostImageCopyFlagBitsEXT = VkHostImageCopyFlagBits;
pub type VkHostImageCopyFlagsEXT = VkHostImageCopyFlags;
pub type VkPhysicalDeviceHostImageCopyFeaturesEXT = VkPhysicalDeviceHostImageCopyFeatures;
pub type VkPhysicalDeviceHostImageCopyPropertiesEXT = VkPhysicalDeviceHostImageCopyProperties;
pub type VkMemoryToImageCopyEXT = VkMemoryToImageCopy;
pub type VkImageToMemoryCopyEXT = VkImageToMemoryCopy;
pub type VkCopyMemoryToImageInfoEXT = VkCopyMemoryToImageInfo;
pub type VkCopyImageToMemoryInfoEXT = VkCopyImageToMemoryInfo;
pub type VkCopyImageToImageInfoEXT = VkCopyImageToImageInfo;
pub type VkHostImageLayoutTransitionInfoEXT = VkHostImageLayoutTransitionInfo;
pub type VkSubresourceHostMemcpySizeEXT = VkSubresourceHostMemcpySize;
pub type VkHostImageCopyDevicePerformanceQueryEXT = VkHostImageCopyDevicePerformanceQuery;
pub type VkSubresourceLayout2EXT = VkSubresourceLayout2;
pub type VkImageSubresource2EXT = VkImageSubresource2;
type PFN_vkCopyMemoryToImageEXT = extern "system" fn(device: VkDevice, pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo) -> VkResult;
type PFN_vkCopyImageToMemoryEXT = extern "system" fn(device: VkDevice, pCopyImageToMemoryInfo: *const VkCopyImageToMemoryInfo) -> VkResult;
type PFN_vkCopyImageToImageEXT = extern "system" fn(device: VkDevice, pCopyImageToImageInfo: *const VkCopyImageToImageInfo) -> VkResult;
type PFN_vkTransitionImageLayoutEXT = extern "system" fn(device: VkDevice, transitionCount: u32, pTransitions: *const VkHostImageLayoutTransitionInfo) -> VkResult;
type PFN_vkGetImageSubresourceLayout2EXT = extern "system" fn(device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource2, pLayout: *mut VkSubresourceLayout2);
extern "system" fn dummy_vkCopyMemoryToImageEXT(_: VkDevice, _: *const VkCopyMemoryToImageInfo) -> VkResult {
	panic!("Vulkan function pointer of `vkCopyMemoryToImageEXT()` is NULL");
}
pub trait VK_EXT_host_image_copy: Debug {
	fn vkCopyMemoryToImageEXT(&self, device: VkDevice, pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_host_image_copy {
	vk_copy_memory_to_image_ext: PFN_vkCopyMemoryToImageEXT,
}
impl VK_EXT_host_image_copy for Vulkan_EXT_host_image_copy {
	fn vkCopyMemoryToImageEXT(&self, device: VkDevice, pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo) -> VkResult {
		(self.vk_copy_memory_to_image_ext)(device, pCopyMemoryToImageInfo)
	}
}
impl Default for Vulkan_EXT_host_image_copy {
	fn default() -> Self {
		Self {
			vk_copy_memory_to_image_ext: dummy_vkCopyMemoryToImageEXT,
		}
	}
}
impl Vulkan_EXT_host_image_copy {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_copy_memory_to_image_ext: {let proc = get_proc_address(instance, "vkCopyMemoryToImageEXT"); if proc == null() {dummy_vkCopyMemoryToImageEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMapMemoryPlacedFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryMapPlaced: VkBool32,
	pub memoryMapRangePlaced: VkBool32,
	pub memoryUnmapReserve: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMapMemoryPlacedPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minPlacedMemoryMapAlignment: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryMapPlacedInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pPlacedAddress: *mut c_void,
}
pub trait VK_EXT_map_memory_placed: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_map_memory_placed {}
impl VK_EXT_map_memory_placed for Vulkan_EXT_map_memory_placed {}
impl Default for Vulkan_EXT_map_memory_placed {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_map_memory_placed {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderBufferFloat16Atomics: VkBool32,
	pub shaderBufferFloat16AtomicAdd: VkBool32,
	pub shaderBufferFloat16AtomicMinMax: VkBool32,
	pub shaderBufferFloat32AtomicMinMax: VkBool32,
	pub shaderBufferFloat64AtomicMinMax: VkBool32,
	pub shaderSharedFloat16Atomics: VkBool32,
	pub shaderSharedFloat16AtomicAdd: VkBool32,
	pub shaderSharedFloat16AtomicMinMax: VkBool32,
	pub shaderSharedFloat32AtomicMinMax: VkBool32,
	pub shaderSharedFloat64AtomicMinMax: VkBool32,
	pub shaderImageFloat32AtomicMinMax: VkBool32,
	pub sparseImageFloat32AtomicMinMax: VkBool32,
}
pub trait VK_EXT_shader_atomic_float2: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_atomic_float2 {}
impl VK_EXT_shader_atomic_float2 for Vulkan_EXT_shader_atomic_float2 {}
impl Default for Vulkan_EXT_shader_atomic_float2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_atomic_float2 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPresentScalingFlagBitsEXT = VkPresentScalingFlagBitsKHR;
pub type VkPresentScalingFlagsEXT = VkPresentScalingFlagsKHR;
pub type VkPresentGravityFlagBitsEXT = VkPresentGravityFlagBitsKHR;
pub type VkPresentGravityFlagsEXT = VkPresentGravityFlagsKHR;
pub type VkSurfacePresentModeEXT = VkSurfacePresentModeKHR;
pub type VkSurfacePresentScalingCapabilitiesEXT = VkSurfacePresentScalingCapabilitiesKHR;
pub type VkSurfacePresentModeCompatibilityEXT = VkSurfacePresentModeCompatibilityKHR;
pub trait VK_EXT_surface_maintenance1: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_surface_maintenance1 {}
impl VK_EXT_surface_maintenance1 for Vulkan_EXT_surface_maintenance1 {}
impl Default for Vulkan_EXT_surface_maintenance1 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_surface_maintenance1 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT = VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR;
pub type VkSwapchainPresentFenceInfoEXT = VkSwapchainPresentFenceInfoKHR;
pub type VkSwapchainPresentModesCreateInfoEXT = VkSwapchainPresentModesCreateInfoKHR;
pub type VkSwapchainPresentModeInfoEXT = VkSwapchainPresentModeInfoKHR;
pub type VkSwapchainPresentScalingCreateInfoEXT = VkSwapchainPresentScalingCreateInfoKHR;
pub type VkReleaseSwapchainImagesInfoEXT = VkReleaseSwapchainImagesInfoKHR;
type PFN_vkReleaseSwapchainImagesEXT = extern "system" fn(device: VkDevice, pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR) -> VkResult;
extern "system" fn dummy_vkReleaseSwapchainImagesEXT(_: VkDevice, _: *const VkReleaseSwapchainImagesInfoKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkReleaseSwapchainImagesEXT()` is NULL");
}
pub trait VK_EXT_swapchain_maintenance1: Debug {
	fn vkReleaseSwapchainImagesEXT(&self, device: VkDevice, pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_swapchain_maintenance1 {
	vk_release_swapchain_images_ext: PFN_vkReleaseSwapchainImagesEXT,
}
impl VK_EXT_swapchain_maintenance1 for Vulkan_EXT_swapchain_maintenance1 {
	fn vkReleaseSwapchainImagesEXT(&self, device: VkDevice, pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR) -> VkResult {
		(self.vk_release_swapchain_images_ext)(device, pReleaseInfo)
	}
}
impl Default for Vulkan_EXT_swapchain_maintenance1 {
	fn default() -> Self {
		Self {
			vk_release_swapchain_images_ext: dummy_vkReleaseSwapchainImagesEXT,
		}
	}
}
impl Vulkan_EXT_swapchain_maintenance1 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_release_swapchain_images_ext: {let proc = get_proc_address(instance, "vkReleaseSwapchainImagesEXT"); if proc == null() {dummy_vkReleaseSwapchainImagesEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures;
pub trait VK_EXT_shader_demote_to_helper_invocation: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_demote_to_helper_invocation {}
impl VK_EXT_shader_demote_to_helper_invocation for Vulkan_EXT_shader_demote_to_helper_invocation {}
impl Default for Vulkan_EXT_shader_demote_to_helper_invocation {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_demote_to_helper_invocation {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkIndirectStateFlagsNV = VkFlags;
pub type VkIndirectCommandsLayoutUsageFlagsNV = VkFlags;
// Define non-dispatchable handle `VkIndirectCommandsLayoutNV`
#[cfg(target_pointer_width = "32")] pub type VkIndirectCommandsLayoutNV = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkIndirectCommandsLayoutNV_T {}
#[cfg(target_pointer_width = "64")] pub type VkIndirectCommandsLayoutNV = *const VkIndirectCommandsLayoutNV_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkIndirectCommandsTokenTypeNV {
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = 0,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = 1,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = 2,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = 3,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = 4,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 5,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 6,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 7,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV = 1000328000,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV = 1000428003,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV = 1000428004,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkIndirectStateFlagBitsNV {
	VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV = 0x00000001,
	VK_INDIRECT_STATE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkIndirectCommandsLayoutUsageFlagBitsNV {
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV = 0x00000001,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV = 0x00000002,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV = 0x00000004,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxGraphicsShaderGroupCount: u32,
	pub maxIndirectSequenceCount: u32,
	pub maxIndirectCommandsTokenCount: u32,
	pub maxIndirectCommandsStreamCount: u32,
	pub maxIndirectCommandsTokenOffset: u32,
	pub maxIndirectCommandsStreamStride: u32,
	pub minSequencesCountBufferOffsetAlignment: u32,
	pub minSequencesIndexBufferOffsetAlignment: u32,
	pub minIndirectCommandsBufferOffsetAlignment: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceGeneratedCommands: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkGraphicsShaderGroupCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stageCount: u32,
	pub pStages: *const VkPipelineShaderStageCreateInfo,
	pub pVertexInputState: *const VkPipelineVertexInputStateCreateInfo,
	pub pTessellationState: *const VkPipelineTessellationStateCreateInfo,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkGraphicsPipelineShaderGroupsCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub groupCount: u32,
	pub pGroups: *const VkGraphicsShaderGroupCreateInfoNV,
	pub pipelineCount: u32,
	pub pPipelines: *const VkPipeline,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindShaderGroupIndirectCommandNV {
	pub groupIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindIndexBufferIndirectCommandNV {
	pub bufferAddress: VkDeviceAddress,
	pub size: u32,
	pub indexType: VkIndexType,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindVertexBufferIndirectCommandNV {
	pub bufferAddress: VkDeviceAddress,
	pub size: u32,
	pub stride: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSetStateFlagsIndirectCommandNV {
	pub data: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkIndirectCommandsStreamNV {
	pub buffer: VkBuffer,
	pub offset: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkIndirectCommandsLayoutTokenNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tokenType: VkIndirectCommandsTokenTypeNV,
	pub stream: u32,
	pub offset: u32,
	pub vertexBindingUnit: u32,
	pub vertexDynamicStride: VkBool32,
	pub pushconstantPipelineLayout: VkPipelineLayout,
	pub pushconstantShaderStageFlags: VkShaderStageFlags,
	pub pushconstantOffset: u32,
	pub pushconstantSize: u32,
	pub indirectStateFlags: VkIndirectStateFlagsNV,
	pub indexTypeCount: u32,
	pub pIndexTypes: *const VkIndexType,
	pub pIndexTypeValues: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkIndirectCommandsLayoutCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkIndirectCommandsLayoutUsageFlagsNV,
	pub pipelineBindPoint: VkPipelineBindPoint,
	pub tokenCount: u32,
	pub pTokens: *const VkIndirectCommandsLayoutTokenNV,
	pub streamCount: u32,
	pub pStreamStrides: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkGeneratedCommandsInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pipelineBindPoint: VkPipelineBindPoint,
	pub pipeline: VkPipeline,
	pub indirectCommandsLayout: VkIndirectCommandsLayoutNV,
	pub streamCount: u32,
	pub pStreams: *const VkIndirectCommandsStreamNV,
	pub sequencesCount: u32,
	pub preprocessBuffer: VkBuffer,
	pub preprocessOffset: VkDeviceSize,
	pub preprocessSize: VkDeviceSize,
	pub sequencesCountBuffer: VkBuffer,
	pub sequencesCountOffset: VkDeviceSize,
	pub sequencesIndexBuffer: VkBuffer,
	pub sequencesIndexOffset: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkGeneratedCommandsMemoryRequirementsInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pipelineBindPoint: VkPipelineBindPoint,
	pub pipeline: VkPipeline,
	pub indirectCommandsLayout: VkIndirectCommandsLayoutNV,
	pub maxSequencesCount: u32,
}
type PFN_vkGetGeneratedCommandsMemoryRequirementsNV = extern "system" fn(device: VkDevice, pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoNV, pMemoryRequirements: *mut VkMemoryRequirements2);
type PFN_vkCmdPreprocessGeneratedCommandsNV = extern "system" fn(commandBuffer: VkCommandBuffer, pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoNV);
type PFN_vkCmdExecuteGeneratedCommandsNV = extern "system" fn(commandBuffer: VkCommandBuffer, isPreprocessed: VkBool32, pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoNV);
type PFN_vkCmdBindPipelineShaderGroupNV = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline, groupIndex: u32);
type PFN_vkCreateIndirectCommandsLayoutNV = extern "system" fn(device: VkDevice, pCreateInfo: *const VkIndirectCommandsLayoutCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pIndirectCommandsLayout: *mut VkIndirectCommandsLayoutNV) -> VkResult;
type PFN_vkDestroyIndirectCommandsLayoutNV = extern "system" fn(device: VkDevice, indirectCommandsLayout: VkIndirectCommandsLayoutNV, pAllocator: *const VkAllocationCallbacks);
extern "system" fn dummy_vkGetGeneratedCommandsMemoryRequirementsNV(_: VkDevice, _: *const VkGeneratedCommandsMemoryRequirementsInfoNV, _: *mut VkMemoryRequirements2) {
	panic!("Vulkan function pointer of `vkGetGeneratedCommandsMemoryRequirementsNV()` is NULL");
}
pub trait VK_NV_device_generated_commands: Debug {
	fn vkGetGeneratedCommandsMemoryRequirementsNV(&self, device: VkDevice, pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoNV, pMemoryRequirements: *mut VkMemoryRequirements2);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_device_generated_commands {
	vk_get_generated_commands_memory_requirements_nv: PFN_vkGetGeneratedCommandsMemoryRequirementsNV,
}
impl VK_NV_device_generated_commands for Vulkan_NV_device_generated_commands {
	fn vkGetGeneratedCommandsMemoryRequirementsNV(&self, device: VkDevice, pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoNV, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_get_generated_commands_memory_requirements_nv)(device, pInfo, pMemoryRequirements)
	}
}
impl Default for Vulkan_NV_device_generated_commands {
	fn default() -> Self {
		Self {
			vk_get_generated_commands_memory_requirements_nv: dummy_vkGetGeneratedCommandsMemoryRequirementsNV,
		}
	}
}
impl Vulkan_NV_device_generated_commands {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_generated_commands_memory_requirements_nv: {let proc = get_proc_address(instance, "vkGetGeneratedCommandsMemoryRequirementsNV"); if proc == null() {dummy_vkGetGeneratedCommandsMemoryRequirementsNV} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceInheritedViewportScissorFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub inheritedViewportScissor2D: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCommandBufferInheritanceViewportScissorInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub viewportScissor2D: VkBool32,
	pub viewportDepthCount: u32,
	pub pViewportDepths: *const VkViewport,
}
pub trait VK_NV_inherited_viewport_scissor: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_inherited_viewport_scissor {}
impl VK_NV_inherited_viewport_scissor for Vulkan_NV_inherited_viewport_scissor {}
impl Default for Vulkan_NV_inherited_viewport_scissor {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_inherited_viewport_scissor {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT = VkPhysicalDeviceTexelBufferAlignmentProperties;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub texelBufferAlignment: VkBool32,
}
pub trait VK_EXT_texel_buffer_alignment: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_texel_buffer_alignment {}
impl VK_EXT_texel_buffer_alignment for Vulkan_EXT_texel_buffer_alignment {}
impl Default for Vulkan_EXT_texel_buffer_alignment {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_texel_buffer_alignment {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassTransformBeginInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub transform: VkSurfaceTransformFlagBitsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCommandBufferInheritanceRenderPassTransformInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub transform: VkSurfaceTransformFlagBitsKHR,
	pub renderArea: VkRect2D,
}
pub trait VK_QCOM_render_pass_transform: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_render_pass_transform {}
impl VK_QCOM_render_pass_transform for Vulkan_QCOM_render_pass_transform {}
impl Default for Vulkan_QCOM_render_pass_transform {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_render_pass_transform {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDepthBiasRepresentationEXT {
	VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT = 0,
	VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT = 1,
	VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT = 2,
	VK_DEPTH_BIAS_REPRESENTATION_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDepthBiasControlFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub depthBiasControl: VkBool32,
	pub leastRepresentableValueForceUnormRepresentation: VkBool32,
	pub floatRepresentation: VkBool32,
	pub depthBiasExact: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDepthBiasInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub depthBiasConstantFactor: f32,
	pub depthBiasClamp: f32,
	pub depthBiasSlopeFactor: f32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDepthBiasRepresentationInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub depthBiasRepresentation: VkDepthBiasRepresentationEXT,
	pub depthBiasExact: VkBool32,
}
type PFN_vkCmdSetDepthBias2EXT = extern "system" fn(commandBuffer: VkCommandBuffer, pDepthBiasInfo: *const VkDepthBiasInfoEXT);
extern "system" fn dummy_vkCmdSetDepthBias2EXT(_: VkCommandBuffer, _: *const VkDepthBiasInfoEXT) {
	panic!("Vulkan function pointer of `vkCmdSetDepthBias2EXT()` is NULL");
}
pub trait VK_EXT_depth_bias_control: Debug {
	fn vkCmdSetDepthBias2EXT(&self, commandBuffer: VkCommandBuffer, pDepthBiasInfo: *const VkDepthBiasInfoEXT);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_depth_bias_control {
	vk_cmd_set_depth_bias2_ext: PFN_vkCmdSetDepthBias2EXT,
}
impl VK_EXT_depth_bias_control for Vulkan_EXT_depth_bias_control {
	fn vkCmdSetDepthBias2EXT(&self, commandBuffer: VkCommandBuffer, pDepthBiasInfo: *const VkDepthBiasInfoEXT) {
		(self.vk_cmd_set_depth_bias2_ext)(commandBuffer, pDepthBiasInfo)
	}
}
impl Default for Vulkan_EXT_depth_bias_control {
	fn default() -> Self {
		Self {
			vk_cmd_set_depth_bias2_ext: dummy_vkCmdSetDepthBias2EXT,
		}
	}
}
impl Vulkan_EXT_depth_bias_control {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_depth_bias2_ext: {let proc = get_proc_address(instance, "vkCmdSetDepthBias2EXT"); if proc == null() {dummy_vkCmdSetDepthBias2EXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkDeviceMemoryReportFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceMemoryReportEventTypeEXT {
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 1,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 2,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 3,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 4,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDeviceMemoryReportFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceMemoryReport: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceMemoryReportCallbackDataEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkDeviceMemoryReportFlagsEXT,
	pub type_: VkDeviceMemoryReportEventTypeEXT,
	pub memoryObjectId: u64,
	pub size: VkDeviceSize,
	pub objectType: VkObjectType,
	pub objectHandle: u64,
	pub heapIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceDeviceMemoryReportCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDeviceMemoryReportFlagsEXT,
	pub pfnUserCallback: PFN_vkDeviceMemoryReportCallbackEXT,
	pub pUserData: *mut c_void,
}
type PFN_vkDeviceMemoryReportCallbackEXT = extern "system" fn(pCallbackData: *const VkDeviceMemoryReportCallbackDataEXT, pUserData: *mut c_void);
pub trait VK_EXT_device_memory_report: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_device_memory_report {}
impl VK_EXT_device_memory_report for Vulkan_EXT_device_memory_report {}
impl Default for Vulkan_EXT_device_memory_report {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_device_memory_report {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
type PFN_vkAcquireDrmDisplayEXT = extern "system" fn(physicalDevice: VkPhysicalDevice, drmFd: i32, display: VkDisplayKHR) -> VkResult;
type PFN_vkGetDrmDisplayEXT = extern "system" fn(physicalDevice: VkPhysicalDevice, drmFd: i32, connectorId: u32, display: *mut VkDisplayKHR) -> VkResult;
extern "system" fn dummy_vkAcquireDrmDisplayEXT(_: VkPhysicalDevice, _: i32, _: VkDisplayKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkAcquireDrmDisplayEXT()` is NULL");
}
pub trait VK_EXT_acquire_drm_display: Debug {
	fn vkAcquireDrmDisplayEXT(&self, physicalDevice: VkPhysicalDevice, drmFd: i32, display: VkDisplayKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_acquire_drm_display {
	vk_acquire_drm_display_ext: PFN_vkAcquireDrmDisplayEXT,
}
impl VK_EXT_acquire_drm_display for Vulkan_EXT_acquire_drm_display {
	fn vkAcquireDrmDisplayEXT(&self, physicalDevice: VkPhysicalDevice, drmFd: i32, display: VkDisplayKHR) -> VkResult {
		(self.vk_acquire_drm_display_ext)(physicalDevice, drmFd, display)
	}
}
impl Default for Vulkan_EXT_acquire_drm_display {
	fn default() -> Self {
		Self {
			vk_acquire_drm_display_ext: dummy_vkAcquireDrmDisplayEXT,
		}
	}
}
impl Vulkan_EXT_acquire_drm_display {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_acquire_drm_display_ext: {let proc = get_proc_address(instance, "vkAcquireDrmDisplayEXT"); if proc == null() {dummy_vkAcquireDrmDisplayEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceRobustness2FeaturesEXT = VkPhysicalDeviceRobustness2FeaturesKHR;
pub type VkPhysicalDeviceRobustness2PropertiesEXT = VkPhysicalDeviceRobustness2PropertiesKHR;
pub trait VK_EXT_robustness2: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_robustness2 {}
impl VK_EXT_robustness2 for Vulkan_EXT_robustness2 {}
impl Default for Vulkan_EXT_robustness2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_robustness2 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSamplerCustomBorderColorCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub customBorderColor: VkClearColorValue,
	pub format: VkFormat,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCustomBorderColorPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxCustomBorderColorSamplers: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCustomBorderColorFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub customBorderColors: VkBool32,
	pub customBorderColorWithoutFormat: VkBool32,
}
pub trait VK_EXT_custom_border_color: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_custom_border_color {}
impl VK_EXT_custom_border_color for Vulkan_EXT_custom_border_color {}
impl Default for Vulkan_EXT_custom_border_color {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_custom_border_color {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_GOOGLE_user_type: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_GOOGLE_user_type {}
impl VK_GOOGLE_user_type for Vulkan_GOOGLE_user_type {}
impl Default for Vulkan_GOOGLE_user_type {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_GOOGLE_user_type {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePresentBarrierFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentBarrier: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSurfaceCapabilitiesPresentBarrierNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentBarrierSupported: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSwapchainPresentBarrierCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentBarrierEnable: VkBool32,
}
pub trait VK_NV_present_barrier: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_present_barrier {}
impl VK_NV_present_barrier for Vulkan_NV_present_barrier {}
impl Default for Vulkan_NV_present_barrier {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_present_barrier {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPrivateDataSlotEXT = VkPrivateDataSlot;
pub type VkPrivateDataSlotCreateFlagsEXT = VkPrivateDataSlotCreateFlags;
pub type VkPhysicalDevicePrivateDataFeaturesEXT = VkPhysicalDevicePrivateDataFeatures;
pub type VkDevicePrivateDataCreateInfoEXT = VkDevicePrivateDataCreateInfo;
pub type VkPrivateDataSlotCreateInfoEXT = VkPrivateDataSlotCreateInfo;
type PFN_vkCreatePrivateDataSlotEXT = extern "system" fn(device: VkDevice, pCreateInfo: *const VkPrivateDataSlotCreateInfo, pAllocator: *const VkAllocationCallbacks, pPrivateDataSlot: *mut VkPrivateDataSlot) -> VkResult;
type PFN_vkDestroyPrivateDataSlotEXT = extern "system" fn(device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: *const VkAllocationCallbacks);
type PFN_vkSetPrivateDataEXT = extern "system" fn(device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, data: u64) -> VkResult;
type PFN_vkGetPrivateDataEXT = extern "system" fn(device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, pData: *mut uint64_t);
extern "system" fn dummy_vkCreatePrivateDataSlotEXT(_: VkDevice, _: *const VkPrivateDataSlotCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkPrivateDataSlot) -> VkResult {
	panic!("Vulkan function pointer of `vkCreatePrivateDataSlotEXT()` is NULL");
}
pub trait VK_EXT_private_data: Debug {
	fn vkCreatePrivateDataSlotEXT(&self, device: VkDevice, pCreateInfo: *const VkPrivateDataSlotCreateInfo, pAllocator: *const VkAllocationCallbacks, pPrivateDataSlot: *mut VkPrivateDataSlot) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_private_data {
	vk_create_private_data_slot_ext: PFN_vkCreatePrivateDataSlotEXT,
}
impl VK_EXT_private_data for Vulkan_EXT_private_data {
	fn vkCreatePrivateDataSlotEXT(&self, device: VkDevice, pCreateInfo: *const VkPrivateDataSlotCreateInfo, pAllocator: *const VkAllocationCallbacks, pPrivateDataSlot: *mut VkPrivateDataSlot) -> VkResult {
		(self.vk_create_private_data_slot_ext)(device, pCreateInfo, pAllocator, pPrivateDataSlot)
	}
}
impl Default for Vulkan_EXT_private_data {
	fn default() -> Self {
		Self {
			vk_create_private_data_slot_ext: dummy_vkCreatePrivateDataSlotEXT,
		}
	}
}
impl Vulkan_EXT_private_data {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_private_data_slot_ext: {let proc = get_proc_address(instance, "vkCreatePrivateDataSlotEXT"); if proc == null() {dummy_vkCreatePrivateDataSlotEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT = VkPhysicalDevicePipelineCreationCacheControlFeatures;
pub trait VK_EXT_pipeline_creation_cache_control: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_pipeline_creation_cache_control {}
impl VK_EXT_pipeline_creation_cache_control for Vulkan_EXT_pipeline_creation_cache_control {}
impl Default for Vulkan_EXT_pipeline_creation_cache_control {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_pipeline_creation_cache_control {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkDeviceDiagnosticsConfigFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceDiagnosticsConfigFlagBitsNV {
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = 0x00000001,
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = 0x00000002,
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = 0x00000004,
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV = 0x00000008,
	VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDiagnosticsConfigFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub diagnosticsConfig: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceDiagnosticsConfigCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDeviceDiagnosticsConfigFlagsNV,
}
pub trait VK_NV_device_diagnostics_config: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_device_diagnostics_config {}
impl VK_NV_device_diagnostics_config for Vulkan_NV_device_diagnostics_config {}
impl Default for Vulkan_NV_device_diagnostics_config {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_device_diagnostics_config {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_QCOM_render_pass_store_ops: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_render_pass_store_ops {}
impl VK_QCOM_render_pass_store_ops for Vulkan_QCOM_render_pass_store_ops {}
impl Default for Vulkan_QCOM_render_pass_store_ops {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_render_pass_store_ops {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkTileShadingRenderPassFlagsQCOM = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkTileShadingRenderPassFlagBitsQCOM {
	VK_TILE_SHADING_RENDER_PASS_ENABLE_BIT_QCOM = 0x00000001,
	VK_TILE_SHADING_RENDER_PASS_PER_TILE_EXECUTION_BIT_QCOM = 0x00000002,
	VK_TILE_SHADING_RENDER_PASS_FLAG_BITS_MAX_ENUM_QCOM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceTileShadingFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub tileShading: VkBool32,
	pub tileShadingFragmentStage: VkBool32,
	pub tileShadingColorAttachments: VkBool32,
	pub tileShadingDepthAttachments: VkBool32,
	pub tileShadingStencilAttachments: VkBool32,
	pub tileShadingInputAttachments: VkBool32,
	pub tileShadingSampledAttachments: VkBool32,
	pub tileShadingPerTileDraw: VkBool32,
	pub tileShadingPerTileDispatch: VkBool32,
	pub tileShadingDispatchTile: VkBool32,
	pub tileShadingApron: VkBool32,
	pub tileShadingAnisotropicApron: VkBool32,
	pub tileShadingAtomicOps: VkBool32,
	pub tileShadingImageProcessing: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceTileShadingPropertiesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxApronSize: u32,
	pub preferNonCoherent: VkBool32,
	pub tileGranularity: VkExtent2D,
	pub maxTileShadingRate: VkExtent2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassTileShadingCreateInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkTileShadingRenderPassFlagsQCOM,
	pub tileApronSize: VkExtent2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPerTileBeginInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPerTileEndInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDispatchTileInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
}
type PFN_vkCmdDispatchTileQCOM = extern "system" fn(commandBuffer: VkCommandBuffer, pDispatchTileInfo: *const VkDispatchTileInfoQCOM);
type PFN_vkCmdBeginPerTileExecutionQCOM = extern "system" fn(commandBuffer: VkCommandBuffer, pPerTileBeginInfo: *const VkPerTileBeginInfoQCOM);
type PFN_vkCmdEndPerTileExecutionQCOM = extern "system" fn(commandBuffer: VkCommandBuffer, pPerTileEndInfo: *const VkPerTileEndInfoQCOM);
extern "system" fn dummy_vkCmdDispatchTileQCOM(_: VkCommandBuffer, _: *const VkDispatchTileInfoQCOM) {
	panic!("Vulkan function pointer of `vkCmdDispatchTileQCOM()` is NULL");
}
pub trait VK_QCOM_tile_shading: Debug {
	fn vkCmdDispatchTileQCOM(&self, commandBuffer: VkCommandBuffer, pDispatchTileInfo: *const VkDispatchTileInfoQCOM);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_tile_shading {
	vk_cmd_dispatch_tile_qcom: PFN_vkCmdDispatchTileQCOM,
}
impl VK_QCOM_tile_shading for Vulkan_QCOM_tile_shading {
	fn vkCmdDispatchTileQCOM(&self, commandBuffer: VkCommandBuffer, pDispatchTileInfo: *const VkDispatchTileInfoQCOM) {
		(self.vk_cmd_dispatch_tile_qcom)(commandBuffer, pDispatchTileInfo)
	}
}
impl Default for Vulkan_QCOM_tile_shading {
	fn default() -> Self {
		Self {
			vk_cmd_dispatch_tile_qcom: dummy_vkCmdDispatchTileQCOM,
		}
	}
}
impl Vulkan_QCOM_tile_shading {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_dispatch_tile_qcom: {let proc = get_proc_address(instance, "vkCmdDispatchTileQCOM"); if proc == null() {dummy_vkCmdDispatchTileQCOM} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkQueryLowLatencySupportNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pQueriedLowLatencyData: *mut c_void,
}
pub trait VK_NV_low_latency: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_low_latency {}
impl VK_NV_low_latency for Vulkan_NV_low_latency {}
impl Default for Vulkan_NV_low_latency {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_low_latency {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
// Define non-dispatchable handle `VkAccelerationStructureKHR`
#[cfg(target_pointer_width = "32")] pub type VkAccelerationStructureKHR = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkAccelerationStructureKHR_T {}
#[cfg(target_pointer_width = "64")] pub type VkAccelerationStructureKHR = *const VkAccelerationStructureKHR_T;
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkDescriptorDataEXT {
	pub pSampler: *const VkSampler,
	pub pCombinedImageSampler: *const VkDescriptorImageInfo,
	pub pInputAttachmentImage: *const VkDescriptorImageInfo,
	pub pSampledImage: *const VkDescriptorImageInfo,
	pub pStorageImage: *const VkDescriptorImageInfo,
	pub pUniformTexelBuffer: *const VkDescriptorAddressInfoEXT,
	pub pStorageTexelBuffer: *const VkDescriptorAddressInfoEXT,
	pub pUniformBuffer: *const VkDescriptorAddressInfoEXT,
	pub pStorageBuffer: *const VkDescriptorAddressInfoEXT,
	pub accelerationStructure: VkDeviceAddress,
}
impl Debug for VkDescriptorDataEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorDataEXT")
		.field("pSampler", unsafe {&self.pSampler})
		.field("pCombinedImageSampler", unsafe {&self.pCombinedImageSampler})
		.field("pInputAttachmentImage", unsafe {&self.pInputAttachmentImage})
		.field("pSampledImage", unsafe {&self.pSampledImage})
		.field("pStorageImage", unsafe {&self.pStorageImage})
		.field("pUniformTexelBuffer", unsafe {&self.pUniformTexelBuffer})
		.field("pStorageTexelBuffer", unsafe {&self.pStorageTexelBuffer})
		.field("pUniformBuffer", unsafe {&self.pUniformBuffer})
		.field("pStorageBuffer", unsafe {&self.pStorageBuffer})
		.field("accelerationStructure", unsafe {&self.accelerationStructure})
		.finish()
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorBufferPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub combinedImageSamplerDescriptorSingleArray: VkBool32,
	pub bufferlessPushDescriptors: VkBool32,
	pub allowSamplerImageViewPostSubmitCreation: VkBool32,
	pub descriptorBufferOffsetAlignment: VkDeviceSize,
	pub maxDescriptorBufferBindings: u32,
	pub maxResourceDescriptorBufferBindings: u32,
	pub maxSamplerDescriptorBufferBindings: u32,
	pub maxEmbeddedImmutableSamplerBindings: u32,
	pub maxEmbeddedImmutableSamplers: u32,
	pub bufferCaptureReplayDescriptorDataSize: usize,
	pub imageCaptureReplayDescriptorDataSize: usize,
	pub imageViewCaptureReplayDescriptorDataSize: usize,
	pub samplerCaptureReplayDescriptorDataSize: usize,
	pub accelerationStructureCaptureReplayDescriptorDataSize: usize,
	pub samplerDescriptorSize: usize,
	pub combinedImageSamplerDescriptorSize: usize,
	pub sampledImageDescriptorSize: usize,
	pub storageImageDescriptorSize: usize,
	pub uniformTexelBufferDescriptorSize: usize,
	pub robustUniformTexelBufferDescriptorSize: usize,
	pub storageTexelBufferDescriptorSize: usize,
	pub robustStorageTexelBufferDescriptorSize: usize,
	pub uniformBufferDescriptorSize: usize,
	pub robustUniformBufferDescriptorSize: usize,
	pub storageBufferDescriptorSize: usize,
	pub robustStorageBufferDescriptorSize: usize,
	pub inputAttachmentDescriptorSize: usize,
	pub accelerationStructureDescriptorSize: usize,
	pub maxSamplerDescriptorBufferRange: VkDeviceSize,
	pub maxResourceDescriptorBufferRange: VkDeviceSize,
	pub samplerDescriptorBufferAddressSpaceSize: VkDeviceSize,
	pub resourceDescriptorBufferAddressSpaceSize: VkDeviceSize,
	pub descriptorBufferAddressSpaceSize: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub combinedImageSamplerDensityMapDescriptorSize: usize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorBufferFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub descriptorBuffer: VkBool32,
	pub descriptorBufferCaptureReplay: VkBool32,
	pub descriptorBufferImageLayoutIgnored: VkBool32,
	pub descriptorBufferPushDescriptors: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorAddressInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub address: VkDeviceAddress,
	pub range: VkDeviceSize,
	pub format: VkFormat,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorBufferBindingInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub address: VkDeviceAddress,
	pub usage: VkBufferUsageFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorBufferBindingPushDescriptorBufferHandleEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub buffer: VkBuffer,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorGetInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkDescriptorType,
	pub data: VkDescriptorDataEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBufferCaptureDescriptorDataInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub buffer: VkBuffer,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageCaptureDescriptorDataInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub image: VkImage,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageViewCaptureDescriptorDataInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub imageView: VkImageView,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSamplerCaptureDescriptorDataInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub sampler: VkSampler,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkOpaqueCaptureDescriptorDataCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub opaqueCaptureDescriptorData: *const c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureCaptureDescriptorDataInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub accelerationStructure: VkAccelerationStructureKHR,
	pub accelerationStructureNV: VkAccelerationStructureNV,
}
type PFN_vkGetDescriptorSetLayoutSizeEXT = extern "system" fn(device: VkDevice, layout: VkDescriptorSetLayout, pLayoutSizeInBytes: *mut VkDeviceSize);
type PFN_vkGetDescriptorSetLayoutBindingOffsetEXT = extern "system" fn(device: VkDevice, layout: VkDescriptorSetLayout, binding: u32, pOffset: *mut VkDeviceSize);
type PFN_vkGetDescriptorEXT = extern "system" fn(device: VkDevice, pDescriptorInfo: *const VkDescriptorGetInfoEXT, dataSize: usize, pDescriptor: *mut c_void);
type PFN_vkCmdBindDescriptorBuffersEXT = extern "system" fn(commandBuffer: VkCommandBuffer, bufferCount: u32, pBindingInfos: *const VkDescriptorBufferBindingInfoEXT);
type PFN_vkCmdSetDescriptorBufferOffsetsEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: u32, setCount: u32, pBufferIndices: *const uint32_t, pOffsets: *const VkDeviceSize);
type PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32);
type PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT = extern "system" fn(device: VkDevice, pInfo: *const VkBufferCaptureDescriptorDataInfoEXT, pData: *mut c_void) -> VkResult;
type PFN_vkGetImageOpaqueCaptureDescriptorDataEXT = extern "system" fn(device: VkDevice, pInfo: *const VkImageCaptureDescriptorDataInfoEXT, pData: *mut c_void) -> VkResult;
type PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT = extern "system" fn(device: VkDevice, pInfo: *const VkImageViewCaptureDescriptorDataInfoEXT, pData: *mut c_void) -> VkResult;
type PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT = extern "system" fn(device: VkDevice, pInfo: *const VkSamplerCaptureDescriptorDataInfoEXT, pData: *mut c_void) -> VkResult;
type PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = extern "system" fn(device: VkDevice, pInfo: *const VkAccelerationStructureCaptureDescriptorDataInfoEXT, pData: *mut c_void) -> VkResult;
extern "system" fn dummy_vkGetDescriptorSetLayoutSizeEXT(_: VkDevice, _: VkDescriptorSetLayout, _: *mut VkDeviceSize) {
	panic!("Vulkan function pointer of `vkGetDescriptorSetLayoutSizeEXT()` is NULL");
}
pub trait VK_EXT_descriptor_buffer: Debug {
	fn vkGetDescriptorSetLayoutSizeEXT(&self, device: VkDevice, layout: VkDescriptorSetLayout, pLayoutSizeInBytes: *mut VkDeviceSize);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_descriptor_buffer {
	vk_get_descriptor_set_layout_size_ext: PFN_vkGetDescriptorSetLayoutSizeEXT,
}
impl VK_EXT_descriptor_buffer for Vulkan_EXT_descriptor_buffer {
	fn vkGetDescriptorSetLayoutSizeEXT(&self, device: VkDevice, layout: VkDescriptorSetLayout, pLayoutSizeInBytes: *mut VkDeviceSize) {
		(self.vk_get_descriptor_set_layout_size_ext)(device, layout, pLayoutSizeInBytes)
	}
}
impl Default for Vulkan_EXT_descriptor_buffer {
	fn default() -> Self {
		Self {
			vk_get_descriptor_set_layout_size_ext: dummy_vkGetDescriptorSetLayoutSizeEXT,
		}
	}
}
impl Vulkan_EXT_descriptor_buffer {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_descriptor_set_layout_size_ext: {let proc = get_proc_address(instance, "vkGetDescriptorSetLayoutSizeEXT"); if proc == null() {dummy_vkGetDescriptorSetLayoutSizeEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkGraphicsPipelineLibraryFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkGraphicsPipelineLibraryFlagBitsEXT {
	VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT = 0x00000001,
	VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT = 0x00000002,
	VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT = 0x00000004,
	VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT = 0x00000008,
	VK_GRAPHICS_PIPELINE_LIBRARY_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub graphicsPipelineLibrary: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub graphicsPipelineLibraryFastLinking: VkBool32,
	pub graphicsPipelineLibraryIndependentInterpolationDecoration: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkGraphicsPipelineLibraryCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkGraphicsPipelineLibraryFlagsEXT,
}
pub trait VK_EXT_graphics_pipeline_library: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_graphics_pipeline_library {}
impl VK_EXT_graphics_pipeline_library for Vulkan_EXT_graphics_pipeline_library {}
impl Default for Vulkan_EXT_graphics_pipeline_library {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_graphics_pipeline_library {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderEarlyAndLateFragmentTests: VkBool32,
}
pub trait VK_AMD_shader_early_and_late_fragment_tests: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_early_and_late_fragment_tests {}
impl VK_AMD_shader_early_and_late_fragment_tests for Vulkan_AMD_shader_early_and_late_fragment_tests {}
impl Default for Vulkan_AMD_shader_early_and_late_fragment_tests {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_shader_early_and_late_fragment_tests {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFragmentShadingRateTypeNV {
	VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = 0,
	VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = 1,
	VK_FRAGMENT_SHADING_RATE_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFragmentShadingRateNV {
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 1,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 4,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 5,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 6,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 10,
	VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 11,
	VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 12,
	VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 13,
	VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 14,
	VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = 15,
	VK_FRAGMENT_SHADING_RATE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub fragmentShadingRateEnums: VkBool32,
	pub supersampleFragmentShadingRates: VkBool32,
	pub noInvocationFragmentShadingRates: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxFragmentShadingRateInvocationCount: VkSampleCountFlagBits,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineFragmentShadingRateEnumStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub shadingRateType: VkFragmentShadingRateTypeNV,
	pub shadingRate: VkFragmentShadingRateNV,
	pub combinerOps: [VkFragmentShadingRateCombinerOpKHR; 2 as usize],
}
type PFN_vkCmdSetFragmentShadingRateEnumNV = extern "system" fn(commandBuffer: VkCommandBuffer, shadingRate: VkFragmentShadingRateNV, combinerOps: &[VkFragmentShadingRateCombinerOpKHR; 2 as usize]);
extern "system" fn dummy_vkCmdSetFragmentShadingRateEnumNV(_: VkCommandBuffer, _: VkFragmentShadingRateNV, _: &[VkFragmentShadingRateCombinerOpKHR; 2 as usize]) {
	panic!("Vulkan function pointer of `vkCmdSetFragmentShadingRateEnumNV()` is NULL");
}
pub trait VK_NV_fragment_shading_rate_enums: Debug {
	fn vkCmdSetFragmentShadingRateEnumNV(&self, commandBuffer: VkCommandBuffer, shadingRate: VkFragmentShadingRateNV, combinerOps: &[VkFragmentShadingRateCombinerOpKHR; 2 as usize]);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_fragment_shading_rate_enums {
	vk_cmd_set_fragment_shading_rate_enum_nv: PFN_vkCmdSetFragmentShadingRateEnumNV,
}
impl VK_NV_fragment_shading_rate_enums for Vulkan_NV_fragment_shading_rate_enums {
	fn vkCmdSetFragmentShadingRateEnumNV(&self, commandBuffer: VkCommandBuffer, shadingRate: VkFragmentShadingRateNV, combinerOps: &[VkFragmentShadingRateCombinerOpKHR; 2 as usize]) {
		(self.vk_cmd_set_fragment_shading_rate_enum_nv)(commandBuffer, shadingRate, combinerOps)
	}
}
impl Default for Vulkan_NV_fragment_shading_rate_enums {
	fn default() -> Self {
		Self {
			vk_cmd_set_fragment_shading_rate_enum_nv: dummy_vkCmdSetFragmentShadingRateEnumNV,
		}
	}
}
impl Vulkan_NV_fragment_shading_rate_enums {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_fragment_shading_rate_enum_nv: {let proc = get_proc_address(instance, "vkCmdSetFragmentShadingRateEnumNV"); if proc == null() {dummy_vkCmdSetFragmentShadingRateEnumNV} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkAccelerationStructureMotionInfoFlagsNV = VkFlags;
pub type VkAccelerationStructureMotionInstanceFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAccelerationStructureMotionInstanceTypeNV {
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = 0,
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = 1,
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = 2,
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkDeviceOrHostAddressConstKHR {
	pub deviceAddress: VkDeviceAddress,
	pub hostAddress: *const c_void,
}
impl Debug for VkDeviceOrHostAddressConstKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceOrHostAddressConstKHR")
		.field("deviceAddress", unsafe {&self.deviceAddress})
		.field("hostAddress", unsafe {&self.hostAddress})
		.finish()
	}
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkAccelerationStructureMotionInstanceDataNV {
	pub staticInstance: VkAccelerationStructureInstanceKHR,
	pub matrixMotionInstance: VkAccelerationStructureMatrixMotionInstanceNV,
	pub srtMotionInstance: VkAccelerationStructureSRTMotionInstanceNV,
}
impl Debug for VkAccelerationStructureMotionInstanceDataNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureMotionInstanceDataNV")
		.field("staticInstance", unsafe {&self.staticInstance})
		.field("matrixMotionInstance", unsafe {&self.matrixMotionInstance})
		.field("srtMotionInstance", unsafe {&self.srtMotionInstance})
		.finish()
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureGeometryMotionTrianglesDataNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub vertexData: VkDeviceOrHostAddressConstKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureMotionInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maxInstances: u32,
	pub flags: VkAccelerationStructureMotionInfoFlagsNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureMatrixMotionInstanceNV {
	pub transformT0: VkTransformMatrixKHR,
	pub transformT1: VkTransformMatrixKHR,
	/// Bitfield: instanceCustomIndex: u32 in 24 bits
	/// Bitfield: mask: u32 in 8 bits
	bitfield1: u32,
	/// Bitfield: instanceShaderBindingTableRecordOffset: u32 in 24 bits
	/// Bitfield: flags: VkGeometryInstanceFlagsKHR in 8 bits
	bitfield2: u32,
	pub accelerationStructureReference: u64,
}
impl VkAccelerationStructureMatrixMotionInstanceNV {
	pub fn get_instanceCustomIndex(&self) -> u32 {
		(self.bitfield1 >> 0) & 0xffffff
	}
	pub fn set_instanceCustomIndex(&mut self, value: u32) {
		self.bitfield1 = (value & 0xffffff) << 0;
	}
	pub fn get_mask(&self) -> u32 {
		(self.bitfield1 >> 24) & 0xff
	}
	pub fn set_mask(&mut self, value: u32) {
		self.bitfield1 = (value & 0xff) << 24;
	}
	pub fn get_instanceShaderBindingTableRecordOffset(&self) -> u32 {
		(self.bitfield2 >> 0) & 0xffffff
	}
	pub fn set_instanceShaderBindingTableRecordOffset(&mut self, value: u32) {
		self.bitfield2 = (value & 0xffffff) << 0;
	}
	pub fn get_flags(&self) -> u32 {
		(self.bitfield2 >> 24) & 0xff
	}
	pub fn set_flags(&mut self, value: u32) {
		self.bitfield2 = (value & 0xff) << 24;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSRTDataNV {
	pub sx: f32,
	pub a: f32,
	pub b: f32,
	pub pvx: f32,
	pub sy: f32,
	pub c: f32,
	pub pvy: f32,
	pub sz: f32,
	pub pvz: f32,
	pub qx: f32,
	pub qy: f32,
	pub qz: f32,
	pub qw: f32,
	pub tx: f32,
	pub ty: f32,
	pub tz: f32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureSRTMotionInstanceNV {
	pub transformT0: VkSRTDataNV,
	pub transformT1: VkSRTDataNV,
	/// Bitfield: instanceCustomIndex: u32 in 24 bits
	/// Bitfield: mask: u32 in 8 bits
	bitfield1: u32,
	/// Bitfield: instanceShaderBindingTableRecordOffset: u32 in 24 bits
	/// Bitfield: flags: VkGeometryInstanceFlagsKHR in 8 bits
	bitfield2: u32,
	pub accelerationStructureReference: u64,
}
impl VkAccelerationStructureSRTMotionInstanceNV {
	pub fn get_instanceCustomIndex(&self) -> u32 {
		(self.bitfield1 >> 0) & 0xffffff
	}
	pub fn set_instanceCustomIndex(&mut self, value: u32) {
		self.bitfield1 = (value & 0xffffff) << 0;
	}
	pub fn get_mask(&self) -> u32 {
		(self.bitfield1 >> 24) & 0xff
	}
	pub fn set_mask(&mut self, value: u32) {
		self.bitfield1 = (value & 0xff) << 24;
	}
	pub fn get_instanceShaderBindingTableRecordOffset(&self) -> u32 {
		(self.bitfield2 >> 0) & 0xffffff
	}
	pub fn set_instanceShaderBindingTableRecordOffset(&mut self, value: u32) {
		self.bitfield2 = (value & 0xffffff) << 0;
	}
	pub fn get_flags(&self) -> u32 {
		(self.bitfield2 >> 24) & 0xff
	}
	pub fn set_flags(&mut self, value: u32) {
		self.bitfield2 = (value & 0xff) << 24;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureMotionInstanceNV {
	pub type_: VkAccelerationStructureMotionInstanceTypeNV,
	pub flags: VkAccelerationStructureMotionInstanceFlagsNV,
	pub data: VkAccelerationStructureMotionInstanceDataNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingMotionBlurFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rayTracingMotionBlur: VkBool32,
	pub rayTracingMotionBlurPipelineTraceRaysIndirect: VkBool32,
}
pub trait VK_NV_ray_tracing_motion_blur: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_ray_tracing_motion_blur {}
impl VK_NV_ray_tracing_motion_blur for Vulkan_NV_ray_tracing_motion_blur {}
impl Default for Vulkan_NV_ray_tracing_motion_blur {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_ray_tracing_motion_blur {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub ycbcr2plane444Formats: VkBool32,
}
pub trait VK_EXT_ycbcr_2plane_444_formats: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_ycbcr_2plane_444_formats {}
impl VK_EXT_ycbcr_2plane_444_formats for Vulkan_EXT_ycbcr_2plane_444_formats {}
impl Default for Vulkan_EXT_ycbcr_2plane_444_formats {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_ycbcr_2plane_444_formats {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFragmentDensityMap2FeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub fragmentDensityMapDeferred: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFragmentDensityMap2PropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub subsampledLoads: VkBool32,
	pub subsampledCoarseReconstructionEarlyAccess: VkBool32,
	pub maxSubsampledArrayLayers: u32,
	pub maxDescriptorSetSubsampledSamplers: u32,
}
pub trait VK_EXT_fragment_density_map2: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_fragment_density_map2 {}
impl VK_EXT_fragment_density_map2 for Vulkan_EXT_fragment_density_map2 {}
impl Default for Vulkan_EXT_fragment_density_map2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_fragment_density_map2 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyCommandTransformInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub transform: VkSurfaceTransformFlagBitsKHR,
}
pub trait VK_QCOM_rotated_copy_commands: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_rotated_copy_commands {}
impl VK_QCOM_rotated_copy_commands for Vulkan_QCOM_rotated_copy_commands {}
impl Default for Vulkan_QCOM_rotated_copy_commands {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_rotated_copy_commands {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceImageRobustnessFeaturesEXT = VkPhysicalDeviceImageRobustnessFeatures;
pub trait VK_EXT_image_robustness: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_image_robustness {}
impl VK_EXT_image_robustness for Vulkan_EXT_image_robustness {}
impl Default for Vulkan_EXT_image_robustness {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_image_robustness {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkImageCompressionFlagsEXT = VkFlags;
pub type VkImageCompressionFixedRateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageCompressionFlagBitsEXT {
	VK_IMAGE_COMPRESSION_DEFAULT_EXT = 0,
	VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT = 0x00000001,
	VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT = 0x00000002,
	VK_IMAGE_COMPRESSION_DISABLED_EXT = 0x00000004,
	VK_IMAGE_COMPRESSION_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageCompressionFixedRateFlagBitsEXT {
	VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT = 0,
	VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT = 0x00000001,
	VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT = 0x00000002,
	VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT = 0x00000004,
	VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT = 0x00000008,
	VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT = 0x00000010,
	VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT = 0x00000020,
	VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT = 0x00000040,
	VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT = 0x00000080,
	VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT = 0x00000100,
	VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT = 0x00000200,
	VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT = 0x00000400,
	VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT = 0x00000800,
	VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT = 0x00001000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT = 0x00002000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT = 0x00004000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT = 0x00008000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT = 0x00010000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT = 0x00020000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT = 0x00040000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT = 0x00080000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT = 0x00100000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT = 0x00200000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT = 0x00400000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT = 0x00800000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceImageCompressionControlFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageCompressionControl: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageCompressionControlEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkImageCompressionFlagsEXT,
	pub compressionControlPlaneCount: u32,
	pub pFixedRateFlags: *mut VkImageCompressionFixedRateFlagsEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageCompressionPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageCompressionFlags: VkImageCompressionFlagsEXT,
	pub imageCompressionFixedRateFlags: VkImageCompressionFixedRateFlagsEXT,
}
pub trait VK_EXT_image_compression_control: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_image_compression_control {}
impl VK_EXT_image_compression_control for Vulkan_EXT_image_compression_control {}
impl Default for Vulkan_EXT_image_compression_control {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_image_compression_control {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub attachmentFeedbackLoopLayout: VkBool32,
}
pub trait VK_EXT_attachment_feedback_loop_layout: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_attachment_feedback_loop_layout {}
impl VK_EXT_attachment_feedback_loop_layout for Vulkan_EXT_attachment_feedback_loop_layout {}
impl Default for Vulkan_EXT_attachment_feedback_loop_layout {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_attachment_feedback_loop_layout {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevice4444FormatsFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub formatA4R4G4B4: VkBool32,
	pub formatA4B4G4R4: VkBool32,
}
pub trait VK_EXT_4444_formats: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_4444_formats {}
impl VK_EXT_4444_formats for Vulkan_EXT_4444_formats {}
impl Default for Vulkan_EXT_4444_formats {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_4444_formats {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceFaultAddressTypeEXT {
	VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT = 0,
	VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT = 1,
	VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT = 2,
	VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT = 3,
	VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT = 4,
	VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT = 5,
	VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT = 6,
	VK_DEVICE_FAULT_ADDRESS_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceFaultVendorBinaryHeaderVersionEXT {
	VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT = 1,
	VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFaultFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceFault: VkBool32,
	pub deviceFaultVendorBinary: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceFaultCountsEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub addressInfoCount: u32,
	pub vendorInfoCount: u32,
	pub vendorBinarySize: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceFaultAddressInfoEXT {
	pub addressType: VkDeviceFaultAddressTypeEXT,
	pub reportedAddress: VkDeviceAddress,
	pub addressPrecision: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceFaultVendorInfoEXT {
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub vendorFaultCode: u64,
	pub vendorFaultData: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceFaultInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub pAddressInfos: *mut VkDeviceFaultAddressInfoEXT,
	pub pVendorInfos: *mut VkDeviceFaultVendorInfoEXT,
	pub pVendorBinaryData: *mut c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceFaultVendorBinaryHeaderVersionOneEXT {
	pub headerSize: u32,
	pub headerVersion: VkDeviceFaultVendorBinaryHeaderVersionEXT,
	pub vendorID: u32,
	pub deviceID: u32,
	pub driverVersion: u32,
	pub pipelineCacheUUID: [u8; VK_UUID_SIZE as usize],
	pub applicationNameOffset: u32,
	pub applicationVersion: u32,
	pub engineNameOffset: u32,
	pub engineVersion: u32,
	pub apiVersion: u32,
}
type PFN_vkGetDeviceFaultInfoEXT = extern "system" fn(device: VkDevice, pFaultCounts: *mut VkDeviceFaultCountsEXT, pFaultInfo: *mut VkDeviceFaultInfoEXT) -> VkResult;
extern "system" fn dummy_vkGetDeviceFaultInfoEXT(_: VkDevice, _: *mut VkDeviceFaultCountsEXT, _: *mut VkDeviceFaultInfoEXT) -> VkResult {
	panic!("Vulkan function pointer of `vkGetDeviceFaultInfoEXT()` is NULL");
}
pub trait VK_EXT_device_fault: Debug {
	fn vkGetDeviceFaultInfoEXT(&self, device: VkDevice, pFaultCounts: *mut VkDeviceFaultCountsEXT, pFaultInfo: *mut VkDeviceFaultInfoEXT) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_device_fault {
	vk_get_device_fault_info_ext: PFN_vkGetDeviceFaultInfoEXT,
}
impl VK_EXT_device_fault for Vulkan_EXT_device_fault {
	fn vkGetDeviceFaultInfoEXT(&self, device: VkDevice, pFaultCounts: *mut VkDeviceFaultCountsEXT, pFaultInfo: *mut VkDeviceFaultInfoEXT) -> VkResult {
		(self.vk_get_device_fault_info_ext)(device, pFaultCounts, pFaultInfo)
	}
}
impl Default for Vulkan_EXT_device_fault {
	fn default() -> Self {
		Self {
			vk_get_device_fault_info_ext: dummy_vkGetDeviceFaultInfoEXT,
		}
	}
}
impl Vulkan_EXT_device_fault {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_device_fault_info_ext: {let proc = get_proc_address(instance, "vkGetDeviceFaultInfoEXT"); if proc == null() {dummy_vkGetDeviceFaultInfoEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rasterizationOrderColorAttachmentAccess: VkBool32,
	pub rasterizationOrderDepthAttachmentAccess: VkBool32,
	pub rasterizationOrderStencilAttachmentAccess: VkBool32,
}
pub trait VK_ARM_rasterization_order_attachment_access: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_rasterization_order_attachment_access {}
impl VK_ARM_rasterization_order_attachment_access for Vulkan_ARM_rasterization_order_attachment_access {}
impl Default for Vulkan_ARM_rasterization_order_attachment_access {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_ARM_rasterization_order_attachment_access {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub formatRgba10x6WithoutYCbCrSampler: VkBool32,
}
pub trait VK_EXT_rgba10x6_formats: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_rgba10x6_formats {}
impl VK_EXT_rgba10x6_formats for Vulkan_EXT_rgba10x6_formats {}
impl Default for Vulkan_EXT_rgba10x6_formats {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_rgba10x6_formats {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE = VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT;
pub type VkMutableDescriptorTypeListVALVE = VkMutableDescriptorTypeListEXT;
pub type VkMutableDescriptorTypeCreateInfoVALVE = VkMutableDescriptorTypeCreateInfoEXT;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub mutableDescriptorType: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMutableDescriptorTypeListEXT {
	pub descriptorTypeCount: u32,
	pub pDescriptorTypes: *const VkDescriptorType,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMutableDescriptorTypeCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub mutableDescriptorTypeListCount: u32,
	pub pMutableDescriptorTypeLists: *const VkMutableDescriptorTypeListEXT,
}
pub trait VK_VALVE_mutable_descriptor_type: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_VALVE_mutable_descriptor_type {}
impl VK_VALVE_mutable_descriptor_type for Vulkan_VALVE_mutable_descriptor_type {}
impl Default for Vulkan_VALVE_mutable_descriptor_type {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_VALVE_mutable_descriptor_type {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub vertexInputDynamicState: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVertexInputBindingDescription2EXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub binding: u32,
	pub stride: u32,
	pub inputRate: VkVertexInputRate,
	pub divisor: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkVertexInputAttributeDescription2EXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub location: u32,
	pub binding: u32,
	pub format: VkFormat,
	pub offset: u32,
}
type PFN_vkCmdSetVertexInputEXT = extern "system" fn(commandBuffer: VkCommandBuffer, vertexBindingDescriptionCount: u32, pVertexBindingDescriptions: *const VkVertexInputBindingDescription2EXT, vertexAttributeDescriptionCount: u32, pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription2EXT);
extern "system" fn dummy_vkCmdSetVertexInputEXT(_: VkCommandBuffer, _: u32, _: *const VkVertexInputBindingDescription2EXT, _: u32, _: *const VkVertexInputAttributeDescription2EXT) {
	panic!("Vulkan function pointer of `vkCmdSetVertexInputEXT()` is NULL");
}
pub trait VK_EXT_vertex_input_dynamic_state: Debug {
	fn vkCmdSetVertexInputEXT(&self, commandBuffer: VkCommandBuffer, vertexBindingDescriptionCount: u32, pVertexBindingDescriptions: *const VkVertexInputBindingDescription2EXT, vertexAttributeDescriptionCount: u32, pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription2EXT);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_vertex_input_dynamic_state {
	vk_cmd_set_vertex_input_ext: PFN_vkCmdSetVertexInputEXT,
}
impl VK_EXT_vertex_input_dynamic_state for Vulkan_EXT_vertex_input_dynamic_state {
	fn vkCmdSetVertexInputEXT(&self, commandBuffer: VkCommandBuffer, vertexBindingDescriptionCount: u32, pVertexBindingDescriptions: *const VkVertexInputBindingDescription2EXT, vertexAttributeDescriptionCount: u32, pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription2EXT) {
		(self.vk_cmd_set_vertex_input_ext)(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions)
	}
}
impl Default for Vulkan_EXT_vertex_input_dynamic_state {
	fn default() -> Self {
		Self {
			vk_cmd_set_vertex_input_ext: dummy_vkCmdSetVertexInputEXT,
		}
	}
}
impl Vulkan_EXT_vertex_input_dynamic_state {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_vertex_input_ext: {let proc = get_proc_address(instance, "vkCmdSetVertexInputEXT"); if proc == null() {dummy_vkCmdSetVertexInputEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDrmPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub hasPrimary: VkBool32,
	pub hasRender: VkBool32,
	pub primaryMajor: i64,
	pub primaryMinor: i64,
	pub renderMajor: i64,
	pub renderMinor: i64,
}
pub trait VK_EXT_physical_device_drm: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_physical_device_drm {}
impl VK_EXT_physical_device_drm for Vulkan_EXT_physical_device_drm {}
impl Default for Vulkan_EXT_physical_device_drm {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_physical_device_drm {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkDeviceAddressBindingFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceAddressBindingTypeEXT {
	VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT = 0,
	VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT = 1,
	VK_DEVICE_ADDRESS_BINDING_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceAddressBindingFlagBitsEXT {
	VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT = 0x00000001,
	VK_DEVICE_ADDRESS_BINDING_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceAddressBindingReportFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub reportAddressBinding: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceAddressBindingCallbackDataEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkDeviceAddressBindingFlagsEXT,
	pub baseAddress: VkDeviceAddress,
	pub size: VkDeviceSize,
	pub bindingType: VkDeviceAddressBindingTypeEXT,
}
pub trait VK_EXT_device_address_binding_report: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_device_address_binding_report {}
impl VK_EXT_device_address_binding_report for Vulkan_EXT_device_address_binding_report {}
impl Default for Vulkan_EXT_device_address_binding_report {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_device_address_binding_report {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDepthClipControlFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub depthClipControl: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineViewportDepthClipControlCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub negativeOneToOne: VkBool32,
}
pub trait VK_EXT_depth_clip_control: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_depth_clip_control {}
impl VK_EXT_depth_clip_control for Vulkan_EXT_depth_clip_control {}
impl Default for Vulkan_EXT_depth_clip_control {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_depth_clip_control {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub primitiveTopologyListRestart: VkBool32,
	pub primitiveTopologyPatchListRestart: VkBool32,
}
pub trait VK_EXT_primitive_topology_list_restart: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_primitive_topology_list_restart {}
impl VK_EXT_primitive_topology_list_restart for Vulkan_EXT_primitive_topology_list_restart {}
impl Default for Vulkan_EXT_primitive_topology_list_restart {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_primitive_topology_list_restart {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT = VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR;
pub trait VK_EXT_present_mode_fifo_latest_ready: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_present_mode_fifo_latest_ready {}
impl VK_EXT_present_mode_fifo_latest_ready for Vulkan_EXT_present_mode_fifo_latest_ready {}
impl Default for Vulkan_EXT_present_mode_fifo_latest_ready {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_present_mode_fifo_latest_ready {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSubpassShadingPipelineCreateInfoHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub renderPass: VkRenderPass,
	pub subpass: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSubpassShadingFeaturesHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub subpassShading: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSubpassShadingPropertiesHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxSubpassShadingWorkgroupSizeAspectRatio: u32,
}
type PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = extern "system" fn(device: VkDevice, renderpass: VkRenderPass, pMaxWorkgroupSize: *mut VkExtent2D) -> VkResult;
type PFN_vkCmdSubpassShadingHUAWEI = extern "system" fn(commandBuffer: VkCommandBuffer);
extern "system" fn dummy_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(_: VkDevice, _: VkRenderPass, _: *mut VkExtent2D) -> VkResult {
	panic!("Vulkan function pointer of `vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI()` is NULL");
}
pub trait VK_HUAWEI_subpass_shading: Debug {
	fn vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(&self, device: VkDevice, renderpass: VkRenderPass, pMaxWorkgroupSize: *mut VkExtent2D) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_HUAWEI_subpass_shading {
	vk_get_device_subpass_shading_max_workgroup_size_huawei: PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI,
}
impl VK_HUAWEI_subpass_shading for Vulkan_HUAWEI_subpass_shading {
	fn vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(&self, device: VkDevice, renderpass: VkRenderPass, pMaxWorkgroupSize: *mut VkExtent2D) -> VkResult {
		(self.vk_get_device_subpass_shading_max_workgroup_size_huawei)(device, renderpass, pMaxWorkgroupSize)
	}
}
impl Default for Vulkan_HUAWEI_subpass_shading {
	fn default() -> Self {
		Self {
			vk_get_device_subpass_shading_max_workgroup_size_huawei: dummy_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI,
		}
	}
}
impl Vulkan_HUAWEI_subpass_shading {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_device_subpass_shading_max_workgroup_size_huawei: {let proc = get_proc_address(instance, "vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI"); if proc == null() {dummy_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceInvocationMaskFeaturesHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub invocationMask: VkBool32,
}
type PFN_vkCmdBindInvocationMaskHUAWEI = extern "system" fn(commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout);
extern "system" fn dummy_vkCmdBindInvocationMaskHUAWEI(_: VkCommandBuffer, _: VkImageView, _: VkImageLayout) {
	panic!("Vulkan function pointer of `vkCmdBindInvocationMaskHUAWEI()` is NULL");
}
pub trait VK_HUAWEI_invocation_mask: Debug {
	fn vkCmdBindInvocationMaskHUAWEI(&self, commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_HUAWEI_invocation_mask {
	vk_cmd_bind_invocation_mask_huawei: PFN_vkCmdBindInvocationMaskHUAWEI,
}
impl VK_HUAWEI_invocation_mask for Vulkan_HUAWEI_invocation_mask {
	fn vkCmdBindInvocationMaskHUAWEI(&self, commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) {
		(self.vk_cmd_bind_invocation_mask_huawei)(commandBuffer, imageView, imageLayout)
	}
}
impl Default for Vulkan_HUAWEI_invocation_mask {
	fn default() -> Self {
		Self {
			vk_cmd_bind_invocation_mask_huawei: dummy_vkCmdBindInvocationMaskHUAWEI,
		}
	}
}
impl Vulkan_HUAWEI_invocation_mask {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_bind_invocation_mask_huawei: {let proc = get_proc_address(instance, "vkCmdBindInvocationMaskHUAWEI"); if proc == null() {dummy_vkCmdBindInvocationMaskHUAWEI} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkRemoteAddressNV = *mut c_void;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryGetRemoteAddressInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub memory: VkDeviceMemory,
	pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceExternalMemoryRDMAFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub externalMemoryRDMA: VkBool32,
}
type PFN_vkGetMemoryRemoteAddressNV = extern "system" fn(device: VkDevice, pMemoryGetRemoteAddressInfo: *const VkMemoryGetRemoteAddressInfoNV, pAddress: *mut VkRemoteAddressNV) -> VkResult;
extern "system" fn dummy_vkGetMemoryRemoteAddressNV(_: VkDevice, _: *const VkMemoryGetRemoteAddressInfoNV, _: *mut VkRemoteAddressNV) -> VkResult {
	panic!("Vulkan function pointer of `vkGetMemoryRemoteAddressNV()` is NULL");
}
pub trait VK_NV_external_memory_rdma: Debug {
	fn vkGetMemoryRemoteAddressNV(&self, device: VkDevice, pMemoryGetRemoteAddressInfo: *const VkMemoryGetRemoteAddressInfoNV, pAddress: *mut VkRemoteAddressNV) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_external_memory_rdma {
	vk_get_memory_remote_address_nv: PFN_vkGetMemoryRemoteAddressNV,
}
impl VK_NV_external_memory_rdma for Vulkan_NV_external_memory_rdma {
	fn vkGetMemoryRemoteAddressNV(&self, device: VkDevice, pMemoryGetRemoteAddressInfo: *const VkMemoryGetRemoteAddressInfoNV, pAddress: *mut VkRemoteAddressNV) -> VkResult {
		(self.vk_get_memory_remote_address_nv)(device, pMemoryGetRemoteAddressInfo, pAddress)
	}
}
impl Default for Vulkan_NV_external_memory_rdma {
	fn default() -> Self {
		Self {
			vk_get_memory_remote_address_nv: dummy_vkGetMemoryRemoteAddressNV,
		}
	}
}
impl Vulkan_NV_external_memory_rdma {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_memory_remote_address_nv: {let proc = get_proc_address(instance, "vkGetMemoryRemoteAddressNV"); if proc == null() {dummy_vkGetMemoryRemoteAddressNV} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPipelineInfoEXT = VkPipelineInfoKHR;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelinePropertiesIdentifierEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineIdentifier: [u8; VK_UUID_SIZE as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePipelinePropertiesFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelinePropertiesIdentifier: VkBool32,
}
type PFN_vkGetPipelinePropertiesEXT = extern "system" fn(device: VkDevice, pPipelineInfo: *const VkPipelineInfoEXT, pPipelineProperties: *mut VkBaseOutStructure) -> VkResult;
extern "system" fn dummy_vkGetPipelinePropertiesEXT(_: VkDevice, _: *const VkPipelineInfoEXT, _: *mut VkBaseOutStructure) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPipelinePropertiesEXT()` is NULL");
}
pub trait VK_EXT_pipeline_properties: Debug {
	fn vkGetPipelinePropertiesEXT(&self, device: VkDevice, pPipelineInfo: *const VkPipelineInfoEXT, pPipelineProperties: *mut VkBaseOutStructure) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_pipeline_properties {
	vk_get_pipeline_properties_ext: PFN_vkGetPipelinePropertiesEXT,
}
impl VK_EXT_pipeline_properties for Vulkan_EXT_pipeline_properties {
	fn vkGetPipelinePropertiesEXT(&self, device: VkDevice, pPipelineInfo: *const VkPipelineInfoEXT, pPipelineProperties: *mut VkBaseOutStructure) -> VkResult {
		(self.vk_get_pipeline_properties_ext)(device, pPipelineInfo, pPipelineProperties)
	}
}
impl Default for Vulkan_EXT_pipeline_properties {
	fn default() -> Self {
		Self {
			vk_get_pipeline_properties_ext: dummy_vkGetPipelinePropertiesEXT,
		}
	}
}
impl Vulkan_EXT_pipeline_properties {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_pipeline_properties_ext: {let proc = get_proc_address(instance, "vkGetPipelinePropertiesEXT"); if proc == null() {dummy_vkGetPipelinePropertiesEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkFrameBoundaryFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFrameBoundaryFlagBitsEXT {
	VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT = 0x00000001,
	VK_FRAME_BOUNDARY_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFrameBoundaryFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub frameBoundary: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkFrameBoundaryEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkFrameBoundaryFlagsEXT,
	pub frameID: u64,
	pub imageCount: u32,
	pub pImages: *const VkImage,
	pub bufferCount: u32,
	pub pBuffers: *const VkBuffer,
	pub tagName: u64,
	pub tagSize: usize,
	pub pTag: *const c_void,
}
pub trait VK_EXT_frame_boundary: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_frame_boundary {}
impl VK_EXT_frame_boundary for Vulkan_EXT_frame_boundary {}
impl Default for Vulkan_EXT_frame_boundary {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_frame_boundary {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub multisampledRenderToSingleSampled: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSubpassResolvePerformanceQueryEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub optimal: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMultisampledRenderToSingleSampledInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub multisampledRenderToSingleSampledEnable: VkBool32,
	pub rasterizationSamples: VkSampleCountFlagBits,
}
pub trait VK_EXT_multisampled_render_to_single_sampled: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_multisampled_render_to_single_sampled {}
impl VK_EXT_multisampled_render_to_single_sampled for Vulkan_EXT_multisampled_render_to_single_sampled {}
impl Default for Vulkan_EXT_multisampled_render_to_single_sampled {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_multisampled_render_to_single_sampled {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceExtendedDynamicState2FeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub extendedDynamicState2: VkBool32,
	pub extendedDynamicState2LogicOp: VkBool32,
	pub extendedDynamicState2PatchControlPoints: VkBool32,
}
type PFN_vkCmdSetPatchControlPointsEXT = extern "system" fn(commandBuffer: VkCommandBuffer, patchControlPoints: u32);
type PFN_vkCmdSetRasterizerDiscardEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32);
type PFN_vkCmdSetDepthBiasEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32);
type PFN_vkCmdSetLogicOpEXT = extern "system" fn(commandBuffer: VkCommandBuffer, logicOp: VkLogicOp);
type PFN_vkCmdSetPrimitiveRestartEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32);
extern "system" fn dummy_vkCmdSetPatchControlPointsEXT(_: VkCommandBuffer, _: u32) {
	panic!("Vulkan function pointer of `vkCmdSetPatchControlPointsEXT()` is NULL");
}
pub trait VK_EXT_extended_dynamic_state2: Debug {
	fn vkCmdSetPatchControlPointsEXT(&self, commandBuffer: VkCommandBuffer, patchControlPoints: u32);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_extended_dynamic_state2 {
	vk_cmd_set_patch_control_points_ext: PFN_vkCmdSetPatchControlPointsEXT,
}
impl VK_EXT_extended_dynamic_state2 for Vulkan_EXT_extended_dynamic_state2 {
	fn vkCmdSetPatchControlPointsEXT(&self, commandBuffer: VkCommandBuffer, patchControlPoints: u32) {
		(self.vk_cmd_set_patch_control_points_ext)(commandBuffer, patchControlPoints)
	}
}
impl Default for Vulkan_EXT_extended_dynamic_state2 {
	fn default() -> Self {
		Self {
			vk_cmd_set_patch_control_points_ext: dummy_vkCmdSetPatchControlPointsEXT,
		}
	}
}
impl Vulkan_EXT_extended_dynamic_state2 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_patch_control_points_ext: {let proc = get_proc_address(instance, "vkCmdSetPatchControlPointsEXT"); if proc == null() {dummy_vkCmdSetPatchControlPointsEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceColorWriteEnableFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub colorWriteEnable: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineColorWriteCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub attachmentCount: u32,
	pub pColorWriteEnables: *const VkBool32,
}
type PFN_vkCmdSetColorWriteEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, attachmentCount: u32, pColorWriteEnables: *const VkBool32);
extern "system" fn dummy_vkCmdSetColorWriteEnableEXT(_: VkCommandBuffer, _: u32, _: *const VkBool32) {
	panic!("Vulkan function pointer of `vkCmdSetColorWriteEnableEXT()` is NULL");
}
pub trait VK_EXT_color_write_enable: Debug {
	fn vkCmdSetColorWriteEnableEXT(&self, commandBuffer: VkCommandBuffer, attachmentCount: u32, pColorWriteEnables: *const VkBool32);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_color_write_enable {
	vk_cmd_set_color_write_enable_ext: PFN_vkCmdSetColorWriteEnableEXT,
}
impl VK_EXT_color_write_enable for Vulkan_EXT_color_write_enable {
	fn vkCmdSetColorWriteEnableEXT(&self, commandBuffer: VkCommandBuffer, attachmentCount: u32, pColorWriteEnables: *const VkBool32) {
		(self.vk_cmd_set_color_write_enable_ext)(commandBuffer, attachmentCount, pColorWriteEnables)
	}
}
impl Default for Vulkan_EXT_color_write_enable {
	fn default() -> Self {
		Self {
			vk_cmd_set_color_write_enable_ext: dummy_vkCmdSetColorWriteEnableEXT,
		}
	}
}
impl Vulkan_EXT_color_write_enable {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_color_write_enable_ext: {let proc = get_proc_address(instance, "vkCmdSetColorWriteEnableEXT"); if proc == null() {dummy_vkCmdSetColorWriteEnableEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub primitivesGeneratedQuery: VkBool32,
	pub primitivesGeneratedQueryWithRasterizerDiscard: VkBool32,
	pub primitivesGeneratedQueryWithNonZeroStreams: VkBool32,
}
pub trait VK_EXT_primitives_generated_query: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_primitives_generated_query {}
impl VK_EXT_primitives_generated_query for Vulkan_EXT_primitives_generated_query {}
impl Default for Vulkan_EXT_primitives_generated_query {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_primitives_generated_query {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const VK_MAX_GLOBAL_PRIORITY_SIZE_EXT: u32 = 16u32;
pub type VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT = VkPhysicalDeviceGlobalPriorityQueryFeatures;
pub type VkQueueFamilyGlobalPriorityPropertiesEXT = VkQueueFamilyGlobalPriorityProperties;
pub trait VK_EXT_global_priority_query: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_global_priority_query {}
impl VK_EXT_global_priority_query for Vulkan_EXT_global_priority_query {}
impl Default for Vulkan_EXT_global_priority_query {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_global_priority_query {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceImageViewMinLodFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minLod: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageViewMinLodCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub minLod: f32,
}
pub trait VK_EXT_image_view_min_lod: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_image_view_min_lod {}
impl VK_EXT_image_view_min_lod for Vulkan_EXT_image_view_min_lod {}
impl Default for Vulkan_EXT_image_view_min_lod {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_image_view_min_lod {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMultiDrawFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub multiDraw: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMultiDrawPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxMultiDrawCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMultiDrawInfoEXT {
	pub firstVertex: u32,
	pub vertexCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMultiDrawIndexedInfoEXT {
	pub firstIndex: u32,
	pub indexCount: u32,
	pub vertexOffset: i32,
}
type PFN_vkCmdDrawMultiEXT = extern "system" fn(commandBuffer: VkCommandBuffer, drawCount: u32, pVertexInfo: *const VkMultiDrawInfoEXT, instanceCount: u32, firstInstance: u32, stride: u32);
type PFN_vkCmdDrawMultiIndexedEXT = extern "system" fn(commandBuffer: VkCommandBuffer, drawCount: u32, pIndexInfo: *const VkMultiDrawIndexedInfoEXT, instanceCount: u32, firstInstance: u32, stride: u32, pVertexOffset: *const int32_t);
extern "system" fn dummy_vkCmdDrawMultiEXT(_: VkCommandBuffer, _: u32, _: *const VkMultiDrawInfoEXT, _: u32, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdDrawMultiEXT()` is NULL");
}
pub trait VK_EXT_multi_draw: Debug {
	fn vkCmdDrawMultiEXT(&self, commandBuffer: VkCommandBuffer, drawCount: u32, pVertexInfo: *const VkMultiDrawInfoEXT, instanceCount: u32, firstInstance: u32, stride: u32);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_multi_draw {
	vk_cmd_draw_multi_ext: PFN_vkCmdDrawMultiEXT,
}
impl VK_EXT_multi_draw for Vulkan_EXT_multi_draw {
	fn vkCmdDrawMultiEXT(&self, commandBuffer: VkCommandBuffer, drawCount: u32, pVertexInfo: *const VkMultiDrawInfoEXT, instanceCount: u32, firstInstance: u32, stride: u32) {
		(self.vk_cmd_draw_multi_ext)(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride)
	}
}
impl Default for Vulkan_EXT_multi_draw {
	fn default() -> Self {
		Self {
			vk_cmd_draw_multi_ext: dummy_vkCmdDrawMultiEXT,
		}
	}
}
impl Vulkan_EXT_multi_draw {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_draw_multi_ext: {let proc = get_proc_address(instance, "vkCmdDrawMultiEXT"); if proc == null() {dummy_vkCmdDrawMultiEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceImage2DViewOf3DFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub image2DViewOf3D: VkBool32,
	pub sampler2DViewOf3D: VkBool32,
}
pub trait VK_EXT_image_2d_view_of_3d: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_image_2d_view_of_3d {}
impl VK_EXT_image_2d_view_of_3d for Vulkan_EXT_image_2d_view_of_3d {}
impl Default for Vulkan_EXT_image_2d_view_of_3d {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_image_2d_view_of_3d {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderTileImageFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderTileImageColorReadAccess: VkBool32,
	pub shaderTileImageDepthReadAccess: VkBool32,
	pub shaderTileImageStencilReadAccess: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderTileImagePropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderTileImageCoherentReadAccelerated: VkBool32,
	pub shaderTileImageReadSampleFromPixelRateInvocation: VkBool32,
	pub shaderTileImageReadFromHelperInvocation: VkBool32,
}
pub trait VK_EXT_shader_tile_image: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_tile_image {}
impl VK_EXT_shader_tile_image for Vulkan_EXT_shader_tile_image {}
impl Default for Vulkan_EXT_shader_tile_image {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_tile_image {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkBuildMicromapFlagsEXT = VkFlags;
pub type VkMicromapCreateFlagsEXT = VkFlags;
// Define non-dispatchable handle `VkMicromapEXT`
#[cfg(target_pointer_width = "32")] pub type VkMicromapEXT = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkMicromapEXT_T {}
#[cfg(target_pointer_width = "64")] pub type VkMicromapEXT = *const VkMicromapEXT_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkMicromapTypeEXT {
	VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT = 0,
	VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV = 1000397000,
	VK_MICROMAP_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBuildMicromapModeEXT {
	VK_BUILD_MICROMAP_MODE_BUILD_EXT = 0,
	VK_BUILD_MICROMAP_MODE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCopyMicromapModeEXT {
	VK_COPY_MICROMAP_MODE_CLONE_EXT = 0,
	VK_COPY_MICROMAP_MODE_SERIALIZE_EXT = 1,
	VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT = 2,
	VK_COPY_MICROMAP_MODE_COMPACT_EXT = 3,
	VK_COPY_MICROMAP_MODE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOpacityMicromapFormatEXT {
	VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT = 1,
	VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT = 2,
	VK_OPACITY_MICROMAP_FORMAT_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOpacityMicromapSpecialIndexEXT {
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT = -1,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT = -2,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT = -3,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT = -4,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV = -5,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAccelerationStructureCompatibilityKHR {
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = 0,
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = 1,
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAccelerationStructureBuildTypeKHR {
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0,
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 1,
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 2,
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBuildMicromapFlagBitsEXT {
	VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT = 0x00000001,
	VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT = 0x00000002,
	VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT = 0x00000004,
	VK_BUILD_MICROMAP_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkMicromapCreateFlagBitsEXT {
	VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 0x00000001,
	VK_MICROMAP_CREATE_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkDeviceOrHostAddressKHR {
	pub deviceAddress: VkDeviceAddress,
	pub hostAddress: *mut c_void,
}
impl Debug for VkDeviceOrHostAddressKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceOrHostAddressKHR")
		.field("deviceAddress", unsafe {&self.deviceAddress})
		.field("hostAddress", unsafe {&self.hostAddress})
		.finish()
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMicromapUsageEXT {
	pub count: u32,
	pub subdivisionLevel: u32,
	pub format: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMicromapBuildInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkMicromapTypeEXT,
	pub flags: VkBuildMicromapFlagsEXT,
	pub mode: VkBuildMicromapModeEXT,
	pub dstMicromap: VkMicromapEXT,
	pub usageCountsCount: u32,
	pub pUsageCounts: *const VkMicromapUsageEXT,
	pub ppUsageCounts: *const *const VkMicromapUsageEXT,
	pub data: VkDeviceOrHostAddressConstKHR,
	pub scratchData: VkDeviceOrHostAddressKHR,
	pub triangleArray: VkDeviceOrHostAddressConstKHR,
	pub triangleArrayStride: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMicromapCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub createFlags: VkMicromapCreateFlagsEXT,
	pub buffer: VkBuffer,
	pub offset: VkDeviceSize,
	pub size: VkDeviceSize,
	pub type_: VkMicromapTypeEXT,
	pub deviceAddress: VkDeviceAddress,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceOpacityMicromapFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub micromap: VkBool32,
	pub micromapCaptureReplay: VkBool32,
	pub micromapHostCommands: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceOpacityMicromapPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxOpacity2StateSubdivisionLevel: u32,
	pub maxOpacity4StateSubdivisionLevel: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMicromapVersionInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pVersionData: *const uint8_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyMicromapToMemoryInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub src: VkMicromapEXT,
	pub dst: VkDeviceOrHostAddressKHR,
	pub mode: VkCopyMicromapModeEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyMemoryToMicromapInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub src: VkDeviceOrHostAddressConstKHR,
	pub dst: VkMicromapEXT,
	pub mode: VkCopyMicromapModeEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyMicromapInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub src: VkMicromapEXT,
	pub dst: VkMicromapEXT,
	pub mode: VkCopyMicromapModeEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMicromapBuildSizesInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub micromapSize: VkDeviceSize,
	pub buildScratchSize: VkDeviceSize,
	pub discardable: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureTrianglesOpacityMicromapEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub indexType: VkIndexType,
	pub indexBuffer: VkDeviceOrHostAddressConstKHR,
	pub indexStride: VkDeviceSize,
	pub baseTriangle: u32,
	pub usageCountsCount: u32,
	pub pUsageCounts: *const VkMicromapUsageEXT,
	pub ppUsageCounts: *const *const VkMicromapUsageEXT,
	pub micromap: VkMicromapEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMicromapTriangleEXT {
	pub dataOffset: u32,
	pub subdivisionLevel: u16,
	pub format: u16,
}
type PFN_vkCreateMicromapEXT = extern "system" fn(device: VkDevice, pCreateInfo: *const VkMicromapCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pMicromap: *mut VkMicromapEXT) -> VkResult;
type PFN_vkDestroyMicromapEXT = extern "system" fn(device: VkDevice, micromap: VkMicromapEXT, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCmdBuildMicromapsEXT = extern "system" fn(commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *const VkMicromapBuildInfoEXT);
type PFN_vkBuildMicromapsEXT = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, infoCount: u32, pInfos: *const VkMicromapBuildInfoEXT) -> VkResult;
type PFN_vkCopyMicromapEXT = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *const VkCopyMicromapInfoEXT) -> VkResult;
type PFN_vkCopyMicromapToMemoryEXT = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *const VkCopyMicromapToMemoryInfoEXT) -> VkResult;
type PFN_vkCopyMemoryToMicromapEXT = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *const VkCopyMemoryToMicromapInfoEXT) -> VkResult;
type PFN_vkWriteMicromapsPropertiesEXT = extern "system" fn(device: VkDevice, micromapCount: u32, pMicromaps: *const VkMicromapEXT, queryType: VkQueryType, dataSize: usize, pData: *mut c_void, stride: usize) -> VkResult;
type PFN_vkCmdCopyMicromapEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pInfo: *const VkCopyMicromapInfoEXT);
type PFN_vkCmdCopyMicromapToMemoryEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pInfo: *const VkCopyMicromapToMemoryInfoEXT);
type PFN_vkCmdCopyMemoryToMicromapEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pInfo: *const VkCopyMemoryToMicromapInfoEXT);
type PFN_vkCmdWriteMicromapsPropertiesEXT = extern "system" fn(commandBuffer: VkCommandBuffer, micromapCount: u32, pMicromaps: *const VkMicromapEXT, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: u32);
type PFN_vkGetDeviceMicromapCompatibilityEXT = extern "system" fn(device: VkDevice, pVersionInfo: *const VkMicromapVersionInfoEXT, pCompatibility: *mut VkAccelerationStructureCompatibilityKHR);
type PFN_vkGetMicromapBuildSizesEXT = extern "system" fn(device: VkDevice, buildType: VkAccelerationStructureBuildTypeKHR, pBuildInfo: *const VkMicromapBuildInfoEXT, pSizeInfo: *mut VkMicromapBuildSizesInfoEXT);
extern "system" fn dummy_vkCreateMicromapEXT(_: VkDevice, _: *const VkMicromapCreateInfoEXT, _: *const VkAllocationCallbacks, _: *mut VkMicromapEXT) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateMicromapEXT()` is NULL");
}
pub trait VK_EXT_opacity_micromap: Debug {
	fn vkCreateMicromapEXT(&self, device: VkDevice, pCreateInfo: *const VkMicromapCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pMicromap: *mut VkMicromapEXT) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_opacity_micromap {
	vk_create_micromap_ext: PFN_vkCreateMicromapEXT,
}
impl VK_EXT_opacity_micromap for Vulkan_EXT_opacity_micromap {
	fn vkCreateMicromapEXT(&self, device: VkDevice, pCreateInfo: *const VkMicromapCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pMicromap: *mut VkMicromapEXT) -> VkResult {
		(self.vk_create_micromap_ext)(device, pCreateInfo, pAllocator, pMicromap)
	}
}
impl Default for Vulkan_EXT_opacity_micromap {
	fn default() -> Self {
		Self {
			vk_create_micromap_ext: dummy_vkCreateMicromapEXT,
		}
	}
}
impl Vulkan_EXT_opacity_micromap {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_micromap_ext: {let proc = get_proc_address(instance, "vkCreateMicromapEXT"); if proc == null() {dummy_vkCreateMicromapEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub trait VK_EXT_load_store_op_none: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_load_store_op_none {}
impl VK_EXT_load_store_op_none for Vulkan_EXT_load_store_op_none {}
impl Default for Vulkan_EXT_load_store_op_none {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_load_store_op_none {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub clustercullingShader: VkBool32,
	pub multiviewClusterCullingShader: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxWorkGroupCount: [u32; 3 as usize],
	pub maxWorkGroupSize: [u32; 3 as usize],
	pub maxOutputClusterCount: u32,
	pub indirectBufferOffsetAlignment: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub clusterShadingRate: VkBool32,
}
type PFN_vkCmdDrawClusterHUAWEI = extern "system" fn(commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32);
type PFN_vkCmdDrawClusterIndirectHUAWEI = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize);
extern "system" fn dummy_vkCmdDrawClusterHUAWEI(_: VkCommandBuffer, _: u32, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdDrawClusterHUAWEI()` is NULL");
}
pub trait VK_HUAWEI_cluster_culling_shader: Debug {
	fn vkCmdDrawClusterHUAWEI(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_HUAWEI_cluster_culling_shader {
	vk_cmd_draw_cluster_huawei: PFN_vkCmdDrawClusterHUAWEI,
}
impl VK_HUAWEI_cluster_culling_shader for Vulkan_HUAWEI_cluster_culling_shader {
	fn vkCmdDrawClusterHUAWEI(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) {
		(self.vk_cmd_draw_cluster_huawei)(commandBuffer, groupCountX, groupCountY, groupCountZ)
	}
}
impl Default for Vulkan_HUAWEI_cluster_culling_shader {
	fn default() -> Self {
		Self {
			vk_cmd_draw_cluster_huawei: dummy_vkCmdDrawClusterHUAWEI,
		}
	}
}
impl Vulkan_HUAWEI_cluster_culling_shader {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_draw_cluster_huawei: {let proc = get_proc_address(instance, "vkCmdDrawClusterHUAWEI"); if proc == null() {dummy_vkCmdDrawClusterHUAWEI} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceBorderColorSwizzleFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub borderColorSwizzle: VkBool32,
	pub borderColorSwizzleFromImage: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSamplerBorderColorComponentMappingCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub components: VkComponentMapping,
	pub srgb: VkBool32,
}
pub trait VK_EXT_border_color_swizzle: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_border_color_swizzle {}
impl VK_EXT_border_color_swizzle for Vulkan_EXT_border_color_swizzle {}
impl Default for Vulkan_EXT_border_color_swizzle {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_border_color_swizzle {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pageableDeviceLocalMemory: VkBool32,
}
type PFN_vkSetDeviceMemoryPriorityEXT = extern "system" fn(device: VkDevice, memory: VkDeviceMemory, priority: f32);
extern "system" fn dummy_vkSetDeviceMemoryPriorityEXT(_: VkDevice, _: VkDeviceMemory, _: f32) {
	panic!("Vulkan function pointer of `vkSetDeviceMemoryPriorityEXT()` is NULL");
}
pub trait VK_EXT_pageable_device_local_memory: Debug {
	fn vkSetDeviceMemoryPriorityEXT(&self, device: VkDevice, memory: VkDeviceMemory, priority: f32);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_pageable_device_local_memory {
	vk_set_device_memory_priority_ext: PFN_vkSetDeviceMemoryPriorityEXT,
}
impl VK_EXT_pageable_device_local_memory for Vulkan_EXT_pageable_device_local_memory {
	fn vkSetDeviceMemoryPriorityEXT(&self, device: VkDevice, memory: VkDeviceMemory, priority: f32) {
		(self.vk_set_device_memory_priority_ext)(device, memory, priority)
	}
}
impl Default for Vulkan_EXT_pageable_device_local_memory {
	fn default() -> Self {
		Self {
			vk_set_device_memory_priority_ext: dummy_vkSetDeviceMemoryPriorityEXT,
		}
	}
}
impl Vulkan_EXT_pageable_device_local_memory {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_set_device_memory_priority_ext: {let proc = get_proc_address(instance, "vkSetDeviceMemoryPriorityEXT"); if proc == null() {dummy_vkSetDeviceMemoryPriorityEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderCorePropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pixelRate: u32,
	pub texelRate: u32,
	pub fmaRate: u32,
}
pub trait VK_ARM_shader_core_properties: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_shader_core_properties {}
impl VK_ARM_shader_core_properties for Vulkan_ARM_shader_core_properties {}
impl Default for Vulkan_ARM_shader_core_properties {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_ARM_shader_core_properties {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceSchedulingControlsFlagsARM = VkFlags64;
pub type VkPhysicalDeviceSchedulingControlsFlagBitsARM = VkFlags64;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceQueueShaderCoreControlCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderCoreCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSchedulingControlsFeaturesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub schedulingControls: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSchedulingControlsPropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub schedulingControlsFlags: VkPhysicalDeviceSchedulingControlsFlagsARM,
}
pub trait VK_ARM_scheduling_controls: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_scheduling_controls {}
impl VK_ARM_scheduling_controls for Vulkan_ARM_scheduling_controls {}
impl Default for Vulkan_ARM_scheduling_controls {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_ARM_scheduling_controls {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub const VK_REMAINING_3D_SLICES_EXT: u32 = !0u32;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageSlicedViewOf3D: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageViewSlicedCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub sliceOffset: u32,
	pub sliceCount: u32,
}
pub trait VK_EXT_image_sliced_view_of_3d: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_image_sliced_view_of_3d {}
impl VK_EXT_image_sliced_view_of_3d for Vulkan_EXT_image_sliced_view_of_3d {}
impl Default for Vulkan_EXT_image_sliced_view_of_3d {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_image_sliced_view_of_3d {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub descriptorSetHostMapping: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorSetBindingReferenceVALVE {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub descriptorSetLayout: VkDescriptorSetLayout,
	pub binding: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorSetLayoutHostMappingInfoVALVE {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub descriptorOffset: usize,
	pub descriptorSize: u32,
}
type PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE = extern "system" fn(device: VkDevice, pBindingReference: *const VkDescriptorSetBindingReferenceVALVE, pHostMapping: *mut VkDescriptorSetLayoutHostMappingInfoVALVE);
type PFN_vkGetDescriptorSetHostMappingVALVE = extern "system" fn(device: VkDevice, descriptorSet: VkDescriptorSet, ppData: *mut *mut c_void);
extern "system" fn dummy_vkGetDescriptorSetLayoutHostMappingInfoVALVE(_: VkDevice, _: *const VkDescriptorSetBindingReferenceVALVE, _: *mut VkDescriptorSetLayoutHostMappingInfoVALVE) {
	panic!("Vulkan function pointer of `vkGetDescriptorSetLayoutHostMappingInfoVALVE()` is NULL");
}
pub trait VK_VALVE_descriptor_set_host_mapping: Debug {
	fn vkGetDescriptorSetLayoutHostMappingInfoVALVE(&self, device: VkDevice, pBindingReference: *const VkDescriptorSetBindingReferenceVALVE, pHostMapping: *mut VkDescriptorSetLayoutHostMappingInfoVALVE);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_VALVE_descriptor_set_host_mapping {
	vk_get_descriptor_set_layout_host_mapping_info_valve: PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE,
}
impl VK_VALVE_descriptor_set_host_mapping for Vulkan_VALVE_descriptor_set_host_mapping {
	fn vkGetDescriptorSetLayoutHostMappingInfoVALVE(&self, device: VkDevice, pBindingReference: *const VkDescriptorSetBindingReferenceVALVE, pHostMapping: *mut VkDescriptorSetLayoutHostMappingInfoVALVE) {
		(self.vk_get_descriptor_set_layout_host_mapping_info_valve)(device, pBindingReference, pHostMapping)
	}
}
impl Default for Vulkan_VALVE_descriptor_set_host_mapping {
	fn default() -> Self {
		Self {
			vk_get_descriptor_set_layout_host_mapping_info_valve: dummy_vkGetDescriptorSetLayoutHostMappingInfoVALVE,
		}
	}
}
impl Vulkan_VALVE_descriptor_set_host_mapping {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_descriptor_set_layout_host_mapping_info_valve: {let proc = get_proc_address(instance, "vkGetDescriptorSetLayoutHostMappingInfoVALVE"); if proc == null() {dummy_vkGetDescriptorSetLayoutHostMappingInfoVALVE} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkPhysicalDeviceDepthClampZeroOneFeaturesEXT = VkPhysicalDeviceDepthClampZeroOneFeaturesKHR;
pub trait VK_EXT_depth_clamp_zero_one: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_depth_clamp_zero_one {}
impl VK_EXT_depth_clamp_zero_one for Vulkan_EXT_depth_clamp_zero_one {}
impl Default for Vulkan_EXT_depth_clamp_zero_one {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_depth_clamp_zero_one {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub nonSeamlessCubeMap: VkBool32,
}
pub trait VK_EXT_non_seamless_cube_map: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_non_seamless_cube_map {}
impl VK_EXT_non_seamless_cube_map for Vulkan_EXT_non_seamless_cube_map {}
impl Default for Vulkan_EXT_non_seamless_cube_map {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_non_seamless_cube_map {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRenderPassStripedFeaturesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub renderPassStriped: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRenderPassStripedPropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub renderPassStripeGranularity: VkExtent2D,
	pub maxRenderPassStripes: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassStripeInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stripeArea: VkRect2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassStripeBeginInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stripeInfoCount: u32,
	pub pStripeInfos: *const VkRenderPassStripeInfoARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassStripeSubmitInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stripeSemaphoreInfoCount: u32,
	pub pStripeSemaphoreInfos: *const VkSemaphoreSubmitInfo,
}
pub trait VK_ARM_render_pass_striped: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_render_pass_striped {}
impl VK_ARM_render_pass_striped for Vulkan_ARM_render_pass_striped {}
impl Default for Vulkan_ARM_render_pass_striped {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_ARM_render_pass_striped {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM = VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT;
pub type VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM = VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT;
pub type VkSubpassFragmentDensityMapOffsetEndInfoQCOM = VkRenderPassFragmentDensityMapOffsetEndInfoEXT;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub fragmentDensityMapOffset: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub fragmentDensityOffsetGranularity: VkExtent2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassFragmentDensityMapOffsetEndInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub fragmentDensityOffsetCount: u32,
	pub pFragmentDensityOffsets: *const VkOffset2D,
}
pub trait VK_QCOM_fragment_density_map_offset: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_fragment_density_map_offset {}
impl VK_QCOM_fragment_density_map_offset for Vulkan_QCOM_fragment_density_map_offset {}
impl Default for Vulkan_QCOM_fragment_density_map_offset {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_fragment_density_map_offset {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyMemoryIndirectCommandNV {
	pub srcAddress: VkDeviceAddress,
	pub dstAddress: VkDeviceAddress,
	pub size: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyMemoryToImageIndirectCommandNV {
	pub srcAddress: VkDeviceAddress,
	pub bufferRowLength: u32,
	pub bufferImageHeight: u32,
	pub imageSubresource: VkImageSubresourceLayers,
	pub imageOffset: VkOffset3D,
	pub imageExtent: VkExtent3D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCopyMemoryIndirectFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub indirectCopy: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCopyMemoryIndirectPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub supportedQueues: VkQueueFlags,
}
type PFN_vkCmdCopyMemoryIndirectNV = extern "system" fn(commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: u32, stride: u32);
type PFN_vkCmdCopyMemoryToImageIndirectNV = extern "system" fn(commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: u32, stride: u32, dstImage: VkImage, dstImageLayout: VkImageLayout, pImageSubresources: *const VkImageSubresourceLayers);
extern "system" fn dummy_vkCmdCopyMemoryIndirectNV(_: VkCommandBuffer, _: VkDeviceAddress, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdCopyMemoryIndirectNV()` is NULL");
}
pub trait VK_NV_copy_memory_indirect: Debug {
	fn vkCmdCopyMemoryIndirectNV(&self, commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: u32, stride: u32);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_copy_memory_indirect {
	vk_cmd_copy_memory_indirect_nv: PFN_vkCmdCopyMemoryIndirectNV,
}
impl VK_NV_copy_memory_indirect for Vulkan_NV_copy_memory_indirect {
	fn vkCmdCopyMemoryIndirectNV(&self, commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: u32, stride: u32) {
		(self.vk_cmd_copy_memory_indirect_nv)(commandBuffer, copyBufferAddress, copyCount, stride)
	}
}
impl Default for Vulkan_NV_copy_memory_indirect {
	fn default() -> Self {
		Self {
			vk_cmd_copy_memory_indirect_nv: dummy_vkCmdCopyMemoryIndirectNV,
		}
	}
}
impl Vulkan_NV_copy_memory_indirect {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_copy_memory_indirect_nv: {let proc = get_proc_address(instance, "vkCmdCopyMemoryIndirectNV"); if proc == null() {dummy_vkCmdCopyMemoryIndirectNV} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkMemoryDecompressionMethodFlagBitsNV = VkFlags64;
pub type VkMemoryDecompressionMethodFlagsNV = VkFlags64;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDecompressMemoryRegionNV {
	pub srcAddress: VkDeviceAddress,
	pub dstAddress: VkDeviceAddress,
	pub compressedSize: VkDeviceSize,
	pub decompressedSize: VkDeviceSize,
	pub decompressionMethod: VkMemoryDecompressionMethodFlagsNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMemoryDecompressionFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryDecompression: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMemoryDecompressionPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub decompressionMethods: VkMemoryDecompressionMethodFlagsNV,
	pub maxDecompressionIndirectCount: u64,
}
type PFN_vkCmdDecompressMemoryNV = extern "system" fn(commandBuffer: VkCommandBuffer, decompressRegionCount: u32, pDecompressMemoryRegions: *const VkDecompressMemoryRegionNV);
type PFN_vkCmdDecompressMemoryIndirectCountNV = extern "system" fn(commandBuffer: VkCommandBuffer, indirectCommandsAddress: VkDeviceAddress, indirectCommandsCountAddress: VkDeviceAddress, stride: u32);
extern "system" fn dummy_vkCmdDecompressMemoryNV(_: VkCommandBuffer, _: u32, _: *const VkDecompressMemoryRegionNV) {
	panic!("Vulkan function pointer of `vkCmdDecompressMemoryNV()` is NULL");
}
pub trait VK_NV_memory_decompression: Debug {
	fn vkCmdDecompressMemoryNV(&self, commandBuffer: VkCommandBuffer, decompressRegionCount: u32, pDecompressMemoryRegions: *const VkDecompressMemoryRegionNV);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_memory_decompression {
	vk_cmd_decompress_memory_nv: PFN_vkCmdDecompressMemoryNV,
}
impl VK_NV_memory_decompression for Vulkan_NV_memory_decompression {
	fn vkCmdDecompressMemoryNV(&self, commandBuffer: VkCommandBuffer, decompressRegionCount: u32, pDecompressMemoryRegions: *const VkDecompressMemoryRegionNV) {
		(self.vk_cmd_decompress_memory_nv)(commandBuffer, decompressRegionCount, pDecompressMemoryRegions)
	}
}
impl Default for Vulkan_NV_memory_decompression {
	fn default() -> Self {
		Self {
			vk_cmd_decompress_memory_nv: dummy_vkCmdDecompressMemoryNV,
		}
	}
}
impl Vulkan_NV_memory_decompression {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_decompress_memory_nv: {let proc = get_proc_address(instance, "vkCmdDecompressMemoryNV"); if proc == null() {dummy_vkCmdDecompressMemoryNV} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceGeneratedCompute: VkBool32,
	pub deviceGeneratedComputePipelines: VkBool32,
	pub deviceGeneratedComputeCaptureReplay: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkComputePipelineIndirectBufferInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub deviceAddress: VkDeviceAddress,
	pub size: VkDeviceSize,
	pub pipelineDeviceAddressCaptureReplay: VkDeviceAddress,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineIndirectDeviceAddressInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pipelineBindPoint: VkPipelineBindPoint,
	pub pipeline: VkPipeline,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindPipelineIndirectCommandNV {
	pub pipelineAddress: VkDeviceAddress,
}
type PFN_vkGetPipelineIndirectMemoryRequirementsNV = extern "system" fn(device: VkDevice, pCreateInfo: *const VkComputePipelineCreateInfo, pMemoryRequirements: *mut VkMemoryRequirements2);
type PFN_vkCmdUpdatePipelineIndirectBufferNV = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline);
type PFN_vkGetPipelineIndirectDeviceAddressNV = extern "system" fn(device: VkDevice, pInfo: *const VkPipelineIndirectDeviceAddressInfoNV) -> VkDeviceAddress;
extern "system" fn dummy_vkGetPipelineIndirectMemoryRequirementsNV(_: VkDevice, _: *const VkComputePipelineCreateInfo, _: *mut VkMemoryRequirements2) {
	panic!("Vulkan function pointer of `vkGetPipelineIndirectMemoryRequirementsNV()` is NULL");
}
pub trait VK_NV_device_generated_commands_compute: Debug {
	fn vkGetPipelineIndirectMemoryRequirementsNV(&self, device: VkDevice, pCreateInfo: *const VkComputePipelineCreateInfo, pMemoryRequirements: *mut VkMemoryRequirements2);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_device_generated_commands_compute {
	vk_get_pipeline_indirect_memory_requirements_nv: PFN_vkGetPipelineIndirectMemoryRequirementsNV,
}
impl VK_NV_device_generated_commands_compute for Vulkan_NV_device_generated_commands_compute {
	fn vkGetPipelineIndirectMemoryRequirementsNV(&self, device: VkDevice, pCreateInfo: *const VkComputePipelineCreateInfo, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_get_pipeline_indirect_memory_requirements_nv)(device, pCreateInfo, pMemoryRequirements)
	}
}
impl Default for Vulkan_NV_device_generated_commands_compute {
	fn default() -> Self {
		Self {
			vk_get_pipeline_indirect_memory_requirements_nv: dummy_vkGetPipelineIndirectMemoryRequirementsNV,
		}
	}
}
impl Vulkan_NV_device_generated_commands_compute {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_pipeline_indirect_memory_requirements_nv: {let proc = get_proc_address(instance, "vkGetPipelineIndirectMemoryRequirementsNV"); if proc == null() {dummy_vkGetPipelineIndirectMemoryRequirementsNV} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkRayTracingLssIndexingModeNV {
	VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV = 0,
	VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV = 1,
	VK_RAY_TRACING_LSS_INDEXING_MODE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkRayTracingLssPrimitiveEndCapsModeNV {
	VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV = 0,
	VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV = 1,
	VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub spheres: VkBool32,
	pub linearSweptSpheres: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureGeometryLinearSweptSpheresDataNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub vertexFormat: VkFormat,
	pub vertexData: VkDeviceOrHostAddressConstKHR,
	pub vertexStride: VkDeviceSize,
	pub radiusFormat: VkFormat,
	pub radiusData: VkDeviceOrHostAddressConstKHR,
	pub radiusStride: VkDeviceSize,
	pub indexType: VkIndexType,
	pub indexData: VkDeviceOrHostAddressConstKHR,
	pub indexStride: VkDeviceSize,
	pub indexingMode: VkRayTracingLssIndexingModeNV,
	pub endCapsMode: VkRayTracingLssPrimitiveEndCapsModeNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureGeometrySpheresDataNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub vertexFormat: VkFormat,
	pub vertexData: VkDeviceOrHostAddressConstKHR,
	pub vertexStride: VkDeviceSize,
	pub radiusFormat: VkFormat,
	pub radiusData: VkDeviceOrHostAddressConstKHR,
	pub radiusStride: VkDeviceSize,
	pub indexType: VkIndexType,
	pub indexData: VkDeviceOrHostAddressConstKHR,
	pub indexStride: VkDeviceSize,
}
pub trait VK_NV_ray_tracing_linear_swept_spheres: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_ray_tracing_linear_swept_spheres {}
impl VK_NV_ray_tracing_linear_swept_spheres for Vulkan_NV_ray_tracing_linear_swept_spheres {}
impl Default for Vulkan_NV_ray_tracing_linear_swept_spheres {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_ray_tracing_linear_swept_spheres {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceLinearColorAttachmentFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub linearColorAttachment: VkBool32,
}
pub trait VK_NV_linear_color_attachment: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_linear_color_attachment {}
impl VK_NV_linear_color_attachment for Vulkan_NV_linear_color_attachment {}
impl Default for Vulkan_NV_linear_color_attachment {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_linear_color_attachment {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_GOOGLE_surfaceless_query: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_GOOGLE_surfaceless_query {}
impl VK_GOOGLE_surfaceless_query for Vulkan_GOOGLE_surfaceless_query {}
impl Default for Vulkan_GOOGLE_surfaceless_query {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_GOOGLE_surfaceless_query {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageCompressionControlSwapchain: VkBool32,
}
pub trait VK_EXT_image_compression_control_swapchain: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_image_compression_control_swapchain {}
impl VK_EXT_image_compression_control_swapchain for Vulkan_EXT_image_compression_control_swapchain {}
impl Default for Vulkan_EXT_image_compression_control_swapchain {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_image_compression_control_swapchain {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageViewSampleWeightCreateInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub filterCenter: VkOffset2D,
	pub filterSize: VkExtent2D,
	pub numPhases: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceImageProcessingFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub textureSampleWeighted: VkBool32,
	pub textureBoxFilter: VkBool32,
	pub textureBlockMatch: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceImageProcessingPropertiesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxWeightFilterPhases: u32,
	pub maxWeightFilterDimension: VkExtent2D,
	pub maxBlockMatchRegion: VkExtent2D,
	pub maxBoxFilterBlockSize: VkExtent2D,
}
pub trait VK_QCOM_image_processing: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_image_processing {}
impl VK_QCOM_image_processing for Vulkan_QCOM_image_processing {}
impl Default for Vulkan_QCOM_image_processing {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_image_processing {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceNestedCommandBufferFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub nestedCommandBuffer: VkBool32,
	pub nestedCommandBufferRendering: VkBool32,
	pub nestedCommandBufferSimultaneousUse: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceNestedCommandBufferPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxCommandBufferNestingLevel: u32,
}
pub trait VK_EXT_nested_command_buffer: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_nested_command_buffer {}
impl VK_EXT_nested_command_buffer for Vulkan_EXT_nested_command_buffer {}
impl Default for Vulkan_EXT_nested_command_buffer {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_nested_command_buffer {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExternalMemoryAcquireUnmodifiedEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub acquireUnmodifiedMemory: VkBool32,
}
pub trait VK_EXT_external_memory_acquire_unmodified: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_external_memory_acquire_unmodified {}
impl VK_EXT_external_memory_acquire_unmodified for Vulkan_EXT_external_memory_acquire_unmodified {}
impl Default for Vulkan_EXT_external_memory_acquire_unmodified {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_external_memory_acquire_unmodified {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceExtendedDynamicState3FeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub extendedDynamicState3TessellationDomainOrigin: VkBool32,
	pub extendedDynamicState3DepthClampEnable: VkBool32,
	pub extendedDynamicState3PolygonMode: VkBool32,
	pub extendedDynamicState3RasterizationSamples: VkBool32,
	pub extendedDynamicState3SampleMask: VkBool32,
	pub extendedDynamicState3AlphaToCoverageEnable: VkBool32,
	pub extendedDynamicState3AlphaToOneEnable: VkBool32,
	pub extendedDynamicState3LogicOpEnable: VkBool32,
	pub extendedDynamicState3ColorBlendEnable: VkBool32,
	pub extendedDynamicState3ColorBlendEquation: VkBool32,
	pub extendedDynamicState3ColorWriteMask: VkBool32,
	pub extendedDynamicState3RasterizationStream: VkBool32,
	pub extendedDynamicState3ConservativeRasterizationMode: VkBool32,
	pub extendedDynamicState3ExtraPrimitiveOverestimationSize: VkBool32,
	pub extendedDynamicState3DepthClipEnable: VkBool32,
	pub extendedDynamicState3SampleLocationsEnable: VkBool32,
	pub extendedDynamicState3ColorBlendAdvanced: VkBool32,
	pub extendedDynamicState3ProvokingVertexMode: VkBool32,
	pub extendedDynamicState3LineRasterizationMode: VkBool32,
	pub extendedDynamicState3LineStippleEnable: VkBool32,
	pub extendedDynamicState3DepthClipNegativeOneToOne: VkBool32,
	pub extendedDynamicState3ViewportWScalingEnable: VkBool32,
	pub extendedDynamicState3ViewportSwizzle: VkBool32,
	pub extendedDynamicState3CoverageToColorEnable: VkBool32,
	pub extendedDynamicState3CoverageToColorLocation: VkBool32,
	pub extendedDynamicState3CoverageModulationMode: VkBool32,
	pub extendedDynamicState3CoverageModulationTableEnable: VkBool32,
	pub extendedDynamicState3CoverageModulationTable: VkBool32,
	pub extendedDynamicState3CoverageReductionMode: VkBool32,
	pub extendedDynamicState3RepresentativeFragmentTestEnable: VkBool32,
	pub extendedDynamicState3ShadingRateImageEnable: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceExtendedDynamicState3PropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub dynamicPrimitiveTopologyUnrestricted: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkColorBlendEquationEXT {
	pub srcColorBlendFactor: VkBlendFactor,
	pub dstColorBlendFactor: VkBlendFactor,
	pub colorBlendOp: VkBlendOp,
	pub srcAlphaBlendFactor: VkBlendFactor,
	pub dstAlphaBlendFactor: VkBlendFactor,
	pub alphaBlendOp: VkBlendOp,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkColorBlendAdvancedEXT {
	pub advancedBlendOp: VkBlendOp,
	pub srcPremultiplied: VkBool32,
	pub dstPremultiplied: VkBool32,
	pub blendOverlap: VkBlendOverlapEXT,
	pub clampResults: VkBool32,
}
type PFN_vkCmdSetDepthClampEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, depthClampEnable: VkBool32);
type PFN_vkCmdSetPolygonModeEXT = extern "system" fn(commandBuffer: VkCommandBuffer, polygonMode: VkPolygonMode);
type PFN_vkCmdSetRasterizationSamplesEXT = extern "system" fn(commandBuffer: VkCommandBuffer, rasterizationSamples: VkSampleCountFlagBits);
type PFN_vkCmdSetSampleMaskEXT = extern "system" fn(commandBuffer: VkCommandBuffer, samples: VkSampleCountFlagBits, pSampleMask: *const VkSampleMask);
type PFN_vkCmdSetAlphaToCoverageEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, alphaToCoverageEnable: VkBool32);
type PFN_vkCmdSetAlphaToOneEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, alphaToOneEnable: VkBool32);
type PFN_vkCmdSetLogicOpEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, logicOpEnable: VkBool32);
type PFN_vkCmdSetColorBlendEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorBlendEnables: *const VkBool32);
type PFN_vkCmdSetColorBlendEquationEXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorBlendEquations: *const VkColorBlendEquationEXT);
type PFN_vkCmdSetColorWriteMaskEXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorWriteMasks: *const VkColorComponentFlags);
type PFN_vkCmdSetTessellationDomainOriginEXT = extern "system" fn(commandBuffer: VkCommandBuffer, domainOrigin: VkTessellationDomainOrigin);
type PFN_vkCmdSetRasterizationStreamEXT = extern "system" fn(commandBuffer: VkCommandBuffer, rasterizationStream: u32);
type PFN_vkCmdSetConservativeRasterizationModeEXT = extern "system" fn(commandBuffer: VkCommandBuffer, conservativeRasterizationMode: VkConservativeRasterizationModeEXT);
type PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT = extern "system" fn(commandBuffer: VkCommandBuffer, extraPrimitiveOverestimationSize: f32);
type PFN_vkCmdSetDepthClipEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, depthClipEnable: VkBool32);
type PFN_vkCmdSetSampleLocationsEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, sampleLocationsEnable: VkBool32);
type PFN_vkCmdSetColorBlendAdvancedEXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorBlendAdvanced: *const VkColorBlendAdvancedEXT);
type PFN_vkCmdSetProvokingVertexModeEXT = extern "system" fn(commandBuffer: VkCommandBuffer, provokingVertexMode: VkProvokingVertexModeEXT);
type PFN_vkCmdSetLineRasterizationModeEXT = extern "system" fn(commandBuffer: VkCommandBuffer, lineRasterizationMode: VkLineRasterizationModeEXT);
type PFN_vkCmdSetLineStippleEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, stippledLineEnable: VkBool32);
type PFN_vkCmdSetDepthClipNegativeOneToOneEXT = extern "system" fn(commandBuffer: VkCommandBuffer, negativeOneToOne: VkBool32);
type PFN_vkCmdSetViewportWScalingEnableNV = extern "system" fn(commandBuffer: VkCommandBuffer, viewportWScalingEnable: VkBool32);
type PFN_vkCmdSetViewportSwizzleNV = extern "system" fn(commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportSwizzles: *const VkViewportSwizzleNV);
type PFN_vkCmdSetCoverageToColorEnableNV = extern "system" fn(commandBuffer: VkCommandBuffer, coverageToColorEnable: VkBool32);
type PFN_vkCmdSetCoverageToColorLocationNV = extern "system" fn(commandBuffer: VkCommandBuffer, coverageToColorLocation: u32);
type PFN_vkCmdSetCoverageModulationModeNV = extern "system" fn(commandBuffer: VkCommandBuffer, coverageModulationMode: VkCoverageModulationModeNV);
type PFN_vkCmdSetCoverageModulationTableEnableNV = extern "system" fn(commandBuffer: VkCommandBuffer, coverageModulationTableEnable: VkBool32);
type PFN_vkCmdSetCoverageModulationTableNV = extern "system" fn(commandBuffer: VkCommandBuffer, coverageModulationTableCount: u32, pCoverageModulationTable: *const float);
type PFN_vkCmdSetShadingRateImageEnableNV = extern "system" fn(commandBuffer: VkCommandBuffer, shadingRateImageEnable: VkBool32);
type PFN_vkCmdSetRepresentativeFragmentTestEnableNV = extern "system" fn(commandBuffer: VkCommandBuffer, representativeFragmentTestEnable: VkBool32);
type PFN_vkCmdSetCoverageReductionModeNV = extern "system" fn(commandBuffer: VkCommandBuffer, coverageReductionMode: VkCoverageReductionModeNV);
extern "system" fn dummy_vkCmdSetDepthClampEnableEXT(_: VkCommandBuffer, _: VkBool32) {
	panic!("Vulkan function pointer of `vkCmdSetDepthClampEnableEXT()` is NULL");
}
pub trait VK_EXT_extended_dynamic_state3: Debug {
	fn vkCmdSetDepthClampEnableEXT(&self, commandBuffer: VkCommandBuffer, depthClampEnable: VkBool32);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_extended_dynamic_state3 {
	vk_cmd_set_depth_clamp_enable_ext: PFN_vkCmdSetDepthClampEnableEXT,
}
impl VK_EXT_extended_dynamic_state3 for Vulkan_EXT_extended_dynamic_state3 {
	fn vkCmdSetDepthClampEnableEXT(&self, commandBuffer: VkCommandBuffer, depthClampEnable: VkBool32) {
		(self.vk_cmd_set_depth_clamp_enable_ext)(commandBuffer, depthClampEnable)
	}
}
impl Default for Vulkan_EXT_extended_dynamic_state3 {
	fn default() -> Self {
		Self {
			vk_cmd_set_depth_clamp_enable_ext: dummy_vkCmdSetDepthClampEnableEXT,
		}
	}
}
impl Vulkan_EXT_extended_dynamic_state3 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_depth_clamp_enable_ext: {let proc = get_proc_address(instance, "vkCmdSetDepthClampEnableEXT"); if proc == null() {dummy_vkCmdSetDepthClampEnableEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSubpassMergeStatusEXT {
	VK_SUBPASS_MERGE_STATUS_MERGED_EXT = 0,
	VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT = 1,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT = 2,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT = 3,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT = 4,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT = 5,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT = 6,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT = 7,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT = 8,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT = 9,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT = 10,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT = 11,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT = 12,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT = 13,
	VK_SUBPASS_MERGE_STATUS_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub subpassMergeFeedback: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassCreationControlEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub disallowMerging: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassCreationFeedbackInfoEXT {
	pub postMergeSubpassCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassCreationFeedbackCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pRenderPassFeedback: *mut VkRenderPassCreationFeedbackInfoEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassSubpassFeedbackInfoEXT {
	pub subpassMergeStatus: VkSubpassMergeStatusEXT,
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub postMergeIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderPassSubpassFeedbackCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pSubpassFeedback: *mut VkRenderPassSubpassFeedbackInfoEXT,
}
pub trait VK_EXT_subpass_merge_feedback: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_subpass_merge_feedback {}
impl VK_EXT_subpass_merge_feedback for Vulkan_EXT_subpass_merge_feedback {}
impl Default for Vulkan_EXT_subpass_merge_feedback {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_subpass_merge_feedback {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkDirectDriverLoadingFlagsLUNARG = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDirectDriverLoadingModeLUNARG {
	VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG = 0,
	VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG = 1,
	VK_DIRECT_DRIVER_LOADING_MODE_MAX_ENUM_LUNARG = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDirectDriverLoadingInfoLUNARG {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkDirectDriverLoadingFlagsLUNARG,
	pub pfnGetInstanceProcAddr: PFN_vkGetInstanceProcAddrLUNARG,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDirectDriverLoadingListLUNARG {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub mode: VkDirectDriverLoadingModeLUNARG,
	pub driverCount: u32,
	pub pDrivers: *const VkDirectDriverLoadingInfoLUNARG,
}
type PFN_vkGetInstanceProcAddrLUNARG = extern "system" fn(instance: VkInstance, pName: *const i8) -> PFN_vkVoidFunction;
pub trait VK_LUNARG_direct_driver_loading: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_LUNARG_direct_driver_loading {}
impl VK_LUNARG_direct_driver_loading for Vulkan_LUNARG_direct_driver_loading {}
impl Default for Vulkan_LUNARG_direct_driver_loading {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_LUNARG_direct_driver_loading {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkTensorCreateFlagsARM = VkFlags64;
pub type VkTensorCreateFlagBitsARM = VkFlags64;
pub type VkTensorViewCreateFlagsARM = VkFlags64;
pub type VkTensorViewCreateFlagBitsARM = VkFlags64;
pub type VkTensorUsageFlagsARM = VkFlags64;
pub type VkTensorUsageFlagBitsARM = VkFlags64;
// Define non-dispatchable handle `VkTensorARM`
#[cfg(target_pointer_width = "32")] pub type VkTensorARM = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkTensorARM_T {}
#[cfg(target_pointer_width = "64")] pub type VkTensorARM = *const VkTensorARM_T;
// Define non-dispatchable handle `VkTensorViewARM`
#[cfg(target_pointer_width = "32")] pub type VkTensorViewARM = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkTensorViewARM_T {}
#[cfg(target_pointer_width = "64")] pub type VkTensorViewARM = *const VkTensorViewARM_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkTensorTilingARM {
	VK_TENSOR_TILING_OPTIMAL_ARM = 0,
	VK_TENSOR_TILING_LINEAR_ARM = 1,
	VK_TENSOR_TILING_MAX_ENUM_ARM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTensorDescriptionARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tiling: VkTensorTilingARM,
	pub format: VkFormat,
	pub dimensionCount: u32,
	pub pDimensions: *const int64_t,
	pub pStrides: *const int64_t,
	pub usage: VkTensorUsageFlagsARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTensorCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkTensorCreateFlagsARM,
	pub pDescription: *const VkTensorDescriptionARM,
	pub sharingMode: VkSharingMode,
	pub queueFamilyIndexCount: u32,
	pub pQueueFamilyIndices: *const uint32_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTensorViewCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkTensorViewCreateFlagsARM,
	pub tensor: VkTensorARM,
	pub format: VkFormat,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTensorMemoryRequirementsInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensor: VkTensorARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindTensorMemoryInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensor: VkTensorARM,
	pub memory: VkDeviceMemory,
	pub memoryOffset: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkWriteDescriptorSetTensorARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensorViewCount: u32,
	pub pTensorViews: *const VkTensorViewARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTensorFormatPropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub optimalTilingTensorFeatures: VkFormatFeatureFlags2,
	pub linearTilingTensorFeatures: VkFormatFeatureFlags2,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceTensorPropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxTensorDimensionCount: u32,
	pub maxTensorElements: u64,
	pub maxPerDimensionTensorElements: u64,
	pub maxTensorStride: i64,
	pub maxTensorSize: u64,
	pub maxTensorShaderAccessArrayLength: u32,
	pub maxTensorShaderAccessSize: u32,
	pub maxDescriptorSetStorageTensors: u32,
	pub maxPerStageDescriptorSetStorageTensors: u32,
	pub maxDescriptorSetUpdateAfterBindStorageTensors: u32,
	pub maxPerStageDescriptorUpdateAfterBindStorageTensors: u32,
	pub shaderStorageTensorArrayNonUniformIndexingNative: VkBool32,
	pub shaderTensorSupportedStages: VkShaderStageFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTensorMemoryBarrierARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcStageMask: VkPipelineStageFlags2,
	pub srcAccessMask: VkAccessFlags2,
	pub dstStageMask: VkPipelineStageFlags2,
	pub dstAccessMask: VkAccessFlags2,
	pub srcQueueFamilyIndex: u32,
	pub dstQueueFamilyIndex: u32,
	pub tensor: VkTensorARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTensorDependencyInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensorMemoryBarrierCount: u32,
	pub pTensorMemoryBarriers: *const VkTensorMemoryBarrierARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceTensorFeaturesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub tensorNonPacked: VkBool32,
	pub shaderTensorAccess: VkBool32,
	pub shaderStorageTensorArrayDynamicIndexing: VkBool32,
	pub shaderStorageTensorArrayNonUniformIndexing: VkBool32,
	pub descriptorBindingStorageTensorUpdateAfterBind: VkBool32,
	pub tensors: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDeviceTensorMemoryRequirementsARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pCreateInfo: *const VkTensorCreateInfoARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTensorCopyARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dimensionCount: u32,
	pub pSrcOffset: *const uint64_t,
	pub pDstOffset: *const uint64_t,
	pub pExtent: *const uint64_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyTensorInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcTensor: VkTensorARM,
	pub dstTensor: VkTensorARM,
	pub regionCount: u32,
	pub pRegions: *const VkTensorCopyARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMemoryDedicatedAllocateInfoTensorARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensor: VkTensorARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceExternalTensorInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkTensorCreateFlagsARM,
	pub pDescription: *const VkTensorDescriptionARM,
	pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExternalTensorPropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub externalMemoryProperties: VkExternalMemoryProperties,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExternalMemoryTensorCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes: VkExternalMemoryHandleTypeFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorBufferTensorFeaturesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub descriptorBufferTensorDescriptors: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorBufferTensorPropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub tensorCaptureReplayDescriptorDataSize: usize,
	pub tensorViewCaptureReplayDescriptorDataSize: usize,
	pub tensorDescriptorSize: usize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDescriptorGetTensorInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensorView: VkTensorViewARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTensorCaptureDescriptorDataInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensor: VkTensorARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTensorViewCaptureDescriptorDataInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensorView: VkTensorViewARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkFrameBoundaryTensorsARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensorCount: u32,
	pub pTensors: *const VkTensorARM,
}
type PFN_vkCreateTensorARM = extern "system" fn(device: VkDevice, pCreateInfo: *const VkTensorCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pTensor: *mut VkTensorARM) -> VkResult;
type PFN_vkDestroyTensorARM = extern "system" fn(device: VkDevice, tensor: VkTensorARM, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCreateTensorViewARM = extern "system" fn(device: VkDevice, pCreateInfo: *const VkTensorViewCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pView: *mut VkTensorViewARM) -> VkResult;
type PFN_vkDestroyTensorViewARM = extern "system" fn(device: VkDevice, tensorView: VkTensorViewARM, pAllocator: *const VkAllocationCallbacks);
type PFN_vkGetTensorMemoryRequirementsARM = extern "system" fn(device: VkDevice, pInfo: *const VkTensorMemoryRequirementsInfoARM, pMemoryRequirements: *mut VkMemoryRequirements2);
type PFN_vkBindTensorMemoryARM = extern "system" fn(device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindTensorMemoryInfoARM) -> VkResult;
type PFN_vkGetDeviceTensorMemoryRequirementsARM = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceTensorMemoryRequirementsARM, pMemoryRequirements: *mut VkMemoryRequirements2);
type PFN_vkCmdCopyTensorARM = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyTensorInfo: *const VkCopyTensorInfoARM);
type PFN_vkGetPhysicalDeviceExternalTensorPropertiesARM = extern "system" fn(physicalDevice: VkPhysicalDevice, pExternalTensorInfo: *const VkPhysicalDeviceExternalTensorInfoARM, pExternalTensorProperties: *mut VkExternalTensorPropertiesARM);
type PFN_vkGetTensorOpaqueCaptureDescriptorDataARM = extern "system" fn(device: VkDevice, pInfo: *const VkTensorCaptureDescriptorDataInfoARM, pData: *mut c_void) -> VkResult;
type PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM = extern "system" fn(device: VkDevice, pInfo: *const VkTensorViewCaptureDescriptorDataInfoARM, pData: *mut c_void) -> VkResult;
extern "system" fn dummy_vkCreateTensorARM(_: VkDevice, _: *const VkTensorCreateInfoARM, _: *const VkAllocationCallbacks, _: *mut VkTensorARM) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateTensorARM()` is NULL");
}
pub trait VK_ARM_tensors: Debug {
	fn vkCreateTensorARM(&self, device: VkDevice, pCreateInfo: *const VkTensorCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pTensor: *mut VkTensorARM) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_tensors {
	vk_create_tensor_arm: PFN_vkCreateTensorARM,
}
impl VK_ARM_tensors for Vulkan_ARM_tensors {
	fn vkCreateTensorARM(&self, device: VkDevice, pCreateInfo: *const VkTensorCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pTensor: *mut VkTensorARM) -> VkResult {
		(self.vk_create_tensor_arm)(device, pCreateInfo, pAllocator, pTensor)
	}
}
impl Default for Vulkan_ARM_tensors {
	fn default() -> Self {
		Self {
			vk_create_tensor_arm: dummy_vkCreateTensorARM,
		}
	}
}
impl Vulkan_ARM_tensors {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_tensor_arm: {let proc = get_proc_address(instance, "vkCreateTensorARM"); if proc == null() {dummy_vkCreateTensorARM} else {unsafe {transmute(proc)}}},
		}
	}
}
pub const VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT: u32 = 32u32;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderModuleIdentifier: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderModuleIdentifierAlgorithmUUID: [u8; VK_UUID_SIZE as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineShaderStageModuleIdentifierCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub identifierSize: u32,
	pub pIdentifier: *const uint8_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkShaderModuleIdentifierEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub identifierSize: u32,
	pub identifier: [u8; VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT as usize],
}
type PFN_vkGetShaderModuleIdentifierEXT = extern "system" fn(device: VkDevice, shaderModule: VkShaderModule, pIdentifier: *mut VkShaderModuleIdentifierEXT);
type PFN_vkGetShaderModuleCreateInfoIdentifierEXT = extern "system" fn(device: VkDevice, pCreateInfo: *const VkShaderModuleCreateInfo, pIdentifier: *mut VkShaderModuleIdentifierEXT);
extern "system" fn dummy_vkGetShaderModuleIdentifierEXT(_: VkDevice, _: VkShaderModule, _: *mut VkShaderModuleIdentifierEXT) {
	panic!("Vulkan function pointer of `vkGetShaderModuleIdentifierEXT()` is NULL");
}
pub trait VK_EXT_shader_module_identifier: Debug {
	fn vkGetShaderModuleIdentifierEXT(&self, device: VkDevice, shaderModule: VkShaderModule, pIdentifier: *mut VkShaderModuleIdentifierEXT);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_module_identifier {
	vk_get_shader_module_identifier_ext: PFN_vkGetShaderModuleIdentifierEXT,
}
impl VK_EXT_shader_module_identifier for Vulkan_EXT_shader_module_identifier {
	fn vkGetShaderModuleIdentifierEXT(&self, device: VkDevice, shaderModule: VkShaderModule, pIdentifier: *mut VkShaderModuleIdentifierEXT) {
		(self.vk_get_shader_module_identifier_ext)(device, shaderModule, pIdentifier)
	}
}
impl Default for Vulkan_EXT_shader_module_identifier {
	fn default() -> Self {
		Self {
			vk_get_shader_module_identifier_ext: dummy_vkGetShaderModuleIdentifierEXT,
		}
	}
}
impl Vulkan_EXT_shader_module_identifier {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_shader_module_identifier_ext: {let proc = get_proc_address(instance, "vkGetShaderModuleIdentifierEXT"); if proc == null() {dummy_vkGetShaderModuleIdentifierEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
pub trait VK_EXT_rasterization_order_attachment_access: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_rasterization_order_attachment_access {}
impl VK_EXT_rasterization_order_attachment_access for Vulkan_EXT_rasterization_order_attachment_access {}
impl Default for Vulkan_EXT_rasterization_order_attachment_access {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_rasterization_order_attachment_access {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkOpticalFlowGridSizeFlagsNV = VkFlags;
pub type VkOpticalFlowUsageFlagsNV = VkFlags;
pub type VkOpticalFlowSessionCreateFlagsNV = VkFlags;
pub type VkOpticalFlowExecuteFlagsNV = VkFlags;
// Define non-dispatchable handle `VkOpticalFlowSessionNV`
#[cfg(target_pointer_width = "32")] pub type VkOpticalFlowSessionNV = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkOpticalFlowSessionNV_T {}
#[cfg(target_pointer_width = "64")] pub type VkOpticalFlowSessionNV = *const VkOpticalFlowSessionNV_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOpticalFlowPerformanceLevelNV {
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV = 0,
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV = 1,
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV = 2,
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV = 3,
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOpticalFlowSessionBindingPointNV {
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV = 0,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV = 1,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV = 2,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV = 3,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV = 4,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV = 5,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV = 6,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV = 7,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV = 8,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOpticalFlowGridSizeFlagBitsNV {
	VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV = 0,
	VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV = 0x00000001,
	VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV = 0x00000002,
	VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV = 0x00000004,
	VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV = 0x00000008,
	VK_OPTICAL_FLOW_GRID_SIZE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOpticalFlowUsageFlagBitsNV {
	VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV = 0,
	VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV = 0x00000001,
	VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV = 0x00000002,
	VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV = 0x00000004,
	VK_OPTICAL_FLOW_USAGE_COST_BIT_NV = 0x00000008,
	VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV = 0x00000010,
	VK_OPTICAL_FLOW_USAGE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOpticalFlowSessionCreateFlagBitsNV {
	VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV = 0x00000001,
	VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV = 0x00000002,
	VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV = 0x00000004,
	VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV = 0x00000008,
	VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV = 0x00000010,
	VK_OPTICAL_FLOW_SESSION_CREATE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOpticalFlowExecuteFlagBitsNV {
	VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV = 0x00000001,
	VK_OPTICAL_FLOW_EXECUTE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceOpticalFlowFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub opticalFlow: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceOpticalFlowPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub supportedOutputGridSizes: VkOpticalFlowGridSizeFlagsNV,
	pub supportedHintGridSizes: VkOpticalFlowGridSizeFlagsNV,
	pub hintSupported: VkBool32,
	pub costSupported: VkBool32,
	pub bidirectionalFlowSupported: VkBool32,
	pub globalFlowSupported: VkBool32,
	pub minWidth: u32,
	pub minHeight: u32,
	pub maxWidth: u32,
	pub maxHeight: u32,
	pub maxNumRegionsOfInterest: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkOpticalFlowImageFormatInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub usage: VkOpticalFlowUsageFlagsNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkOpticalFlowImageFormatPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub format: VkFormat,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkOpticalFlowSessionCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub width: u32,
	pub height: u32,
	pub imageFormat: VkFormat,
	pub flowVectorFormat: VkFormat,
	pub costFormat: VkFormat,
	pub outputGridSize: VkOpticalFlowGridSizeFlagsNV,
	pub hintGridSize: VkOpticalFlowGridSizeFlagsNV,
	pub performanceLevel: VkOpticalFlowPerformanceLevelNV,
	pub flags: VkOpticalFlowSessionCreateFlagsNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkOpticalFlowSessionCreatePrivateDataInfoNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub id: u32,
	pub size: u32,
	pub pPrivateData: *const c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkOpticalFlowExecuteInfoNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkOpticalFlowExecuteFlagsNV,
	pub regionCount: u32,
	pub pRegions: *const VkRect2D,
}
type PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV = extern "system" fn(physicalDevice: VkPhysicalDevice, pOpticalFlowImageFormatInfo: *const VkOpticalFlowImageFormatInfoNV, pFormatCount: *mut uint32_t, pImageFormatProperties: *mut VkOpticalFlowImageFormatPropertiesNV) -> VkResult;
type PFN_vkCreateOpticalFlowSessionNV = extern "system" fn(device: VkDevice, pCreateInfo: *const VkOpticalFlowSessionCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pSession: *mut VkOpticalFlowSessionNV) -> VkResult;
type PFN_vkDestroyOpticalFlowSessionNV = extern "system" fn(device: VkDevice, session: VkOpticalFlowSessionNV, pAllocator: *const VkAllocationCallbacks);
type PFN_vkBindOpticalFlowSessionImageNV = extern "system" fn(device: VkDevice, session: VkOpticalFlowSessionNV, bindingPoint: VkOpticalFlowSessionBindingPointNV, view: VkImageView, layout: VkImageLayout) -> VkResult;
type PFN_vkCmdOpticalFlowExecuteNV = extern "system" fn(commandBuffer: VkCommandBuffer, session: VkOpticalFlowSessionNV, pExecuteInfo: *const VkOpticalFlowExecuteInfoNV);
extern "system" fn dummy_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(_: VkPhysicalDevice, _: *const VkOpticalFlowImageFormatInfoNV, _: *mut uint32_t, _: *mut VkOpticalFlowImageFormatPropertiesNV) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceOpticalFlowImageFormatsNV()` is NULL");
}
pub trait VK_NV_optical_flow: Debug {
	fn vkGetPhysicalDeviceOpticalFlowImageFormatsNV(&self, physicalDevice: VkPhysicalDevice, pOpticalFlowImageFormatInfo: *const VkOpticalFlowImageFormatInfoNV, pFormatCount: *mut uint32_t, pImageFormatProperties: *mut VkOpticalFlowImageFormatPropertiesNV) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_optical_flow {
	vk_get_physical_device_optical_flow_image_formats_nv: PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV,
}
impl VK_NV_optical_flow for Vulkan_NV_optical_flow {
	fn vkGetPhysicalDeviceOpticalFlowImageFormatsNV(&self, physicalDevice: VkPhysicalDevice, pOpticalFlowImageFormatInfo: *const VkOpticalFlowImageFormatInfoNV, pFormatCount: *mut uint32_t, pImageFormatProperties: *mut VkOpticalFlowImageFormatPropertiesNV) -> VkResult {
		(self.vk_get_physical_device_optical_flow_image_formats_nv)(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties)
	}
}
impl Default for Vulkan_NV_optical_flow {
	fn default() -> Self {
		Self {
			vk_get_physical_device_optical_flow_image_formats_nv: dummy_vkGetPhysicalDeviceOpticalFlowImageFormatsNV,
		}
	}
}
impl Vulkan_NV_optical_flow {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_optical_flow_image_formats_nv: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV"); if proc == null() {dummy_vkGetPhysicalDeviceOpticalFlowImageFormatsNV} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceLegacyDitheringFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub legacyDithering: VkBool32,
}
pub trait VK_EXT_legacy_dithering: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_legacy_dithering {}
impl VK_EXT_legacy_dithering for Vulkan_EXT_legacy_dithering {}
impl Default for Vulkan_EXT_legacy_dithering {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_legacy_dithering {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkPhysicalDevicePipelineProtectedAccessFeaturesEXT = VkPhysicalDevicePipelineProtectedAccessFeatures;
pub trait VK_EXT_pipeline_protected_access: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_pipeline_protected_access {}
impl VK_EXT_pipeline_protected_access for Vulkan_EXT_pipeline_protected_access {}
impl Default for Vulkan_EXT_pipeline_protected_access {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_pipeline_protected_access {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAntiLagModeAMD {
	VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD = 0,
	VK_ANTI_LAG_MODE_ON_AMD = 1,
	VK_ANTI_LAG_MODE_OFF_AMD = 2,
	VK_ANTI_LAG_MODE_MAX_ENUM_AMD = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAntiLagStageAMD {
	VK_ANTI_LAG_STAGE_INPUT_AMD = 0,
	VK_ANTI_LAG_STAGE_PRESENT_AMD = 1,
	VK_ANTI_LAG_STAGE_MAX_ENUM_AMD = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceAntiLagFeaturesAMD {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub antiLag: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAntiLagPresentationInfoAMD {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub stage: VkAntiLagStageAMD,
	pub frameIndex: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAntiLagDataAMD {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub mode: VkAntiLagModeAMD,
	pub maxFPS: u32,
	pub pPresentationInfo: *const VkAntiLagPresentationInfoAMD,
}
type PFN_vkAntiLagUpdateAMD = extern "system" fn(device: VkDevice, pData: *const VkAntiLagDataAMD);
extern "system" fn dummy_vkAntiLagUpdateAMD(_: VkDevice, _: *const VkAntiLagDataAMD) {
	panic!("Vulkan function pointer of `vkAntiLagUpdateAMD()` is NULL");
}
pub trait VK_AMD_anti_lag: Debug {
	fn vkAntiLagUpdateAMD(&self, device: VkDevice, pData: *const VkAntiLagDataAMD);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_anti_lag {
	vk_anti_lag_update_amd: PFN_vkAntiLagUpdateAMD,
}
impl VK_AMD_anti_lag for Vulkan_AMD_anti_lag {
	fn vkAntiLagUpdateAMD(&self, device: VkDevice, pData: *const VkAntiLagDataAMD) {
		(self.vk_anti_lag_update_amd)(device, pData)
	}
}
impl Default for Vulkan_AMD_anti_lag {
	fn default() -> Self {
		Self {
			vk_anti_lag_update_amd: dummy_vkAntiLagUpdateAMD,
		}
	}
}
impl Vulkan_AMD_anti_lag {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_anti_lag_update_amd: {let proc = get_proc_address(instance, "vkAntiLagUpdateAMD"); if proc == null() {dummy_vkAntiLagUpdateAMD} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkShaderCreateFlagsEXT = VkFlags;
pub type VkShaderRequiredSubgroupSizeCreateInfoEXT = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;
// Define non-dispatchable handle `VkShaderEXT`
#[cfg(target_pointer_width = "32")] pub type VkShaderEXT = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkShaderEXT_T {}
#[cfg(target_pointer_width = "64")] pub type VkShaderEXT = *const VkShaderEXT_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkShaderCodeTypeEXT {
	VK_SHADER_CODE_TYPE_BINARY_EXT = 0,
	VK_SHADER_CODE_TYPE_SPIRV_EXT = 1,
	VK_SHADER_CODE_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDepthClampModeEXT {
	VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT = 0,
	VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT = 1,
	VK_DEPTH_CLAMP_MODE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkShaderCreateFlagBitsEXT {
	VK_SHADER_CREATE_LINK_STAGE_BIT_EXT = 0x00000001,
	VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 0x00000002,
	VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = 0x00000004,
	VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT = 0x00000008,
	VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT = 0x00000010,
	VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT = 0x00000020,
	VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00000040,
	VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT = 0x00000080,
	VK_SHADER_CREATE_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderObjectFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderObject: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderObjectPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderBinaryUUID: [u8; VK_UUID_SIZE as usize],
	pub shaderBinaryVersion: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkShaderCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkShaderCreateFlagsEXT,
	pub stage: VkShaderStageFlagBits,
	pub nextStage: VkShaderStageFlags,
	pub codeType: VkShaderCodeTypeEXT,
	pub codeSize: usize,
	pub pCode: *const c_void,
	pub pName: *const i8,
	pub setLayoutCount: u32,
	pub pSetLayouts: *const VkDescriptorSetLayout,
	pub pushConstantRangeCount: u32,
	pub pPushConstantRanges: *const VkPushConstantRange,
	pub pSpecializationInfo: *const VkSpecializationInfo,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDepthClampRangeEXT {
	pub minDepthClamp: f32,
	pub maxDepthClamp: f32,
}
type PFN_vkCreateShadersEXT = extern "system" fn(device: VkDevice, createInfoCount: u32, pCreateInfos: *const VkShaderCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pShaders: *mut VkShaderEXT) -> VkResult;
type PFN_vkDestroyShaderEXT = extern "system" fn(device: VkDevice, shader: VkShaderEXT, pAllocator: *const VkAllocationCallbacks);
type PFN_vkGetShaderBinaryDataEXT = extern "system" fn(device: VkDevice, shader: VkShaderEXT, pDataSize: *mut size_t, pData: *mut c_void) -> VkResult;
type PFN_vkCmdBindShadersEXT = extern "system" fn(commandBuffer: VkCommandBuffer, stageCount: u32, pStages: *const VkShaderStageFlagBits, pShaders: *const VkShaderEXT);
type PFN_vkCmdSetDepthClampRangeEXT = extern "system" fn(commandBuffer: VkCommandBuffer, depthClampMode: VkDepthClampModeEXT, pDepthClampRange: *const VkDepthClampRangeEXT);
extern "system" fn dummy_vkCreateShadersEXT(_: VkDevice, _: u32, _: *const VkShaderCreateInfoEXT, _: *const VkAllocationCallbacks, _: *mut VkShaderEXT) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateShadersEXT()` is NULL");
}
pub trait VK_EXT_shader_object: Debug {
	fn vkCreateShadersEXT(&self, device: VkDevice, createInfoCount: u32, pCreateInfos: *const VkShaderCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pShaders: *mut VkShaderEXT) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_object {
	vk_create_shaders_ext: PFN_vkCreateShadersEXT,
}
impl VK_EXT_shader_object for Vulkan_EXT_shader_object {
	fn vkCreateShadersEXT(&self, device: VkDevice, createInfoCount: u32, pCreateInfos: *const VkShaderCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pShaders: *mut VkShaderEXT) -> VkResult {
		(self.vk_create_shaders_ext)(device, createInfoCount, pCreateInfos, pAllocator, pShaders)
	}
}
impl Default for Vulkan_EXT_shader_object {
	fn default() -> Self {
		Self {
			vk_create_shaders_ext: dummy_vkCreateShadersEXT,
		}
	}
}
impl Vulkan_EXT_shader_object {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_shaders_ext: {let proc = get_proc_address(instance, "vkCreateShadersEXT"); if proc == null() {dummy_vkCreateShadersEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceTilePropertiesFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub tileProperties: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTilePropertiesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub tileSize: VkExtent3D,
	pub apronSize: VkExtent2D,
	pub origin: VkOffset2D,
}
type PFN_vkGetFramebufferTilePropertiesQCOM = extern "system" fn(device: VkDevice, framebuffer: VkFramebuffer, pPropertiesCount: *mut uint32_t, pProperties: *mut VkTilePropertiesQCOM) -> VkResult;
type PFN_vkGetDynamicRenderingTilePropertiesQCOM = extern "system" fn(device: VkDevice, pRenderingInfo: *const VkRenderingInfo, pProperties: *mut VkTilePropertiesQCOM) -> VkResult;
extern "system" fn dummy_vkGetFramebufferTilePropertiesQCOM(_: VkDevice, _: VkFramebuffer, _: *mut uint32_t, _: *mut VkTilePropertiesQCOM) -> VkResult {
	panic!("Vulkan function pointer of `vkGetFramebufferTilePropertiesQCOM()` is NULL");
}
pub trait VK_QCOM_tile_properties: Debug {
	fn vkGetFramebufferTilePropertiesQCOM(&self, device: VkDevice, framebuffer: VkFramebuffer, pPropertiesCount: *mut uint32_t, pProperties: *mut VkTilePropertiesQCOM) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_tile_properties {
	vk_get_framebuffer_tile_properties_qcom: PFN_vkGetFramebufferTilePropertiesQCOM,
}
impl VK_QCOM_tile_properties for Vulkan_QCOM_tile_properties {
	fn vkGetFramebufferTilePropertiesQCOM(&self, device: VkDevice, framebuffer: VkFramebuffer, pPropertiesCount: *mut uint32_t, pProperties: *mut VkTilePropertiesQCOM) -> VkResult {
		(self.vk_get_framebuffer_tile_properties_qcom)(device, framebuffer, pPropertiesCount, pProperties)
	}
}
impl Default for Vulkan_QCOM_tile_properties {
	fn default() -> Self {
		Self {
			vk_get_framebuffer_tile_properties_qcom: dummy_vkGetFramebufferTilePropertiesQCOM,
		}
	}
}
impl Vulkan_QCOM_tile_properties {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_framebuffer_tile_properties_qcom: {let proc = get_proc_address(instance, "vkGetFramebufferTilePropertiesQCOM"); if proc == null() {dummy_vkGetFramebufferTilePropertiesQCOM} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceAmigoProfilingFeaturesSEC {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub amigoProfiling: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAmigoProfilingSubmitInfoSEC {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub firstDrawTimestamp: u64,
	pub swapBufferTimestamp: u64,
}
pub trait VK_SEC_amigo_profiling: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_SEC_amigo_profiling {}
impl VK_SEC_amigo_profiling for Vulkan_SEC_amigo_profiling {}
impl Default for Vulkan_SEC_amigo_profiling {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_SEC_amigo_profiling {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub multiviewPerViewViewports: VkBool32,
}
pub trait VK_QCOM_multiview_per_view_viewports: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_multiview_per_view_viewports {}
impl VK_QCOM_multiview_per_view_viewports for Vulkan_QCOM_multiview_per_view_viewports {}
impl Default for Vulkan_QCOM_multiview_per_view_viewports {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_multiview_per_view_viewports {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkRayTracingInvocationReorderModeNV {
	VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV = 0,
	VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV = 1,
	VK_RAY_TRACING_INVOCATION_REORDER_MODE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rayTracingInvocationReorderReorderingHint: VkRayTracingInvocationReorderModeNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rayTracingInvocationReorder: VkBool32,
}
pub trait VK_NV_ray_tracing_invocation_reorder: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_ray_tracing_invocation_reorder {}
impl VK_NV_ray_tracing_invocation_reorder for Vulkan_NV_ray_tracing_invocation_reorder {}
impl Default for Vulkan_NV_ray_tracing_invocation_reorder {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_ray_tracing_invocation_reorder {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCooperativeVectorMatrixLayoutNV {
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV = 0,
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV = 1,
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV = 2,
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV = 3,
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCooperativeVectorPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cooperativeVectorSupportedStages: VkShaderStageFlags,
	pub cooperativeVectorTrainingFloat16Accumulation: VkBool32,
	pub cooperativeVectorTrainingFloat32Accumulation: VkBool32,
	pub maxCooperativeVectorComponents: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCooperativeVectorFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cooperativeVector: VkBool32,
	pub cooperativeVectorTraining: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCooperativeVectorPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub inputType: VkComponentTypeKHR,
	pub inputInterpretation: VkComponentTypeKHR,
	pub matrixInterpretation: VkComponentTypeKHR,
	pub biasInterpretation: VkComponentTypeKHR,
	pub resultType: VkComponentTypeKHR,
	pub transpose: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkConvertCooperativeVectorMatrixInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcSize: usize,
	pub srcData: VkDeviceOrHostAddressConstKHR,
	pub pDstSize: *mut size_t,
	pub dstData: VkDeviceOrHostAddressKHR,
	pub srcComponentType: VkComponentTypeKHR,
	pub dstComponentType: VkComponentTypeKHR,
	pub numRows: u32,
	pub numColumns: u32,
	pub srcLayout: VkCooperativeVectorMatrixLayoutNV,
	pub srcStride: usize,
	pub dstLayout: VkCooperativeVectorMatrixLayoutNV,
	pub dstStride: usize,
}
type PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeVectorPropertiesNV) -> VkResult;
type PFN_vkConvertCooperativeVectorMatrixNV = extern "system" fn(device: VkDevice, pInfo: *const VkConvertCooperativeVectorMatrixInfoNV) -> VkResult;
type PFN_vkCmdConvertCooperativeVectorMatrixNV = extern "system" fn(commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *const VkConvertCooperativeVectorMatrixInfoNV);
extern "system" fn dummy_vkGetPhysicalDeviceCooperativeVectorPropertiesNV(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkCooperativeVectorPropertiesNV) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceCooperativeVectorPropertiesNV()` is NULL");
}
pub trait VK_NV_cooperative_vector: Debug {
	fn vkGetPhysicalDeviceCooperativeVectorPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeVectorPropertiesNV) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_cooperative_vector {
	vk_get_physical_device_cooperative_vector_properties_nv: PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV,
}
impl VK_NV_cooperative_vector for Vulkan_NV_cooperative_vector {
	fn vkGetPhysicalDeviceCooperativeVectorPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeVectorPropertiesNV) -> VkResult {
		(self.vk_get_physical_device_cooperative_vector_properties_nv)(physicalDevice, pPropertyCount, pProperties)
	}
}
impl Default for Vulkan_NV_cooperative_vector {
	fn default() -> Self {
		Self {
			vk_get_physical_device_cooperative_vector_properties_nv: dummy_vkGetPhysicalDeviceCooperativeVectorPropertiesNV,
		}
	}
}
impl Vulkan_NV_cooperative_vector {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_cooperative_vector_properties_nv: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceCooperativeVectorPropertiesNV"); if proc == null() {dummy_vkGetPhysicalDeviceCooperativeVectorPropertiesNV} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub extendedSparseAddressSpace: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub extendedSparseAddressSpaceSize: VkDeviceSize,
	pub extendedSparseImageUsageFlags: VkImageUsageFlags,
	pub extendedSparseBufferUsageFlags: VkBufferUsageFlags,
}
pub trait VK_NV_extended_sparse_address_space: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_extended_sparse_address_space {}
impl VK_NV_extended_sparse_address_space for Vulkan_NV_extended_sparse_address_space {}
impl Default for Vulkan_NV_extended_sparse_address_space {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_extended_sparse_address_space {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub trait VK_EXT_mutable_descriptor_type: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_mutable_descriptor_type {}
impl VK_EXT_mutable_descriptor_type for Vulkan_EXT_mutable_descriptor_type {}
impl Default for Vulkan_EXT_mutable_descriptor_type {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_mutable_descriptor_type {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub legacyVertexAttributes: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub nativeUnalignedPerformance: VkBool32,
}
pub trait VK_EXT_legacy_vertex_attributes: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_legacy_vertex_attributes {}
impl VK_EXT_legacy_vertex_attributes for Vulkan_EXT_legacy_vertex_attributes {}
impl Default for Vulkan_EXT_legacy_vertex_attributes {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_legacy_vertex_attributes {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkLayerSettingTypeEXT {
	VK_LAYER_SETTING_TYPE_BOOL32_EXT = 0,
	VK_LAYER_SETTING_TYPE_INT32_EXT = 1,
	VK_LAYER_SETTING_TYPE_INT64_EXT = 2,
	VK_LAYER_SETTING_TYPE_UINT32_EXT = 3,
	VK_LAYER_SETTING_TYPE_UINT64_EXT = 4,
	VK_LAYER_SETTING_TYPE_FLOAT32_EXT = 5,
	VK_LAYER_SETTING_TYPE_FLOAT64_EXT = 6,
	VK_LAYER_SETTING_TYPE_STRING_EXT = 7,
	VK_LAYER_SETTING_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkLayerSettingEXT {
	pub pLayerName: *const i8,
	pub pSettingName: *const i8,
	pub type_: VkLayerSettingTypeEXT,
	pub valueCount: u32,
	pub pValues: *const c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkLayerSettingsCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub settingCount: u32,
	pub pSettings: *const VkLayerSettingEXT,
}
pub trait VK_EXT_layer_settings: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_layer_settings {}
impl VK_EXT_layer_settings for Vulkan_EXT_layer_settings {}
impl Default for Vulkan_EXT_layer_settings {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_layer_settings {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderCoreBuiltins: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderCoreMask: u64,
	pub shaderCoreCount: u32,
	pub shaderWarpsPerCore: u32,
}
pub trait VK_ARM_shader_core_builtins: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_shader_core_builtins {}
impl VK_ARM_shader_core_builtins for Vulkan_ARM_shader_core_builtins {}
impl Default for Vulkan_ARM_shader_core_builtins {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_ARM_shader_core_builtins {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineLibraryGroupHandles: VkBool32,
}
pub trait VK_EXT_pipeline_library_group_handles: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_pipeline_library_group_handles {}
impl VK_EXT_pipeline_library_group_handles for Vulkan_EXT_pipeline_library_group_handles {}
impl Default for Vulkan_EXT_pipeline_library_group_handles {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_pipeline_library_group_handles {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub dynamicRenderingUnusedAttachments: VkBool32,
}
pub trait VK_EXT_dynamic_rendering_unused_attachments: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_dynamic_rendering_unused_attachments {}
impl VK_EXT_dynamic_rendering_unused_attachments for Vulkan_EXT_dynamic_rendering_unused_attachments {}
impl Default for Vulkan_EXT_dynamic_rendering_unused_attachments {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_dynamic_rendering_unused_attachments {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkLatencyMarkerNV {
	VK_LATENCY_MARKER_SIMULATION_START_NV = 0,
	VK_LATENCY_MARKER_SIMULATION_END_NV = 1,
	VK_LATENCY_MARKER_RENDERSUBMIT_START_NV = 2,
	VK_LATENCY_MARKER_RENDERSUBMIT_END_NV = 3,
	VK_LATENCY_MARKER_PRESENT_START_NV = 4,
	VK_LATENCY_MARKER_PRESENT_END_NV = 5,
	VK_LATENCY_MARKER_INPUT_SAMPLE_NV = 6,
	VK_LATENCY_MARKER_TRIGGER_FLASH_NV = 7,
	VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV = 8,
	VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV = 9,
	VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV = 10,
	VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV = 11,
	VK_LATENCY_MARKER_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOutOfBandQueueTypeNV {
	VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV = 0,
	VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV = 1,
	VK_OUT_OF_BAND_QUEUE_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkLatencySleepModeInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub lowLatencyMode: VkBool32,
	pub lowLatencyBoost: VkBool32,
	pub minimumIntervalUs: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkLatencySleepInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub signalSemaphore: VkSemaphore,
	pub value: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSetLatencyMarkerInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub presentID: u64,
	pub marker: VkLatencyMarkerNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkLatencyTimingsFrameReportNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub presentID: u64,
	pub inputSampleTimeUs: u64,
	pub simStartTimeUs: u64,
	pub simEndTimeUs: u64,
	pub renderSubmitStartTimeUs: u64,
	pub renderSubmitEndTimeUs: u64,
	pub presentStartTimeUs: u64,
	pub presentEndTimeUs: u64,
	pub driverStartTimeUs: u64,
	pub driverEndTimeUs: u64,
	pub osRenderQueueStartTimeUs: u64,
	pub osRenderQueueEndTimeUs: u64,
	pub gpuRenderStartTimeUs: u64,
	pub gpuRenderEndTimeUs: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkGetLatencyMarkerInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub timingCount: u32,
	pub pTimings: *mut VkLatencyTimingsFrameReportNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkLatencySubmissionPresentIdNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub presentID: u64,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSwapchainLatencyCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub latencyModeEnable: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkOutOfBandQueueTypeInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub queueType: VkOutOfBandQueueTypeNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkLatencySurfaceCapabilitiesNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub presentModeCount: u32,
	pub pPresentModes: *mut VkPresentModeKHR,
}
type PFN_vkSetLatencySleepModeNV = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pSleepModeInfo: *const VkLatencySleepModeInfoNV) -> VkResult;
type PFN_vkLatencySleepNV = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pSleepInfo: *const VkLatencySleepInfoNV) -> VkResult;
type PFN_vkSetLatencyMarkerNV = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pLatencyMarkerInfo: *const VkSetLatencyMarkerInfoNV);
type PFN_vkGetLatencyTimingsNV = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pLatencyMarkerInfo: *mut VkGetLatencyMarkerInfoNV);
type PFN_vkQueueNotifyOutOfBandNV = extern "system" fn(queue: VkQueue, pQueueTypeInfo: *const VkOutOfBandQueueTypeInfoNV);
extern "system" fn dummy_vkSetLatencySleepModeNV(_: VkDevice, _: VkSwapchainKHR, _: *const VkLatencySleepModeInfoNV) -> VkResult {
	panic!("Vulkan function pointer of `vkSetLatencySleepModeNV()` is NULL");
}
pub trait VK_NV_low_latency2: Debug {
	fn vkSetLatencySleepModeNV(&self, device: VkDevice, swapchain: VkSwapchainKHR, pSleepModeInfo: *const VkLatencySleepModeInfoNV) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_low_latency2 {
	vk_set_latency_sleep_mode_nv: PFN_vkSetLatencySleepModeNV,
}
impl VK_NV_low_latency2 for Vulkan_NV_low_latency2 {
	fn vkSetLatencySleepModeNV(&self, device: VkDevice, swapchain: VkSwapchainKHR, pSleepModeInfo: *const VkLatencySleepModeInfoNV) -> VkResult {
		(self.vk_set_latency_sleep_mode_nv)(device, swapchain, pSleepModeInfo)
	}
}
impl Default for Vulkan_NV_low_latency2 {
	fn default() -> Self {
		Self {
			vk_set_latency_sleep_mode_nv: dummy_vkSetLatencySleepModeNV,
		}
	}
}
impl Vulkan_NV_low_latency2 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_set_latency_sleep_mode_nv: {let proc = get_proc_address(instance, "vkSetLatencySleepModeNV"); if proc == null() {dummy_vkSetLatencySleepModeNV} else {unsafe {transmute(proc)}}},
		}
	}
}
pub const VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM: u32 = 128u32;
pub type VkDataGraphPipelineSessionCreateFlagsARM = VkFlags64;
pub type VkDataGraphPipelineSessionCreateFlagBitsARM = VkFlags64;
pub type VkDataGraphPipelineDispatchFlagsARM = VkFlags64;
pub type VkDataGraphPipelineDispatchFlagBitsARM = VkFlags64;
// Define non-dispatchable handle `VkDataGraphPipelineSessionARM`
#[cfg(target_pointer_width = "32")] pub type VkDataGraphPipelineSessionARM = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkDataGraphPipelineSessionARM_T {}
#[cfg(target_pointer_width = "64")] pub type VkDataGraphPipelineSessionARM = *const VkDataGraphPipelineSessionARM_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDataGraphPipelineSessionBindPointARM {
	VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM = 0,
	VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_MAX_ENUM_ARM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDataGraphPipelineSessionBindPointTypeARM {
	VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM = 0,
	VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MAX_ENUM_ARM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDataGraphPipelinePropertyARM {
	VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM = 0,
	VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM = 1,
	VK_DATA_GRAPH_PIPELINE_PROPERTY_MAX_ENUM_ARM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPhysicalDeviceDataGraphProcessingEngineTypeARM {
	VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM = 0,
	VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_MAX_ENUM_ARM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPhysicalDeviceDataGraphOperationTypeARM {
	VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM = 0,
	VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_MAX_ENUM_ARM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDataGraphFeaturesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub dataGraph: VkBool32,
	pub dataGraphUpdateAfterBind: VkBool32,
	pub dataGraphSpecializationConstants: VkBool32,
	pub dataGraphDescriptorBuffer: VkBool32,
	pub dataGraphShaderModule: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDataGraphPipelineConstantARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub id: u32,
	pub pConstantData: *const c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDataGraphPipelineResourceInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub descriptorSet: u32,
	pub binding: u32,
	pub arrayElement: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDataGraphPipelineCompilerControlCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pVendorOptions: *const i8,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDataGraphPipelineCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCreateFlags2KHR,
	pub layout: VkPipelineLayout,
	pub resourceInfoCount: u32,
	pub pResourceInfos: *const VkDataGraphPipelineResourceInfoARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDataGraphPipelineShaderModuleCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub module: VkShaderModule,
	pub pName: *const i8,
	pub pSpecializationInfo: *const VkSpecializationInfo,
	pub constantCount: u32,
	pub pConstants: *const VkDataGraphPipelineConstantARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDataGraphPipelineSessionCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDataGraphPipelineSessionCreateFlagsARM,
	pub dataGraphPipeline: VkPipeline,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDataGraphPipelineSessionBindPointRequirementsInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub session: VkDataGraphPipelineSessionARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDataGraphPipelineSessionBindPointRequirementARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub bindPoint: VkDataGraphPipelineSessionBindPointARM,
	pub bindPointType: VkDataGraphPipelineSessionBindPointTypeARM,
	pub numObjects: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDataGraphPipelineSessionMemoryRequirementsInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub session: VkDataGraphPipelineSessionARM,
	pub bindPoint: VkDataGraphPipelineSessionBindPointARM,
	pub objectIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindDataGraphPipelineSessionMemoryInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub session: VkDataGraphPipelineSessionARM,
	pub bindPoint: VkDataGraphPipelineSessionBindPointARM,
	pub objectIndex: u32,
	pub memory: VkDeviceMemory,
	pub memoryOffset: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDataGraphPipelineInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dataGraphPipeline: VkPipeline,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDataGraphPipelinePropertyQueryResultARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub property: VkDataGraphPipelinePropertyARM,
	pub isText: VkBool32,
	pub dataSize: usize,
	pub pData: *mut c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDataGraphPipelineIdentifierCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub identifierSize: u32,
	pub pIdentifier: *const uint8_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDataGraphPipelineDispatchInfoARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkDataGraphPipelineDispatchFlagsARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDataGraphProcessingEngineARM {
	pub type_: VkPhysicalDeviceDataGraphProcessingEngineTypeARM,
	pub isForeign: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDataGraphOperationSupportARM {
	pub operationType: VkPhysicalDeviceDataGraphOperationTypeARM,
	pub name: [i8; VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM as usize],
	pub version: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkQueueFamilyDataGraphPropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub engine: VkPhysicalDeviceDataGraphProcessingEngineARM,
	pub operation: VkPhysicalDeviceDataGraphOperationSupportARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDataGraphProcessingEngineCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub processingEngineCount: u32,
	pub pProcessingEngines: *mut VkPhysicalDeviceDataGraphProcessingEngineARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub queueFamilyIndex: u32,
	pub engineType: VkPhysicalDeviceDataGraphProcessingEngineTypeARM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkQueueFamilyDataGraphProcessingEnginePropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub foreignSemaphoreHandleTypes: VkExternalSemaphoreHandleTypeFlags,
	pub foreignMemoryHandleTypes: VkExternalMemoryHandleTypeFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dimension: u32,
	pub zeroCount: u32,
	pub groupSize: u32,
}
type PFN_vkCreateDataGraphPipelinesARM = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkDataGraphPipelineCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult;
type PFN_vkCreateDataGraphPipelineSessionARM = extern "system" fn(device: VkDevice, pCreateInfo: *const VkDataGraphPipelineSessionCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pSession: *mut VkDataGraphPipelineSessionARM) -> VkResult;
type PFN_vkGetDataGraphPipelineSessionBindPointRequirementsARM = extern "system" fn(device: VkDevice, pInfo: *const VkDataGraphPipelineSessionBindPointRequirementsInfoARM, pBindPointRequirementCount: *mut uint32_t, pBindPointRequirements: *mut VkDataGraphPipelineSessionBindPointRequirementARM) -> VkResult;
type PFN_vkGetDataGraphPipelineSessionMemoryRequirementsARM = extern "system" fn(device: VkDevice, pInfo: *const VkDataGraphPipelineSessionMemoryRequirementsInfoARM, pMemoryRequirements: *mut VkMemoryRequirements2);
type PFN_vkBindDataGraphPipelineSessionMemoryARM = extern "system" fn(device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindDataGraphPipelineSessionMemoryInfoARM) -> VkResult;
type PFN_vkDestroyDataGraphPipelineSessionARM = extern "system" fn(device: VkDevice, session: VkDataGraphPipelineSessionARM, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCmdDispatchDataGraphARM = extern "system" fn(commandBuffer: VkCommandBuffer, session: VkDataGraphPipelineSessionARM, pInfo: *const VkDataGraphPipelineDispatchInfoARM);
type PFN_vkGetDataGraphPipelineAvailablePropertiesARM = extern "system" fn(device: VkDevice, pPipelineInfo: *const VkDataGraphPipelineInfoARM, pPropertiesCount: *mut uint32_t, pProperties: *mut VkDataGraphPipelinePropertyARM) -> VkResult;
type PFN_vkGetDataGraphPipelinePropertiesARM = extern "system" fn(device: VkDevice, pPipelineInfo: *const VkDataGraphPipelineInfoARM, propertiesCount: u32, pProperties: *mut VkDataGraphPipelinePropertyQueryResultARM) -> VkResult;
type PFN_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM = extern "system" fn(physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, pQueueFamilyDataGraphPropertyCount: *mut uint32_t, pQueueFamilyDataGraphProperties: *mut VkQueueFamilyDataGraphPropertiesARM) -> VkResult;
type PFN_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM = extern "system" fn(physicalDevice: VkPhysicalDevice, pQueueFamilyDataGraphProcessingEngineInfo: *const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM, pQueueFamilyDataGraphProcessingEngineProperties: *mut VkQueueFamilyDataGraphProcessingEnginePropertiesARM);
extern "system" fn dummy_vkCreateDataGraphPipelinesARM(_: VkDevice, _: VkDeferredOperationKHR, _: VkPipelineCache, _: u32, _: *const VkDataGraphPipelineCreateInfoARM, _: *const VkAllocationCallbacks, _: *mut VkPipeline) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateDataGraphPipelinesARM()` is NULL");
}
pub trait VK_ARM_data_graph: Debug {
	fn vkCreateDataGraphPipelinesARM(&self, device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkDataGraphPipelineCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_data_graph {
	vk_create_data_graph_pipelines_arm: PFN_vkCreateDataGraphPipelinesARM,
}
impl VK_ARM_data_graph for Vulkan_ARM_data_graph {
	fn vkCreateDataGraphPipelinesARM(&self, device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkDataGraphPipelineCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult {
		(self.vk_create_data_graph_pipelines_arm)(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)
	}
}
impl Default for Vulkan_ARM_data_graph {
	fn default() -> Self {
		Self {
			vk_create_data_graph_pipelines_arm: dummy_vkCreateDataGraphPipelinesARM,
		}
	}
}
impl Vulkan_ARM_data_graph {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_data_graph_pipelines_arm: {let proc = get_proc_address(instance, "vkCreateDataGraphPipelinesARM"); if proc == null() {dummy_vkCreateDataGraphPipelinesARM} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub multiviewPerViewRenderAreas: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub perViewRenderAreaCount: u32,
	pub pPerViewRenderAreas: *const VkRect2D,
}
pub trait VK_QCOM_multiview_per_view_render_areas: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_multiview_per_view_render_areas {}
impl VK_QCOM_multiview_per_view_render_areas for Vulkan_QCOM_multiview_per_view_render_areas {}
impl Default for Vulkan_QCOM_multiview_per_view_render_areas {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_multiview_per_view_render_areas {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePerStageDescriptorSetFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub perStageDescriptorSet: VkBool32,
	pub dynamicPipelineLayout: VkBool32,
}
pub trait VK_NV_per_stage_descriptor_set: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_per_stage_descriptor_set {}
impl VK_NV_per_stage_descriptor_set for Vulkan_NV_per_stage_descriptor_set {}
impl Default for Vulkan_NV_per_stage_descriptor_set {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_per_stage_descriptor_set {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBlockMatchWindowCompareModeQCOM {
	VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM = 0,
	VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM = 1,
	VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_ENUM_QCOM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceImageProcessing2FeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub textureBlockMatch2: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceImageProcessing2PropertiesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxBlockMatchWindow: VkExtent2D,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSamplerBlockMatchWindowCreateInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub windowExtent: VkExtent2D,
	pub windowCompareMode: VkBlockMatchWindowCompareModeQCOM,
}
pub trait VK_QCOM_image_processing2: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_image_processing2 {}
impl VK_QCOM_image_processing2 for Vulkan_QCOM_image_processing2 {}
impl Default for Vulkan_QCOM_image_processing2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_image_processing2 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCubicFilterWeightsQCOM {
	VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM = 0,
	VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM = 1,
	VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM = 2,
	VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM = 3,
	VK_CUBIC_FILTER_WEIGHTS_MAX_ENUM_QCOM = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCubicWeightsFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub selectableCubicWeights: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSamplerCubicWeightsCreateInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub cubicWeights: VkCubicFilterWeightsQCOM,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBlitImageCubicWeightsInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub cubicWeights: VkCubicFilterWeightsQCOM,
}
pub trait VK_QCOM_filter_cubic_weights: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_filter_cubic_weights {}
impl VK_QCOM_filter_cubic_weights for Vulkan_QCOM_filter_cubic_weights {}
impl Default for Vulkan_QCOM_filter_cubic_weights {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_filter_cubic_weights {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceYcbcrDegammaFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub ycbcrDegamma: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub enableYDegamma: VkBool32,
	pub enableCbCrDegamma: VkBool32,
}
pub trait VK_QCOM_ycbcr_degamma: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_ycbcr_degamma {}
impl VK_QCOM_ycbcr_degamma for Vulkan_QCOM_ycbcr_degamma {}
impl Default for Vulkan_QCOM_ycbcr_degamma {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_ycbcr_degamma {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCubicClampFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cubicRangeClamp: VkBool32,
}
pub trait VK_QCOM_filter_cubic_clamp: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_filter_cubic_clamp {}
impl VK_QCOM_filter_cubic_clamp for Vulkan_QCOM_filter_cubic_clamp {}
impl Default for Vulkan_QCOM_filter_cubic_clamp {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_filter_cubic_clamp {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub attachmentFeedbackLoopDynamicState: VkBool32,
}
type PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, aspectMask: VkImageAspectFlags);
extern "system" fn dummy_vkCmdSetAttachmentFeedbackLoopEnableEXT(_: VkCommandBuffer, _: VkImageAspectFlags) {
	panic!("Vulkan function pointer of `vkCmdSetAttachmentFeedbackLoopEnableEXT()` is NULL");
}
pub trait VK_EXT_attachment_feedback_loop_dynamic_state: Debug {
	fn vkCmdSetAttachmentFeedbackLoopEnableEXT(&self, commandBuffer: VkCommandBuffer, aspectMask: VkImageAspectFlags);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_attachment_feedback_loop_dynamic_state {
	vk_cmd_set_attachment_feedback_loop_enable_ext: PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT,
}
impl VK_EXT_attachment_feedback_loop_dynamic_state for Vulkan_EXT_attachment_feedback_loop_dynamic_state {
	fn vkCmdSetAttachmentFeedbackLoopEnableEXT(&self, commandBuffer: VkCommandBuffer, aspectMask: VkImageAspectFlags) {
		(self.vk_cmd_set_attachment_feedback_loop_enable_ext)(commandBuffer, aspectMask)
	}
}
impl Default for Vulkan_EXT_attachment_feedback_loop_dynamic_state {
	fn default() -> Self {
		Self {
			vk_cmd_set_attachment_feedback_loop_enable_ext: dummy_vkCmdSetAttachmentFeedbackLoopEnableEXT,
		}
	}
}
impl Vulkan_EXT_attachment_feedback_loop_dynamic_state {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_attachment_feedback_loop_enable_ext: {let proc = get_proc_address(instance, "vkCmdSetAttachmentFeedbackLoopEnableEXT"); if proc == null() {dummy_vkCmdSetAttachmentFeedbackLoopEnableEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkLayeredDriverUnderlyingApiMSFT {
	VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT = 0,
	VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT = 1,
	VK_LAYERED_DRIVER_UNDERLYING_API_MAX_ENUM_MSFT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceLayeredDriverPropertiesMSFT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub underlyingAPI: VkLayeredDriverUnderlyingApiMSFT,
}
pub trait VK_MSFT_layered_driver: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_MSFT_layered_driver {}
impl VK_MSFT_layered_driver for Vulkan_MSFT_layered_driver {}
impl Default for Vulkan_MSFT_layered_driver {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_MSFT_layered_driver {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub descriptorPoolOverallocation: VkBool32,
}
pub trait VK_NV_descriptor_pool_overallocation: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_descriptor_pool_overallocation {}
impl VK_NV_descriptor_pool_overallocation for Vulkan_NV_descriptor_pool_overallocation {}
impl Default for Vulkan_NV_descriptor_pool_overallocation {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_descriptor_pool_overallocation {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceTileMemoryHeapFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub tileMemoryHeap: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceTileMemoryHeapPropertiesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub queueSubmitBoundary: VkBool32,
	pub tileBufferTransfers: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTileMemoryRequirementsQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub size: VkDeviceSize,
	pub alignment: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTileMemoryBindInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub memory: VkDeviceMemory,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTileMemorySizeInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub size: VkDeviceSize,
}
type PFN_vkCmdBindTileMemoryQCOM = extern "system" fn(commandBuffer: VkCommandBuffer, pTileMemoryBindInfo: *const VkTileMemoryBindInfoQCOM);
extern "system" fn dummy_vkCmdBindTileMemoryQCOM(_: VkCommandBuffer, _: *const VkTileMemoryBindInfoQCOM) {
	panic!("Vulkan function pointer of `vkCmdBindTileMemoryQCOM()` is NULL");
}
pub trait VK_QCOM_tile_memory_heap: Debug {
	fn vkCmdBindTileMemoryQCOM(&self, commandBuffer: VkCommandBuffer, pTileMemoryBindInfo: *const VkTileMemoryBindInfoQCOM);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_tile_memory_heap {
	vk_cmd_bind_tile_memory_qcom: PFN_vkCmdBindTileMemoryQCOM,
}
impl VK_QCOM_tile_memory_heap for Vulkan_QCOM_tile_memory_heap {
	fn vkCmdBindTileMemoryQCOM(&self, commandBuffer: VkCommandBuffer, pTileMemoryBindInfo: *const VkTileMemoryBindInfoQCOM) {
		(self.vk_cmd_bind_tile_memory_qcom)(commandBuffer, pTileMemoryBindInfo)
	}
}
impl Default for Vulkan_QCOM_tile_memory_heap {
	fn default() -> Self {
		Self {
			vk_cmd_bind_tile_memory_qcom: dummy_vkCmdBindTileMemoryQCOM,
		}
	}
}
impl Vulkan_QCOM_tile_memory_heap {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_bind_tile_memory_qcom: {let proc = get_proc_address(instance, "vkCmdBindTileMemoryQCOM"); if proc == null() {dummy_vkCmdBindTileMemoryQCOM} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDisplaySurfaceStereoTypeNV {
	VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV = 0,
	VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV = 1,
	VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV = 2,
	VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV = 3,
	VK_DISPLAY_SURFACE_STEREO_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplaySurfaceStereoCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stereoType: VkDisplaySurfaceStereoTypeNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDisplayModeStereoPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub hdmi3DSupported: VkBool32,
}
pub trait VK_NV_display_stereo: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_display_stereo {}
impl VK_NV_display_stereo for Vulkan_NV_display_stereo {}
impl Default for Vulkan_NV_display_stereo {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_display_stereo {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRawAccessChainsFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderRawAccessChains: VkBool32,
}
pub trait VK_NV_raw_access_chains: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_raw_access_chains {}
impl VK_NV_raw_access_chains for Vulkan_NV_raw_access_chains {}
impl Default for Vulkan_NV_raw_access_chains {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_raw_access_chains {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
// Define handle `VkExternalComputeQueueNV`
#[derive(Debug, Clone, Copy)] pub struct VkExternalComputeQueueNV_T {}
pub type VkExternalComputeQueueNV = *const VkExternalComputeQueueNV_T;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExternalComputeQueueDeviceCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub reservedExternalQueues: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExternalComputeQueueCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub preferredQueue: VkQueue,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkExternalComputeQueueDataParamsNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub deviceIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceExternalComputeQueuePropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub externalDataSize: u32,
	pub maxExternalQueues: u32,
}
type PFN_vkCreateExternalComputeQueueNV = extern "system" fn(device: VkDevice, pCreateInfo: *const VkExternalComputeQueueCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pExternalQueue: *mut VkExternalComputeQueueNV) -> VkResult;
type PFN_vkDestroyExternalComputeQueueNV = extern "system" fn(device: VkDevice, externalQueue: VkExternalComputeQueueNV, pAllocator: *const VkAllocationCallbacks);
type PFN_vkGetExternalComputeQueueDataNV = extern "system" fn(externalQueue: VkExternalComputeQueueNV, params: *mut VkExternalComputeQueueDataParamsNV, pData: *mut c_void);
extern "system" fn dummy_vkCreateExternalComputeQueueNV(_: VkDevice, _: *const VkExternalComputeQueueCreateInfoNV, _: *const VkAllocationCallbacks, _: *mut VkExternalComputeQueueNV) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateExternalComputeQueueNV()` is NULL");
}
pub trait VK_NV_external_compute_queue: Debug {
	fn vkCreateExternalComputeQueueNV(&self, device: VkDevice, pCreateInfo: *const VkExternalComputeQueueCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pExternalQueue: *mut VkExternalComputeQueueNV) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_external_compute_queue {
	vk_create_external_compute_queue_nv: PFN_vkCreateExternalComputeQueueNV,
}
impl VK_NV_external_compute_queue for Vulkan_NV_external_compute_queue {
	fn vkCreateExternalComputeQueueNV(&self, device: VkDevice, pCreateInfo: *const VkExternalComputeQueueCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pExternalQueue: *mut VkExternalComputeQueueNV) -> VkResult {
		(self.vk_create_external_compute_queue_nv)(device, pCreateInfo, pAllocator, pExternalQueue)
	}
}
impl Default for Vulkan_NV_external_compute_queue {
	fn default() -> Self {
		Self {
			vk_create_external_compute_queue_nv: dummy_vkCreateExternalComputeQueueNV,
		}
	}
}
impl Vulkan_NV_external_compute_queue {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_external_compute_queue_nv: {let proc = get_proc_address(instance, "vkCreateExternalComputeQueueNV"); if proc == null() {dummy_vkCreateExternalComputeQueueNV} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCommandBufferInheritanceFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub commandBufferInheritance: VkBool32,
}
pub trait VK_NV_command_buffer_inheritance: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_command_buffer_inheritance {}
impl VK_NV_command_buffer_inheritance for Vulkan_NV_command_buffer_inheritance {}
impl Default for Vulkan_NV_command_buffer_inheritance {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_command_buffer_inheritance {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderFloat16VectorAtomics: VkBool32,
}
pub trait VK_NV_shader_atomic_float16_vector: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_shader_atomic_float16_vector {}
impl VK_NV_shader_atomic_float16_vector for Vulkan_NV_shader_atomic_float16_vector {}
impl Default for Vulkan_NV_shader_atomic_float16_vector {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_shader_atomic_float16_vector {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderReplicatedComposites: VkBool32,
}
pub trait VK_EXT_shader_replicated_composites: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_replicated_composites {}
impl VK_EXT_shader_replicated_composites for Vulkan_EXT_shader_replicated_composites {}
impl Default for Vulkan_EXT_shader_replicated_composites {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_replicated_composites {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceShaderFloat8FeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderFloat8: VkBool32,
	pub shaderFloat8CooperativeMatrix: VkBool32,
}
pub trait VK_EXT_shader_float8: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_float8 {}
impl VK_EXT_shader_float8 for Vulkan_EXT_shader_float8 {}
impl Default for Vulkan_EXT_shader_float8 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_float8 {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingValidationFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rayTracingValidation: VkBool32,
}
pub trait VK_NV_ray_tracing_validation: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_ray_tracing_validation {}
impl VK_NV_ray_tracing_validation for Vulkan_NV_ray_tracing_validation {}
impl Default for Vulkan_NV_ray_tracing_validation {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_ray_tracing_validation {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkClusterAccelerationStructureAddressResolutionFlagsNV = VkFlags;
pub type VkClusterAccelerationStructureClusterFlagsNV = VkFlags;
pub type VkClusterAccelerationStructureGeometryFlagsNV = VkFlags;
pub type VkClusterAccelerationStructureIndexFormatFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkClusterAccelerationStructureTypeNV {
	VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV = 0,
	VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV = 1,
	VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV = 2,
	VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkClusterAccelerationStructureOpTypeNV {
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV = 0,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV = 1,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV = 2,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV = 3,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV = 4,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV = 5,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkClusterAccelerationStructureOpModeNV {
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV = 0,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV = 1,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV = 2,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkClusterAccelerationStructureAddressResolutionFlagBitsNV {
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_NONE_NV = 0,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV = 0x00000001,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV = 0x00000002,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV = 0x00000004,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV = 0x00000008,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV = 0x00000010,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV = 0x00000020,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkClusterAccelerationStructureClusterFlagBitsNV {
	VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV = 0x00000001,
	VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkClusterAccelerationStructureGeometryFlagBitsNV {
	VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV = 0x00000001,
	VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV = 0x00000002,
	VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV = 0x00000004,
	VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkClusterAccelerationStructureIndexFormatFlagBitsNV {
	VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV = 0x00000001,
	VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV = 0x00000002,
	VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV = 0x00000004,
	VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkClusterAccelerationStructureOpInputNV {
	pub pClustersBottomLevel: *mut VkClusterAccelerationStructureClustersBottomLevelInputNV,
	pub pTriangleClusters: *mut VkClusterAccelerationStructureTriangleClusterInputNV,
	pub pMoveObjects: *mut VkClusterAccelerationStructureMoveObjectsInputNV,
}
impl Debug for VkClusterAccelerationStructureOpInputNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClusterAccelerationStructureOpInputNV")
		.field("pClustersBottomLevel", unsafe {&self.pClustersBottomLevel})
		.field("pTriangleClusters", unsafe {&self.pTriangleClusters})
		.field("pMoveObjects", unsafe {&self.pMoveObjects})
		.finish()
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceClusterAccelerationStructureFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub clusterAccelerationStructure: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceClusterAccelerationStructurePropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxVerticesPerCluster: u32,
	pub maxTrianglesPerCluster: u32,
	pub clusterScratchByteAlignment: u32,
	pub clusterByteAlignment: u32,
	pub clusterTemplateByteAlignment: u32,
	pub clusterBottomLevelByteAlignment: u32,
	pub clusterTemplateBoundsByteAlignment: u32,
	pub maxClusterGeometryIndex: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkClusterAccelerationStructureClustersBottomLevelInputNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxTotalClusterCount: u32,
	pub maxClusterCountPerAccelerationStructure: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkClusterAccelerationStructureTriangleClusterInputNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub vertexFormat: VkFormat,
	pub maxGeometryIndexValue: u32,
	pub maxClusterUniqueGeometryCount: u32,
	pub maxClusterTriangleCount: u32,
	pub maxClusterVertexCount: u32,
	pub maxTotalTriangleCount: u32,
	pub maxTotalVertexCount: u32,
	pub minPositionTruncateBitCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkClusterAccelerationStructureMoveObjectsInputNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub type_: VkClusterAccelerationStructureTypeNV,
	pub noMoveOverlap: VkBool32,
	pub maxMovedBytes: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkClusterAccelerationStructureInputInfoNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxAccelerationStructureCount: u32,
	pub flags: VkBuildAccelerationStructureFlagsKHR,
	pub opType: VkClusterAccelerationStructureOpTypeNV,
	pub opMode: VkClusterAccelerationStructureOpModeNV,
	pub opInput: VkClusterAccelerationStructureOpInputNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkStridedDeviceAddressRegionKHR {
	pub deviceAddress: VkDeviceAddress,
	pub stride: VkDeviceSize,
	pub size: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkClusterAccelerationStructureCommandsInfoNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub input: VkClusterAccelerationStructureInputInfoNV,
	pub dstImplicitData: VkDeviceAddress,
	pub scratchData: VkDeviceAddress,
	pub dstAddressesArray: VkStridedDeviceAddressRegionKHR,
	pub dstSizesArray: VkStridedDeviceAddressRegionKHR,
	pub srcInfosArray: VkStridedDeviceAddressRegionKHR,
	pub srcInfosCount: VkDeviceAddress,
	pub addressResolutionFlags: VkClusterAccelerationStructureAddressResolutionFlagsNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkStridedDeviceAddressNV {
	pub startAddress: VkDeviceAddress,
	pub strideInBytes: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV {
	/// Bitfield: geometryIndex: u32 in 24 bits
	/// Bitfield: reserved: u32 in 5 bits
	/// Bitfield: geometryFlags: u32 in 3 bits
	bitfield1: u32,
}
impl VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV {
	pub fn get_geometryIndex(&self) -> u32 {
		(self.bitfield1 >> 0) & 0xffffff
	}
	pub fn set_geometryIndex(&mut self, value: u32) {
		self.bitfield1 = (value & 0xffffff) << 0;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 24) & 0x1f
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1f) << 24;
	}
	pub fn get_geometryFlags(&self) -> u32 {
		(self.bitfield1 >> 29) & 0x7
	}
	pub fn set_geometryFlags(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7) << 29;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkClusterAccelerationStructureMoveObjectsInfoNV {
	pub srcAccelerationStructure: VkDeviceAddress,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV {
	pub clusterReferencesCount: u32,
	pub clusterReferencesStride: u32,
	pub clusterReferences: VkDeviceAddress,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkClusterAccelerationStructureBuildTriangleClusterInfoNV {
	pub clusterID: u32,
	pub clusterFlags: VkClusterAccelerationStructureClusterFlagsNV,
	/// Bitfield: triangleCount: u32 in 9 bits
	/// Bitfield: vertexCount: u32 in 9 bits
	/// Bitfield: positionTruncateBitCount: u32 in 6 bits
	/// Bitfield: indexType: u32 in 4 bits
	/// Bitfield: opacityMicromapIndexType: u32 in 4 bits
	bitfield1: u32,
	pub baseGeometryIndexAndGeometryFlags: VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV,
	pub indexBufferStride: u16,
	pub vertexBufferStride: u16,
	pub geometryIndexAndFlagsBufferStride: u16,
	pub opacityMicromapIndexBufferStride: u16,
	pub indexBuffer: VkDeviceAddress,
	pub vertexBuffer: VkDeviceAddress,
	pub geometryIndexAndFlagsBuffer: VkDeviceAddress,
	pub opacityMicromapArray: VkDeviceAddress,
	pub opacityMicromapIndexBuffer: VkDeviceAddress,
}
impl VkClusterAccelerationStructureBuildTriangleClusterInfoNV {
	pub fn get_triangleCount(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1ff
	}
	pub fn set_triangleCount(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1ff) << 0;
	}
	pub fn get_vertexCount(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1ff
	}
	pub fn set_vertexCount(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1ff) << 9;
	}
	pub fn get_positionTruncateBitCount(&self) -> u32 {
		(self.bitfield1 >> 18) & 0x3f
	}
	pub fn set_positionTruncateBitCount(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3f) << 18;
	}
	pub fn get_indexType(&self) -> u32 {
		(self.bitfield1 >> 24) & 0xf
	}
	pub fn set_indexType(&mut self, value: u32) {
		self.bitfield1 = (value & 0xf) << 24;
	}
	pub fn get_opacityMicromapIndexType(&self) -> u32 {
		(self.bitfield1 >> 28) & 0xf
	}
	pub fn set_opacityMicromapIndexType(&mut self, value: u32) {
		self.bitfield1 = (value & 0xf) << 28;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV {
	pub clusterID: u32,
	pub clusterFlags: VkClusterAccelerationStructureClusterFlagsNV,
	/// Bitfield: triangleCount: u32 in 9 bits
	/// Bitfield: vertexCount: u32 in 9 bits
	/// Bitfield: positionTruncateBitCount: u32 in 6 bits
	/// Bitfield: indexType: u32 in 4 bits
	/// Bitfield: opacityMicromapIndexType: u32 in 4 bits
	bitfield1: u32,
	pub baseGeometryIndexAndGeometryFlags: VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV,
	pub indexBufferStride: u16,
	pub vertexBufferStride: u16,
	pub geometryIndexAndFlagsBufferStride: u16,
	pub opacityMicromapIndexBufferStride: u16,
	pub indexBuffer: VkDeviceAddress,
	pub vertexBuffer: VkDeviceAddress,
	pub geometryIndexAndFlagsBuffer: VkDeviceAddress,
	pub opacityMicromapArray: VkDeviceAddress,
	pub opacityMicromapIndexBuffer: VkDeviceAddress,
	pub instantiationBoundingBoxLimit: VkDeviceAddress,
}
impl VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV {
	pub fn get_triangleCount(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1ff
	}
	pub fn set_triangleCount(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1ff) << 0;
	}
	pub fn get_vertexCount(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1ff
	}
	pub fn set_vertexCount(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1ff) << 9;
	}
	pub fn get_positionTruncateBitCount(&self) -> u32 {
		(self.bitfield1 >> 18) & 0x3f
	}
	pub fn set_positionTruncateBitCount(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3f) << 18;
	}
	pub fn get_indexType(&self) -> u32 {
		(self.bitfield1 >> 24) & 0xf
	}
	pub fn set_indexType(&mut self, value: u32) {
		self.bitfield1 = (value & 0xf) << 24;
	}
	pub fn get_opacityMicromapIndexType(&self) -> u32 {
		(self.bitfield1 >> 28) & 0xf
	}
	pub fn set_opacityMicromapIndexType(&mut self, value: u32) {
		self.bitfield1 = (value & 0xf) << 28;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkClusterAccelerationStructureInstantiateClusterInfoNV {
	pub clusterIdOffset: u32,
	/// Bitfield: geometryIndexOffset: u32 in 24 bits
	/// Bitfield: reserved: u32 in 8 bits
	bitfield1: u32,
	pub clusterTemplateAddress: VkDeviceAddress,
	pub vertexBuffer: VkStridedDeviceAddressNV,
}
impl VkClusterAccelerationStructureInstantiateClusterInfoNV {
	pub fn get_geometryIndexOffset(&self) -> u32 {
		(self.bitfield1 >> 0) & 0xffffff
	}
	pub fn set_geometryIndexOffset(&mut self, value: u32) {
		self.bitfield1 = (value & 0xffffff) << 0;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 24) & 0xff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0xff) << 24;
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkClusterAccelerationStructureGetTemplateIndicesInfoNV {
	pub clusterTemplateAddress: VkDeviceAddress,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureBuildSizesInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub accelerationStructureSize: VkDeviceSize,
	pub updateScratchSize: VkDeviceSize,
	pub buildScratchSize: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub allowClusterAccelerationStructure: VkBool32,
}
type PFN_vkGetClusterAccelerationStructureBuildSizesNV = extern "system" fn(device: VkDevice, pInfo: *const VkClusterAccelerationStructureInputInfoNV, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR);
type PFN_vkCmdBuildClusterAccelerationStructureIndirectNV = extern "system" fn(commandBuffer: VkCommandBuffer, pCommandInfos: *const VkClusterAccelerationStructureCommandsInfoNV);
extern "system" fn dummy_vkGetClusterAccelerationStructureBuildSizesNV(_: VkDevice, _: *const VkClusterAccelerationStructureInputInfoNV, _: *mut VkAccelerationStructureBuildSizesInfoKHR) {
	panic!("Vulkan function pointer of `vkGetClusterAccelerationStructureBuildSizesNV()` is NULL");
}
pub trait VK_NV_cluster_acceleration_structure: Debug {
	fn vkGetClusterAccelerationStructureBuildSizesNV(&self, device: VkDevice, pInfo: *const VkClusterAccelerationStructureInputInfoNV, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_cluster_acceleration_structure {
	vk_get_cluster_acceleration_structure_build_sizes_nv: PFN_vkGetClusterAccelerationStructureBuildSizesNV,
}
impl VK_NV_cluster_acceleration_structure for Vulkan_NV_cluster_acceleration_structure {
	fn vkGetClusterAccelerationStructureBuildSizesNV(&self, device: VkDevice, pInfo: *const VkClusterAccelerationStructureInputInfoNV, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR) {
		(self.vk_get_cluster_acceleration_structure_build_sizes_nv)(device, pInfo, pSizeInfo)
	}
}
impl Default for Vulkan_NV_cluster_acceleration_structure {
	fn default() -> Self {
		Self {
			vk_get_cluster_acceleration_structure_build_sizes_nv: dummy_vkGetClusterAccelerationStructureBuildSizesNV,
		}
	}
}
impl Vulkan_NV_cluster_acceleration_structure {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_cluster_acceleration_structure_build_sizes_nv: {let proc = get_proc_address(instance, "vkGetClusterAccelerationStructureBuildSizesNV"); if proc == null() {dummy_vkGetClusterAccelerationStructureBuildSizesNV} else {unsafe {transmute(proc)}}},
		}
	}
}
pub const VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV: u32 = !0u32;
pub type VkPartitionedAccelerationStructureInstanceFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPartitionedAccelerationStructureOpTypeNV {
	VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV = 0,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV = 1,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV = 2,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPartitionedAccelerationStructureInstanceFlagBitsNV {
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV = 0x00000001,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV = 0x00000002,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV = 0x00000004,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV = 0x00000008,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV = 0x00000010,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub partitionedAccelerationStructure: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxPartitionCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPartitionedAccelerationStructureFlagsNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub enablePartitionTranslation: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBuildPartitionedAccelerationStructureIndirectCommandNV {
	pub opType: VkPartitionedAccelerationStructureOpTypeNV,
	pub argCount: u32,
	pub argData: VkStridedDeviceAddressNV,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPartitionedAccelerationStructureWriteInstanceDataNV {
	pub transform: VkTransformMatrixKHR,
	pub explicitAABB: [f32; 6 as usize],
	pub instanceID: u32,
	pub instanceMask: u32,
	pub instanceContributionToHitGroupIndex: u32,
	pub instanceFlags: VkPartitionedAccelerationStructureInstanceFlagsNV,
	pub instanceIndex: u32,
	pub partitionIndex: u32,
	pub accelerationStructure: VkDeviceAddress,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPartitionedAccelerationStructureUpdateInstanceDataNV {
	pub instanceIndex: u32,
	pub instanceContributionToHitGroupIndex: u32,
	pub accelerationStructure: VkDeviceAddress,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPartitionedAccelerationStructureWritePartitionTranslationDataNV {
	pub partitionIndex: u32,
	pub partitionTranslation: [f32; 3 as usize],
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkWriteDescriptorSetPartitionedAccelerationStructureNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub accelerationStructureCount: u32,
	pub pAccelerationStructures: *const VkDeviceAddress,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPartitionedAccelerationStructureInstancesInputNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkBuildAccelerationStructureFlagsKHR,
	pub instanceCount: u32,
	pub maxInstancePerPartitionCount: u32,
	pub partitionCount: u32,
	pub maxInstanceInGlobalPartitionCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBuildPartitionedAccelerationStructureInfoNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub input: VkPartitionedAccelerationStructureInstancesInputNV,
	pub srcAccelerationStructureData: VkDeviceAddress,
	pub dstAccelerationStructureData: VkDeviceAddress,
	pub scratchData: VkDeviceAddress,
	pub srcInfos: VkDeviceAddress,
	pub srcInfosCount: VkDeviceAddress,
}
type PFN_vkGetPartitionedAccelerationStructuresBuildSizesNV = extern "system" fn(device: VkDevice, pInfo: *const VkPartitionedAccelerationStructureInstancesInputNV, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR);
type PFN_vkCmdBuildPartitionedAccelerationStructuresNV = extern "system" fn(commandBuffer: VkCommandBuffer, pBuildInfo: *const VkBuildPartitionedAccelerationStructureInfoNV);
extern "system" fn dummy_vkGetPartitionedAccelerationStructuresBuildSizesNV(_: VkDevice, _: *const VkPartitionedAccelerationStructureInstancesInputNV, _: *mut VkAccelerationStructureBuildSizesInfoKHR) {
	panic!("Vulkan function pointer of `vkGetPartitionedAccelerationStructuresBuildSizesNV()` is NULL");
}
pub trait VK_NV_partitioned_acceleration_structure: Debug {
	fn vkGetPartitionedAccelerationStructuresBuildSizesNV(&self, device: VkDevice, pInfo: *const VkPartitionedAccelerationStructureInstancesInputNV, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_partitioned_acceleration_structure {
	vk_get_partitioned_acceleration_structures_build_sizes_nv: PFN_vkGetPartitionedAccelerationStructuresBuildSizesNV,
}
impl VK_NV_partitioned_acceleration_structure for Vulkan_NV_partitioned_acceleration_structure {
	fn vkGetPartitionedAccelerationStructuresBuildSizesNV(&self, device: VkDevice, pInfo: *const VkPartitionedAccelerationStructureInstancesInputNV, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR) {
		(self.vk_get_partitioned_acceleration_structures_build_sizes_nv)(device, pInfo, pSizeInfo)
	}
}
impl Default for Vulkan_NV_partitioned_acceleration_structure {
	fn default() -> Self {
		Self {
			vk_get_partitioned_acceleration_structures_build_sizes_nv: dummy_vkGetPartitionedAccelerationStructuresBuildSizesNV,
		}
	}
}
impl Vulkan_NV_partitioned_acceleration_structure {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_partitioned_acceleration_structures_build_sizes_nv: {let proc = get_proc_address(instance, "vkGetPartitionedAccelerationStructuresBuildSizesNV"); if proc == null() {dummy_vkGetPartitionedAccelerationStructuresBuildSizesNV} else {unsafe {transmute(proc)}}},
		}
	}
}
pub type VkIndirectCommandsInputModeFlagsEXT = VkFlags;
pub type VkIndirectCommandsLayoutUsageFlagsEXT = VkFlags;
// Define non-dispatchable handle `VkIndirectExecutionSetEXT`
#[cfg(target_pointer_width = "32")] pub type VkIndirectExecutionSetEXT = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkIndirectExecutionSetEXT_T {}
#[cfg(target_pointer_width = "64")] pub type VkIndirectExecutionSetEXT = *const VkIndirectExecutionSetEXT_T;
// Define non-dispatchable handle `VkIndirectCommandsLayoutEXT`
#[cfg(target_pointer_width = "32")] pub type VkIndirectCommandsLayoutEXT = u64;
#[cfg(target_pointer_width = "64")] #[derive(Debug, Clone, Copy)] pub struct VkIndirectCommandsLayoutEXT_T {}
#[cfg(target_pointer_width = "64")] pub type VkIndirectCommandsLayoutEXT = *const VkIndirectCommandsLayoutEXT_T;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkIndirectExecutionSetInfoTypeEXT {
	VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT = 0,
	VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT = 1,
	VK_INDIRECT_EXECUTION_SET_INFO_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkIndirectCommandsTokenTypeEXT {
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT = 0,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT = 1,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT = 2,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT = 3,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT = 4,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT = 5,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT = 6,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT = 7,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT = 8,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT = 9,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT = 1000202002,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT = 1000202003,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT = 1000328000,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT = 1000328001,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT = 1000386004,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkIndirectCommandsInputModeFlagBitsEXT {
	VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT = 0x00000001,
	VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT = 0x00000002,
	VK_INDIRECT_COMMANDS_INPUT_MODE_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkIndirectCommandsLayoutUsageFlagBitsEXT {
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT = 0x00000001,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT = 0x00000002,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkIndirectExecutionSetInfoEXT {
	pub pPipelineInfo: *const VkIndirectExecutionSetPipelineInfoEXT,
	pub pShaderInfo: *const VkIndirectExecutionSetShaderInfoEXT,
}
impl Debug for VkIndirectExecutionSetInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectExecutionSetInfoEXT")
		.field("pPipelineInfo", unsafe {&self.pPipelineInfo})
		.field("pShaderInfo", unsafe {&self.pShaderInfo})
		.finish()
	}
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkIndirectCommandsTokenDataEXT {
	pub pPushConstant: *const VkIndirectCommandsPushConstantTokenEXT,
	pub pVertexBuffer: *const VkIndirectCommandsVertexBufferTokenEXT,
	pub pIndexBuffer: *const VkIndirectCommandsIndexBufferTokenEXT,
	pub pExecutionSet: *const VkIndirectCommandsExecutionSetTokenEXT,
}
impl Debug for VkIndirectCommandsTokenDataEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectCommandsTokenDataEXT")
		.field("pPushConstant", unsafe {&self.pPushConstant})
		.field("pVertexBuffer", unsafe {&self.pVertexBuffer})
		.field("pIndexBuffer", unsafe {&self.pIndexBuffer})
		.field("pExecutionSet", unsafe {&self.pExecutionSet})
		.finish()
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceGeneratedCommands: VkBool32,
	pub dynamicGeneratedPipelineLayout: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxIndirectPipelineCount: u32,
	pub maxIndirectShaderObjectCount: u32,
	pub maxIndirectSequenceCount: u32,
	pub maxIndirectCommandsTokenCount: u32,
	pub maxIndirectCommandsTokenOffset: u32,
	pub maxIndirectCommandsIndirectStride: u32,
	pub supportedIndirectCommandsInputModes: VkIndirectCommandsInputModeFlagsEXT,
	pub supportedIndirectCommandsShaderStages: VkShaderStageFlags,
	pub supportedIndirectCommandsShaderStagesPipelineBinding: VkShaderStageFlags,
	pub supportedIndirectCommandsShaderStagesShaderBinding: VkShaderStageFlags,
	pub deviceGeneratedCommandsTransformFeedback: VkBool32,
	pub deviceGeneratedCommandsMultiDrawIndirectCount: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkGeneratedCommandsMemoryRequirementsInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub indirectExecutionSet: VkIndirectExecutionSetEXT,
	pub indirectCommandsLayout: VkIndirectCommandsLayoutEXT,
	pub maxSequenceCount: u32,
	pub maxDrawCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkIndirectExecutionSetPipelineInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub initialPipeline: VkPipeline,
	pub maxPipelineCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkIndirectExecutionSetShaderLayoutInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub setLayoutCount: u32,
	pub pSetLayouts: *const VkDescriptorSetLayout,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkIndirectExecutionSetShaderInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub shaderCount: u32,
	pub pInitialShaders: *const VkShaderEXT,
	pub pSetLayoutInfos: *const VkIndirectExecutionSetShaderLayoutInfoEXT,
	pub maxShaderCount: u32,
	pub pushConstantRangeCount: u32,
	pub pPushConstantRanges: *const VkPushConstantRange,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkIndirectExecutionSetCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkIndirectExecutionSetInfoTypeEXT,
	pub info: VkIndirectExecutionSetInfoEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkGeneratedCommandsInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub shaderStages: VkShaderStageFlags,
	pub indirectExecutionSet: VkIndirectExecutionSetEXT,
	pub indirectCommandsLayout: VkIndirectCommandsLayoutEXT,
	pub indirectAddress: VkDeviceAddress,
	pub indirectAddressSize: VkDeviceSize,
	pub preprocessAddress: VkDeviceAddress,
	pub preprocessSize: VkDeviceSize,
	pub maxSequenceCount: u32,
	pub sequenceCountAddress: VkDeviceAddress,
	pub maxDrawCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkWriteIndirectExecutionSetPipelineEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub index: u32,
	pub pipeline: VkPipeline,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkIndirectCommandsPushConstantTokenEXT {
	pub updateRange: VkPushConstantRange,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkIndirectCommandsVertexBufferTokenEXT {
	pub vertexBindingUnit: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkIndirectCommandsIndexBufferTokenEXT {
	pub mode: VkIndirectCommandsInputModeFlagBitsEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkIndirectCommandsExecutionSetTokenEXT {
	pub type_: VkIndirectExecutionSetInfoTypeEXT,
	pub shaderStages: VkShaderStageFlags,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkIndirectCommandsLayoutTokenEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkIndirectCommandsTokenTypeEXT,
	pub data: VkIndirectCommandsTokenDataEXT,
	pub offset: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkIndirectCommandsLayoutCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkIndirectCommandsLayoutUsageFlagsEXT,
	pub shaderStages: VkShaderStageFlags,
	pub indirectStride: u32,
	pub pipelineLayout: VkPipelineLayout,
	pub tokenCount: u32,
	pub pTokens: *const VkIndirectCommandsLayoutTokenEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDrawIndirectCountIndirectCommandEXT {
	pub bufferAddress: VkDeviceAddress,
	pub stride: u32,
	pub commandCount: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindVertexBufferIndirectCommandEXT {
	pub bufferAddress: VkDeviceAddress,
	pub size: u32,
	pub stride: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkBindIndexBufferIndirectCommandEXT {
	pub bufferAddress: VkDeviceAddress,
	pub size: u32,
	pub indexType: VkIndexType,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkGeneratedCommandsPipelineInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipeline: VkPipeline,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkGeneratedCommandsShaderInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderCount: u32,
	pub pShaders: *const VkShaderEXT,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkWriteIndirectExecutionSetShaderEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub index: u32,
	pub shader: VkShaderEXT,
}
type PFN_vkGetGeneratedCommandsMemoryRequirementsEXT = extern "system" fn(device: VkDevice, pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoEXT, pMemoryRequirements: *mut VkMemoryRequirements2);
type PFN_vkCmdPreprocessGeneratedCommandsEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoEXT, stateCommandBuffer: VkCommandBuffer);
type PFN_vkCmdExecuteGeneratedCommandsEXT = extern "system" fn(commandBuffer: VkCommandBuffer, isPreprocessed: VkBool32, pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoEXT);
type PFN_vkCreateIndirectCommandsLayoutEXT = extern "system" fn(device: VkDevice, pCreateInfo: *const VkIndirectCommandsLayoutCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pIndirectCommandsLayout: *mut VkIndirectCommandsLayoutEXT) -> VkResult;
type PFN_vkDestroyIndirectCommandsLayoutEXT = extern "system" fn(device: VkDevice, indirectCommandsLayout: VkIndirectCommandsLayoutEXT, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCreateIndirectExecutionSetEXT = extern "system" fn(device: VkDevice, pCreateInfo: *const VkIndirectExecutionSetCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pIndirectExecutionSet: *mut VkIndirectExecutionSetEXT) -> VkResult;
type PFN_vkDestroyIndirectExecutionSetEXT = extern "system" fn(device: VkDevice, indirectExecutionSet: VkIndirectExecutionSetEXT, pAllocator: *const VkAllocationCallbacks);
type PFN_vkUpdateIndirectExecutionSetPipelineEXT = extern "system" fn(device: VkDevice, indirectExecutionSet: VkIndirectExecutionSetEXT, executionSetWriteCount: u32, pExecutionSetWrites: *const VkWriteIndirectExecutionSetPipelineEXT);
type PFN_vkUpdateIndirectExecutionSetShaderEXT = extern "system" fn(device: VkDevice, indirectExecutionSet: VkIndirectExecutionSetEXT, executionSetWriteCount: u32, pExecutionSetWrites: *const VkWriteIndirectExecutionSetShaderEXT);
extern "system" fn dummy_vkGetGeneratedCommandsMemoryRequirementsEXT(_: VkDevice, _: *const VkGeneratedCommandsMemoryRequirementsInfoEXT, _: *mut VkMemoryRequirements2) {
	panic!("Vulkan function pointer of `vkGetGeneratedCommandsMemoryRequirementsEXT()` is NULL");
}
pub trait VK_EXT_device_generated_commands: Debug {
	fn vkGetGeneratedCommandsMemoryRequirementsEXT(&self, device: VkDevice, pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoEXT, pMemoryRequirements: *mut VkMemoryRequirements2);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_device_generated_commands {
	vk_get_generated_commands_memory_requirements_ext: PFN_vkGetGeneratedCommandsMemoryRequirementsEXT,
}
impl VK_EXT_device_generated_commands for Vulkan_EXT_device_generated_commands {
	fn vkGetGeneratedCommandsMemoryRequirementsEXT(&self, device: VkDevice, pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoEXT, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_get_generated_commands_memory_requirements_ext)(device, pInfo, pMemoryRequirements)
	}
}
impl Default for Vulkan_EXT_device_generated_commands {
	fn default() -> Self {
		Self {
			vk_get_generated_commands_memory_requirements_ext: dummy_vkGetGeneratedCommandsMemoryRequirementsEXT,
		}
	}
}
impl Vulkan_EXT_device_generated_commands {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_generated_commands_memory_requirements_ext: {let proc = get_proc_address(instance, "vkGetGeneratedCommandsMemoryRequirementsEXT"); if proc == null() {dummy_vkGetGeneratedCommandsMemoryRequirementsEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceImageAlignmentControlFeaturesMESA {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageAlignmentControl: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceImageAlignmentControlPropertiesMESA {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub supportedImageAlignmentMask: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkImageAlignmentControlCreateInfoMESA {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maximumRequestedAlignment: u32,
}
pub trait VK_MESA_image_alignment_control: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_MESA_image_alignment_control {}
impl VK_MESA_image_alignment_control for Vulkan_MESA_image_alignment_control {}
impl Default for Vulkan_MESA_image_alignment_control {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_MESA_image_alignment_control {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceDepthClampControlFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub depthClampControl: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineViewportDepthClampControlCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub depthClampMode: VkDepthClampModeEXT,
	pub pDepthClampRange: *const VkDepthClampRangeEXT,
}
pub trait VK_EXT_depth_clamp_control: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_depth_clamp_control {}
impl VK_EXT_depth_clamp_control for Vulkan_EXT_depth_clamp_control {}
impl Default for Vulkan_EXT_depth_clamp_control {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_depth_clamp_control {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceHdrVividFeaturesHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub hdrVivid: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkHdrVividDynamicMetadataHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dynamicMetadataSize: usize,
	pub pDynamicMetadata: *const c_void,
}
pub trait VK_HUAWEI_hdr_vivid: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_HUAWEI_hdr_vivid {}
impl VK_HUAWEI_hdr_vivid for Vulkan_HUAWEI_hdr_vivid {}
impl Default for Vulkan_HUAWEI_hdr_vivid {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_HUAWEI_hdr_vivid {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCooperativeMatrixFlexibleDimensionsPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub MGranularity: u32,
	pub NGranularity: u32,
	pub KGranularity: u32,
	pub AType: VkComponentTypeKHR,
	pub BType: VkComponentTypeKHR,
	pub CType: VkComponentTypeKHR,
	pub ResultType: VkComponentTypeKHR,
	pub saturatingAccumulation: VkBool32,
	pub scope: VkScopeKHR,
	pub workgroupInvocations: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCooperativeMatrix2FeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cooperativeMatrixWorkgroupScope: VkBool32,
	pub cooperativeMatrixFlexibleDimensions: VkBool32,
	pub cooperativeMatrixReductions: VkBool32,
	pub cooperativeMatrixConversions: VkBool32,
	pub cooperativeMatrixPerElementOperations: VkBool32,
	pub cooperativeMatrixTensorAddressing: VkBool32,
	pub cooperativeMatrixBlockLoads: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceCooperativeMatrix2PropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cooperativeMatrixWorkgroupScopeMaxWorkgroupSize: u32,
	pub cooperativeMatrixFlexibleDimensionsMaxDimension: u32,
	pub cooperativeMatrixWorkgroupScopeReservedSharedMemory: u32,
}
type PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixFlexibleDimensionsPropertiesNV) -> VkResult;
extern "system" fn dummy_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkCooperativeMatrixFlexibleDimensionsPropertiesNV) -> VkResult {
	panic!("Vulkan function pointer of `vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV()` is NULL");
}
pub trait VK_NV_cooperative_matrix2: Debug {
	fn vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixFlexibleDimensionsPropertiesNV) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_cooperative_matrix2 {
	vk_get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv: PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV,
}
impl VK_NV_cooperative_matrix2 for Vulkan_NV_cooperative_matrix2 {
	fn vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixFlexibleDimensionsPropertiesNV) -> VkResult {
		(self.vk_get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv)(physicalDevice, pPropertyCount, pProperties)
	}
}
impl Default for Vulkan_NV_cooperative_matrix2 {
	fn default() -> Self {
		Self {
			vk_get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv: dummy_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV,
		}
	}
}
impl Vulkan_NV_cooperative_matrix2 {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv: {let proc = get_proc_address(instance, "vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV"); if proc == null() {dummy_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePipelineOpacityMicromapFeaturesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineOpacityMicromap: VkBool32,
}
pub trait VK_ARM_pipeline_opacity_micromap: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_pipeline_opacity_micromap {}
impl VK_ARM_pipeline_opacity_micromap for Vulkan_ARM_pipeline_opacity_micromap {}
impl Default for Vulkan_ARM_pipeline_opacity_micromap {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_ARM_pipeline_opacity_micromap {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub vertexAttributeRobustness: VkBool32,
}
pub trait VK_EXT_vertex_attribute_robustness: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_vertex_attribute_robustness {}
impl VK_EXT_vertex_attribute_robustness for Vulkan_EXT_vertex_attribute_robustness {}
impl Default for Vulkan_EXT_vertex_attribute_robustness {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_vertex_attribute_robustness {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFormatPackFeaturesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub formatPack: VkBool32,
}
pub trait VK_ARM_format_pack: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_format_pack {}
impl VK_ARM_format_pack for Vulkan_ARM_format_pack {}
impl Default for Vulkan_ARM_format_pack {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_ARM_format_pack {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub fragmentDensityMapLayered: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxFragmentDensityMapLayers: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPipelineFragmentDensityMapLayeredCreateInfoVALVE {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maxFragmentDensityMapLayers: u32,
}
pub trait VK_VALVE_fragment_density_map_layered: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_VALVE_fragment_density_map_layered {}
impl VK_VALVE_fragment_density_map_layered for Vulkan_VALVE_fragment_density_map_layered {}
impl Default for Vulkan_VALVE_fragment_density_map_layered {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_VALVE_fragment_density_map_layered {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkSetPresentConfigNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub numFramesPerBatch: u32,
	pub presentConfigFeedback: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePresentMeteringFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentMetering: VkBool32,
}
pub trait VK_NV_present_metering: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_present_metering {}
impl VK_NV_present_metering for Vulkan_NV_present_metering {}
impl Default for Vulkan_NV_present_metering {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_present_metering {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRenderingEndInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
}
type PFN_vkCmdEndRendering2EXT = extern "system" fn(commandBuffer: VkCommandBuffer, pRenderingEndInfo: *const VkRenderingEndInfoEXT);
extern "system" fn dummy_vkCmdEndRendering2EXT(_: VkCommandBuffer, _: *const VkRenderingEndInfoEXT) {
	panic!("Vulkan function pointer of `vkCmdEndRendering2EXT()` is NULL");
}
pub trait VK_EXT_fragment_density_map_offset: Debug {
	fn vkCmdEndRendering2EXT(&self, commandBuffer: VkCommandBuffer, pRenderingEndInfo: *const VkRenderingEndInfoEXT);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_fragment_density_map_offset {
	vk_cmd_end_rendering2_ext: PFN_vkCmdEndRendering2EXT,
}
impl VK_EXT_fragment_density_map_offset for Vulkan_EXT_fragment_density_map_offset {
	fn vkCmdEndRendering2EXT(&self, commandBuffer: VkCommandBuffer, pRenderingEndInfo: *const VkRenderingEndInfoEXT) {
		(self.vk_cmd_end_rendering2_ext)(commandBuffer, pRenderingEndInfo)
	}
}
impl Default for Vulkan_EXT_fragment_density_map_offset {
	fn default() -> Self {
		Self {
			vk_cmd_end_rendering2_ext: dummy_vkCmdEndRendering2EXT,
		}
	}
}
impl Vulkan_EXT_fragment_density_map_offset {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_end_rendering2_ext: {let proc = get_proc_address(instance, "vkCmdEndRendering2EXT"); if proc == null() {dummy_vkCmdEndRendering2EXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub zeroInitializeDeviceMemory: VkBool32,
}
pub trait VK_EXT_zero_initialize_device_memory: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_zero_initialize_device_memory {}
impl VK_EXT_zero_initialize_device_memory for Vulkan_EXT_zero_initialize_device_memory {}
impl Default for Vulkan_EXT_zero_initialize_device_memory {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_zero_initialize_device_memory {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineCacheIncrementalMode: VkBool32,
}
pub trait VK_SEC_pipeline_cache_incremental_mode: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_SEC_pipeline_cache_incremental_mode {}
impl VK_SEC_pipeline_cache_incremental_mode for Vulkan_SEC_pipeline_cache_incremental_mode {}
impl Default for Vulkan_SEC_pipeline_cache_incremental_mode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_SEC_pipeline_cache_incremental_mode {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
pub type VkAccelerationStructureCreateFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBuildAccelerationStructureModeKHR {
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = 0,
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = 1,
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAccelerationStructureCreateFlagBitsKHR {
	VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 0x00000001,
	VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000008,
	VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV = 0x00000004,
	VK_ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkAccelerationStructureGeometryDataKHR {
	pub triangles: VkAccelerationStructureGeometryTrianglesDataKHR,
	pub aabbs: VkAccelerationStructureGeometryAabbsDataKHR,
	pub instances: VkAccelerationStructureGeometryInstancesDataKHR,
}
impl Debug for VkAccelerationStructureGeometryDataKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureGeometryDataKHR")
		.field("triangles", unsafe {&self.triangles})
		.field("aabbs", unsafe {&self.aabbs})
		.field("instances", unsafe {&self.instances})
		.finish()
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureBuildRangeInfoKHR {
	pub primitiveCount: u32,
	pub primitiveOffset: u32,
	pub firstVertex: u32,
	pub transformOffset: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureGeometryTrianglesDataKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub vertexFormat: VkFormat,
	pub vertexData: VkDeviceOrHostAddressConstKHR,
	pub vertexStride: VkDeviceSize,
	pub maxVertex: u32,
	pub indexType: VkIndexType,
	pub indexData: VkDeviceOrHostAddressConstKHR,
	pub transformData: VkDeviceOrHostAddressConstKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureGeometryAabbsDataKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub data: VkDeviceOrHostAddressConstKHR,
	pub stride: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureGeometryInstancesDataKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub arrayOfPointers: VkBool32,
	pub data: VkDeviceOrHostAddressConstKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureGeometryKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub geometryType: VkGeometryTypeKHR,
	pub geometry: VkAccelerationStructureGeometryDataKHR,
	pub flags: VkGeometryFlagsKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureBuildGeometryInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkAccelerationStructureTypeKHR,
	pub flags: VkBuildAccelerationStructureFlagsKHR,
	pub mode: VkBuildAccelerationStructureModeKHR,
	pub srcAccelerationStructure: VkAccelerationStructureKHR,
	pub dstAccelerationStructure: VkAccelerationStructureKHR,
	pub geometryCount: u32,
	pub pGeometries: *const VkAccelerationStructureGeometryKHR,
	pub ppGeometries: *const *const VkAccelerationStructureGeometryKHR,
	pub scratchData: VkDeviceOrHostAddressKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub createFlags: VkAccelerationStructureCreateFlagsKHR,
	pub buffer: VkBuffer,
	pub offset: VkDeviceSize,
	pub size: VkDeviceSize,
	pub type_: VkAccelerationStructureTypeKHR,
	pub deviceAddress: VkDeviceAddress,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkWriteDescriptorSetAccelerationStructureKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub accelerationStructureCount: u32,
	pub pAccelerationStructures: *const VkAccelerationStructureKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceAccelerationStructureFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub accelerationStructure: VkBool32,
	pub accelerationStructureCaptureReplay: VkBool32,
	pub accelerationStructureIndirectBuild: VkBool32,
	pub accelerationStructureHostCommands: VkBool32,
	pub descriptorBindingAccelerationStructureUpdateAfterBind: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceAccelerationStructurePropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxGeometryCount: u64,
	pub maxInstanceCount: u64,
	pub maxPrimitiveCount: u64,
	pub maxPerStageDescriptorAccelerationStructures: u32,
	pub maxPerStageDescriptorUpdateAfterBindAccelerationStructures: u32,
	pub maxDescriptorSetAccelerationStructures: u32,
	pub maxDescriptorSetUpdateAfterBindAccelerationStructures: u32,
	pub minAccelerationStructureScratchOffsetAlignment: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureDeviceAddressInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub accelerationStructure: VkAccelerationStructureKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkAccelerationStructureVersionInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pVersionData: *const uint8_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyAccelerationStructureToMemoryInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub src: VkAccelerationStructureKHR,
	pub dst: VkDeviceOrHostAddressKHR,
	pub mode: VkCopyAccelerationStructureModeKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyMemoryToAccelerationStructureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub src: VkDeviceOrHostAddressConstKHR,
	pub dst: VkAccelerationStructureKHR,
	pub mode: VkCopyAccelerationStructureModeKHR,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkCopyAccelerationStructureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub src: VkAccelerationStructureKHR,
	pub dst: VkAccelerationStructureKHR,
	pub mode: VkCopyAccelerationStructureModeKHR,
}
type PFN_vkCreateAccelerationStructureKHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkAccelerationStructureCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pAccelerationStructure: *mut VkAccelerationStructureKHR) -> VkResult;
type PFN_vkDestroyAccelerationStructureKHR = extern "system" fn(device: VkDevice, accelerationStructure: VkAccelerationStructureKHR, pAllocator: *const VkAllocationCallbacks);
type PFN_vkCmdBuildAccelerationStructuresKHR = extern "system" fn(commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *const VkAccelerationStructureBuildGeometryInfoKHR, ppBuildRangeInfos: *const *const VkAccelerationStructureBuildRangeInfoKHR);
type PFN_vkCmdBuildAccelerationStructuresIndirectKHR = extern "system" fn(commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *const VkAccelerationStructureBuildGeometryInfoKHR, pIndirectDeviceAddresses: *const VkDeviceAddress, pIndirectStrides: *const uint32_t, ppMaxPrimitiveCounts: *const *const uint32_t);
type PFN_vkBuildAccelerationStructuresKHR = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, infoCount: u32, pInfos: *const VkAccelerationStructureBuildGeometryInfoKHR, ppBuildRangeInfos: *const *const VkAccelerationStructureBuildRangeInfoKHR) -> VkResult;
type PFN_vkCopyAccelerationStructureKHR = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *const VkCopyAccelerationStructureInfoKHR) -> VkResult;
type PFN_vkCopyAccelerationStructureToMemoryKHR = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *const VkCopyAccelerationStructureToMemoryInfoKHR) -> VkResult;
type PFN_vkCopyMemoryToAccelerationStructureKHR = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *const VkCopyMemoryToAccelerationStructureInfoKHR) -> VkResult;
type PFN_vkWriteAccelerationStructuresPropertiesKHR = extern "system" fn(device: VkDevice, accelerationStructureCount: u32, pAccelerationStructures: *const VkAccelerationStructureKHR, queryType: VkQueryType, dataSize: usize, pData: *mut c_void, stride: usize) -> VkResult;
type PFN_vkCmdCopyAccelerationStructureKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pInfo: *const VkCopyAccelerationStructureInfoKHR);
type PFN_vkCmdCopyAccelerationStructureToMemoryKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pInfo: *const VkCopyAccelerationStructureToMemoryInfoKHR);
type PFN_vkCmdCopyMemoryToAccelerationStructureKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pInfo: *const VkCopyMemoryToAccelerationStructureInfoKHR);
type PFN_vkGetAccelerationStructureDeviceAddressKHR = extern "system" fn(device: VkDevice, pInfo: *const VkAccelerationStructureDeviceAddressInfoKHR) -> VkDeviceAddress;
type PFN_vkCmdWriteAccelerationStructuresPropertiesKHR = extern "system" fn(commandBuffer: VkCommandBuffer, accelerationStructureCount: u32, pAccelerationStructures: *const VkAccelerationStructureKHR, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: u32);
type PFN_vkGetDeviceAccelerationStructureCompatibilityKHR = extern "system" fn(device: VkDevice, pVersionInfo: *const VkAccelerationStructureVersionInfoKHR, pCompatibility: *mut VkAccelerationStructureCompatibilityKHR);
type PFN_vkGetAccelerationStructureBuildSizesKHR = extern "system" fn(device: VkDevice, buildType: VkAccelerationStructureBuildTypeKHR, pBuildInfo: *const VkAccelerationStructureBuildGeometryInfoKHR, pMaxPrimitiveCounts: *const uint32_t, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR);
extern "system" fn dummy_vkCreateAccelerationStructureKHR(_: VkDevice, _: *const VkAccelerationStructureCreateInfoKHR, _: *const VkAllocationCallbacks, _: *mut VkAccelerationStructureKHR) -> VkResult {
	panic!("Vulkan function pointer of `vkCreateAccelerationStructureKHR()` is NULL");
}
pub trait VK_KHR_acceleration_structure: Debug {
	fn vkCreateAccelerationStructureKHR(&self, device: VkDevice, pCreateInfo: *const VkAccelerationStructureCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pAccelerationStructure: *mut VkAccelerationStructureKHR) -> VkResult;
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_acceleration_structure {
	vk_create_acceleration_structure_khr: PFN_vkCreateAccelerationStructureKHR,
}
impl VK_KHR_acceleration_structure for Vulkan_KHR_acceleration_structure {
	fn vkCreateAccelerationStructureKHR(&self, device: VkDevice, pCreateInfo: *const VkAccelerationStructureCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pAccelerationStructure: *mut VkAccelerationStructureKHR) -> VkResult {
		(self.vk_create_acceleration_structure_khr)(device, pCreateInfo, pAllocator, pAccelerationStructure)
	}
}
impl Default for Vulkan_KHR_acceleration_structure {
	fn default() -> Self {
		Self {
			vk_create_acceleration_structure_khr: dummy_vkCreateAccelerationStructureKHR,
		}
	}
}
impl Vulkan_KHR_acceleration_structure {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_acceleration_structure_khr: {let proc = get_proc_address(instance, "vkCreateAccelerationStructureKHR"); if proc == null() {dummy_vkCreateAccelerationStructureKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkShaderGroupShaderKHR {
	VK_SHADER_GROUP_SHADER_GENERAL_KHR = 0,
	VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = 1,
	VK_SHADER_GROUP_SHADER_ANY_HIT_KHR = 2,
	VK_SHADER_GROUP_SHADER_INTERSECTION_KHR = 3,
	VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR = 0x7fffffff,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRayTracingShaderGroupCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkRayTracingShaderGroupTypeKHR,
	pub generalShader: u32,
	pub closestHitShader: u32,
	pub anyHitShader: u32,
	pub intersectionShader: u32,
	pub pShaderGroupCaptureReplayHandle: *const c_void,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRayTracingPipelineInterfaceCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maxPipelineRayPayloadSize: u32,
	pub maxPipelineRayHitAttributeSize: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkRayTracingPipelineCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCreateFlags,
	pub stageCount: u32,
	pub pStages: *const VkPipelineShaderStageCreateInfo,
	pub groupCount: u32,
	pub pGroups: *const VkRayTracingShaderGroupCreateInfoKHR,
	pub maxPipelineRayRecursionDepth: u32,
	pub pLibraryInfo: *const VkPipelineLibraryCreateInfoKHR,
	pub pLibraryInterface: *const VkRayTracingPipelineInterfaceCreateInfoKHR,
	pub pDynamicState: *const VkPipelineDynamicStateCreateInfo,
	pub layout: VkPipelineLayout,
	pub basePipelineHandle: VkPipeline,
	pub basePipelineIndex: i32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingPipelineFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rayTracingPipeline: VkBool32,
	pub rayTracingPipelineShaderGroupHandleCaptureReplay: VkBool32,
	pub rayTracingPipelineShaderGroupHandleCaptureReplayMixed: VkBool32,
	pub rayTracingPipelineTraceRaysIndirect: VkBool32,
	pub rayTraversalPrimitiveCulling: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingPipelinePropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderGroupHandleSize: u32,
	pub maxRayRecursionDepth: u32,
	pub maxShaderGroupStride: u32,
	pub shaderGroupBaseAlignment: u32,
	pub shaderGroupHandleCaptureReplaySize: u32,
	pub maxRayDispatchInvocationCount: u32,
	pub shaderGroupHandleAlignment: u32,
	pub maxRayHitAttributeSize: u32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkTraceRaysIndirectCommandKHR {
	pub width: u32,
	pub height: u32,
	pub depth: u32,
}
type PFN_vkCmdTraceRaysKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, width: u32, height: u32, depth: u32);
type PFN_vkCreateRayTracingPipelinesKHR = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkRayTracingPipelineCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult;
type PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = extern "system" fn(device: VkDevice, pipeline: VkPipeline, firstGroup: u32, groupCount: u32, dataSize: usize, pData: *mut c_void) -> VkResult;
type PFN_vkCmdTraceRaysIndirectKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, indirectDeviceAddress: VkDeviceAddress);
type PFN_vkGetRayTracingShaderGroupStackSizeKHR = extern "system" fn(device: VkDevice, pipeline: VkPipeline, group: u32, groupShader: VkShaderGroupShaderKHR) -> VkDeviceSize;
type PFN_vkCmdSetRayTracingPipelineStackSizeKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineStackSize: u32);
extern "system" fn dummy_vkCmdTraceRaysKHR(_: VkCommandBuffer, _: *const VkStridedDeviceAddressRegionKHR, _: *const VkStridedDeviceAddressRegionKHR, _: *const VkStridedDeviceAddressRegionKHR, _: *const VkStridedDeviceAddressRegionKHR, _: u32, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdTraceRaysKHR()` is NULL");
}
pub trait VK_KHR_ray_tracing_pipeline: Debug {
	fn vkCmdTraceRaysKHR(&self, commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, width: u32, height: u32, depth: u32);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_ray_tracing_pipeline {
	vk_cmd_trace_rays_khr: PFN_vkCmdTraceRaysKHR,
}
impl VK_KHR_ray_tracing_pipeline for Vulkan_KHR_ray_tracing_pipeline {
	fn vkCmdTraceRaysKHR(&self, commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, width: u32, height: u32, depth: u32) {
		(self.vk_cmd_trace_rays_khr)(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth)
	}
}
impl Default for Vulkan_KHR_ray_tracing_pipeline {
	fn default() -> Self {
		Self {
			vk_cmd_trace_rays_khr: dummy_vkCmdTraceRaysKHR,
		}
	}
}
impl Vulkan_KHR_ray_tracing_pipeline {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_trace_rays_khr: {let proc = get_proc_address(instance, "vkCmdTraceRaysKHR"); if proc == null() {dummy_vkCmdTraceRaysKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceRayQueryFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rayQuery: VkBool32,
}
pub trait VK_KHR_ray_query: Debug {}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_ray_query {}
impl VK_KHR_ray_query for Vulkan_KHR_ray_query {}
impl Default for Vulkan_KHR_ray_query {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_ray_query {
	pub fn new(_instance: VkInstance, _get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMeshShaderFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub taskShader: VkBool32,
	pub meshShader: VkBool32,
	pub multiviewMeshShader: VkBool32,
	pub primitiveFragmentShadingRateMeshShader: VkBool32,
	pub meshShaderQueries: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDeviceMeshShaderPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxTaskWorkGroupTotalCount: u32,
	pub maxTaskWorkGroupCount: [u32; 3 as usize],
	pub maxTaskWorkGroupInvocations: u32,
	pub maxTaskWorkGroupSize: [u32; 3 as usize],
	pub maxTaskPayloadSize: u32,
	pub maxTaskSharedMemorySize: u32,
	pub maxTaskPayloadAndSharedMemorySize: u32,
	pub maxMeshWorkGroupTotalCount: u32,
	pub maxMeshWorkGroupCount: [u32; 3 as usize],
	pub maxMeshWorkGroupInvocations: u32,
	pub maxMeshWorkGroupSize: [u32; 3 as usize],
	pub maxMeshSharedMemorySize: u32,
	pub maxMeshPayloadAndSharedMemorySize: u32,
	pub maxMeshOutputMemorySize: u32,
	pub maxMeshPayloadAndOutputMemorySize: u32,
	pub maxMeshOutputComponents: u32,
	pub maxMeshOutputVertices: u32,
	pub maxMeshOutputPrimitives: u32,
	pub maxMeshOutputLayers: u32,
	pub maxMeshMultiviewViewCount: u32,
	pub meshOutputPerVertexGranularity: u32,
	pub meshOutputPerPrimitiveGranularity: u32,
	pub maxPreferredTaskWorkGroupInvocations: u32,
	pub maxPreferredMeshWorkGroupInvocations: u32,
	pub prefersLocalInvocationVertexOutput: VkBool32,
	pub prefersLocalInvocationPrimitiveOutput: VkBool32,
	pub prefersCompactVertexOutput: VkBool32,
	pub prefersCompactPrimitiveOutput: VkBool32,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct VkDrawMeshTasksIndirectCommandEXT {
	pub groupCountX: u32,
	pub groupCountY: u32,
	pub groupCountZ: u32,
}
type PFN_vkCmdDrawMeshTasksEXT = extern "system" fn(commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32);
type PFN_vkCmdDrawMeshTasksIndirectEXT = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32);
type PFN_vkCmdDrawMeshTasksIndirectCountEXT = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
extern "system" fn dummy_vkCmdDrawMeshTasksEXT(_: VkCommandBuffer, _: u32, _: u32, _: u32) {
	panic!("Vulkan function pointer of `vkCmdDrawMeshTasksEXT()` is NULL");
}
pub trait VK_EXT_mesh_shader: Debug {
	fn vkCmdDrawMeshTasksEXT(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32);
}
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_mesh_shader {
	vk_cmd_draw_mesh_tasks_ext: PFN_vkCmdDrawMeshTasksEXT,
}
impl VK_EXT_mesh_shader for Vulkan_EXT_mesh_shader {
	fn vkCmdDrawMeshTasksEXT(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) {
		(self.vk_cmd_draw_mesh_tasks_ext)(commandBuffer, groupCountX, groupCountY, groupCountZ)
	}
}
impl Default for Vulkan_EXT_mesh_shader {
	fn default() -> Self {
		Self {
			vk_cmd_draw_mesh_tasks_ext: dummy_vkCmdDrawMeshTasksEXT,
		}
	}
}
impl Vulkan_EXT_mesh_shader {
	pub fn new(instance: VkInstance, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_draw_mesh_tasks_ext: {let proc = get_proc_address(instance, "vkCmdDrawMeshTasksEXT"); if proc == null() {dummy_vkCmdDrawMeshTasksEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
#[derive(Default, Debug, Clone)]
pub struct VkCore {
	pub instance: VkInstance,
	pub extensions: BTreeSet<String>,
	pub vk_version_1_0: Vulkan_VERSION_1_0,
	pub vk_version_1_1: Vulkan_VERSION_1_1,
	pub vk_version_1_2: Vulkan_VERSION_1_2,
	pub vk_version_1_3: Vulkan_VERSION_1_3,
	pub vk_version_1_4: Vulkan_VERSION_1_4,
	pub vk_khr_surface: Vulkan_KHR_surface,
	pub vk_khr_swapchain: Vulkan_KHR_swapchain,
	pub vk_khr_display: Vulkan_KHR_display,
	pub vk_khr_display_swapchain: Vulkan_KHR_display_swapchain,
	pub vk_khr_sampler_mirror_clamp_to_edge: Vulkan_KHR_sampler_mirror_clamp_to_edge,
	pub vk_khr_video_queue: Vulkan_KHR_video_queue,
	pub vk_khr_video_decode_queue: Vulkan_KHR_video_decode_queue,
	pub vk_khr_video_encode_h264: Vulkan_KHR_video_encode_h264,
	pub vulkan_video_codec_h264std: Vulkan_video_codec_h264std,
	pub vulkan_video_codecs_common: Vulkan_video_codecs_common,
	pub vulkan_video_codec_h264std_encode: Vulkan_video_codec_h264std_encode,
	pub vk_khr_video_encode_h265: Vulkan_KHR_video_encode_h265,
	pub vulkan_video_codec_h265std: Vulkan_video_codec_h265std,
	pub vulkan_video_codec_h265std_encode: Vulkan_video_codec_h265std_encode,
	pub vk_khr_video_decode_h264: Vulkan_KHR_video_decode_h264,
	pub vulkan_video_codec_h264std_decode: Vulkan_video_codec_h264std_decode,
	pub vk_khr_dynamic_rendering: Vulkan_KHR_dynamic_rendering,
	pub vk_khr_multiview: Vulkan_KHR_multiview,
	pub vk_khr_get_physical_device_properties2: Vulkan_KHR_get_physical_device_properties2,
	pub vk_khr_device_group: Vulkan_KHR_device_group,
	pub vk_khr_shader_draw_parameters: Vulkan_KHR_shader_draw_parameters,
	pub vk_khr_maintenance1: Vulkan_KHR_maintenance1,
	pub vk_khr_device_group_creation: Vulkan_KHR_device_group_creation,
	pub vk_khr_external_memory_capabilities: Vulkan_KHR_external_memory_capabilities,
	pub vk_khr_external_memory: Vulkan_KHR_external_memory,
	pub vk_khr_external_memory_fd: Vulkan_KHR_external_memory_fd,
	pub vk_khr_external_semaphore_capabilities: Vulkan_KHR_external_semaphore_capabilities,
	pub vk_khr_external_semaphore: Vulkan_KHR_external_semaphore,
	pub vk_khr_external_semaphore_fd: Vulkan_KHR_external_semaphore_fd,
	pub vk_khr_push_descriptor: Vulkan_KHR_push_descriptor,
	pub vk_khr_shader_float16_int8: Vulkan_KHR_shader_float16_int8,
	pub vk_khr_16bit_storage: Vulkan_KHR_16bit_storage,
	pub vk_khr_incremental_present: Vulkan_KHR_incremental_present,
	pub vk_khr_descriptor_update_template: Vulkan_KHR_descriptor_update_template,
	pub vk_khr_imageless_framebuffer: Vulkan_KHR_imageless_framebuffer,
	pub vk_khr_create_renderpass2: Vulkan_KHR_create_renderpass2,
	pub vk_khr_shared_presentable_image: Vulkan_KHR_shared_presentable_image,
	pub vk_khr_external_fence_capabilities: Vulkan_KHR_external_fence_capabilities,
	pub vk_khr_external_fence: Vulkan_KHR_external_fence,
	pub vk_khr_external_fence_fd: Vulkan_KHR_external_fence_fd,
	pub vk_khr_performance_query: Vulkan_KHR_performance_query,
	pub vk_khr_maintenance2: Vulkan_KHR_maintenance2,
	pub vk_khr_get_surface_capabilities2: Vulkan_KHR_get_surface_capabilities2,
	pub vk_khr_variable_pointers: Vulkan_KHR_variable_pointers,
	pub vk_khr_get_display_properties2: Vulkan_KHR_get_display_properties2,
	pub vk_khr_dedicated_allocation: Vulkan_KHR_dedicated_allocation,
	pub vk_khr_storage_buffer_storage_class: Vulkan_KHR_storage_buffer_storage_class,
	pub vk_khr_shader_bfloat16: Vulkan_KHR_shader_bfloat16,
	pub vk_khr_relaxed_block_layout: Vulkan_KHR_relaxed_block_layout,
	pub vk_khr_get_memory_requirements2: Vulkan_KHR_get_memory_requirements2,
	pub vk_khr_image_format_list: Vulkan_KHR_image_format_list,
	pub vk_khr_sampler_ycbcr_conversion: Vulkan_KHR_sampler_ycbcr_conversion,
	pub vk_khr_bind_memory2: Vulkan_KHR_bind_memory2,
	pub vk_khr_maintenance3: Vulkan_KHR_maintenance3,
	pub vk_khr_draw_indirect_count: Vulkan_KHR_draw_indirect_count,
	pub vk_khr_shader_subgroup_extended_types: Vulkan_KHR_shader_subgroup_extended_types,
	pub vk_khr_8bit_storage: Vulkan_KHR_8bit_storage,
	pub vk_khr_shader_atomic_int64: Vulkan_KHR_shader_atomic_int64,
	pub vk_khr_shader_clock: Vulkan_KHR_shader_clock,
	pub vk_khr_video_decode_h265: Vulkan_KHR_video_decode_h265,
	pub vulkan_video_codec_h265std_decode: Vulkan_video_codec_h265std_decode,
	pub vk_khr_global_priority: Vulkan_KHR_global_priority,
	pub vk_khr_driver_properties: Vulkan_KHR_driver_properties,
	pub vk_khr_shader_float_controls: Vulkan_KHR_shader_float_controls,
	pub vk_khr_depth_stencil_resolve: Vulkan_KHR_depth_stencil_resolve,
	pub vk_khr_swapchain_mutable_format: Vulkan_KHR_swapchain_mutable_format,
	pub vk_khr_timeline_semaphore: Vulkan_KHR_timeline_semaphore,
	pub vk_khr_vulkan_memory_model: Vulkan_KHR_vulkan_memory_model,
	pub vk_khr_shader_terminate_invocation: Vulkan_KHR_shader_terminate_invocation,
	pub vk_khr_fragment_shading_rate: Vulkan_KHR_fragment_shading_rate,
	pub vk_khr_dynamic_rendering_local_read: Vulkan_KHR_dynamic_rendering_local_read,
	pub vk_khr_shader_quad_control: Vulkan_KHR_shader_quad_control,
	pub vk_khr_spirv_1_4: Vulkan_KHR_spirv_1_4,
	pub vk_khr_surface_protected_capabilities: Vulkan_KHR_surface_protected_capabilities,
	pub vk_khr_separate_depth_stencil_layouts: Vulkan_KHR_separate_depth_stencil_layouts,
	pub vk_khr_present_wait: Vulkan_KHR_present_wait,
	pub vk_khr_uniform_buffer_standard_layout: Vulkan_KHR_uniform_buffer_standard_layout,
	pub vk_khr_buffer_device_address: Vulkan_KHR_buffer_device_address,
	pub vk_khr_deferred_host_operations: Vulkan_KHR_deferred_host_operations,
	pub vk_khr_pipeline_executable_properties: Vulkan_KHR_pipeline_executable_properties,
	pub vk_khr_map_memory2: Vulkan_KHR_map_memory2,
	pub vk_khr_shader_integer_dot_product: Vulkan_KHR_shader_integer_dot_product,
	pub vk_khr_pipeline_library: Vulkan_KHR_pipeline_library,
	pub vk_khr_shader_non_semantic_info: Vulkan_KHR_shader_non_semantic_info,
	pub vk_khr_present_id: Vulkan_KHR_present_id,
	pub vk_khr_video_encode_queue: Vulkan_KHR_video_encode_queue,
	pub vk_khr_synchronization2: Vulkan_KHR_synchronization2,
	pub vk_khr_fragment_shader_barycentric: Vulkan_KHR_fragment_shader_barycentric,
	pub vk_khr_shader_subgroup_uniform_control_flow: Vulkan_KHR_shader_subgroup_uniform_control_flow,
	pub vk_khr_zero_initialize_workgroup_memory: Vulkan_KHR_zero_initialize_workgroup_memory,
	pub vk_khr_workgroup_memory_explicit_layout: Vulkan_KHR_workgroup_memory_explicit_layout,
	pub vk_khr_copy_commands2: Vulkan_KHR_copy_commands2,
	pub vk_khr_format_feature_flags2: Vulkan_KHR_format_feature_flags2,
	pub vk_khr_ray_tracing_maintenance1: Vulkan_KHR_ray_tracing_maintenance1,
	pub vk_khr_portability_enumeration: Vulkan_KHR_portability_enumeration,
	pub vk_khr_maintenance4: Vulkan_KHR_maintenance4,
	pub vk_khr_shader_subgroup_rotate: Vulkan_KHR_shader_subgroup_rotate,
	pub vk_khr_shader_maximal_reconvergence: Vulkan_KHR_shader_maximal_reconvergence,
	pub vk_khr_maintenance5: Vulkan_KHR_maintenance5,
	pub vk_khr_present_id2: Vulkan_KHR_present_id2,
	pub vk_khr_present_wait2: Vulkan_KHR_present_wait2,
	pub vk_khr_ray_tracing_position_fetch: Vulkan_KHR_ray_tracing_position_fetch,
	pub vk_khr_pipeline_binary: Vulkan_KHR_pipeline_binary,
	pub vk_khr_surface_maintenance1: Vulkan_KHR_surface_maintenance1,
	pub vk_khr_swapchain_maintenance1: Vulkan_KHR_swapchain_maintenance1,
	pub vk_khr_cooperative_matrix: Vulkan_KHR_cooperative_matrix,
	pub vk_khr_compute_shader_derivatives: Vulkan_KHR_compute_shader_derivatives,
	pub vk_khr_video_decode_av1: Vulkan_KHR_video_decode_av1,
	pub vulkan_video_codec_av1std: Vulkan_video_codec_av1std,
	pub vulkan_video_codec_av1std_decode: Vulkan_video_codec_av1std_decode,
	pub vk_khr_video_encode_av1: Vulkan_KHR_video_encode_av1,
	pub vulkan_video_codec_av1std_encode: Vulkan_video_codec_av1std_encode,
	pub vk_khr_video_decode_vp9: Vulkan_KHR_video_decode_vp9,
	pub vulkan_video_codec_vp9std: Vulkan_video_codec_vp9std,
	pub vulkan_video_codec_vp9std_decode: Vulkan_video_codec_vp9std_decode,
	pub vk_khr_video_maintenance1: Vulkan_KHR_video_maintenance1,
	pub vk_khr_vertex_attribute_divisor: Vulkan_KHR_vertex_attribute_divisor,
	pub vk_khr_load_store_op_none: Vulkan_KHR_load_store_op_none,
	pub vk_khr_unified_image_layouts: Vulkan_KHR_unified_image_layouts,
	pub vk_khr_shader_float_controls2: Vulkan_KHR_shader_float_controls2,
	pub vk_khr_index_type_uint8: Vulkan_KHR_index_type_uint8,
	pub vk_khr_line_rasterization: Vulkan_KHR_line_rasterization,
	pub vk_khr_calibrated_timestamps: Vulkan_KHR_calibrated_timestamps,
	pub vk_khr_shader_expect_assume: Vulkan_KHR_shader_expect_assume,
	pub vk_khr_maintenance6: Vulkan_KHR_maintenance6,
	pub vk_khr_video_encode_intra_refresh: Vulkan_KHR_video_encode_intra_refresh,
	pub vk_khr_video_encode_quantization_map: Vulkan_KHR_video_encode_quantization_map,
	pub vk_khr_shader_relaxed_extended_instruction: Vulkan_KHR_shader_relaxed_extended_instruction,
	pub vk_khr_maintenance7: Vulkan_KHR_maintenance7,
	pub vk_khr_maintenance8: Vulkan_KHR_maintenance8,
	pub vk_khr_maintenance9: Vulkan_KHR_maintenance9,
	pub vk_khr_video_maintenance2: Vulkan_KHR_video_maintenance2,
	pub vk_khr_depth_clamp_zero_one: Vulkan_KHR_depth_clamp_zero_one,
	pub vk_khr_robustness2: Vulkan_KHR_robustness2,
	pub vk_khr_present_mode_fifo_latest_ready: Vulkan_KHR_present_mode_fifo_latest_ready,
	pub vk_ext_debug_report: Vulkan_EXT_debug_report,
	pub vk_nv_glsl_shader: Vulkan_NV_glsl_shader,
	pub vk_ext_depth_range_unrestricted: Vulkan_EXT_depth_range_unrestricted,
	pub vk_img_filter_cubic: Vulkan_IMG_filter_cubic,
	pub vk_amd_rasterization_order: Vulkan_AMD_rasterization_order,
	pub vk_amd_shader_trinary_minmax: Vulkan_AMD_shader_trinary_minmax,
	pub vk_amd_shader_explicit_vertex_parameter: Vulkan_AMD_shader_explicit_vertex_parameter,
	pub vk_ext_debug_marker: Vulkan_EXT_debug_marker,
	pub vk_amd_gcn_shader: Vulkan_AMD_gcn_shader,
	pub vk_nv_dedicated_allocation: Vulkan_NV_dedicated_allocation,
	pub vk_ext_transform_feedback: Vulkan_EXT_transform_feedback,
	pub vk_nvx_binary_import: Vulkan_NVX_binary_import,
	pub vk_nvx_image_view_handle: Vulkan_NVX_image_view_handle,
	pub vk_amd_draw_indirect_count: Vulkan_AMD_draw_indirect_count,
	pub vk_amd_negative_viewport_height: Vulkan_AMD_negative_viewport_height,
	pub vk_amd_gpu_shader_half_float: Vulkan_AMD_gpu_shader_half_float,
	pub vk_amd_shader_ballot: Vulkan_AMD_shader_ballot,
	pub vk_amd_texture_gather_bias_lod: Vulkan_AMD_texture_gather_bias_lod,
	pub vk_amd_shader_info: Vulkan_AMD_shader_info,
	pub vk_amd_shader_image_load_store_lod: Vulkan_AMD_shader_image_load_store_lod,
	pub vk_nv_corner_sampled_image: Vulkan_NV_corner_sampled_image,
	pub vk_img_format_pvrtc: Vulkan_IMG_format_pvrtc,
	pub vk_nv_external_memory_capabilities: Vulkan_NV_external_memory_capabilities,
	pub vk_nv_external_memory: Vulkan_NV_external_memory,
	pub vk_ext_validation_flags: Vulkan_EXT_validation_flags,
	pub vk_ext_shader_subgroup_ballot: Vulkan_EXT_shader_subgroup_ballot,
	pub vk_ext_shader_subgroup_vote: Vulkan_EXT_shader_subgroup_vote,
	pub vk_ext_texture_compression_astc_hdr: Vulkan_EXT_texture_compression_astc_hdr,
	pub vk_ext_astc_decode_mode: Vulkan_EXT_astc_decode_mode,
	pub vk_ext_pipeline_robustness: Vulkan_EXT_pipeline_robustness,
	pub vk_ext_conditional_rendering: Vulkan_EXT_conditional_rendering,
	pub vk_nv_clip_space_w_scaling: Vulkan_NV_clip_space_w_scaling,
	pub vk_ext_direct_mode_display: Vulkan_EXT_direct_mode_display,
	pub vk_ext_display_surface_counter: Vulkan_EXT_display_surface_counter,
	pub vk_ext_display_control: Vulkan_EXT_display_control,
	pub vk_google_display_timing: Vulkan_GOOGLE_display_timing,
	pub vk_nv_sample_mask_override_coverage: Vulkan_NV_sample_mask_override_coverage,
	pub vk_nv_geometry_shader_passthrough: Vulkan_NV_geometry_shader_passthrough,
	pub vk_nv_viewport_array2: Vulkan_NV_viewport_array2,
	pub vk_nvx_multiview_per_view_attributes: Vulkan_NVX_multiview_per_view_attributes,
	pub vk_nv_viewport_swizzle: Vulkan_NV_viewport_swizzle,
	pub vk_ext_discard_rectangles: Vulkan_EXT_discard_rectangles,
	pub vk_ext_conservative_rasterization: Vulkan_EXT_conservative_rasterization,
	pub vk_ext_depth_clip_enable: Vulkan_EXT_depth_clip_enable,
	pub vk_ext_swapchain_colorspace: Vulkan_EXT_swapchain_colorspace,
	pub vk_ext_hdr_metadata: Vulkan_EXT_hdr_metadata,
	pub vk_img_relaxed_line_rasterization: Vulkan_IMG_relaxed_line_rasterization,
	pub vk_ext_external_memory_dma_buf: Vulkan_EXT_external_memory_dma_buf,
	pub vk_ext_queue_family_foreign: Vulkan_EXT_queue_family_foreign,
	pub vk_ext_debug_utils: Vulkan_EXT_debug_utils,
	pub vk_ext_sampler_filter_minmax: Vulkan_EXT_sampler_filter_minmax,
	pub vk_amd_gpu_shader_int16: Vulkan_AMD_gpu_shader_int16,
	pub vk_amd_mixed_attachment_samples: Vulkan_AMD_mixed_attachment_samples,
	pub vk_amd_shader_fragment_mask: Vulkan_AMD_shader_fragment_mask,
	pub vk_ext_inline_uniform_block: Vulkan_EXT_inline_uniform_block,
	pub vk_ext_shader_stencil_export: Vulkan_EXT_shader_stencil_export,
	pub vk_ext_sample_locations: Vulkan_EXT_sample_locations,
	pub vk_ext_blend_operation_advanced: Vulkan_EXT_blend_operation_advanced,
	pub vk_nv_fragment_coverage_to_color: Vulkan_NV_fragment_coverage_to_color,
	pub vk_nv_framebuffer_mixed_samples: Vulkan_NV_framebuffer_mixed_samples,
	pub vk_nv_fill_rectangle: Vulkan_NV_fill_rectangle,
	pub vk_nv_shader_sm_builtins: Vulkan_NV_shader_sm_builtins,
	pub vk_ext_post_depth_coverage: Vulkan_EXT_post_depth_coverage,
	pub vk_ext_image_drm_format_modifier: Vulkan_EXT_image_drm_format_modifier,
	pub vk_ext_validation_cache: Vulkan_EXT_validation_cache,
	pub vk_ext_descriptor_indexing: Vulkan_EXT_descriptor_indexing,
	pub vk_ext_shader_viewport_index_layer: Vulkan_EXT_shader_viewport_index_layer,
	pub vk_nv_shading_rate_image: Vulkan_NV_shading_rate_image,
	pub vk_nv_ray_tracing: Vulkan_NV_ray_tracing,
	pub vk_nv_representative_fragment_test: Vulkan_NV_representative_fragment_test,
	pub vk_ext_filter_cubic: Vulkan_EXT_filter_cubic,
	pub vk_qcom_render_pass_shader_resolve: Vulkan_QCOM_render_pass_shader_resolve,
	pub vk_ext_global_priority: Vulkan_EXT_global_priority,
	pub vk_ext_external_memory_host: Vulkan_EXT_external_memory_host,
	pub vk_amd_buffer_marker: Vulkan_AMD_buffer_marker,
	pub vk_amd_pipeline_compiler_control: Vulkan_AMD_pipeline_compiler_control,
	pub vk_ext_calibrated_timestamps: Vulkan_EXT_calibrated_timestamps,
	pub vk_amd_shader_core_properties: Vulkan_AMD_shader_core_properties,
	pub vk_amd_memory_overallocation_behavior: Vulkan_AMD_memory_overallocation_behavior,
	pub vk_ext_vertex_attribute_divisor: Vulkan_EXT_vertex_attribute_divisor,
	pub vk_ext_pipeline_creation_feedback: Vulkan_EXT_pipeline_creation_feedback,
	pub vk_nv_shader_subgroup_partitioned: Vulkan_NV_shader_subgroup_partitioned,
	pub vk_nv_compute_shader_derivatives: Vulkan_NV_compute_shader_derivatives,
	pub vk_nv_mesh_shader: Vulkan_NV_mesh_shader,
	pub vk_nv_fragment_shader_barycentric: Vulkan_NV_fragment_shader_barycentric,
	pub vk_nv_shader_image_footprint: Vulkan_NV_shader_image_footprint,
	pub vk_nv_scissor_exclusive: Vulkan_NV_scissor_exclusive,
	pub vk_nv_device_diagnostic_checkpoints: Vulkan_NV_device_diagnostic_checkpoints,
	pub vk_intel_shader_integer_functions2: Vulkan_INTEL_shader_integer_functions2,
	pub vk_intel_performance_query: Vulkan_INTEL_performance_query,
	pub vk_ext_pci_bus_info: Vulkan_EXT_pci_bus_info,
	pub vk_amd_display_native_hdr: Vulkan_AMD_display_native_hdr,
	pub vk_ext_fragment_density_map: Vulkan_EXT_fragment_density_map,
	pub vk_ext_scalar_block_layout: Vulkan_EXT_scalar_block_layout,
	pub vk_google_hlsl_functionality1: Vulkan_GOOGLE_hlsl_functionality1,
	pub vk_google_decorate_string: Vulkan_GOOGLE_decorate_string,
	pub vk_ext_subgroup_size_control: Vulkan_EXT_subgroup_size_control,
	pub vk_amd_shader_core_properties2: Vulkan_AMD_shader_core_properties2,
	pub vk_amd_device_coherent_memory: Vulkan_AMD_device_coherent_memory,
	pub vk_ext_shader_image_atomic_int64: Vulkan_EXT_shader_image_atomic_int64,
	pub vk_ext_memory_budget: Vulkan_EXT_memory_budget,
	pub vk_ext_memory_priority: Vulkan_EXT_memory_priority,
	pub vk_nv_dedicated_allocation_image_aliasing: Vulkan_NV_dedicated_allocation_image_aliasing,
	pub vk_ext_buffer_device_address: Vulkan_EXT_buffer_device_address,
	pub vk_ext_tooling_info: Vulkan_EXT_tooling_info,
	pub vk_ext_separate_stencil_usage: Vulkan_EXT_separate_stencil_usage,
	pub vk_ext_validation_features: Vulkan_EXT_validation_features,
	pub vk_nv_cooperative_matrix: Vulkan_NV_cooperative_matrix,
	pub vk_nv_coverage_reduction_mode: Vulkan_NV_coverage_reduction_mode,
	pub vk_ext_fragment_shader_interlock: Vulkan_EXT_fragment_shader_interlock,
	pub vk_ext_ycbcr_image_arrays: Vulkan_EXT_ycbcr_image_arrays,
	pub vk_ext_provoking_vertex: Vulkan_EXT_provoking_vertex,
	pub vk_ext_headless_surface: Vulkan_EXT_headless_surface,
	pub vk_ext_line_rasterization: Vulkan_EXT_line_rasterization,
	pub vk_ext_shader_atomic_float: Vulkan_EXT_shader_atomic_float,
	pub vk_ext_host_query_reset: Vulkan_EXT_host_query_reset,
	pub vk_ext_index_type_uint8: Vulkan_EXT_index_type_uint8,
	pub vk_ext_extended_dynamic_state: Vulkan_EXT_extended_dynamic_state,
	pub vk_ext_host_image_copy: Vulkan_EXT_host_image_copy,
	pub vk_ext_map_memory_placed: Vulkan_EXT_map_memory_placed,
	pub vk_ext_shader_atomic_float2: Vulkan_EXT_shader_atomic_float2,
	pub vk_ext_surface_maintenance1: Vulkan_EXT_surface_maintenance1,
	pub vk_ext_swapchain_maintenance1: Vulkan_EXT_swapchain_maintenance1,
	pub vk_ext_shader_demote_to_helper_invocation: Vulkan_EXT_shader_demote_to_helper_invocation,
	pub vk_nv_device_generated_commands: Vulkan_NV_device_generated_commands,
	pub vk_nv_inherited_viewport_scissor: Vulkan_NV_inherited_viewport_scissor,
	pub vk_ext_texel_buffer_alignment: Vulkan_EXT_texel_buffer_alignment,
	pub vk_qcom_render_pass_transform: Vulkan_QCOM_render_pass_transform,
	pub vk_ext_depth_bias_control: Vulkan_EXT_depth_bias_control,
	pub vk_ext_device_memory_report: Vulkan_EXT_device_memory_report,
	pub vk_ext_acquire_drm_display: Vulkan_EXT_acquire_drm_display,
	pub vk_ext_robustness2: Vulkan_EXT_robustness2,
	pub vk_ext_custom_border_color: Vulkan_EXT_custom_border_color,
	pub vk_google_user_type: Vulkan_GOOGLE_user_type,
	pub vk_nv_present_barrier: Vulkan_NV_present_barrier,
	pub vk_ext_private_data: Vulkan_EXT_private_data,
	pub vk_ext_pipeline_creation_cache_control: Vulkan_EXT_pipeline_creation_cache_control,
	pub vk_nv_device_diagnostics_config: Vulkan_NV_device_diagnostics_config,
	pub vk_qcom_render_pass_store_ops: Vulkan_QCOM_render_pass_store_ops,
	pub vk_qcom_tile_shading: Vulkan_QCOM_tile_shading,
	pub vk_nv_low_latency: Vulkan_NV_low_latency,
	pub vk_ext_descriptor_buffer: Vulkan_EXT_descriptor_buffer,
	pub vk_ext_graphics_pipeline_library: Vulkan_EXT_graphics_pipeline_library,
	pub vk_amd_shader_early_and_late_fragment_tests: Vulkan_AMD_shader_early_and_late_fragment_tests,
	pub vk_nv_fragment_shading_rate_enums: Vulkan_NV_fragment_shading_rate_enums,
	pub vk_nv_ray_tracing_motion_blur: Vulkan_NV_ray_tracing_motion_blur,
	pub vk_ext_ycbcr_2plane_444_formats: Vulkan_EXT_ycbcr_2plane_444_formats,
	pub vk_ext_fragment_density_map2: Vulkan_EXT_fragment_density_map2,
	pub vk_qcom_rotated_copy_commands: Vulkan_QCOM_rotated_copy_commands,
	pub vk_ext_image_robustness: Vulkan_EXT_image_robustness,
	pub vk_ext_image_compression_control: Vulkan_EXT_image_compression_control,
	pub vk_ext_attachment_feedback_loop_layout: Vulkan_EXT_attachment_feedback_loop_layout,
	pub vk_ext_4444_formats: Vulkan_EXT_4444_formats,
	pub vk_ext_device_fault: Vulkan_EXT_device_fault,
	pub vk_arm_rasterization_order_attachment_access: Vulkan_ARM_rasterization_order_attachment_access,
	pub vk_ext_rgba10x6_formats: Vulkan_EXT_rgba10x6_formats,
	pub vk_valve_mutable_descriptor_type: Vulkan_VALVE_mutable_descriptor_type,
	pub vk_ext_vertex_input_dynamic_state: Vulkan_EXT_vertex_input_dynamic_state,
	pub vk_ext_physical_device_drm: Vulkan_EXT_physical_device_drm,
	pub vk_ext_device_address_binding_report: Vulkan_EXT_device_address_binding_report,
	pub vk_ext_depth_clip_control: Vulkan_EXT_depth_clip_control,
	pub vk_ext_primitive_topology_list_restart: Vulkan_EXT_primitive_topology_list_restart,
	pub vk_ext_present_mode_fifo_latest_ready: Vulkan_EXT_present_mode_fifo_latest_ready,
	pub vk_huawei_subpass_shading: Vulkan_HUAWEI_subpass_shading,
	pub vk_huawei_invocation_mask: Vulkan_HUAWEI_invocation_mask,
	pub vk_nv_external_memory_rdma: Vulkan_NV_external_memory_rdma,
	pub vk_ext_pipeline_properties: Vulkan_EXT_pipeline_properties,
	pub vk_ext_frame_boundary: Vulkan_EXT_frame_boundary,
	pub vk_ext_multisampled_render_to_single_sampled: Vulkan_EXT_multisampled_render_to_single_sampled,
	pub vk_ext_extended_dynamic_state2: Vulkan_EXT_extended_dynamic_state2,
	pub vk_ext_color_write_enable: Vulkan_EXT_color_write_enable,
	pub vk_ext_primitives_generated_query: Vulkan_EXT_primitives_generated_query,
	pub vk_ext_global_priority_query: Vulkan_EXT_global_priority_query,
	pub vk_ext_image_view_min_lod: Vulkan_EXT_image_view_min_lod,
	pub vk_ext_multi_draw: Vulkan_EXT_multi_draw,
	pub vk_ext_image_2d_view_of_3d: Vulkan_EXT_image_2d_view_of_3d,
	pub vk_ext_shader_tile_image: Vulkan_EXT_shader_tile_image,
	pub vk_ext_opacity_micromap: Vulkan_EXT_opacity_micromap,
	pub vk_ext_load_store_op_none: Vulkan_EXT_load_store_op_none,
	pub vk_huawei_cluster_culling_shader: Vulkan_HUAWEI_cluster_culling_shader,
	pub vk_ext_border_color_swizzle: Vulkan_EXT_border_color_swizzle,
	pub vk_ext_pageable_device_local_memory: Vulkan_EXT_pageable_device_local_memory,
	pub vk_arm_shader_core_properties: Vulkan_ARM_shader_core_properties,
	pub vk_arm_scheduling_controls: Vulkan_ARM_scheduling_controls,
	pub vk_ext_image_sliced_view_of_3d: Vulkan_EXT_image_sliced_view_of_3d,
	pub vk_valve_descriptor_set_host_mapping: Vulkan_VALVE_descriptor_set_host_mapping,
	pub vk_ext_depth_clamp_zero_one: Vulkan_EXT_depth_clamp_zero_one,
	pub vk_ext_non_seamless_cube_map: Vulkan_EXT_non_seamless_cube_map,
	pub vk_arm_render_pass_striped: Vulkan_ARM_render_pass_striped,
	pub vk_qcom_fragment_density_map_offset: Vulkan_QCOM_fragment_density_map_offset,
	pub vk_nv_copy_memory_indirect: Vulkan_NV_copy_memory_indirect,
	pub vk_nv_memory_decompression: Vulkan_NV_memory_decompression,
	pub vk_nv_device_generated_commands_compute: Vulkan_NV_device_generated_commands_compute,
	pub vk_nv_ray_tracing_linear_swept_spheres: Vulkan_NV_ray_tracing_linear_swept_spheres,
	pub vk_nv_linear_color_attachment: Vulkan_NV_linear_color_attachment,
	pub vk_google_surfaceless_query: Vulkan_GOOGLE_surfaceless_query,
	pub vk_ext_image_compression_control_swapchain: Vulkan_EXT_image_compression_control_swapchain,
	pub vk_qcom_image_processing: Vulkan_QCOM_image_processing,
	pub vk_ext_nested_command_buffer: Vulkan_EXT_nested_command_buffer,
	pub vk_ext_external_memory_acquire_unmodified: Vulkan_EXT_external_memory_acquire_unmodified,
	pub vk_ext_extended_dynamic_state3: Vulkan_EXT_extended_dynamic_state3,
	pub vk_ext_subpass_merge_feedback: Vulkan_EXT_subpass_merge_feedback,
	pub vk_lunarg_direct_driver_loading: Vulkan_LUNARG_direct_driver_loading,
	pub vk_arm_tensors: Vulkan_ARM_tensors,
	pub vk_ext_shader_module_identifier: Vulkan_EXT_shader_module_identifier,
	pub vk_ext_rasterization_order_attachment_access: Vulkan_EXT_rasterization_order_attachment_access,
	pub vk_nv_optical_flow: Vulkan_NV_optical_flow,
	pub vk_ext_legacy_dithering: Vulkan_EXT_legacy_dithering,
	pub vk_ext_pipeline_protected_access: Vulkan_EXT_pipeline_protected_access,
	pub vk_amd_anti_lag: Vulkan_AMD_anti_lag,
	pub vk_ext_shader_object: Vulkan_EXT_shader_object,
	pub vk_qcom_tile_properties: Vulkan_QCOM_tile_properties,
	pub vk_sec_amigo_profiling: Vulkan_SEC_amigo_profiling,
	pub vk_qcom_multiview_per_view_viewports: Vulkan_QCOM_multiview_per_view_viewports,
	pub vk_nv_ray_tracing_invocation_reorder: Vulkan_NV_ray_tracing_invocation_reorder,
	pub vk_nv_cooperative_vector: Vulkan_NV_cooperative_vector,
	pub vk_nv_extended_sparse_address_space: Vulkan_NV_extended_sparse_address_space,
	pub vk_ext_mutable_descriptor_type: Vulkan_EXT_mutable_descriptor_type,
	pub vk_ext_legacy_vertex_attributes: Vulkan_EXT_legacy_vertex_attributes,
	pub vk_ext_layer_settings: Vulkan_EXT_layer_settings,
	pub vk_arm_shader_core_builtins: Vulkan_ARM_shader_core_builtins,
	pub vk_ext_pipeline_library_group_handles: Vulkan_EXT_pipeline_library_group_handles,
	pub vk_ext_dynamic_rendering_unused_attachments: Vulkan_EXT_dynamic_rendering_unused_attachments,
	pub vk_nv_low_latency2: Vulkan_NV_low_latency2,
	pub vk_arm_data_graph: Vulkan_ARM_data_graph,
	pub vk_qcom_multiview_per_view_render_areas: Vulkan_QCOM_multiview_per_view_render_areas,
	pub vk_nv_per_stage_descriptor_set: Vulkan_NV_per_stage_descriptor_set,
	pub vk_qcom_image_processing2: Vulkan_QCOM_image_processing2,
	pub vk_qcom_filter_cubic_weights: Vulkan_QCOM_filter_cubic_weights,
	pub vk_qcom_ycbcr_degamma: Vulkan_QCOM_ycbcr_degamma,
	pub vk_qcom_filter_cubic_clamp: Vulkan_QCOM_filter_cubic_clamp,
	pub vk_ext_attachment_feedback_loop_dynamic_state: Vulkan_EXT_attachment_feedback_loop_dynamic_state,
	pub vk_msft_layered_driver: Vulkan_MSFT_layered_driver,
	pub vk_nv_descriptor_pool_overallocation: Vulkan_NV_descriptor_pool_overallocation,
	pub vk_qcom_tile_memory_heap: Vulkan_QCOM_tile_memory_heap,
	pub vk_nv_display_stereo: Vulkan_NV_display_stereo,
	pub vk_nv_raw_access_chains: Vulkan_NV_raw_access_chains,
	pub vk_nv_external_compute_queue: Vulkan_NV_external_compute_queue,
	pub vk_nv_command_buffer_inheritance: Vulkan_NV_command_buffer_inheritance,
	pub vk_nv_shader_atomic_float16_vector: Vulkan_NV_shader_atomic_float16_vector,
	pub vk_ext_shader_replicated_composites: Vulkan_EXT_shader_replicated_composites,
	pub vk_ext_shader_float8: Vulkan_EXT_shader_float8,
	pub vk_nv_ray_tracing_validation: Vulkan_NV_ray_tracing_validation,
	pub vk_nv_cluster_acceleration_structure: Vulkan_NV_cluster_acceleration_structure,
	pub vk_nv_partitioned_acceleration_structure: Vulkan_NV_partitioned_acceleration_structure,
	pub vk_ext_device_generated_commands: Vulkan_EXT_device_generated_commands,
	pub vk_mesa_image_alignment_control: Vulkan_MESA_image_alignment_control,
	pub vk_ext_depth_clamp_control: Vulkan_EXT_depth_clamp_control,
	pub vk_huawei_hdr_vivid: Vulkan_HUAWEI_hdr_vivid,
	pub vk_nv_cooperative_matrix2: Vulkan_NV_cooperative_matrix2,
	pub vk_arm_pipeline_opacity_micromap: Vulkan_ARM_pipeline_opacity_micromap,
	pub vk_ext_vertex_attribute_robustness: Vulkan_EXT_vertex_attribute_robustness,
	pub vk_arm_format_pack: Vulkan_ARM_format_pack,
	pub vk_valve_fragment_density_map_layered: Vulkan_VALVE_fragment_density_map_layered,
	pub vk_nv_present_metering: Vulkan_NV_present_metering,
	pub vk_ext_fragment_density_map_offset: Vulkan_EXT_fragment_density_map_offset,
	pub vk_ext_zero_initialize_device_memory: Vulkan_EXT_zero_initialize_device_memory,
	pub vk_sec_pipeline_cache_incremental_mode: Vulkan_SEC_pipeline_cache_incremental_mode,
	pub vk_khr_acceleration_structure: Vulkan_KHR_acceleration_structure,
	pub vk_khr_ray_tracing_pipeline: Vulkan_KHR_ray_tracing_pipeline,
	pub vk_khr_ray_query: Vulkan_KHR_ray_query,
	pub vk_ext_mesh_shader: Vulkan_EXT_mesh_shader,
}
impl VK_VERSION_1_0 for VkCore {
	fn vkCreateInstance(&self, pCreateInfo: *const VkInstanceCreateInfo, pAllocator: *const VkAllocationCallbacks, pInstance: *mut VkInstance) -> VkResult {
		(self.vk_version_1_0.vk_create_instance)(pCreateInfo, pAllocator, pInstance)
	}
	fn vkDestroyInstance(&self, instance: VkInstance, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_instance)(instance, pAllocator)
	}
	fn vkEnumeratePhysicalDevices(&self, instance: VkInstance, pPhysicalDeviceCount: *mut uint32_t, pPhysicalDevices: *mut VkPhysicalDevice) -> VkResult {
		(self.vk_version_1_0.vk_enumerate_physical_devices)(instance, pPhysicalDeviceCount, pPhysicalDevices)
	}
	fn vkGetPhysicalDeviceFeatures(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures) {
		(self.vk_version_1_0.vk_get_physical_device_features)(physicalDevice, pFeatures)
	}
	fn vkGetPhysicalDeviceFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties) {
		(self.vk_version_1_0.vk_get_physical_device_format_properties)(physicalDevice, format, pFormatProperties)
	}
	fn vkGetPhysicalDeviceImageFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, pImageFormatProperties: *mut VkImageFormatProperties) -> VkResult {
		(self.vk_version_1_0.vk_get_physical_device_image_format_properties)(physicalDevice, format, type_, tiling, usage, flags, pImageFormatProperties)
	}
	fn vkGetPhysicalDeviceProperties(&self, physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties) {
		(self.vk_version_1_0.vk_get_physical_device_properties)(physicalDevice, pProperties)
	}
	fn vkGetPhysicalDeviceQueueFamilyProperties(&self, physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties) {
		(self.vk_version_1_0.vk_get_physical_device_queue_family_properties)(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)
	}
	fn vkGetPhysicalDeviceMemoryProperties(&self, physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties) {
		(self.vk_version_1_0.vk_get_physical_device_memory_properties)(physicalDevice, pMemoryProperties)
	}
	fn vkGetInstanceProcAddr(&self, instance: VkInstance, pName: *const i8) -> PFN_vkVoidFunction {
		(self.vk_version_1_0.vk_get_instance_proc_addr)(instance, pName)
	}
	fn vkGetDeviceProcAddr(&self, device: VkDevice, pName: *const i8) -> PFN_vkVoidFunction {
		(self.vk_version_1_0.vk_get_device_proc_addr)(device, pName)
	}
	fn vkCreateDevice(&self, physicalDevice: VkPhysicalDevice, pCreateInfo: *const VkDeviceCreateInfo, pAllocator: *const VkAllocationCallbacks, pDevice: *mut VkDevice) -> VkResult {
		(self.vk_version_1_0.vk_create_device)(physicalDevice, pCreateInfo, pAllocator, pDevice)
	}
	fn vkDestroyDevice(&self, device: VkDevice, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_device)(device, pAllocator)
	}
	fn vkEnumerateInstanceExtensionProperties(&self, pLayerName: *const i8, pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> VkResult {
		(self.vk_version_1_0.vk_enumerate_instance_extension_properties)(pLayerName, pPropertyCount, pProperties)
	}
	fn vkEnumerateDeviceExtensionProperties(&self, physicalDevice: VkPhysicalDevice, pLayerName: *const i8, pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> VkResult {
		(self.vk_version_1_0.vk_enumerate_device_extension_properties)(physicalDevice, pLayerName, pPropertyCount, pProperties)
	}
	fn vkEnumerateInstanceLayerProperties(&self, pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> VkResult {
		(self.vk_version_1_0.vk_enumerate_instance_layer_properties)(pPropertyCount, pProperties)
	}
	fn vkEnumerateDeviceLayerProperties(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> VkResult {
		(self.vk_version_1_0.vk_enumerate_device_layer_properties)(physicalDevice, pPropertyCount, pProperties)
	}
	fn vkGetDeviceQueue(&self, device: VkDevice, queueFamilyIndex: u32, queueIndex: u32, pQueue: *mut VkQueue) {
		(self.vk_version_1_0.vk_get_device_queue)(device, queueFamilyIndex, queueIndex, pQueue)
	}
	fn vkQueueSubmit(&self, queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo, fence: VkFence) -> VkResult {
		(self.vk_version_1_0.vk_queue_submit)(queue, submitCount, pSubmits, fence)
	}
	fn vkQueueWaitIdle(&self, queue: VkQueue) -> VkResult {
		(self.vk_version_1_0.vk_queue_wait_idle)(queue)
	}
	fn vkDeviceWaitIdle(&self, device: VkDevice) -> VkResult {
		(self.vk_version_1_0.vk_device_wait_idle)(device)
	}
	fn vkAllocateMemory(&self, device: VkDevice, pAllocateInfo: *const VkMemoryAllocateInfo, pAllocator: *const VkAllocationCallbacks, pMemory: *mut VkDeviceMemory) -> VkResult {
		(self.vk_version_1_0.vk_allocate_memory)(device, pAllocateInfo, pAllocator, pMemory)
	}
	fn vkFreeMemory(&self, device: VkDevice, memory: VkDeviceMemory, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_free_memory)(device, memory, pAllocator)
	}
	fn vkMapMemory(&self, device: VkDevice, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize, flags: VkMemoryMapFlags, ppData: *mut *mut c_void) -> VkResult {
		(self.vk_version_1_0.vk_map_memory)(device, memory, offset, size, flags, ppData)
	}
	fn vkUnmapMemory(&self, device: VkDevice, memory: VkDeviceMemory) {
		(self.vk_version_1_0.vk_unmap_memory)(device, memory)
	}
	fn vkFlushMappedMemoryRanges(&self, device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *const VkMappedMemoryRange) -> VkResult {
		(self.vk_version_1_0.vk_flush_mapped_memory_ranges)(device, memoryRangeCount, pMemoryRanges)
	}
	fn vkInvalidateMappedMemoryRanges(&self, device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *const VkMappedMemoryRange) -> VkResult {
		(self.vk_version_1_0.vk_invalidate_mapped_memory_ranges)(device, memoryRangeCount, pMemoryRanges)
	}
	fn vkGetDeviceMemoryCommitment(&self, device: VkDevice, memory: VkDeviceMemory, pCommittedMemoryInBytes: *mut VkDeviceSize) {
		(self.vk_version_1_0.vk_get_device_memory_commitment)(device, memory, pCommittedMemoryInBytes)
	}
	fn vkBindBufferMemory(&self, device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> VkResult {
		(self.vk_version_1_0.vk_bind_buffer_memory)(device, buffer, memory, memoryOffset)
	}
	fn vkBindImageMemory(&self, device: VkDevice, image: VkImage, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> VkResult {
		(self.vk_version_1_0.vk_bind_image_memory)(device, image, memory, memoryOffset)
	}
	fn vkGetBufferMemoryRequirements(&self, device: VkDevice, buffer: VkBuffer, pMemoryRequirements: *mut VkMemoryRequirements) {
		(self.vk_version_1_0.vk_get_buffer_memory_requirements)(device, buffer, pMemoryRequirements)
	}
	fn vkGetImageMemoryRequirements(&self, device: VkDevice, image: VkImage, pMemoryRequirements: *mut VkMemoryRequirements) {
		(self.vk_version_1_0.vk_get_image_memory_requirements)(device, image, pMemoryRequirements)
	}
	fn vkGetImageSparseMemoryRequirements(&self, device: VkDevice, image: VkImage, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements) {
		(self.vk_version_1_0.vk_get_image_sparse_memory_requirements)(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements)
	}
	fn vkGetPhysicalDeviceSparseImageFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties) {
		(self.vk_version_1_0.vk_get_physical_device_sparse_image_format_properties)(physicalDevice, format, type_, samples, usage, tiling, pPropertyCount, pProperties)
	}
	fn vkQueueBindSparse(&self, queue: VkQueue, bindInfoCount: u32, pBindInfo: *const VkBindSparseInfo, fence: VkFence) -> VkResult {
		(self.vk_version_1_0.vk_queue_bind_sparse)(queue, bindInfoCount, pBindInfo, fence)
	}
	fn vkCreateFence(&self, device: VkDevice, pCreateInfo: *const VkFenceCreateInfo, pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence) -> VkResult {
		(self.vk_version_1_0.vk_create_fence)(device, pCreateInfo, pAllocator, pFence)
	}
	fn vkDestroyFence(&self, device: VkDevice, fence: VkFence, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_fence)(device, fence, pAllocator)
	}
	fn vkResetFences(&self, device: VkDevice, fenceCount: u32, pFences: *const VkFence) -> VkResult {
		(self.vk_version_1_0.vk_reset_fences)(device, fenceCount, pFences)
	}
	fn vkGetFenceStatus(&self, device: VkDevice, fence: VkFence) -> VkResult {
		(self.vk_version_1_0.vk_get_fence_status)(device, fence)
	}
	fn vkWaitForFences(&self, device: VkDevice, fenceCount: u32, pFences: *const VkFence, waitAll: VkBool32, timeout: u64) -> VkResult {
		(self.vk_version_1_0.vk_wait_for_fences)(device, fenceCount, pFences, waitAll, timeout)
	}
	fn vkCreateSemaphore(&self, device: VkDevice, pCreateInfo: *const VkSemaphoreCreateInfo, pAllocator: *const VkAllocationCallbacks, pSemaphore: *mut VkSemaphore) -> VkResult {
		(self.vk_version_1_0.vk_create_semaphore)(device, pCreateInfo, pAllocator, pSemaphore)
	}
	fn vkDestroySemaphore(&self, device: VkDevice, semaphore: VkSemaphore, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_semaphore)(device, semaphore, pAllocator)
	}
	fn vkCreateEvent(&self, device: VkDevice, pCreateInfo: *const VkEventCreateInfo, pAllocator: *const VkAllocationCallbacks, pEvent: *mut VkEvent) -> VkResult {
		(self.vk_version_1_0.vk_create_event)(device, pCreateInfo, pAllocator, pEvent)
	}
	fn vkDestroyEvent(&self, device: VkDevice, event: VkEvent, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_event)(device, event, pAllocator)
	}
	fn vkGetEventStatus(&self, device: VkDevice, event: VkEvent) -> VkResult {
		(self.vk_version_1_0.vk_get_event_status)(device, event)
	}
	fn vkSetEvent(&self, device: VkDevice, event: VkEvent) -> VkResult {
		(self.vk_version_1_0.vk_set_event)(device, event)
	}
	fn vkResetEvent(&self, device: VkDevice, event: VkEvent) -> VkResult {
		(self.vk_version_1_0.vk_reset_event)(device, event)
	}
	fn vkCreateQueryPool(&self, device: VkDevice, pCreateInfo: *const VkQueryPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pQueryPool: *mut VkQueryPool) -> VkResult {
		(self.vk_version_1_0.vk_create_query_pool)(device, pCreateInfo, pAllocator, pQueryPool)
	}
	fn vkDestroyQueryPool(&self, device: VkDevice, queryPool: VkQueryPool, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_query_pool)(device, queryPool, pAllocator)
	}
	fn vkGetQueryPoolResults(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dataSize: usize, pData: *mut c_void, stride: VkDeviceSize, flags: VkQueryResultFlags) -> VkResult {
		(self.vk_version_1_0.vk_get_query_pool_results)(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags)
	}
	fn vkCreateBuffer(&self, device: VkDevice, pCreateInfo: *const VkBufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pBuffer: *mut VkBuffer) -> VkResult {
		(self.vk_version_1_0.vk_create_buffer)(device, pCreateInfo, pAllocator, pBuffer)
	}
	fn vkDestroyBuffer(&self, device: VkDevice, buffer: VkBuffer, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_buffer)(device, buffer, pAllocator)
	}
	fn vkCreateBufferView(&self, device: VkDevice, pCreateInfo: *const VkBufferViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkBufferView) -> VkResult {
		(self.vk_version_1_0.vk_create_buffer_view)(device, pCreateInfo, pAllocator, pView)
	}
	fn vkDestroyBufferView(&self, device: VkDevice, bufferView: VkBufferView, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_buffer_view)(device, bufferView, pAllocator)
	}
	fn vkCreateImage(&self, device: VkDevice, pCreateInfo: *const VkImageCreateInfo, pAllocator: *const VkAllocationCallbacks, pImage: *mut VkImage) -> VkResult {
		(self.vk_version_1_0.vk_create_image)(device, pCreateInfo, pAllocator, pImage)
	}
	fn vkDestroyImage(&self, device: VkDevice, image: VkImage, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_image)(device, image, pAllocator)
	}
	fn vkGetImageSubresourceLayout(&self, device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource, pLayout: *mut VkSubresourceLayout) {
		(self.vk_version_1_0.vk_get_image_subresource_layout)(device, image, pSubresource, pLayout)
	}
	fn vkCreateImageView(&self, device: VkDevice, pCreateInfo: *const VkImageViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkImageView) -> VkResult {
		(self.vk_version_1_0.vk_create_image_view)(device, pCreateInfo, pAllocator, pView)
	}
	fn vkDestroyImageView(&self, device: VkDevice, imageView: VkImageView, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_image_view)(device, imageView, pAllocator)
	}
	fn vkCreateShaderModule(&self, device: VkDevice, pCreateInfo: *const VkShaderModuleCreateInfo, pAllocator: *const VkAllocationCallbacks, pShaderModule: *mut VkShaderModule) -> VkResult {
		(self.vk_version_1_0.vk_create_shader_module)(device, pCreateInfo, pAllocator, pShaderModule)
	}
	fn vkDestroyShaderModule(&self, device: VkDevice, shaderModule: VkShaderModule, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_shader_module)(device, shaderModule, pAllocator)
	}
	fn vkCreatePipelineCache(&self, device: VkDevice, pCreateInfo: *const VkPipelineCacheCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineCache: *mut VkPipelineCache) -> VkResult {
		(self.vk_version_1_0.vk_create_pipeline_cache)(device, pCreateInfo, pAllocator, pPipelineCache)
	}
	fn vkDestroyPipelineCache(&self, device: VkDevice, pipelineCache: VkPipelineCache, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_pipeline_cache)(device, pipelineCache, pAllocator)
	}
	fn vkGetPipelineCacheData(&self, device: VkDevice, pipelineCache: VkPipelineCache, pDataSize: *mut size_t, pData: *mut c_void) -> VkResult {
		(self.vk_version_1_0.vk_get_pipeline_cache_data)(device, pipelineCache, pDataSize, pData)
	}
	fn vkMergePipelineCaches(&self, device: VkDevice, dstCache: VkPipelineCache, srcCacheCount: u32, pSrcCaches: *const VkPipelineCache) -> VkResult {
		(self.vk_version_1_0.vk_merge_pipeline_caches)(device, dstCache, srcCacheCount, pSrcCaches)
	}
	fn vkCreateGraphicsPipelines(&self, device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkGraphicsPipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult {
		(self.vk_version_1_0.vk_create_graphics_pipelines)(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)
	}
	fn vkCreateComputePipelines(&self, device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkComputePipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult {
		(self.vk_version_1_0.vk_create_compute_pipelines)(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)
	}
	fn vkDestroyPipeline(&self, device: VkDevice, pipeline: VkPipeline, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_pipeline)(device, pipeline, pAllocator)
	}
	fn vkCreatePipelineLayout(&self, device: VkDevice, pCreateInfo: *const VkPipelineLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineLayout: *mut VkPipelineLayout) -> VkResult {
		(self.vk_version_1_0.vk_create_pipeline_layout)(device, pCreateInfo, pAllocator, pPipelineLayout)
	}
	fn vkDestroyPipelineLayout(&self, device: VkDevice, pipelineLayout: VkPipelineLayout, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_pipeline_layout)(device, pipelineLayout, pAllocator)
	}
	fn vkCreateSampler(&self, device: VkDevice, pCreateInfo: *const VkSamplerCreateInfo, pAllocator: *const VkAllocationCallbacks, pSampler: *mut VkSampler) -> VkResult {
		(self.vk_version_1_0.vk_create_sampler)(device, pCreateInfo, pAllocator, pSampler)
	}
	fn vkDestroySampler(&self, device: VkDevice, sampler: VkSampler, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_sampler)(device, sampler, pAllocator)
	}
	fn vkCreateDescriptorSetLayout(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pSetLayout: *mut VkDescriptorSetLayout) -> VkResult {
		(self.vk_version_1_0.vk_create_descriptor_set_layout)(device, pCreateInfo, pAllocator, pSetLayout)
	}
	fn vkDestroyDescriptorSetLayout(&self, device: VkDevice, descriptorSetLayout: VkDescriptorSetLayout, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_descriptor_set_layout)(device, descriptorSetLayout, pAllocator)
	}
	fn vkCreateDescriptorPool(&self, device: VkDevice, pCreateInfo: *const VkDescriptorPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorPool: *mut VkDescriptorPool) -> VkResult {
		(self.vk_version_1_0.vk_create_descriptor_pool)(device, pCreateInfo, pAllocator, pDescriptorPool)
	}
	fn vkDestroyDescriptorPool(&self, device: VkDevice, descriptorPool: VkDescriptorPool, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_descriptor_pool)(device, descriptorPool, pAllocator)
	}
	fn vkResetDescriptorPool(&self, device: VkDevice, descriptorPool: VkDescriptorPool, flags: VkDescriptorPoolResetFlags) -> VkResult {
		(self.vk_version_1_0.vk_reset_descriptor_pool)(device, descriptorPool, flags)
	}
	fn vkAllocateDescriptorSets(&self, device: VkDevice, pAllocateInfo: *const VkDescriptorSetAllocateInfo, pDescriptorSets: *mut VkDescriptorSet) -> VkResult {
		(self.vk_version_1_0.vk_allocate_descriptor_sets)(device, pAllocateInfo, pDescriptorSets)
	}
	fn vkFreeDescriptorSets(&self, device: VkDevice, descriptorPool: VkDescriptorPool, descriptorSetCount: u32, pDescriptorSets: *const VkDescriptorSet) -> VkResult {
		(self.vk_version_1_0.vk_free_descriptor_sets)(device, descriptorPool, descriptorSetCount, pDescriptorSets)
	}
	fn vkUpdateDescriptorSets(&self, device: VkDevice, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: *const VkCopyDescriptorSet) {
		(self.vk_version_1_0.vk_update_descriptor_sets)(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies)
	}
	fn vkCreateFramebuffer(&self, device: VkDevice, pCreateInfo: *const VkFramebufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pFramebuffer: *mut VkFramebuffer) -> VkResult {
		(self.vk_version_1_0.vk_create_framebuffer)(device, pCreateInfo, pAllocator, pFramebuffer)
	}
	fn vkDestroyFramebuffer(&self, device: VkDevice, framebuffer: VkFramebuffer, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_framebuffer)(device, framebuffer, pAllocator)
	}
	fn vkCreateRenderPass(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult {
		(self.vk_version_1_0.vk_create_render_pass)(device, pCreateInfo, pAllocator, pRenderPass)
	}
	fn vkDestroyRenderPass(&self, device: VkDevice, renderPass: VkRenderPass, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_render_pass)(device, renderPass, pAllocator)
	}
	fn vkGetRenderAreaGranularity(&self, device: VkDevice, renderPass: VkRenderPass, pGranularity: *mut VkExtent2D) {
		(self.vk_version_1_0.vk_get_render_area_granularity)(device, renderPass, pGranularity)
	}
	fn vkCreateCommandPool(&self, device: VkDevice, pCreateInfo: *const VkCommandPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pCommandPool: *mut VkCommandPool) -> VkResult {
		(self.vk_version_1_0.vk_create_command_pool)(device, pCreateInfo, pAllocator, pCommandPool)
	}
	fn vkDestroyCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_0.vk_destroy_command_pool)(device, commandPool, pAllocator)
	}
	fn vkResetCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolResetFlags) -> VkResult {
		(self.vk_version_1_0.vk_reset_command_pool)(device, commandPool, flags)
	}
	fn vkAllocateCommandBuffers(&self, device: VkDevice, pAllocateInfo: *const VkCommandBufferAllocateInfo, pCommandBuffers: *mut VkCommandBuffer) -> VkResult {
		(self.vk_version_1_0.vk_allocate_command_buffers)(device, pAllocateInfo, pCommandBuffers)
	}
	fn vkFreeCommandBuffers(&self, device: VkDevice, commandPool: VkCommandPool, commandBufferCount: u32, pCommandBuffers: *const VkCommandBuffer) {
		(self.vk_version_1_0.vk_free_command_buffers)(device, commandPool, commandBufferCount, pCommandBuffers)
	}
	fn vkBeginCommandBuffer(&self, commandBuffer: VkCommandBuffer, pBeginInfo: *const VkCommandBufferBeginInfo) -> VkResult {
		(self.vk_version_1_0.vk_begin_command_buffer)(commandBuffer, pBeginInfo)
	}
	fn vkEndCommandBuffer(&self, commandBuffer: VkCommandBuffer) -> VkResult {
		(self.vk_version_1_0.vk_end_command_buffer)(commandBuffer)
	}
	fn vkResetCommandBuffer(&self, commandBuffer: VkCommandBuffer, flags: VkCommandBufferResetFlags) -> VkResult {
		(self.vk_version_1_0.vk_reset_command_buffer)(commandBuffer, flags)
	}
	fn vkCmdBindPipeline(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline) {
		(self.vk_version_1_0.vk_cmd_bind_pipeline)(commandBuffer, pipelineBindPoint, pipeline)
	}
	fn vkCmdSetViewport(&self, commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: *const VkViewport) {
		(self.vk_version_1_0.vk_cmd_set_viewport)(commandBuffer, firstViewport, viewportCount, pViewports)
	}
	fn vkCmdSetScissor(&self, commandBuffer: VkCommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: *const VkRect2D) {
		(self.vk_version_1_0.vk_cmd_set_scissor)(commandBuffer, firstScissor, scissorCount, pScissors)
	}
	fn vkCmdSetLineWidth(&self, commandBuffer: VkCommandBuffer, lineWidth: f32) {
		(self.vk_version_1_0.vk_cmd_set_line_width)(commandBuffer, lineWidth)
	}
	fn vkCmdSetDepthBias(&self, commandBuffer: VkCommandBuffer, depthBiasConstantFactor: f32, depthBiasClamp: f32, depthBiasSlopeFactor: f32) {
		(self.vk_version_1_0.vk_cmd_set_depth_bias)(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)
	}
	fn vkCmdSetBlendConstants(&self, commandBuffer: VkCommandBuffer, blendConstants: &[float; 4 as usize]) {
		(self.vk_version_1_0.vk_cmd_set_blend_constants)(commandBuffer, blendConstants)
	}
	fn vkCmdSetDepthBounds(&self, commandBuffer: VkCommandBuffer, minDepthBounds: f32, maxDepthBounds: f32) {
		(self.vk_version_1_0.vk_cmd_set_depth_bounds)(commandBuffer, minDepthBounds, maxDepthBounds)
	}
	fn vkCmdSetStencilCompareMask(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, compareMask: u32) {
		(self.vk_version_1_0.vk_cmd_set_stencil_compare_mask)(commandBuffer, faceMask, compareMask)
	}
	fn vkCmdSetStencilWriteMask(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, writeMask: u32) {
		(self.vk_version_1_0.vk_cmd_set_stencil_write_mask)(commandBuffer, faceMask, writeMask)
	}
	fn vkCmdSetStencilReference(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, reference: u32) {
		(self.vk_version_1_0.vk_cmd_set_stencil_reference)(commandBuffer, faceMask, reference)
	}
	fn vkCmdBindDescriptorSets(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: *const VkDescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: *const uint32_t) {
		(self.vk_version_1_0.vk_cmd_bind_descriptor_sets)(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets)
	}
	fn vkCmdBindIndexBuffer(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, indexType: VkIndexType) {
		(self.vk_version_1_0.vk_cmd_bind_index_buffer)(commandBuffer, buffer, offset, indexType)
	}
	fn vkCmdBindVertexBuffers(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize) {
		(self.vk_version_1_0.vk_cmd_bind_vertex_buffers)(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets)
	}
	fn vkCmdDraw(&self, commandBuffer: VkCommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32) {
		(self.vk_version_1_0.vk_cmd_draw)(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance)
	}
	fn vkCmdDrawIndexed(&self, commandBuffer: VkCommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: i32, firstInstance: u32) {
		(self.vk_version_1_0.vk_cmd_draw_indexed)(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)
	}
	fn vkCmdDrawIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) {
		(self.vk_version_1_0.vk_cmd_draw_indirect)(commandBuffer, buffer, offset, drawCount, stride)
	}
	fn vkCmdDrawIndexedIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) {
		(self.vk_version_1_0.vk_cmd_draw_indexed_indirect)(commandBuffer, buffer, offset, drawCount, stride)
	}
	fn vkCmdDispatch(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) {
		(self.vk_version_1_0.vk_cmd_dispatch)(commandBuffer, groupCountX, groupCountY, groupCountZ)
	}
	fn vkCmdDispatchIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize) {
		(self.vk_version_1_0.vk_cmd_dispatch_indirect)(commandBuffer, buffer, offset)
	}
	fn vkCmdCopyBuffer(&self, commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstBuffer: VkBuffer, regionCount: u32, pRegions: *const VkBufferCopy) {
		(self.vk_version_1_0.vk_cmd_copy_buffer)(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions)
	}
	fn vkCmdCopyImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageCopy) {
		(self.vk_version_1_0.vk_cmd_copy_image)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)
	}
	fn vkCmdBlitImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageBlit, filter: VkFilter) {
		(self.vk_version_1_0.vk_cmd_blit_image)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter)
	}
	fn vkCmdCopyBufferToImage(&self, commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkBufferImageCopy) {
		(self.vk_version_1_0.vk_cmd_copy_buffer_to_image)(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions)
	}
	fn vkCmdCopyImageToBuffer(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstBuffer: VkBuffer, regionCount: u32, pRegions: *const VkBufferImageCopy) {
		(self.vk_version_1_0.vk_cmd_copy_image_to_buffer)(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions)
	}
	fn vkCmdUpdateBuffer(&self, commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, dataSize: VkDeviceSize, pData: *const c_void) {
		(self.vk_version_1_0.vk_cmd_update_buffer)(commandBuffer, dstBuffer, dstOffset, dataSize, pData)
	}
	fn vkCmdFillBuffer(&self, commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, size: VkDeviceSize, data: u32) {
		(self.vk_version_1_0.vk_cmd_fill_buffer)(commandBuffer, dstBuffer, dstOffset, size, data)
	}
	fn vkCmdClearColorImage(&self, commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pColor: *const VkClearColorValue, rangeCount: u32, pRanges: *const VkImageSubresourceRange) {
		(self.vk_version_1_0.vk_cmd_clear_color_image)(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges)
	}
	fn vkCmdClearDepthStencilImage(&self, commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pDepthStencil: *const VkClearDepthStencilValue, rangeCount: u32, pRanges: *const VkImageSubresourceRange) {
		(self.vk_version_1_0.vk_cmd_clear_depth_stencil_image)(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges)
	}
	fn vkCmdClearAttachments(&self, commandBuffer: VkCommandBuffer, attachmentCount: u32, pAttachments: *const VkClearAttachment, rectCount: u32, pRects: *const VkClearRect) {
		(self.vk_version_1_0.vk_cmd_clear_attachments)(commandBuffer, attachmentCount, pAttachments, rectCount, pRects)
	}
	fn vkCmdResolveImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageResolve) {
		(self.vk_version_1_0.vk_cmd_resolve_image)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)
	}
	fn vkCmdSetEvent(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) {
		(self.vk_version_1_0.vk_cmd_set_event)(commandBuffer, event, stageMask)
	}
	fn vkCmdResetEvent(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) {
		(self.vk_version_1_0.vk_cmd_reset_event)(commandBuffer, event, stageMask)
	}
	fn vkCmdWaitEvents(&self, commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const VkImageMemoryBarrier) {
		(self.vk_version_1_0.vk_cmd_wait_events)(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)
	}
	fn vkCmdPipelineBarrier(&self, commandBuffer: VkCommandBuffer, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, dependencyFlags: VkDependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const VkImageMemoryBarrier) {
		(self.vk_version_1_0.vk_cmd_pipeline_barrier)(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)
	}
	fn vkCmdBeginQuery(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags) {
		(self.vk_version_1_0.vk_cmd_begin_query)(commandBuffer, queryPool, query, flags)
	}
	fn vkCmdEndQuery(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32) {
		(self.vk_version_1_0.vk_cmd_end_query)(commandBuffer, queryPool, query)
	}
	fn vkCmdResetQueryPool(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) {
		(self.vk_version_1_0.vk_cmd_reset_query_pool)(commandBuffer, queryPool, firstQuery, queryCount)
	}
	fn vkCmdWriteTimestamp(&self, commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, queryPool: VkQueryPool, query: u32) {
		(self.vk_version_1_0.vk_cmd_write_timestamp)(commandBuffer, pipelineStage, queryPool, query)
	}
	fn vkCmdCopyQueryPoolResults(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, stride: VkDeviceSize, flags: VkQueryResultFlags) {
		(self.vk_version_1_0.vk_cmd_copy_query_pool_results)(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags)
	}
	fn vkCmdPushConstants(&self, commandBuffer: VkCommandBuffer, layout: VkPipelineLayout, stageFlags: VkShaderStageFlags, offset: u32, size: u32, pValues: *const c_void) {
		(self.vk_version_1_0.vk_cmd_push_constants)(commandBuffer, layout, stageFlags, offset, size, pValues)
	}
	fn vkCmdBeginRenderPass(&self, commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, contents: VkSubpassContents) {
		(self.vk_version_1_0.vk_cmd_begin_render_pass)(commandBuffer, pRenderPassBegin, contents)
	}
	fn vkCmdNextSubpass(&self, commandBuffer: VkCommandBuffer, contents: VkSubpassContents) {
		(self.vk_version_1_0.vk_cmd_next_subpass)(commandBuffer, contents)
	}
	fn vkCmdEndRenderPass(&self, commandBuffer: VkCommandBuffer) {
		(self.vk_version_1_0.vk_cmd_end_render_pass)(commandBuffer)
	}
	fn vkCmdExecuteCommands(&self, commandBuffer: VkCommandBuffer, commandBufferCount: u32, pCommandBuffers: *const VkCommandBuffer) {
		(self.vk_version_1_0.vk_cmd_execute_commands)(commandBuffer, commandBufferCount, pCommandBuffers)
	}
}
impl VK_VERSION_1_1 for VkCore {
	fn vkEnumerateInstanceVersion(&self, pApiVersion: *mut uint32_t) -> VkResult {
		(self.vk_version_1_1.vk_enumerate_instance_version)(pApiVersion)
	}
	fn vkBindBufferMemory2(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindBufferMemoryInfo) -> VkResult {
		(self.vk_version_1_1.vk_bind_buffer_memory2)(device, bindInfoCount, pBindInfos)
	}
	fn vkBindImageMemory2(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindImageMemoryInfo) -> VkResult {
		(self.vk_version_1_1.vk_bind_image_memory2)(device, bindInfoCount, pBindInfos)
	}
	fn vkGetDeviceGroupPeerMemoryFeatures(&self, device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags) {
		(self.vk_version_1_1.vk_get_device_group_peer_memory_features)(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures)
	}
	fn vkCmdSetDeviceMask(&self, commandBuffer: VkCommandBuffer, deviceMask: u32) {
		(self.vk_version_1_1.vk_cmd_set_device_mask)(commandBuffer, deviceMask)
	}
	fn vkCmdDispatchBase(&self, commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32) {
		(self.vk_version_1_1.vk_cmd_dispatch_base)(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)
	}
	fn vkEnumeratePhysicalDeviceGroups(&self, instance: VkInstance, pPhysicalDeviceGroupCount: *mut uint32_t, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties) -> VkResult {
		(self.vk_version_1_1.vk_enumerate_physical_device_groups)(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties)
	}
	fn vkGetImageMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkImageMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_version_1_1.vk_get_image_memory_requirements2)(device, pInfo, pMemoryRequirements)
	}
	fn vkGetBufferMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_version_1_1.vk_get_buffer_memory_requirements2)(device, pInfo, pMemoryRequirements)
	}
	fn vkGetImageSparseMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2) {
		(self.vk_version_1_1.vk_get_image_sparse_memory_requirements2)(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements)
	}
	fn vkGetPhysicalDeviceFeatures2(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2) {
		(self.vk_version_1_1.vk_get_physical_device_features2)(physicalDevice, pFeatures)
	}
	fn vkGetPhysicalDeviceProperties2(&self, physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties2) {
		(self.vk_version_1_1.vk_get_physical_device_properties2)(physicalDevice, pProperties)
	}
	fn vkGetPhysicalDeviceFormatProperties2(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties2) {
		(self.vk_version_1_1.vk_get_physical_device_format_properties2)(physicalDevice, format, pFormatProperties)
	}
	fn vkGetPhysicalDeviceImageFormatProperties2(&self, physicalDevice: VkPhysicalDevice, pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *mut VkImageFormatProperties2) -> VkResult {
		(self.vk_version_1_1.vk_get_physical_device_image_format_properties2)(physicalDevice, pImageFormatInfo, pImageFormatProperties)
	}
	fn vkGetPhysicalDeviceQueueFamilyProperties2(&self, physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties2) {
		(self.vk_version_1_1.vk_get_physical_device_queue_family_properties2)(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)
	}
	fn vkGetPhysicalDeviceMemoryProperties2(&self, physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2) {
		(self.vk_version_1_1.vk_get_physical_device_memory_properties2)(physicalDevice, pMemoryProperties)
	}
	fn vkGetPhysicalDeviceSparseImageFormatProperties2(&self, physicalDevice: VkPhysicalDevice, pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties2) {
		(self.vk_version_1_1.vk_get_physical_device_sparse_image_format_properties2)(physicalDevice, pFormatInfo, pPropertyCount, pProperties)
	}
	fn vkTrimCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) {
		(self.vk_version_1_1.vk_trim_command_pool)(device, commandPool, flags)
	}
	fn vkGetDeviceQueue2(&self, device: VkDevice, pQueueInfo: *const VkDeviceQueueInfo2, pQueue: *mut VkQueue) {
		(self.vk_version_1_1.vk_get_device_queue2)(device, pQueueInfo, pQueue)
	}
	fn vkCreateSamplerYcbcrConversion(&self, device: VkDevice, pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo, pAllocator: *const VkAllocationCallbacks, pYcbcrConversion: *mut VkSamplerYcbcrConversion) -> VkResult {
		(self.vk_version_1_1.vk_create_sampler_ycbcr_conversion)(device, pCreateInfo, pAllocator, pYcbcrConversion)
	}
	fn vkDestroySamplerYcbcrConversion(&self, device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_1.vk_destroy_sampler_ycbcr_conversion)(device, ycbcrConversion, pAllocator)
	}
	fn vkCreateDescriptorUpdateTemplate(&self, device: VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate) -> VkResult {
		(self.vk_version_1_1.vk_create_descriptor_update_template)(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate)
	}
	fn vkDestroyDescriptorUpdateTemplate(&self, device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_1.vk_destroy_descriptor_update_template)(device, descriptorUpdateTemplate, pAllocator)
	}
	fn vkUpdateDescriptorSetWithTemplate(&self, device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: *const c_void) {
		(self.vk_version_1_1.vk_update_descriptor_set_with_template)(device, descriptorSet, descriptorUpdateTemplate, pData)
	}
	fn vkGetPhysicalDeviceExternalBufferProperties(&self, physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut VkExternalBufferProperties) {
		(self.vk_version_1_1.vk_get_physical_device_external_buffer_properties)(physicalDevice, pExternalBufferInfo, pExternalBufferProperties)
	}
	fn vkGetPhysicalDeviceExternalFenceProperties(&self, physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut VkExternalFenceProperties) {
		(self.vk_version_1_1.vk_get_physical_device_external_fence_properties)(physicalDevice, pExternalFenceInfo, pExternalFenceProperties)
	}
	fn vkGetPhysicalDeviceExternalSemaphoreProperties(&self, physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties) {
		(self.vk_version_1_1.vk_get_physical_device_external_semaphore_properties)(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties)
	}
	fn vkGetDescriptorSetLayoutSupport(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pSupport: *mut VkDescriptorSetLayoutSupport) {
		(self.vk_version_1_1.vk_get_descriptor_set_layout_support)(device, pCreateInfo, pSupport)
	}
}
impl VK_VERSION_1_2 for VkCore {
	fn vkCmdDrawIndirectCount(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) {
		(self.vk_version_1_2.vk_cmd_draw_indirect_count)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	}
	fn vkCmdDrawIndexedIndirectCount(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) {
		(self.vk_version_1_2.vk_cmd_draw_indexed_indirect_count)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	}
	fn vkCreateRenderPass2(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo2, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult {
		(self.vk_version_1_2.vk_create_render_pass2)(device, pCreateInfo, pAllocator, pRenderPass)
	}
	fn vkCmdBeginRenderPass2(&self, commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, pSubpassBeginInfo: *const VkSubpassBeginInfo) {
		(self.vk_version_1_2.vk_cmd_begin_render_pass2)(commandBuffer, pRenderPassBegin, pSubpassBeginInfo)
	}
	fn vkCmdNextSubpass2(&self, commandBuffer: VkCommandBuffer, pSubpassBeginInfo: *const VkSubpassBeginInfo, pSubpassEndInfo: *const VkSubpassEndInfo) {
		(self.vk_version_1_2.vk_cmd_next_subpass2)(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo)
	}
	fn vkCmdEndRenderPass2(&self, commandBuffer: VkCommandBuffer, pSubpassEndInfo: *const VkSubpassEndInfo) {
		(self.vk_version_1_2.vk_cmd_end_render_pass2)(commandBuffer, pSubpassEndInfo)
	}
	fn vkResetQueryPool(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) {
		(self.vk_version_1_2.vk_reset_query_pool)(device, queryPool, firstQuery, queryCount)
	}
	fn vkGetSemaphoreCounterValue(&self, device: VkDevice, semaphore: VkSemaphore, pValue: *mut uint64_t) -> VkResult {
		(self.vk_version_1_2.vk_get_semaphore_counter_value)(device, semaphore, pValue)
	}
	fn vkWaitSemaphores(&self, device: VkDevice, pWaitInfo: *const VkSemaphoreWaitInfo, timeout: u64) -> VkResult {
		(self.vk_version_1_2.vk_wait_semaphores)(device, pWaitInfo, timeout)
	}
	fn vkSignalSemaphore(&self, device: VkDevice, pSignalInfo: *const VkSemaphoreSignalInfo) -> VkResult {
		(self.vk_version_1_2.vk_signal_semaphore)(device, pSignalInfo)
	}
	fn vkGetBufferDeviceAddress(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress {
		(self.vk_version_1_2.vk_get_buffer_device_address)(device, pInfo)
	}
	fn vkGetBufferOpaqueCaptureAddress(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> u64 {
		(self.vk_version_1_2.vk_get_buffer_opaque_capture_address)(device, pInfo)
	}
	fn vkGetDeviceMemoryOpaqueCaptureAddress(&self, device: VkDevice, pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo) -> u64 {
		(self.vk_version_1_2.vk_get_device_memory_opaque_capture_address)(device, pInfo)
	}
}
impl VK_VERSION_1_3 for VkCore {
	fn vkGetPhysicalDeviceToolProperties(&self, physicalDevice: VkPhysicalDevice, pToolCount: *mut uint32_t, pToolProperties: *mut VkPhysicalDeviceToolProperties) -> VkResult {
		(self.vk_version_1_3.vk_get_physical_device_tool_properties)(physicalDevice, pToolCount, pToolProperties)
	}
	fn vkCreatePrivateDataSlot(&self, device: VkDevice, pCreateInfo: *const VkPrivateDataSlotCreateInfo, pAllocator: *const VkAllocationCallbacks, pPrivateDataSlot: *mut VkPrivateDataSlot) -> VkResult {
		(self.vk_version_1_3.vk_create_private_data_slot)(device, pCreateInfo, pAllocator, pPrivateDataSlot)
	}
	fn vkDestroyPrivateDataSlot(&self, device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_version_1_3.vk_destroy_private_data_slot)(device, privateDataSlot, pAllocator)
	}
	fn vkSetPrivateData(&self, device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, data: u64) -> VkResult {
		(self.vk_version_1_3.vk_set_private_data)(device, objectType, objectHandle, privateDataSlot, data)
	}
	fn vkGetPrivateData(&self, device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, pData: *mut uint64_t) {
		(self.vk_version_1_3.vk_get_private_data)(device, objectType, objectHandle, privateDataSlot, pData)
	}
	fn vkCmdSetEvent2(&self, commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *const VkDependencyInfo) {
		(self.vk_version_1_3.vk_cmd_set_event2)(commandBuffer, event, pDependencyInfo)
	}
	fn vkCmdResetEvent2(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2) {
		(self.vk_version_1_3.vk_cmd_reset_event2)(commandBuffer, event, stageMask)
	}
	fn vkCmdWaitEvents2(&self, commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, pDependencyInfos: *const VkDependencyInfo) {
		(self.vk_version_1_3.vk_cmd_wait_events2)(commandBuffer, eventCount, pEvents, pDependencyInfos)
	}
	fn vkCmdPipelineBarrier2(&self, commandBuffer: VkCommandBuffer, pDependencyInfo: *const VkDependencyInfo) {
		(self.vk_version_1_3.vk_cmd_pipeline_barrier2)(commandBuffer, pDependencyInfo)
	}
	fn vkCmdWriteTimestamp2(&self, commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: u32) {
		(self.vk_version_1_3.vk_cmd_write_timestamp2)(commandBuffer, stage, queryPool, query)
	}
	fn vkQueueSubmit2(&self, queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo2, fence: VkFence) -> VkResult {
		(self.vk_version_1_3.vk_queue_submit2)(queue, submitCount, pSubmits, fence)
	}
	fn vkCmdCopyBuffer2(&self, commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2) {
		(self.vk_version_1_3.vk_cmd_copy_buffer2)(commandBuffer, pCopyBufferInfo)
	}
	fn vkCmdCopyImage2(&self, commandBuffer: VkCommandBuffer, pCopyImageInfo: *const VkCopyImageInfo2) {
		(self.vk_version_1_3.vk_cmd_copy_image2)(commandBuffer, pCopyImageInfo)
	}
	fn vkCmdCopyBufferToImage2(&self, commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: *const VkCopyBufferToImageInfo2) {
		(self.vk_version_1_3.vk_cmd_copy_buffer_to_image2)(commandBuffer, pCopyBufferToImageInfo)
	}
	fn vkCmdCopyImageToBuffer2(&self, commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: *const VkCopyImageToBufferInfo2) {
		(self.vk_version_1_3.vk_cmd_copy_image_to_buffer2)(commandBuffer, pCopyImageToBufferInfo)
	}
	fn vkCmdBlitImage2(&self, commandBuffer: VkCommandBuffer, pBlitImageInfo: *const VkBlitImageInfo2) {
		(self.vk_version_1_3.vk_cmd_blit_image2)(commandBuffer, pBlitImageInfo)
	}
	fn vkCmdResolveImage2(&self, commandBuffer: VkCommandBuffer, pResolveImageInfo: *const VkResolveImageInfo2) {
		(self.vk_version_1_3.vk_cmd_resolve_image2)(commandBuffer, pResolveImageInfo)
	}
	fn vkCmdBeginRendering(&self, commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo) {
		(self.vk_version_1_3.vk_cmd_begin_rendering)(commandBuffer, pRenderingInfo)
	}
	fn vkCmdEndRendering(&self, commandBuffer: VkCommandBuffer) {
		(self.vk_version_1_3.vk_cmd_end_rendering)(commandBuffer)
	}
	fn vkCmdSetCullMode(&self, commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) {
		(self.vk_version_1_3.vk_cmd_set_cull_mode)(commandBuffer, cullMode)
	}
	fn vkCmdSetFrontFace(&self, commandBuffer: VkCommandBuffer, frontFace: VkFrontFace) {
		(self.vk_version_1_3.vk_cmd_set_front_face)(commandBuffer, frontFace)
	}
	fn vkCmdSetPrimitiveTopology(&self, commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology) {
		(self.vk_version_1_3.vk_cmd_set_primitive_topology)(commandBuffer, primitiveTopology)
	}
	fn vkCmdSetViewportWithCount(&self, commandBuffer: VkCommandBuffer, viewportCount: u32, pViewports: *const VkViewport) {
		(self.vk_version_1_3.vk_cmd_set_viewport_with_count)(commandBuffer, viewportCount, pViewports)
	}
	fn vkCmdSetScissorWithCount(&self, commandBuffer: VkCommandBuffer, scissorCount: u32, pScissors: *const VkRect2D) {
		(self.vk_version_1_3.vk_cmd_set_scissor_with_count)(commandBuffer, scissorCount, pScissors)
	}
	fn vkCmdBindVertexBuffers2(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize, pStrides: *const VkDeviceSize) {
		(self.vk_version_1_3.vk_cmd_bind_vertex_buffers2)(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides)
	}
	fn vkCmdSetDepthTestEnable(&self, commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32) {
		(self.vk_version_1_3.vk_cmd_set_depth_test_enable)(commandBuffer, depthTestEnable)
	}
	fn vkCmdSetDepthWriteEnable(&self, commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32) {
		(self.vk_version_1_3.vk_cmd_set_depth_write_enable)(commandBuffer, depthWriteEnable)
	}
	fn vkCmdSetDepthCompareOp(&self, commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp) {
		(self.vk_version_1_3.vk_cmd_set_depth_compare_op)(commandBuffer, depthCompareOp)
	}
	fn vkCmdSetDepthBoundsTestEnable(&self, commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32) {
		(self.vk_version_1_3.vk_cmd_set_depth_bounds_test_enable)(commandBuffer, depthBoundsTestEnable)
	}
	fn vkCmdSetStencilTestEnable(&self, commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32) {
		(self.vk_version_1_3.vk_cmd_set_stencil_test_enable)(commandBuffer, stencilTestEnable)
	}
	fn vkCmdSetStencilOp(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp) {
		(self.vk_version_1_3.vk_cmd_set_stencil_op)(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp)
	}
	fn vkCmdSetRasterizerDiscardEnable(&self, commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32) {
		(self.vk_version_1_3.vk_cmd_set_rasterizer_discard_enable)(commandBuffer, rasterizerDiscardEnable)
	}
	fn vkCmdSetDepthBiasEnable(&self, commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32) {
		(self.vk_version_1_3.vk_cmd_set_depth_bias_enable)(commandBuffer, depthBiasEnable)
	}
	fn vkCmdSetPrimitiveRestartEnable(&self, commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32) {
		(self.vk_version_1_3.vk_cmd_set_primitive_restart_enable)(commandBuffer, primitiveRestartEnable)
	}
	fn vkGetDeviceBufferMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceBufferMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_version_1_3.vk_get_device_buffer_memory_requirements)(device, pInfo, pMemoryRequirements)
	}
	fn vkGetDeviceImageMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_version_1_3.vk_get_device_image_memory_requirements)(device, pInfo, pMemoryRequirements)
	}
	fn vkGetDeviceImageSparseMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2) {
		(self.vk_version_1_3.vk_get_device_image_sparse_memory_requirements)(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements)
	}
}
impl VK_VERSION_1_4 for VkCore {
	fn vkCmdSetLineStipple(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) {
		(self.vk_version_1_4.vk_cmd_set_line_stipple)(commandBuffer, lineStippleFactor, lineStipplePattern)
	}
	fn vkMapMemory2(&self, device: VkDevice, pMemoryMapInfo: *const VkMemoryMapInfo, ppData: *mut *mut c_void) -> VkResult {
		(self.vk_version_1_4.vk_map_memory2)(device, pMemoryMapInfo, ppData)
	}
	fn vkUnmapMemory2(&self, device: VkDevice, pMemoryUnmapInfo: *const VkMemoryUnmapInfo) -> VkResult {
		(self.vk_version_1_4.vk_unmap_memory2)(device, pMemoryUnmapInfo)
	}
	fn vkCmdBindIndexBuffer2(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType) {
		(self.vk_version_1_4.vk_cmd_bind_index_buffer2)(commandBuffer, buffer, offset, size, indexType)
	}
	fn vkGetRenderingAreaGranularity(&self, device: VkDevice, pRenderingAreaInfo: *const VkRenderingAreaInfo, pGranularity: *mut VkExtent2D) {
		(self.vk_version_1_4.vk_get_rendering_area_granularity)(device, pRenderingAreaInfo, pGranularity)
	}
	fn vkGetDeviceImageSubresourceLayout(&self, device: VkDevice, pInfo: *const VkDeviceImageSubresourceInfo, pLayout: *mut VkSubresourceLayout2) {
		(self.vk_version_1_4.vk_get_device_image_subresource_layout)(device, pInfo, pLayout)
	}
	fn vkGetImageSubresourceLayout2(&self, device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource2, pLayout: *mut VkSubresourceLayout2) {
		(self.vk_version_1_4.vk_get_image_subresource_layout2)(device, image, pSubresource, pLayout)
	}
	fn vkCmdPushDescriptorSet(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet) {
		(self.vk_version_1_4.vk_cmd_push_descriptor_set)(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites)
	}
	fn vkCmdPushDescriptorSetWithTemplate(&self, commandBuffer: VkCommandBuffer, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: u32, pData: *const c_void) {
		(self.vk_version_1_4.vk_cmd_push_descriptor_set_with_template)(commandBuffer, descriptorUpdateTemplate, layout, set, pData)
	}
	fn vkCmdSetRenderingAttachmentLocations(&self, commandBuffer: VkCommandBuffer, pLocationInfo: *const VkRenderingAttachmentLocationInfo) {
		(self.vk_version_1_4.vk_cmd_set_rendering_attachment_locations)(commandBuffer, pLocationInfo)
	}
	fn vkCmdSetRenderingInputAttachmentIndices(&self, commandBuffer: VkCommandBuffer, pInputAttachmentIndexInfo: *const VkRenderingInputAttachmentIndexInfo) {
		(self.vk_version_1_4.vk_cmd_set_rendering_input_attachment_indices)(commandBuffer, pInputAttachmentIndexInfo)
	}
	fn vkCmdBindDescriptorSets2(&self, commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo) {
		(self.vk_version_1_4.vk_cmd_bind_descriptor_sets2)(commandBuffer, pBindDescriptorSetsInfo)
	}
	fn vkCmdPushConstants2(&self, commandBuffer: VkCommandBuffer, pPushConstantsInfo: *const VkPushConstantsInfo) {
		(self.vk_version_1_4.vk_cmd_push_constants2)(commandBuffer, pPushConstantsInfo)
	}
	fn vkCmdPushDescriptorSet2(&self, commandBuffer: VkCommandBuffer, pPushDescriptorSetInfo: *const VkPushDescriptorSetInfo) {
		(self.vk_version_1_4.vk_cmd_push_descriptor_set2)(commandBuffer, pPushDescriptorSetInfo)
	}
	fn vkCmdPushDescriptorSetWithTemplate2(&self, commandBuffer: VkCommandBuffer, pPushDescriptorSetWithTemplateInfo: *const VkPushDescriptorSetWithTemplateInfo) {
		(self.vk_version_1_4.vk_cmd_push_descriptor_set_with_template2)(commandBuffer, pPushDescriptorSetWithTemplateInfo)
	}
	fn vkCopyMemoryToImage(&self, device: VkDevice, pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo) -> VkResult {
		(self.vk_version_1_4.vk_copy_memory_to_image)(device, pCopyMemoryToImageInfo)
	}
	fn vkCopyImageToMemory(&self, device: VkDevice, pCopyImageToMemoryInfo: *const VkCopyImageToMemoryInfo) -> VkResult {
		(self.vk_version_1_4.vk_copy_image_to_memory)(device, pCopyImageToMemoryInfo)
	}
	fn vkCopyImageToImage(&self, device: VkDevice, pCopyImageToImageInfo: *const VkCopyImageToImageInfo) -> VkResult {
		(self.vk_version_1_4.vk_copy_image_to_image)(device, pCopyImageToImageInfo)
	}
	fn vkTransitionImageLayout(&self, device: VkDevice, transitionCount: u32, pTransitions: *const VkHostImageLayoutTransitionInfo) -> VkResult {
		(self.vk_version_1_4.vk_transition_image_layout)(device, transitionCount, pTransitions)
	}
}
impl VK_KHR_surface for VkCore {
	fn vkDestroySurfaceKHR(&self, instance: VkInstance, surface: VkSurfaceKHR, pAllocator: *const VkAllocationCallbacks) {
		(self.vk_khr_surface.vk_destroy_surface_khr)(instance, surface, pAllocator)
	}
}
impl VK_KHR_swapchain for VkCore {
	fn vkCreateSwapchainKHR(&self, device: VkDevice, pCreateInfo: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchain: *mut VkSwapchainKHR) -> VkResult {
		(self.vk_khr_swapchain.vk_create_swapchain_khr)(device, pCreateInfo, pAllocator, pSwapchain)
	}
}
impl VK_KHR_display for VkCore {
	fn vkGetPhysicalDeviceDisplayPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayPropertiesKHR) -> VkResult {
		(self.vk_khr_display.vk_get_physical_device_display_properties_khr)(physicalDevice, pPropertyCount, pProperties)
	}
}
impl VK_KHR_display_swapchain for VkCore {
	fn vkCreateSharedSwapchainsKHR(&self, device: VkDevice, swapchainCount: u32, pCreateInfos: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchains: *mut VkSwapchainKHR) -> VkResult {
		(self.vk_khr_display_swapchain.vk_create_shared_swapchains_khr)(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains)
	}
}
impl VK_KHR_sampler_mirror_clamp_to_edge for VkCore {}
impl VK_KHR_video_queue for VkCore {
	fn vkGetPhysicalDeviceVideoCapabilitiesKHR(&self, physicalDevice: VkPhysicalDevice, pVideoProfile: *const VkVideoProfileInfoKHR, pCapabilities: *mut VkVideoCapabilitiesKHR) -> VkResult {
		(self.vk_khr_video_queue.vk_get_physical_device_video_capabilities_khr)(physicalDevice, pVideoProfile, pCapabilities)
	}
}
impl VK_KHR_video_decode_queue for VkCore {
	fn vkCmdDecodeVideoKHR(&self, commandBuffer: VkCommandBuffer, pDecodeInfo: *const VkVideoDecodeInfoKHR) {
		(self.vk_khr_video_decode_queue.vk_cmd_decode_video_khr)(commandBuffer, pDecodeInfo)
	}
}
impl VK_KHR_video_encode_h264 for VkCore {}
impl vulkan_video_codec_h264std for VkCore {}
impl vulkan_video_codecs_common for VkCore {}
impl vulkan_video_codec_h264std_encode for VkCore {}
impl VK_KHR_video_encode_h265 for VkCore {}
impl vulkan_video_codec_h265std for VkCore {}
impl vulkan_video_codec_h265std_encode for VkCore {}
impl VK_KHR_video_decode_h264 for VkCore {}
impl vulkan_video_codec_h264std_decode for VkCore {}
impl VK_KHR_dynamic_rendering for VkCore {
	fn vkCmdBeginRenderingKHR(&self, commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo) {
		(self.vk_khr_dynamic_rendering.vk_cmd_begin_rendering_khr)(commandBuffer, pRenderingInfo)
	}
}
impl VK_KHR_multiview for VkCore {}
impl VK_KHR_get_physical_device_properties2 for VkCore {
	fn vkGetPhysicalDeviceFeatures2KHR(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2) {
		(self.vk_khr_get_physical_device_properties2.vk_get_physical_device_features2_khr)(physicalDevice, pFeatures)
	}
}
impl VK_KHR_device_group for VkCore {
	fn vkGetDeviceGroupPeerMemoryFeaturesKHR(&self, device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags) {
		(self.vk_khr_device_group.vk_get_device_group_peer_memory_features_khr)(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures)
	}
}
impl VK_KHR_shader_draw_parameters for VkCore {}
impl VK_KHR_maintenance1 for VkCore {
	fn vkTrimCommandPoolKHR(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) {
		(self.vk_khr_maintenance1.vk_trim_command_pool_khr)(device, commandPool, flags)
	}
}
impl VK_KHR_device_group_creation for VkCore {
	fn vkEnumeratePhysicalDeviceGroupsKHR(&self, instance: VkInstance, pPhysicalDeviceGroupCount: *mut uint32_t, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties) -> VkResult {
		(self.vk_khr_device_group_creation.vk_enumerate_physical_device_groups_khr)(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties)
	}
}
impl VK_KHR_external_memory_capabilities for VkCore {
	fn vkGetPhysicalDeviceExternalBufferPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut VkExternalBufferProperties) {
		(self.vk_khr_external_memory_capabilities.vk_get_physical_device_external_buffer_properties_khr)(physicalDevice, pExternalBufferInfo, pExternalBufferProperties)
	}
}
impl VK_KHR_external_memory for VkCore {}
impl VK_KHR_external_memory_fd for VkCore {
	fn vkGetMemoryFdKHR(&self, device: VkDevice, pGetFdInfo: *const VkMemoryGetFdInfoKHR, pFd: *mut int) -> VkResult {
		(self.vk_khr_external_memory_fd.vk_get_memory_fd_khr)(device, pGetFdInfo, pFd)
	}
}
impl VK_KHR_external_semaphore_capabilities for VkCore {
	fn vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties) {
		(self.vk_khr_external_semaphore_capabilities.vk_get_physical_device_external_semaphore_properties_khr)(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties)
	}
}
impl VK_KHR_external_semaphore for VkCore {}
impl VK_KHR_external_semaphore_fd for VkCore {
	fn vkImportSemaphoreFdKHR(&self, device: VkDevice, pImportSemaphoreFdInfo: *const VkImportSemaphoreFdInfoKHR) -> VkResult {
		(self.vk_khr_external_semaphore_fd.vk_import_semaphore_fd_khr)(device, pImportSemaphoreFdInfo)
	}
}
impl VK_KHR_push_descriptor for VkCore {
	fn vkCmdPushDescriptorSetKHR(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet) {
		(self.vk_khr_push_descriptor.vk_cmd_push_descriptor_set_khr)(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites)
	}
}
impl VK_KHR_shader_float16_int8 for VkCore {}
impl VK_KHR_16bit_storage for VkCore {}
impl VK_KHR_incremental_present for VkCore {}
impl VK_KHR_descriptor_update_template for VkCore {
	fn vkCreateDescriptorUpdateTemplateKHR(&self, device: VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate) -> VkResult {
		(self.vk_khr_descriptor_update_template.vk_create_descriptor_update_template_khr)(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate)
	}
}
impl VK_KHR_imageless_framebuffer for VkCore {}
impl VK_KHR_create_renderpass2 for VkCore {
	fn vkCreateRenderPass2KHR(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo2, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult {
		(self.vk_khr_create_renderpass2.vk_create_render_pass2_khr)(device, pCreateInfo, pAllocator, pRenderPass)
	}
}
impl VK_KHR_shared_presentable_image for VkCore {
	fn vkGetSwapchainStatusKHR(&self, device: VkDevice, swapchain: VkSwapchainKHR) -> VkResult {
		(self.vk_khr_shared_presentable_image.vk_get_swapchain_status_khr)(device, swapchain)
	}
}
impl VK_KHR_external_fence_capabilities for VkCore {
	fn vkGetPhysicalDeviceExternalFencePropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut VkExternalFenceProperties) {
		(self.vk_khr_external_fence_capabilities.vk_get_physical_device_external_fence_properties_khr)(physicalDevice, pExternalFenceInfo, pExternalFenceProperties)
	}
}
impl VK_KHR_external_fence for VkCore {}
impl VK_KHR_external_fence_fd for VkCore {
	fn vkImportFenceFdKHR(&self, device: VkDevice, pImportFenceFdInfo: *const VkImportFenceFdInfoKHR) -> VkResult {
		(self.vk_khr_external_fence_fd.vk_import_fence_fd_khr)(device, pImportFenceFdInfo)
	}
}
impl VK_KHR_performance_query for VkCore {
	fn vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(&self, physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, pCounterCount: *mut uint32_t, pCounters: *mut VkPerformanceCounterKHR, pCounterDescriptions: *mut VkPerformanceCounterDescriptionKHR) -> VkResult {
		(self.vk_khr_performance_query.vk_enumerate_physical_device_queue_family_performance_query_counters_khr)(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions)
	}
}
impl VK_KHR_maintenance2 for VkCore {}
impl VK_KHR_get_surface_capabilities2 for VkCore {
	fn vkGetPhysicalDeviceSurfaceCapabilities2KHR(&self, physicalDevice: VkPhysicalDevice, pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2KHR) -> VkResult {
		(self.vk_khr_get_surface_capabilities2.vk_get_physical_device_surface_capabilities2_khr)(physicalDevice, pSurfaceInfo, pSurfaceCapabilities)
	}
}
impl VK_KHR_variable_pointers for VkCore {}
impl VK_KHR_get_display_properties2 for VkCore {
	fn vkGetPhysicalDeviceDisplayProperties2KHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayProperties2KHR) -> VkResult {
		(self.vk_khr_get_display_properties2.vk_get_physical_device_display_properties2_khr)(physicalDevice, pPropertyCount, pProperties)
	}
}
impl VK_KHR_dedicated_allocation for VkCore {}
impl VK_KHR_storage_buffer_storage_class for VkCore {}
impl VK_KHR_shader_bfloat16 for VkCore {}
impl VK_KHR_relaxed_block_layout for VkCore {}
impl VK_KHR_get_memory_requirements2 for VkCore {
	fn vkGetImageMemoryRequirements2KHR(&self, device: VkDevice, pInfo: *const VkImageMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_khr_get_memory_requirements2.vk_get_image_memory_requirements2_khr)(device, pInfo, pMemoryRequirements)
	}
}
impl VK_KHR_image_format_list for VkCore {}
impl VK_KHR_sampler_ycbcr_conversion for VkCore {
	fn vkCreateSamplerYcbcrConversionKHR(&self, device: VkDevice, pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo, pAllocator: *const VkAllocationCallbacks, pYcbcrConversion: *mut VkSamplerYcbcrConversion) -> VkResult {
		(self.vk_khr_sampler_ycbcr_conversion.vk_create_sampler_ycbcr_conversion_khr)(device, pCreateInfo, pAllocator, pYcbcrConversion)
	}
}
impl VK_KHR_bind_memory2 for VkCore {
	fn vkBindBufferMemory2KHR(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindBufferMemoryInfo) -> VkResult {
		(self.vk_khr_bind_memory2.vk_bind_buffer_memory2_khr)(device, bindInfoCount, pBindInfos)
	}
}
impl VK_KHR_maintenance3 for VkCore {
	fn vkGetDescriptorSetLayoutSupportKHR(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pSupport: *mut VkDescriptorSetLayoutSupport) {
		(self.vk_khr_maintenance3.vk_get_descriptor_set_layout_support_khr)(device, pCreateInfo, pSupport)
	}
}
impl VK_KHR_draw_indirect_count for VkCore {
	fn vkCmdDrawIndirectCountKHR(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) {
		(self.vk_khr_draw_indirect_count.vk_cmd_draw_indirect_count_khr)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	}
}
impl VK_KHR_shader_subgroup_extended_types for VkCore {}
impl VK_KHR_8bit_storage for VkCore {}
impl VK_KHR_shader_atomic_int64 for VkCore {}
impl VK_KHR_shader_clock for VkCore {}
impl VK_KHR_video_decode_h265 for VkCore {}
impl vulkan_video_codec_h265std_decode for VkCore {}
impl VK_KHR_global_priority for VkCore {}
impl VK_KHR_driver_properties for VkCore {}
impl VK_KHR_shader_float_controls for VkCore {}
impl VK_KHR_depth_stencil_resolve for VkCore {}
impl VK_KHR_swapchain_mutable_format for VkCore {}
impl VK_KHR_timeline_semaphore for VkCore {
	fn vkGetSemaphoreCounterValueKHR(&self, device: VkDevice, semaphore: VkSemaphore, pValue: *mut uint64_t) -> VkResult {
		(self.vk_khr_timeline_semaphore.vk_get_semaphore_counter_value_khr)(device, semaphore, pValue)
	}
}
impl VK_KHR_vulkan_memory_model for VkCore {}
impl VK_KHR_shader_terminate_invocation for VkCore {}
impl VK_KHR_fragment_shading_rate for VkCore {
	fn vkGetPhysicalDeviceFragmentShadingRatesKHR(&self, physicalDevice: VkPhysicalDevice, pFragmentShadingRateCount: *mut uint32_t, pFragmentShadingRates: *mut VkPhysicalDeviceFragmentShadingRateKHR) -> VkResult {
		(self.vk_khr_fragment_shading_rate.vk_get_physical_device_fragment_shading_rates_khr)(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates)
	}
}
impl VK_KHR_dynamic_rendering_local_read for VkCore {
	fn vkCmdSetRenderingAttachmentLocationsKHR(&self, commandBuffer: VkCommandBuffer, pLocationInfo: *const VkRenderingAttachmentLocationInfo) {
		(self.vk_khr_dynamic_rendering_local_read.vk_cmd_set_rendering_attachment_locations_khr)(commandBuffer, pLocationInfo)
	}
}
impl VK_KHR_shader_quad_control for VkCore {}
impl VK_KHR_spirv_1_4 for VkCore {}
impl VK_KHR_surface_protected_capabilities for VkCore {}
impl VK_KHR_separate_depth_stencil_layouts for VkCore {}
impl VK_KHR_present_wait for VkCore {
	fn vkWaitForPresentKHR(&self, device: VkDevice, swapchain: VkSwapchainKHR, presentId: u64, timeout: u64) -> VkResult {
		(self.vk_khr_present_wait.vk_wait_for_present_khr)(device, swapchain, presentId, timeout)
	}
}
impl VK_KHR_uniform_buffer_standard_layout for VkCore {}
impl VK_KHR_buffer_device_address for VkCore {
	fn vkGetBufferDeviceAddressKHR(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress {
		(self.vk_khr_buffer_device_address.vk_get_buffer_device_address_khr)(device, pInfo)
	}
}
impl VK_KHR_deferred_host_operations for VkCore {
	fn vkCreateDeferredOperationKHR(&self, device: VkDevice, pAllocator: *const VkAllocationCallbacks, pDeferredOperation: *mut VkDeferredOperationKHR) -> VkResult {
		(self.vk_khr_deferred_host_operations.vk_create_deferred_operation_khr)(device, pAllocator, pDeferredOperation)
	}
}
impl VK_KHR_pipeline_executable_properties for VkCore {
	fn vkGetPipelineExecutablePropertiesKHR(&self, device: VkDevice, pPipelineInfo: *const VkPipelineInfoKHR, pExecutableCount: *mut uint32_t, pProperties: *mut VkPipelineExecutablePropertiesKHR) -> VkResult {
		(self.vk_khr_pipeline_executable_properties.vk_get_pipeline_executable_properties_khr)(device, pPipelineInfo, pExecutableCount, pProperties)
	}
}
impl VK_KHR_map_memory2 for VkCore {
	fn vkMapMemory2KHR(&self, device: VkDevice, pMemoryMapInfo: *const VkMemoryMapInfo, ppData: *mut *mut c_void) -> VkResult {
		(self.vk_khr_map_memory2.vk_map_memory2_khr)(device, pMemoryMapInfo, ppData)
	}
}
impl VK_KHR_shader_integer_dot_product for VkCore {}
impl VK_KHR_pipeline_library for VkCore {}
impl VK_KHR_shader_non_semantic_info for VkCore {}
impl VK_KHR_present_id for VkCore {}
impl VK_KHR_video_encode_queue for VkCore {
	fn vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pQualityLevelInfo: *const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, pQualityLevelProperties: *mut VkVideoEncodeQualityLevelPropertiesKHR) -> VkResult {
		(self.vk_khr_video_encode_queue.vk_get_physical_device_video_encode_quality_level_properties_khr)(physicalDevice, pQualityLevelInfo, pQualityLevelProperties)
	}
}
impl VK_KHR_synchronization2 for VkCore {
	fn vkCmdSetEvent2KHR(&self, commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *const VkDependencyInfo) {
		(self.vk_khr_synchronization2.vk_cmd_set_event2_khr)(commandBuffer, event, pDependencyInfo)
	}
}
impl VK_KHR_fragment_shader_barycentric for VkCore {}
impl VK_KHR_shader_subgroup_uniform_control_flow for VkCore {}
impl VK_KHR_zero_initialize_workgroup_memory for VkCore {}
impl VK_KHR_workgroup_memory_explicit_layout for VkCore {}
impl VK_KHR_copy_commands2 for VkCore {
	fn vkCmdCopyBuffer2KHR(&self, commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2) {
		(self.vk_khr_copy_commands2.vk_cmd_copy_buffer2_khr)(commandBuffer, pCopyBufferInfo)
	}
}
impl VK_KHR_format_feature_flags2 for VkCore {}
impl VK_KHR_ray_tracing_maintenance1 for VkCore {
	fn vkCmdTraceRaysIndirect2KHR(&self, commandBuffer: VkCommandBuffer, indirectDeviceAddress: VkDeviceAddress) {
		(self.vk_khr_ray_tracing_maintenance1.vk_cmd_trace_rays_indirect2_khr)(commandBuffer, indirectDeviceAddress)
	}
}
impl VK_KHR_portability_enumeration for VkCore {}
impl VK_KHR_maintenance4 for VkCore {
	fn vkGetDeviceBufferMemoryRequirementsKHR(&self, device: VkDevice, pInfo: *const VkDeviceBufferMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_khr_maintenance4.vk_get_device_buffer_memory_requirements_khr)(device, pInfo, pMemoryRequirements)
	}
}
impl VK_KHR_shader_subgroup_rotate for VkCore {}
impl VK_KHR_shader_maximal_reconvergence for VkCore {}
impl VK_KHR_maintenance5 for VkCore {
	fn vkCmdBindIndexBuffer2KHR(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType) {
		(self.vk_khr_maintenance5.vk_cmd_bind_index_buffer2_khr)(commandBuffer, buffer, offset, size, indexType)
	}
}
impl VK_KHR_present_id2 for VkCore {}
impl VK_KHR_present_wait2 for VkCore {
	fn vkWaitForPresent2KHR(&self, device: VkDevice, swapchain: VkSwapchainKHR, pPresentWait2Info: *const VkPresentWait2InfoKHR) -> VkResult {
		(self.vk_khr_present_wait2.vk_wait_for_present2_khr)(device, swapchain, pPresentWait2Info)
	}
}
impl VK_KHR_ray_tracing_position_fetch for VkCore {}
impl VK_KHR_pipeline_binary for VkCore {
	fn vkCreatePipelineBinariesKHR(&self, device: VkDevice, pCreateInfo: *const VkPipelineBinaryCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pBinaries: *mut VkPipelineBinaryHandlesInfoKHR) -> VkResult {
		(self.vk_khr_pipeline_binary.vk_create_pipeline_binaries_khr)(device, pCreateInfo, pAllocator, pBinaries)
	}
}
impl VK_KHR_surface_maintenance1 for VkCore {}
impl VK_KHR_swapchain_maintenance1 for VkCore {
	fn vkReleaseSwapchainImagesKHR(&self, device: VkDevice, pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR) -> VkResult {
		(self.vk_khr_swapchain_maintenance1.vk_release_swapchain_images_khr)(device, pReleaseInfo)
	}
}
impl VK_KHR_cooperative_matrix for VkCore {
	fn vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixPropertiesKHR) -> VkResult {
		(self.vk_khr_cooperative_matrix.vk_get_physical_device_cooperative_matrix_properties_khr)(physicalDevice, pPropertyCount, pProperties)
	}
}
impl VK_KHR_compute_shader_derivatives for VkCore {}
impl VK_KHR_video_decode_av1 for VkCore {}
impl vulkan_video_codec_av1std for VkCore {}
impl vulkan_video_codec_av1std_decode for VkCore {}
impl VK_KHR_video_encode_av1 for VkCore {}
impl vulkan_video_codec_av1std_encode for VkCore {}
impl VK_KHR_video_decode_vp9 for VkCore {}
impl vulkan_video_codec_vp9std for VkCore {}
impl vulkan_video_codec_vp9std_decode for VkCore {}
impl VK_KHR_video_maintenance1 for VkCore {}
impl VK_KHR_vertex_attribute_divisor for VkCore {}
impl VK_KHR_load_store_op_none for VkCore {}
impl VK_KHR_unified_image_layouts for VkCore {}
impl VK_KHR_shader_float_controls2 for VkCore {}
impl VK_KHR_index_type_uint8 for VkCore {}
impl VK_KHR_line_rasterization for VkCore {
	fn vkCmdSetLineStippleKHR(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) {
		(self.vk_khr_line_rasterization.vk_cmd_set_line_stipple_khr)(commandBuffer, lineStippleFactor, lineStipplePattern)
	}
}
impl VK_KHR_calibrated_timestamps for VkCore {
	fn vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(&self, physicalDevice: VkPhysicalDevice, pTimeDomainCount: *mut uint32_t, pTimeDomains: *mut VkTimeDomainKHR) -> VkResult {
		(self.vk_khr_calibrated_timestamps.vk_get_physical_device_calibrateable_time_domains_khr)(physicalDevice, pTimeDomainCount, pTimeDomains)
	}
}
impl VK_KHR_shader_expect_assume for VkCore {}
impl VK_KHR_maintenance6 for VkCore {
	fn vkCmdBindDescriptorSets2KHR(&self, commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo) {
		(self.vk_khr_maintenance6.vk_cmd_bind_descriptor_sets2_khr)(commandBuffer, pBindDescriptorSetsInfo)
	}
}
impl VK_KHR_video_encode_intra_refresh for VkCore {}
impl VK_KHR_video_encode_quantization_map for VkCore {}
impl VK_KHR_shader_relaxed_extended_instruction for VkCore {}
impl VK_KHR_maintenance7 for VkCore {}
impl VK_KHR_maintenance8 for VkCore {}
impl VK_KHR_maintenance9 for VkCore {}
impl VK_KHR_video_maintenance2 for VkCore {}
impl VK_KHR_depth_clamp_zero_one for VkCore {}
impl VK_KHR_robustness2 for VkCore {}
impl VK_KHR_present_mode_fifo_latest_ready for VkCore {}
impl VK_EXT_debug_report for VkCore {
	fn vkCreateDebugReportCallbackEXT(&self, instance: VkInstance, pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pCallback: *mut VkDebugReportCallbackEXT) -> VkResult {
		(self.vk_ext_debug_report.vk_create_debug_report_callback_ext)(instance, pCreateInfo, pAllocator, pCallback)
	}
}
impl VK_NV_glsl_shader for VkCore {}
impl VK_EXT_depth_range_unrestricted for VkCore {}
impl VK_IMG_filter_cubic for VkCore {}
impl VK_AMD_rasterization_order for VkCore {}
impl VK_AMD_shader_trinary_minmax for VkCore {}
impl VK_AMD_shader_explicit_vertex_parameter for VkCore {}
impl VK_EXT_debug_marker for VkCore {
	fn vkDebugMarkerSetObjectTagEXT(&self, device: VkDevice, pTagInfo: *const VkDebugMarkerObjectTagInfoEXT) -> VkResult {
		(self.vk_ext_debug_marker.vk_debug_marker_set_object_tag_ext)(device, pTagInfo)
	}
}
impl VK_AMD_gcn_shader for VkCore {}
impl VK_NV_dedicated_allocation for VkCore {}
impl VK_EXT_transform_feedback for VkCore {
	fn vkCmdBindTransformFeedbackBuffersEXT(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize) {
		(self.vk_ext_transform_feedback.vk_cmd_bind_transform_feedback_buffers_ext)(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes)
	}
}
impl VK_NVX_binary_import for VkCore {
	fn vkCreateCuModuleNVX(&self, device: VkDevice, pCreateInfo: *const VkCuModuleCreateInfoNVX, pAllocator: *const VkAllocationCallbacks, pModule: *mut VkCuModuleNVX) -> VkResult {
		(self.vk_nvx_binary_import.vk_create_cu_module_nvx)(device, pCreateInfo, pAllocator, pModule)
	}
}
impl VK_NVX_image_view_handle for VkCore {
	fn vkGetImageViewHandleNVX(&self, device: VkDevice, pInfo: *const VkImageViewHandleInfoNVX) -> u32 {
		(self.vk_nvx_image_view_handle.vk_get_image_view_handle_nvx)(device, pInfo)
	}
}
impl VK_AMD_draw_indirect_count for VkCore {
	fn vkCmdDrawIndirectCountAMD(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) {
		(self.vk_amd_draw_indirect_count.vk_cmd_draw_indirect_count_amd)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	}
}
impl VK_AMD_negative_viewport_height for VkCore {}
impl VK_AMD_gpu_shader_half_float for VkCore {}
impl VK_AMD_shader_ballot for VkCore {}
impl VK_AMD_texture_gather_bias_lod for VkCore {}
impl VK_AMD_shader_info for VkCore {
	fn vkGetShaderInfoAMD(&self, device: VkDevice, pipeline: VkPipeline, shaderStage: VkShaderStageFlagBits, infoType: VkShaderInfoTypeAMD, pInfoSize: *mut size_t, pInfo: *mut c_void) -> VkResult {
		(self.vk_amd_shader_info.vk_get_shader_info_amd)(device, pipeline, shaderStage, infoType, pInfoSize, pInfo)
	}
}
impl VK_AMD_shader_image_load_store_lod for VkCore {}
impl VK_NV_corner_sampled_image for VkCore {}
impl VK_IMG_format_pvrtc for VkCore {}
impl VK_NV_external_memory_capabilities for VkCore {
	fn vkGetPhysicalDeviceExternalImageFormatPropertiesNV(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, externalHandleType: VkExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *mut VkExternalImageFormatPropertiesNV) -> VkResult {
		(self.vk_nv_external_memory_capabilities.vk_get_physical_device_external_image_format_properties_nv)(physicalDevice, format, type_, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties)
	}
}
impl VK_NV_external_memory for VkCore {}
impl VK_EXT_validation_flags for VkCore {}
impl VK_EXT_shader_subgroup_ballot for VkCore {}
impl VK_EXT_shader_subgroup_vote for VkCore {}
impl VK_EXT_texture_compression_astc_hdr for VkCore {}
impl VK_EXT_astc_decode_mode for VkCore {}
impl VK_EXT_pipeline_robustness for VkCore {}
impl VK_EXT_conditional_rendering for VkCore {
	fn vkCmdBeginConditionalRenderingEXT(&self, commandBuffer: VkCommandBuffer, pConditionalRenderingBegin: *const VkConditionalRenderingBeginInfoEXT) {
		(self.vk_ext_conditional_rendering.vk_cmd_begin_conditional_rendering_ext)(commandBuffer, pConditionalRenderingBegin)
	}
}
impl VK_NV_clip_space_w_scaling for VkCore {
	fn vkCmdSetViewportWScalingNV(&self, commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportWScalings: *const VkViewportWScalingNV) {
		(self.vk_nv_clip_space_w_scaling.vk_cmd_set_viewport_wscaling_nv)(commandBuffer, firstViewport, viewportCount, pViewportWScalings)
	}
}
impl VK_EXT_direct_mode_display for VkCore {
	fn vkReleaseDisplayEXT(&self, physicalDevice: VkPhysicalDevice, display: VkDisplayKHR) -> VkResult {
		(self.vk_ext_direct_mode_display.vk_release_display_ext)(physicalDevice, display)
	}
}
impl VK_EXT_display_surface_counter for VkCore {
	fn vkGetPhysicalDeviceSurfaceCapabilities2EXT(&self, physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2EXT) -> VkResult {
		(self.vk_ext_display_surface_counter.vk_get_physical_device_surface_capabilities2_ext)(physicalDevice, surface, pSurfaceCapabilities)
	}
}
impl VK_EXT_display_control for VkCore {
	fn vkDisplayPowerControlEXT(&self, device: VkDevice, display: VkDisplayKHR, pDisplayPowerInfo: *const VkDisplayPowerInfoEXT) -> VkResult {
		(self.vk_ext_display_control.vk_display_power_control_ext)(device, display, pDisplayPowerInfo)
	}
}
impl VK_GOOGLE_display_timing for VkCore {
	fn vkGetRefreshCycleDurationGOOGLE(&self, device: VkDevice, swapchain: VkSwapchainKHR, pDisplayTimingProperties: *mut VkRefreshCycleDurationGOOGLE) -> VkResult {
		(self.vk_google_display_timing.vk_get_refresh_cycle_duration_google)(device, swapchain, pDisplayTimingProperties)
	}
}
impl VK_NV_sample_mask_override_coverage for VkCore {}
impl VK_NV_geometry_shader_passthrough for VkCore {}
impl VK_NV_viewport_array2 for VkCore {}
impl VK_NVX_multiview_per_view_attributes for VkCore {}
impl VK_NV_viewport_swizzle for VkCore {}
impl VK_EXT_discard_rectangles for VkCore {
	fn vkCmdSetDiscardRectangleEXT(&self, commandBuffer: VkCommandBuffer, firstDiscardRectangle: u32, discardRectangleCount: u32, pDiscardRectangles: *const VkRect2D) {
		(self.vk_ext_discard_rectangles.vk_cmd_set_discard_rectangle_ext)(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles)
	}
}
impl VK_EXT_conservative_rasterization for VkCore {}
impl VK_EXT_depth_clip_enable for VkCore {}
impl VK_EXT_swapchain_colorspace for VkCore {}
impl VK_EXT_hdr_metadata for VkCore {
	fn vkSetHdrMetadataEXT(&self, device: VkDevice, swapchainCount: u32, pSwapchains: *const VkSwapchainKHR, pMetadata: *const VkHdrMetadataEXT) {
		(self.vk_ext_hdr_metadata.vk_set_hdr_metadata_ext)(device, swapchainCount, pSwapchains, pMetadata)
	}
}
impl VK_IMG_relaxed_line_rasterization for VkCore {}
impl VK_EXT_external_memory_dma_buf for VkCore {}
impl VK_EXT_queue_family_foreign for VkCore {}
impl VK_EXT_debug_utils for VkCore {
	fn vkSetDebugUtilsObjectNameEXT(&self, device: VkDevice, pNameInfo: *const VkDebugUtilsObjectNameInfoEXT) -> VkResult {
		(self.vk_ext_debug_utils.vk_set_debug_utils_object_name_ext)(device, pNameInfo)
	}
}
impl VK_EXT_sampler_filter_minmax for VkCore {}
impl VK_AMD_gpu_shader_int16 for VkCore {}
impl VK_AMD_mixed_attachment_samples for VkCore {}
impl VK_AMD_shader_fragment_mask for VkCore {}
impl VK_EXT_inline_uniform_block for VkCore {}
impl VK_EXT_shader_stencil_export for VkCore {}
impl VK_EXT_sample_locations for VkCore {
	fn vkCmdSetSampleLocationsEXT(&self, commandBuffer: VkCommandBuffer, pSampleLocationsInfo: *const VkSampleLocationsInfoEXT) {
		(self.vk_ext_sample_locations.vk_cmd_set_sample_locations_ext)(commandBuffer, pSampleLocationsInfo)
	}
}
impl VK_EXT_blend_operation_advanced for VkCore {}
impl VK_NV_fragment_coverage_to_color for VkCore {}
impl VK_NV_framebuffer_mixed_samples for VkCore {}
impl VK_NV_fill_rectangle for VkCore {}
impl VK_NV_shader_sm_builtins for VkCore {}
impl VK_EXT_post_depth_coverage for VkCore {}
impl VK_EXT_image_drm_format_modifier for VkCore {
	fn vkGetImageDrmFormatModifierPropertiesEXT(&self, device: VkDevice, image: VkImage, pProperties: *mut VkImageDrmFormatModifierPropertiesEXT) -> VkResult {
		(self.vk_ext_image_drm_format_modifier.vk_get_image_drm_format_modifier_properties_ext)(device, image, pProperties)
	}
}
impl VK_EXT_validation_cache for VkCore {
	fn vkCreateValidationCacheEXT(&self, device: VkDevice, pCreateInfo: *const VkValidationCacheCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pValidationCache: *mut VkValidationCacheEXT) -> VkResult {
		(self.vk_ext_validation_cache.vk_create_validation_cache_ext)(device, pCreateInfo, pAllocator, pValidationCache)
	}
}
impl VK_EXT_descriptor_indexing for VkCore {}
impl VK_EXT_shader_viewport_index_layer for VkCore {}
impl VK_NV_shading_rate_image for VkCore {
	fn vkCmdBindShadingRateImageNV(&self, commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) {
		(self.vk_nv_shading_rate_image.vk_cmd_bind_shading_rate_image_nv)(commandBuffer, imageView, imageLayout)
	}
}
impl VK_NV_ray_tracing for VkCore {
	fn vkCreateAccelerationStructureNV(&self, device: VkDevice, pCreateInfo: *const VkAccelerationStructureCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pAccelerationStructure: *mut VkAccelerationStructureNV) -> VkResult {
		(self.vk_nv_ray_tracing.vk_create_acceleration_structure_nv)(device, pCreateInfo, pAllocator, pAccelerationStructure)
	}
}
impl VK_NV_representative_fragment_test for VkCore {}
impl VK_EXT_filter_cubic for VkCore {}
impl VK_QCOM_render_pass_shader_resolve for VkCore {}
impl VK_EXT_global_priority for VkCore {}
impl VK_EXT_external_memory_host for VkCore {
	fn vkGetMemoryHostPointerPropertiesEXT(&self, device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHostPointer: *const c_void, pMemoryHostPointerProperties: *mut VkMemoryHostPointerPropertiesEXT) -> VkResult {
		(self.vk_ext_external_memory_host.vk_get_memory_host_pointer_properties_ext)(device, handleType, pHostPointer, pMemoryHostPointerProperties)
	}
}
impl VK_AMD_buffer_marker for VkCore {
	fn vkCmdWriteBufferMarkerAMD(&self, commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32) {
		(self.vk_amd_buffer_marker.vk_cmd_write_buffer_marker_amd)(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker)
	}
}
impl VK_AMD_pipeline_compiler_control for VkCore {}
impl VK_EXT_calibrated_timestamps for VkCore {
	fn vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(&self, physicalDevice: VkPhysicalDevice, pTimeDomainCount: *mut uint32_t, pTimeDomains: *mut VkTimeDomainKHR) -> VkResult {
		(self.vk_ext_calibrated_timestamps.vk_get_physical_device_calibrateable_time_domains_ext)(physicalDevice, pTimeDomainCount, pTimeDomains)
	}
}
impl VK_AMD_shader_core_properties for VkCore {}
impl VK_AMD_memory_overallocation_behavior for VkCore {}
impl VK_EXT_vertex_attribute_divisor for VkCore {}
impl VK_EXT_pipeline_creation_feedback for VkCore {}
impl VK_NV_shader_subgroup_partitioned for VkCore {}
impl VK_NV_compute_shader_derivatives for VkCore {}
impl VK_NV_mesh_shader for VkCore {
	fn vkCmdDrawMeshTasksNV(&self, commandBuffer: VkCommandBuffer, taskCount: u32, firstTask: u32) {
		(self.vk_nv_mesh_shader.vk_cmd_draw_mesh_tasks_nv)(commandBuffer, taskCount, firstTask)
	}
}
impl VK_NV_fragment_shader_barycentric for VkCore {}
impl VK_NV_shader_image_footprint for VkCore {}
impl VK_NV_scissor_exclusive for VkCore {
	fn vkCmdSetExclusiveScissorEnableNV(&self, commandBuffer: VkCommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissorEnables: *const VkBool32) {
		(self.vk_nv_scissor_exclusive.vk_cmd_set_exclusive_scissor_enable_nv)(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables)
	}
}
impl VK_NV_device_diagnostic_checkpoints for VkCore {
	fn vkCmdSetCheckpointNV(&self, commandBuffer: VkCommandBuffer, pCheckpointMarker: *const c_void) {
		(self.vk_nv_device_diagnostic_checkpoints.vk_cmd_set_checkpoint_nv)(commandBuffer, pCheckpointMarker)
	}
}
impl VK_INTEL_shader_integer_functions2 for VkCore {}
impl VK_INTEL_performance_query for VkCore {
	fn vkInitializePerformanceApiINTEL(&self, device: VkDevice, pInitializeInfo: *const VkInitializePerformanceApiInfoINTEL) -> VkResult {
		(self.vk_intel_performance_query.vk_initialize_performance_api_intel)(device, pInitializeInfo)
	}
}
impl VK_EXT_pci_bus_info for VkCore {}
impl VK_AMD_display_native_hdr for VkCore {
	fn vkSetLocalDimmingAMD(&self, device: VkDevice, swapChain: VkSwapchainKHR, localDimmingEnable: VkBool32) {
		(self.vk_amd_display_native_hdr.vk_set_local_dimming_amd)(device, swapChain, localDimmingEnable)
	}
}
impl VK_EXT_fragment_density_map for VkCore {}
impl VK_EXT_scalar_block_layout for VkCore {}
impl VK_GOOGLE_hlsl_functionality1 for VkCore {}
impl VK_GOOGLE_decorate_string for VkCore {}
impl VK_EXT_subgroup_size_control for VkCore {}
impl VK_AMD_shader_core_properties2 for VkCore {}
impl VK_AMD_device_coherent_memory for VkCore {}
impl VK_EXT_shader_image_atomic_int64 for VkCore {}
impl VK_EXT_memory_budget for VkCore {}
impl VK_EXT_memory_priority for VkCore {}
impl VK_NV_dedicated_allocation_image_aliasing for VkCore {}
impl VK_EXT_buffer_device_address for VkCore {
	fn vkGetBufferDeviceAddressEXT(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress {
		(self.vk_ext_buffer_device_address.vk_get_buffer_device_address_ext)(device, pInfo)
	}
}
impl VK_EXT_tooling_info for VkCore {
	fn vkGetPhysicalDeviceToolPropertiesEXT(&self, physicalDevice: VkPhysicalDevice, pToolCount: *mut uint32_t, pToolProperties: *mut VkPhysicalDeviceToolProperties) -> VkResult {
		(self.vk_ext_tooling_info.vk_get_physical_device_tool_properties_ext)(physicalDevice, pToolCount, pToolProperties)
	}
}
impl VK_EXT_separate_stencil_usage for VkCore {}
impl VK_EXT_validation_features for VkCore {}
impl VK_NV_cooperative_matrix for VkCore {
	fn vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixPropertiesNV) -> VkResult {
		(self.vk_nv_cooperative_matrix.vk_get_physical_device_cooperative_matrix_properties_nv)(physicalDevice, pPropertyCount, pProperties)
	}
}
impl VK_NV_coverage_reduction_mode for VkCore {
	fn vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(&self, physicalDevice: VkPhysicalDevice, pCombinationCount: *mut uint32_t, pCombinations: *mut VkFramebufferMixedSamplesCombinationNV) -> VkResult {
		(self.vk_nv_coverage_reduction_mode.vk_get_physical_device_supported_framebuffer_mixed_samples_combinations_nv)(physicalDevice, pCombinationCount, pCombinations)
	}
}
impl VK_EXT_fragment_shader_interlock for VkCore {}
impl VK_EXT_ycbcr_image_arrays for VkCore {}
impl VK_EXT_provoking_vertex for VkCore {}
impl VK_EXT_headless_surface for VkCore {
	fn vkCreateHeadlessSurfaceEXT(&self, instance: VkInstance, pCreateInfo: *const VkHeadlessSurfaceCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR) -> VkResult {
		(self.vk_ext_headless_surface.vk_create_headless_surface_ext)(instance, pCreateInfo, pAllocator, pSurface)
	}
}
impl VK_EXT_line_rasterization for VkCore {
	fn vkCmdSetLineStippleEXT(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) {
		(self.vk_ext_line_rasterization.vk_cmd_set_line_stipple_ext)(commandBuffer, lineStippleFactor, lineStipplePattern)
	}
}
impl VK_EXT_shader_atomic_float for VkCore {}
impl VK_EXT_host_query_reset for VkCore {
	fn vkResetQueryPoolEXT(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) {
		(self.vk_ext_host_query_reset.vk_reset_query_pool_ext)(device, queryPool, firstQuery, queryCount)
	}
}
impl VK_EXT_index_type_uint8 for VkCore {}
impl VK_EXT_extended_dynamic_state for VkCore {
	fn vkCmdSetCullModeEXT(&self, commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) {
		(self.vk_ext_extended_dynamic_state.vk_cmd_set_cull_mode_ext)(commandBuffer, cullMode)
	}
}
impl VK_EXT_host_image_copy for VkCore {
	fn vkCopyMemoryToImageEXT(&self, device: VkDevice, pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo) -> VkResult {
		(self.vk_ext_host_image_copy.vk_copy_memory_to_image_ext)(device, pCopyMemoryToImageInfo)
	}
}
impl VK_EXT_map_memory_placed for VkCore {}
impl VK_EXT_shader_atomic_float2 for VkCore {}
impl VK_EXT_surface_maintenance1 for VkCore {}
impl VK_EXT_swapchain_maintenance1 for VkCore {
	fn vkReleaseSwapchainImagesEXT(&self, device: VkDevice, pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR) -> VkResult {
		(self.vk_ext_swapchain_maintenance1.vk_release_swapchain_images_ext)(device, pReleaseInfo)
	}
}
impl VK_EXT_shader_demote_to_helper_invocation for VkCore {}
impl VK_NV_device_generated_commands for VkCore {
	fn vkGetGeneratedCommandsMemoryRequirementsNV(&self, device: VkDevice, pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoNV, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_nv_device_generated_commands.vk_get_generated_commands_memory_requirements_nv)(device, pInfo, pMemoryRequirements)
	}
}
impl VK_NV_inherited_viewport_scissor for VkCore {}
impl VK_EXT_texel_buffer_alignment for VkCore {}
impl VK_QCOM_render_pass_transform for VkCore {}
impl VK_EXT_depth_bias_control for VkCore {
	fn vkCmdSetDepthBias2EXT(&self, commandBuffer: VkCommandBuffer, pDepthBiasInfo: *const VkDepthBiasInfoEXT) {
		(self.vk_ext_depth_bias_control.vk_cmd_set_depth_bias2_ext)(commandBuffer, pDepthBiasInfo)
	}
}
impl VK_EXT_device_memory_report for VkCore {}
impl VK_EXT_acquire_drm_display for VkCore {
	fn vkAcquireDrmDisplayEXT(&self, physicalDevice: VkPhysicalDevice, drmFd: i32, display: VkDisplayKHR) -> VkResult {
		(self.vk_ext_acquire_drm_display.vk_acquire_drm_display_ext)(physicalDevice, drmFd, display)
	}
}
impl VK_EXT_robustness2 for VkCore {}
impl VK_EXT_custom_border_color for VkCore {}
impl VK_GOOGLE_user_type for VkCore {}
impl VK_NV_present_barrier for VkCore {}
impl VK_EXT_private_data for VkCore {
	fn vkCreatePrivateDataSlotEXT(&self, device: VkDevice, pCreateInfo: *const VkPrivateDataSlotCreateInfo, pAllocator: *const VkAllocationCallbacks, pPrivateDataSlot: *mut VkPrivateDataSlot) -> VkResult {
		(self.vk_ext_private_data.vk_create_private_data_slot_ext)(device, pCreateInfo, pAllocator, pPrivateDataSlot)
	}
}
impl VK_EXT_pipeline_creation_cache_control for VkCore {}
impl VK_NV_device_diagnostics_config for VkCore {}
impl VK_QCOM_render_pass_store_ops for VkCore {}
impl VK_QCOM_tile_shading for VkCore {
	fn vkCmdDispatchTileQCOM(&self, commandBuffer: VkCommandBuffer, pDispatchTileInfo: *const VkDispatchTileInfoQCOM) {
		(self.vk_qcom_tile_shading.vk_cmd_dispatch_tile_qcom)(commandBuffer, pDispatchTileInfo)
	}
}
impl VK_NV_low_latency for VkCore {}
impl VK_EXT_descriptor_buffer for VkCore {
	fn vkGetDescriptorSetLayoutSizeEXT(&self, device: VkDevice, layout: VkDescriptorSetLayout, pLayoutSizeInBytes: *mut VkDeviceSize) {
		(self.vk_ext_descriptor_buffer.vk_get_descriptor_set_layout_size_ext)(device, layout, pLayoutSizeInBytes)
	}
}
impl VK_EXT_graphics_pipeline_library for VkCore {}
impl VK_AMD_shader_early_and_late_fragment_tests for VkCore {}
impl VK_NV_fragment_shading_rate_enums for VkCore {
	fn vkCmdSetFragmentShadingRateEnumNV(&self, commandBuffer: VkCommandBuffer, shadingRate: VkFragmentShadingRateNV, combinerOps: &[VkFragmentShadingRateCombinerOpKHR; 2 as usize]) {
		(self.vk_nv_fragment_shading_rate_enums.vk_cmd_set_fragment_shading_rate_enum_nv)(commandBuffer, shadingRate, combinerOps)
	}
}
impl VK_NV_ray_tracing_motion_blur for VkCore {}
impl VK_EXT_ycbcr_2plane_444_formats for VkCore {}
impl VK_EXT_fragment_density_map2 for VkCore {}
impl VK_QCOM_rotated_copy_commands for VkCore {}
impl VK_EXT_image_robustness for VkCore {}
impl VK_EXT_image_compression_control for VkCore {}
impl VK_EXT_attachment_feedback_loop_layout for VkCore {}
impl VK_EXT_4444_formats for VkCore {}
impl VK_EXT_device_fault for VkCore {
	fn vkGetDeviceFaultInfoEXT(&self, device: VkDevice, pFaultCounts: *mut VkDeviceFaultCountsEXT, pFaultInfo: *mut VkDeviceFaultInfoEXT) -> VkResult {
		(self.vk_ext_device_fault.vk_get_device_fault_info_ext)(device, pFaultCounts, pFaultInfo)
	}
}
impl VK_ARM_rasterization_order_attachment_access for VkCore {}
impl VK_EXT_rgba10x6_formats for VkCore {}
impl VK_VALVE_mutable_descriptor_type for VkCore {}
impl VK_EXT_vertex_input_dynamic_state for VkCore {
	fn vkCmdSetVertexInputEXT(&self, commandBuffer: VkCommandBuffer, vertexBindingDescriptionCount: u32, pVertexBindingDescriptions: *const VkVertexInputBindingDescription2EXT, vertexAttributeDescriptionCount: u32, pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription2EXT) {
		(self.vk_ext_vertex_input_dynamic_state.vk_cmd_set_vertex_input_ext)(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions)
	}
}
impl VK_EXT_physical_device_drm for VkCore {}
impl VK_EXT_device_address_binding_report for VkCore {}
impl VK_EXT_depth_clip_control for VkCore {}
impl VK_EXT_primitive_topology_list_restart for VkCore {}
impl VK_EXT_present_mode_fifo_latest_ready for VkCore {}
impl VK_HUAWEI_subpass_shading for VkCore {
	fn vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(&self, device: VkDevice, renderpass: VkRenderPass, pMaxWorkgroupSize: *mut VkExtent2D) -> VkResult {
		(self.vk_huawei_subpass_shading.vk_get_device_subpass_shading_max_workgroup_size_huawei)(device, renderpass, pMaxWorkgroupSize)
	}
}
impl VK_HUAWEI_invocation_mask for VkCore {
	fn vkCmdBindInvocationMaskHUAWEI(&self, commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) {
		(self.vk_huawei_invocation_mask.vk_cmd_bind_invocation_mask_huawei)(commandBuffer, imageView, imageLayout)
	}
}
impl VK_NV_external_memory_rdma for VkCore {
	fn vkGetMemoryRemoteAddressNV(&self, device: VkDevice, pMemoryGetRemoteAddressInfo: *const VkMemoryGetRemoteAddressInfoNV, pAddress: *mut VkRemoteAddressNV) -> VkResult {
		(self.vk_nv_external_memory_rdma.vk_get_memory_remote_address_nv)(device, pMemoryGetRemoteAddressInfo, pAddress)
	}
}
impl VK_EXT_pipeline_properties for VkCore {
	fn vkGetPipelinePropertiesEXT(&self, device: VkDevice, pPipelineInfo: *const VkPipelineInfoEXT, pPipelineProperties: *mut VkBaseOutStructure) -> VkResult {
		(self.vk_ext_pipeline_properties.vk_get_pipeline_properties_ext)(device, pPipelineInfo, pPipelineProperties)
	}
}
impl VK_EXT_frame_boundary for VkCore {}
impl VK_EXT_multisampled_render_to_single_sampled for VkCore {}
impl VK_EXT_extended_dynamic_state2 for VkCore {
	fn vkCmdSetPatchControlPointsEXT(&self, commandBuffer: VkCommandBuffer, patchControlPoints: u32) {
		(self.vk_ext_extended_dynamic_state2.vk_cmd_set_patch_control_points_ext)(commandBuffer, patchControlPoints)
	}
}
impl VK_EXT_color_write_enable for VkCore {
	fn vkCmdSetColorWriteEnableEXT(&self, commandBuffer: VkCommandBuffer, attachmentCount: u32, pColorWriteEnables: *const VkBool32) {
		(self.vk_ext_color_write_enable.vk_cmd_set_color_write_enable_ext)(commandBuffer, attachmentCount, pColorWriteEnables)
	}
}
impl VK_EXT_primitives_generated_query for VkCore {}
impl VK_EXT_global_priority_query for VkCore {}
impl VK_EXT_image_view_min_lod for VkCore {}
impl VK_EXT_multi_draw for VkCore {
	fn vkCmdDrawMultiEXT(&self, commandBuffer: VkCommandBuffer, drawCount: u32, pVertexInfo: *const VkMultiDrawInfoEXT, instanceCount: u32, firstInstance: u32, stride: u32) {
		(self.vk_ext_multi_draw.vk_cmd_draw_multi_ext)(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride)
	}
}
impl VK_EXT_image_2d_view_of_3d for VkCore {}
impl VK_EXT_shader_tile_image for VkCore {}
impl VK_EXT_opacity_micromap for VkCore {
	fn vkCreateMicromapEXT(&self, device: VkDevice, pCreateInfo: *const VkMicromapCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pMicromap: *mut VkMicromapEXT) -> VkResult {
		(self.vk_ext_opacity_micromap.vk_create_micromap_ext)(device, pCreateInfo, pAllocator, pMicromap)
	}
}
impl VK_EXT_load_store_op_none for VkCore {}
impl VK_HUAWEI_cluster_culling_shader for VkCore {
	fn vkCmdDrawClusterHUAWEI(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) {
		(self.vk_huawei_cluster_culling_shader.vk_cmd_draw_cluster_huawei)(commandBuffer, groupCountX, groupCountY, groupCountZ)
	}
}
impl VK_EXT_border_color_swizzle for VkCore {}
impl VK_EXT_pageable_device_local_memory for VkCore {
	fn vkSetDeviceMemoryPriorityEXT(&self, device: VkDevice, memory: VkDeviceMemory, priority: f32) {
		(self.vk_ext_pageable_device_local_memory.vk_set_device_memory_priority_ext)(device, memory, priority)
	}
}
impl VK_ARM_shader_core_properties for VkCore {}
impl VK_ARM_scheduling_controls for VkCore {}
impl VK_EXT_image_sliced_view_of_3d for VkCore {}
impl VK_VALVE_descriptor_set_host_mapping for VkCore {
	fn vkGetDescriptorSetLayoutHostMappingInfoVALVE(&self, device: VkDevice, pBindingReference: *const VkDescriptorSetBindingReferenceVALVE, pHostMapping: *mut VkDescriptorSetLayoutHostMappingInfoVALVE) {
		(self.vk_valve_descriptor_set_host_mapping.vk_get_descriptor_set_layout_host_mapping_info_valve)(device, pBindingReference, pHostMapping)
	}
}
impl VK_EXT_depth_clamp_zero_one for VkCore {}
impl VK_EXT_non_seamless_cube_map for VkCore {}
impl VK_ARM_render_pass_striped for VkCore {}
impl VK_QCOM_fragment_density_map_offset for VkCore {}
impl VK_NV_copy_memory_indirect for VkCore {
	fn vkCmdCopyMemoryIndirectNV(&self, commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: u32, stride: u32) {
		(self.vk_nv_copy_memory_indirect.vk_cmd_copy_memory_indirect_nv)(commandBuffer, copyBufferAddress, copyCount, stride)
	}
}
impl VK_NV_memory_decompression for VkCore {
	fn vkCmdDecompressMemoryNV(&self, commandBuffer: VkCommandBuffer, decompressRegionCount: u32, pDecompressMemoryRegions: *const VkDecompressMemoryRegionNV) {
		(self.vk_nv_memory_decompression.vk_cmd_decompress_memory_nv)(commandBuffer, decompressRegionCount, pDecompressMemoryRegions)
	}
}
impl VK_NV_device_generated_commands_compute for VkCore {
	fn vkGetPipelineIndirectMemoryRequirementsNV(&self, device: VkDevice, pCreateInfo: *const VkComputePipelineCreateInfo, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_nv_device_generated_commands_compute.vk_get_pipeline_indirect_memory_requirements_nv)(device, pCreateInfo, pMemoryRequirements)
	}
}
impl VK_NV_ray_tracing_linear_swept_spheres for VkCore {}
impl VK_NV_linear_color_attachment for VkCore {}
impl VK_GOOGLE_surfaceless_query for VkCore {}
impl VK_EXT_image_compression_control_swapchain for VkCore {}
impl VK_QCOM_image_processing for VkCore {}
impl VK_EXT_nested_command_buffer for VkCore {}
impl VK_EXT_external_memory_acquire_unmodified for VkCore {}
impl VK_EXT_extended_dynamic_state3 for VkCore {
	fn vkCmdSetDepthClampEnableEXT(&self, commandBuffer: VkCommandBuffer, depthClampEnable: VkBool32) {
		(self.vk_ext_extended_dynamic_state3.vk_cmd_set_depth_clamp_enable_ext)(commandBuffer, depthClampEnable)
	}
}
impl VK_EXT_subpass_merge_feedback for VkCore {}
impl VK_LUNARG_direct_driver_loading for VkCore {}
impl VK_ARM_tensors for VkCore {
	fn vkCreateTensorARM(&self, device: VkDevice, pCreateInfo: *const VkTensorCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pTensor: *mut VkTensorARM) -> VkResult {
		(self.vk_arm_tensors.vk_create_tensor_arm)(device, pCreateInfo, pAllocator, pTensor)
	}
}
impl VK_EXT_shader_module_identifier for VkCore {
	fn vkGetShaderModuleIdentifierEXT(&self, device: VkDevice, shaderModule: VkShaderModule, pIdentifier: *mut VkShaderModuleIdentifierEXT) {
		(self.vk_ext_shader_module_identifier.vk_get_shader_module_identifier_ext)(device, shaderModule, pIdentifier)
	}
}
impl VK_EXT_rasterization_order_attachment_access for VkCore {}
impl VK_NV_optical_flow for VkCore {
	fn vkGetPhysicalDeviceOpticalFlowImageFormatsNV(&self, physicalDevice: VkPhysicalDevice, pOpticalFlowImageFormatInfo: *const VkOpticalFlowImageFormatInfoNV, pFormatCount: *mut uint32_t, pImageFormatProperties: *mut VkOpticalFlowImageFormatPropertiesNV) -> VkResult {
		(self.vk_nv_optical_flow.vk_get_physical_device_optical_flow_image_formats_nv)(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties)
	}
}
impl VK_EXT_legacy_dithering for VkCore {}
impl VK_EXT_pipeline_protected_access for VkCore {}
impl VK_AMD_anti_lag for VkCore {
	fn vkAntiLagUpdateAMD(&self, device: VkDevice, pData: *const VkAntiLagDataAMD) {
		(self.vk_amd_anti_lag.vk_anti_lag_update_amd)(device, pData)
	}
}
impl VK_EXT_shader_object for VkCore {
	fn vkCreateShadersEXT(&self, device: VkDevice, createInfoCount: u32, pCreateInfos: *const VkShaderCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pShaders: *mut VkShaderEXT) -> VkResult {
		(self.vk_ext_shader_object.vk_create_shaders_ext)(device, createInfoCount, pCreateInfos, pAllocator, pShaders)
	}
}
impl VK_QCOM_tile_properties for VkCore {
	fn vkGetFramebufferTilePropertiesQCOM(&self, device: VkDevice, framebuffer: VkFramebuffer, pPropertiesCount: *mut uint32_t, pProperties: *mut VkTilePropertiesQCOM) -> VkResult {
		(self.vk_qcom_tile_properties.vk_get_framebuffer_tile_properties_qcom)(device, framebuffer, pPropertiesCount, pProperties)
	}
}
impl VK_SEC_amigo_profiling for VkCore {}
impl VK_QCOM_multiview_per_view_viewports for VkCore {}
impl VK_NV_ray_tracing_invocation_reorder for VkCore {}
impl VK_NV_cooperative_vector for VkCore {
	fn vkGetPhysicalDeviceCooperativeVectorPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeVectorPropertiesNV) -> VkResult {
		(self.vk_nv_cooperative_vector.vk_get_physical_device_cooperative_vector_properties_nv)(physicalDevice, pPropertyCount, pProperties)
	}
}
impl VK_NV_extended_sparse_address_space for VkCore {}
impl VK_EXT_mutable_descriptor_type for VkCore {}
impl VK_EXT_legacy_vertex_attributes for VkCore {}
impl VK_EXT_layer_settings for VkCore {}
impl VK_ARM_shader_core_builtins for VkCore {}
impl VK_EXT_pipeline_library_group_handles for VkCore {}
impl VK_EXT_dynamic_rendering_unused_attachments for VkCore {}
impl VK_NV_low_latency2 for VkCore {
	fn vkSetLatencySleepModeNV(&self, device: VkDevice, swapchain: VkSwapchainKHR, pSleepModeInfo: *const VkLatencySleepModeInfoNV) -> VkResult {
		(self.vk_nv_low_latency2.vk_set_latency_sleep_mode_nv)(device, swapchain, pSleepModeInfo)
	}
}
impl VK_ARM_data_graph for VkCore {
	fn vkCreateDataGraphPipelinesARM(&self, device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkDataGraphPipelineCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult {
		(self.vk_arm_data_graph.vk_create_data_graph_pipelines_arm)(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)
	}
}
impl VK_QCOM_multiview_per_view_render_areas for VkCore {}
impl VK_NV_per_stage_descriptor_set for VkCore {}
impl VK_QCOM_image_processing2 for VkCore {}
impl VK_QCOM_filter_cubic_weights for VkCore {}
impl VK_QCOM_ycbcr_degamma for VkCore {}
impl VK_QCOM_filter_cubic_clamp for VkCore {}
impl VK_EXT_attachment_feedback_loop_dynamic_state for VkCore {
	fn vkCmdSetAttachmentFeedbackLoopEnableEXT(&self, commandBuffer: VkCommandBuffer, aspectMask: VkImageAspectFlags) {
		(self.vk_ext_attachment_feedback_loop_dynamic_state.vk_cmd_set_attachment_feedback_loop_enable_ext)(commandBuffer, aspectMask)
	}
}
impl VK_MSFT_layered_driver for VkCore {}
impl VK_NV_descriptor_pool_overallocation for VkCore {}
impl VK_QCOM_tile_memory_heap for VkCore {
	fn vkCmdBindTileMemoryQCOM(&self, commandBuffer: VkCommandBuffer, pTileMemoryBindInfo: *const VkTileMemoryBindInfoQCOM) {
		(self.vk_qcom_tile_memory_heap.vk_cmd_bind_tile_memory_qcom)(commandBuffer, pTileMemoryBindInfo)
	}
}
impl VK_NV_display_stereo for VkCore {}
impl VK_NV_raw_access_chains for VkCore {}
impl VK_NV_external_compute_queue for VkCore {
	fn vkCreateExternalComputeQueueNV(&self, device: VkDevice, pCreateInfo: *const VkExternalComputeQueueCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pExternalQueue: *mut VkExternalComputeQueueNV) -> VkResult {
		(self.vk_nv_external_compute_queue.vk_create_external_compute_queue_nv)(device, pCreateInfo, pAllocator, pExternalQueue)
	}
}
impl VK_NV_command_buffer_inheritance for VkCore {}
impl VK_NV_shader_atomic_float16_vector for VkCore {}
impl VK_EXT_shader_replicated_composites for VkCore {}
impl VK_EXT_shader_float8 for VkCore {}
impl VK_NV_ray_tracing_validation for VkCore {}
impl VK_NV_cluster_acceleration_structure for VkCore {
	fn vkGetClusterAccelerationStructureBuildSizesNV(&self, device: VkDevice, pInfo: *const VkClusterAccelerationStructureInputInfoNV, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR) {
		(self.vk_nv_cluster_acceleration_structure.vk_get_cluster_acceleration_structure_build_sizes_nv)(device, pInfo, pSizeInfo)
	}
}
impl VK_NV_partitioned_acceleration_structure for VkCore {
	fn vkGetPartitionedAccelerationStructuresBuildSizesNV(&self, device: VkDevice, pInfo: *const VkPartitionedAccelerationStructureInstancesInputNV, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR) {
		(self.vk_nv_partitioned_acceleration_structure.vk_get_partitioned_acceleration_structures_build_sizes_nv)(device, pInfo, pSizeInfo)
	}
}
impl VK_EXT_device_generated_commands for VkCore {
	fn vkGetGeneratedCommandsMemoryRequirementsEXT(&self, device: VkDevice, pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoEXT, pMemoryRequirements: *mut VkMemoryRequirements2) {
		(self.vk_ext_device_generated_commands.vk_get_generated_commands_memory_requirements_ext)(device, pInfo, pMemoryRequirements)
	}
}
impl VK_MESA_image_alignment_control for VkCore {}
impl VK_EXT_depth_clamp_control for VkCore {}
impl VK_HUAWEI_hdr_vivid for VkCore {}
impl VK_NV_cooperative_matrix2 for VkCore {
	fn vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixFlexibleDimensionsPropertiesNV) -> VkResult {
		(self.vk_nv_cooperative_matrix2.vk_get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv)(physicalDevice, pPropertyCount, pProperties)
	}
}
impl VK_ARM_pipeline_opacity_micromap for VkCore {}
impl VK_EXT_vertex_attribute_robustness for VkCore {}
impl VK_ARM_format_pack for VkCore {}
impl VK_VALVE_fragment_density_map_layered for VkCore {}
impl VK_NV_present_metering for VkCore {}
impl VK_EXT_fragment_density_map_offset for VkCore {
	fn vkCmdEndRendering2EXT(&self, commandBuffer: VkCommandBuffer, pRenderingEndInfo: *const VkRenderingEndInfoEXT) {
		(self.vk_ext_fragment_density_map_offset.vk_cmd_end_rendering2_ext)(commandBuffer, pRenderingEndInfo)
	}
}
impl VK_EXT_zero_initialize_device_memory for VkCore {}
impl VK_SEC_pipeline_cache_incremental_mode for VkCore {}
impl VK_KHR_acceleration_structure for VkCore {
	fn vkCreateAccelerationStructureKHR(&self, device: VkDevice, pCreateInfo: *const VkAccelerationStructureCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pAccelerationStructure: *mut VkAccelerationStructureKHR) -> VkResult {
		(self.vk_khr_acceleration_structure.vk_create_acceleration_structure_khr)(device, pCreateInfo, pAllocator, pAccelerationStructure)
	}
}
impl VK_KHR_ray_tracing_pipeline for VkCore {
	fn vkCmdTraceRaysKHR(&self, commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, width: u32, height: u32, depth: u32) {
		(self.vk_khr_ray_tracing_pipeline.vk_cmd_trace_rays_khr)(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth)
	}
}
impl VK_KHR_ray_query for VkCore {}
impl VK_EXT_mesh_shader for VkCore {
	fn vkCmdDrawMeshTasksEXT(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) {
		(self.vk_ext_mesh_shader.vk_cmd_draw_mesh_tasks_ext)(commandBuffer, groupCountX, groupCountY, groupCountZ)
	}
}
impl VkCore {
	pub fn new(app_info: VkApplicationInfo, mut get_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		let vkEnumerateInstanceExtensionProperties = get_proc_address(null(), "vkEnumerateInstanceExtensionProperties");
		if vkEnumerateInstanceExtensionProperties == null() {
			panic!("Initialize Vulkan failed: couldn't get the address of `vkEnumerateInstanceExtensionProperties()`");
		}
		let vkEnumerateInstanceExtensionProperties: PFN_vkEnumerateInstanceExtensionProperties = unsafe{transmute(vkEnumerateInstanceExtensionProperties)};
		let mut count: u32 = 0;
		let err = vkEnumerateInstanceExtensionProperties(null(), &mut count as *mut _, null_mut());
		if err != VkResult::VK_SUCCESS {
			panic!("Initialize Vulkan failed: couldn't get the number of the Vulkan extensions: {err:?}")
		}
		let mut extensions: Vec<VkExtensionProperties> = Vec::with_capacity(count as usize);
		unsafe {extensions.set_len(count as usize)};
		let err = vkEnumerateInstanceExtensionProperties(null(), &mut count as *mut _, extensions.as_mut_ptr());
		if err != VkResult::VK_SUCCESS {
			panic!("Initialize Vulkan failed: couldn't get the list of the Vulkan extensions: {err:?}")
		}
		let create_info = VkInstanceCreateInfo {
			sType: VkStructureType::VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
			pNext: null(),
			flags: 0,
			enabledLayerCount: 0,
			pApplicationInfo: &app_info as *const _,
			ppEnabledLayerNames: null(),
			enabledExtensionCount: count,
			ppEnabledExtensionNames: extensions.as_ptr() as *const _
		};
		let vkCreateInstance = get_proc_address(null(), "vkCreateInstance");
		if vkCreateInstance == null() {
			panic!("Initialize Vulkan failed: couldn't get a valid `vkCreateInstance()` function pointer.")
		}
		let vkCreateInstance: PFN_vkCreateInstance = unsafe{transmute(vkCreateInstance)};
		let mut instance: VkInstance = null();
		let result = vkCreateInstance(&create_info, null(), &mut instance);
		if result != VkResult::VK_SUCCESS {
			panic!("Initialize Vulkan failed: `vkCreateInstance()` failed: {result:?}")
		}
		
		Self {
			instance,
			extensions: extensions.into_iter().map(|prop|unsafe {CStr::from_ptr(prop.extensionName.as_ptr())}.to_string_lossy().to_string()).collect(),
			vk_version_1_0: Vulkan_VERSION_1_0::new(instance, &mut get_proc_address),
			vk_version_1_1: Vulkan_VERSION_1_1::new(instance, &mut get_proc_address),
			vk_version_1_2: Vulkan_VERSION_1_2::new(instance, &mut get_proc_address),
			vk_version_1_3: Vulkan_VERSION_1_3::new(instance, &mut get_proc_address),
			vk_version_1_4: Vulkan_VERSION_1_4::new(instance, &mut get_proc_address),
			vk_khr_surface: Vulkan_KHR_surface::new(instance, &mut get_proc_address),
			vk_khr_swapchain: Vulkan_KHR_swapchain::new(instance, &mut get_proc_address),
			vk_khr_display: Vulkan_KHR_display::new(instance, &mut get_proc_address),
			vk_khr_display_swapchain: Vulkan_KHR_display_swapchain::new(instance, &mut get_proc_address),
			vk_khr_sampler_mirror_clamp_to_edge: Vulkan_KHR_sampler_mirror_clamp_to_edge::new(instance, &mut get_proc_address),
			vk_khr_video_queue: Vulkan_KHR_video_queue::new(instance, &mut get_proc_address),
			vk_khr_video_decode_queue: Vulkan_KHR_video_decode_queue::new(instance, &mut get_proc_address),
			vk_khr_video_encode_h264: Vulkan_KHR_video_encode_h264::new(instance, &mut get_proc_address),
			vulkan_video_codec_h264std: Vulkan_video_codec_h264std::new(instance, &mut get_proc_address),
			vulkan_video_codecs_common: Vulkan_video_codecs_common::new(instance, &mut get_proc_address),
			vulkan_video_codec_h264std_encode: Vulkan_video_codec_h264std_encode::new(instance, &mut get_proc_address),
			vk_khr_video_encode_h265: Vulkan_KHR_video_encode_h265::new(instance, &mut get_proc_address),
			vulkan_video_codec_h265std: Vulkan_video_codec_h265std::new(instance, &mut get_proc_address),
			vulkan_video_codec_h265std_encode: Vulkan_video_codec_h265std_encode::new(instance, &mut get_proc_address),
			vk_khr_video_decode_h264: Vulkan_KHR_video_decode_h264::new(instance, &mut get_proc_address),
			vulkan_video_codec_h264std_decode: Vulkan_video_codec_h264std_decode::new(instance, &mut get_proc_address),
			vk_khr_dynamic_rendering: Vulkan_KHR_dynamic_rendering::new(instance, &mut get_proc_address),
			vk_khr_multiview: Vulkan_KHR_multiview::new(instance, &mut get_proc_address),
			vk_khr_get_physical_device_properties2: Vulkan_KHR_get_physical_device_properties2::new(instance, &mut get_proc_address),
			vk_khr_device_group: Vulkan_KHR_device_group::new(instance, &mut get_proc_address),
			vk_khr_shader_draw_parameters: Vulkan_KHR_shader_draw_parameters::new(instance, &mut get_proc_address),
			vk_khr_maintenance1: Vulkan_KHR_maintenance1::new(instance, &mut get_proc_address),
			vk_khr_device_group_creation: Vulkan_KHR_device_group_creation::new(instance, &mut get_proc_address),
			vk_khr_external_memory_capabilities: Vulkan_KHR_external_memory_capabilities::new(instance, &mut get_proc_address),
			vk_khr_external_memory: Vulkan_KHR_external_memory::new(instance, &mut get_proc_address),
			vk_khr_external_memory_fd: Vulkan_KHR_external_memory_fd::new(instance, &mut get_proc_address),
			vk_khr_external_semaphore_capabilities: Vulkan_KHR_external_semaphore_capabilities::new(instance, &mut get_proc_address),
			vk_khr_external_semaphore: Vulkan_KHR_external_semaphore::new(instance, &mut get_proc_address),
			vk_khr_external_semaphore_fd: Vulkan_KHR_external_semaphore_fd::new(instance, &mut get_proc_address),
			vk_khr_push_descriptor: Vulkan_KHR_push_descriptor::new(instance, &mut get_proc_address),
			vk_khr_shader_float16_int8: Vulkan_KHR_shader_float16_int8::new(instance, &mut get_proc_address),
			vk_khr_16bit_storage: Vulkan_KHR_16bit_storage::new(instance, &mut get_proc_address),
			vk_khr_incremental_present: Vulkan_KHR_incremental_present::new(instance, &mut get_proc_address),
			vk_khr_descriptor_update_template: Vulkan_KHR_descriptor_update_template::new(instance, &mut get_proc_address),
			vk_khr_imageless_framebuffer: Vulkan_KHR_imageless_framebuffer::new(instance, &mut get_proc_address),
			vk_khr_create_renderpass2: Vulkan_KHR_create_renderpass2::new(instance, &mut get_proc_address),
			vk_khr_shared_presentable_image: Vulkan_KHR_shared_presentable_image::new(instance, &mut get_proc_address),
			vk_khr_external_fence_capabilities: Vulkan_KHR_external_fence_capabilities::new(instance, &mut get_proc_address),
			vk_khr_external_fence: Vulkan_KHR_external_fence::new(instance, &mut get_proc_address),
			vk_khr_external_fence_fd: Vulkan_KHR_external_fence_fd::new(instance, &mut get_proc_address),
			vk_khr_performance_query: Vulkan_KHR_performance_query::new(instance, &mut get_proc_address),
			vk_khr_maintenance2: Vulkan_KHR_maintenance2::new(instance, &mut get_proc_address),
			vk_khr_get_surface_capabilities2: Vulkan_KHR_get_surface_capabilities2::new(instance, &mut get_proc_address),
			vk_khr_variable_pointers: Vulkan_KHR_variable_pointers::new(instance, &mut get_proc_address),
			vk_khr_get_display_properties2: Vulkan_KHR_get_display_properties2::new(instance, &mut get_proc_address),
			vk_khr_dedicated_allocation: Vulkan_KHR_dedicated_allocation::new(instance, &mut get_proc_address),
			vk_khr_storage_buffer_storage_class: Vulkan_KHR_storage_buffer_storage_class::new(instance, &mut get_proc_address),
			vk_khr_shader_bfloat16: Vulkan_KHR_shader_bfloat16::new(instance, &mut get_proc_address),
			vk_khr_relaxed_block_layout: Vulkan_KHR_relaxed_block_layout::new(instance, &mut get_proc_address),
			vk_khr_get_memory_requirements2: Vulkan_KHR_get_memory_requirements2::new(instance, &mut get_proc_address),
			vk_khr_image_format_list: Vulkan_KHR_image_format_list::new(instance, &mut get_proc_address),
			vk_khr_sampler_ycbcr_conversion: Vulkan_KHR_sampler_ycbcr_conversion::new(instance, &mut get_proc_address),
			vk_khr_bind_memory2: Vulkan_KHR_bind_memory2::new(instance, &mut get_proc_address),
			vk_khr_maintenance3: Vulkan_KHR_maintenance3::new(instance, &mut get_proc_address),
			vk_khr_draw_indirect_count: Vulkan_KHR_draw_indirect_count::new(instance, &mut get_proc_address),
			vk_khr_shader_subgroup_extended_types: Vulkan_KHR_shader_subgroup_extended_types::new(instance, &mut get_proc_address),
			vk_khr_8bit_storage: Vulkan_KHR_8bit_storage::new(instance, &mut get_proc_address),
			vk_khr_shader_atomic_int64: Vulkan_KHR_shader_atomic_int64::new(instance, &mut get_proc_address),
			vk_khr_shader_clock: Vulkan_KHR_shader_clock::new(instance, &mut get_proc_address),
			vk_khr_video_decode_h265: Vulkan_KHR_video_decode_h265::new(instance, &mut get_proc_address),
			vulkan_video_codec_h265std_decode: Vulkan_video_codec_h265std_decode::new(instance, &mut get_proc_address),
			vk_khr_global_priority: Vulkan_KHR_global_priority::new(instance, &mut get_proc_address),
			vk_khr_driver_properties: Vulkan_KHR_driver_properties::new(instance, &mut get_proc_address),
			vk_khr_shader_float_controls: Vulkan_KHR_shader_float_controls::new(instance, &mut get_proc_address),
			vk_khr_depth_stencil_resolve: Vulkan_KHR_depth_stencil_resolve::new(instance, &mut get_proc_address),
			vk_khr_swapchain_mutable_format: Vulkan_KHR_swapchain_mutable_format::new(instance, &mut get_proc_address),
			vk_khr_timeline_semaphore: Vulkan_KHR_timeline_semaphore::new(instance, &mut get_proc_address),
			vk_khr_vulkan_memory_model: Vulkan_KHR_vulkan_memory_model::new(instance, &mut get_proc_address),
			vk_khr_shader_terminate_invocation: Vulkan_KHR_shader_terminate_invocation::new(instance, &mut get_proc_address),
			vk_khr_fragment_shading_rate: Vulkan_KHR_fragment_shading_rate::new(instance, &mut get_proc_address),
			vk_khr_dynamic_rendering_local_read: Vulkan_KHR_dynamic_rendering_local_read::new(instance, &mut get_proc_address),
			vk_khr_shader_quad_control: Vulkan_KHR_shader_quad_control::new(instance, &mut get_proc_address),
			vk_khr_spirv_1_4: Vulkan_KHR_spirv_1_4::new(instance, &mut get_proc_address),
			vk_khr_surface_protected_capabilities: Vulkan_KHR_surface_protected_capabilities::new(instance, &mut get_proc_address),
			vk_khr_separate_depth_stencil_layouts: Vulkan_KHR_separate_depth_stencil_layouts::new(instance, &mut get_proc_address),
			vk_khr_present_wait: Vulkan_KHR_present_wait::new(instance, &mut get_proc_address),
			vk_khr_uniform_buffer_standard_layout: Vulkan_KHR_uniform_buffer_standard_layout::new(instance, &mut get_proc_address),
			vk_khr_buffer_device_address: Vulkan_KHR_buffer_device_address::new(instance, &mut get_proc_address),
			vk_khr_deferred_host_operations: Vulkan_KHR_deferred_host_operations::new(instance, &mut get_proc_address),
			vk_khr_pipeline_executable_properties: Vulkan_KHR_pipeline_executable_properties::new(instance, &mut get_proc_address),
			vk_khr_map_memory2: Vulkan_KHR_map_memory2::new(instance, &mut get_proc_address),
			vk_khr_shader_integer_dot_product: Vulkan_KHR_shader_integer_dot_product::new(instance, &mut get_proc_address),
			vk_khr_pipeline_library: Vulkan_KHR_pipeline_library::new(instance, &mut get_proc_address),
			vk_khr_shader_non_semantic_info: Vulkan_KHR_shader_non_semantic_info::new(instance, &mut get_proc_address),
			vk_khr_present_id: Vulkan_KHR_present_id::new(instance, &mut get_proc_address),
			vk_khr_video_encode_queue: Vulkan_KHR_video_encode_queue::new(instance, &mut get_proc_address),
			vk_khr_synchronization2: Vulkan_KHR_synchronization2::new(instance, &mut get_proc_address),
			vk_khr_fragment_shader_barycentric: Vulkan_KHR_fragment_shader_barycentric::new(instance, &mut get_proc_address),
			vk_khr_shader_subgroup_uniform_control_flow: Vulkan_KHR_shader_subgroup_uniform_control_flow::new(instance, &mut get_proc_address),
			vk_khr_zero_initialize_workgroup_memory: Vulkan_KHR_zero_initialize_workgroup_memory::new(instance, &mut get_proc_address),
			vk_khr_workgroup_memory_explicit_layout: Vulkan_KHR_workgroup_memory_explicit_layout::new(instance, &mut get_proc_address),
			vk_khr_copy_commands2: Vulkan_KHR_copy_commands2::new(instance, &mut get_proc_address),
			vk_khr_format_feature_flags2: Vulkan_KHR_format_feature_flags2::new(instance, &mut get_proc_address),
			vk_khr_ray_tracing_maintenance1: Vulkan_KHR_ray_tracing_maintenance1::new(instance, &mut get_proc_address),
			vk_khr_portability_enumeration: Vulkan_KHR_portability_enumeration::new(instance, &mut get_proc_address),
			vk_khr_maintenance4: Vulkan_KHR_maintenance4::new(instance, &mut get_proc_address),
			vk_khr_shader_subgroup_rotate: Vulkan_KHR_shader_subgroup_rotate::new(instance, &mut get_proc_address),
			vk_khr_shader_maximal_reconvergence: Vulkan_KHR_shader_maximal_reconvergence::new(instance, &mut get_proc_address),
			vk_khr_maintenance5: Vulkan_KHR_maintenance5::new(instance, &mut get_proc_address),
			vk_khr_present_id2: Vulkan_KHR_present_id2::new(instance, &mut get_proc_address),
			vk_khr_present_wait2: Vulkan_KHR_present_wait2::new(instance, &mut get_proc_address),
			vk_khr_ray_tracing_position_fetch: Vulkan_KHR_ray_tracing_position_fetch::new(instance, &mut get_proc_address),
			vk_khr_pipeline_binary: Vulkan_KHR_pipeline_binary::new(instance, &mut get_proc_address),
			vk_khr_surface_maintenance1: Vulkan_KHR_surface_maintenance1::new(instance, &mut get_proc_address),
			vk_khr_swapchain_maintenance1: Vulkan_KHR_swapchain_maintenance1::new(instance, &mut get_proc_address),
			vk_khr_cooperative_matrix: Vulkan_KHR_cooperative_matrix::new(instance, &mut get_proc_address),
			vk_khr_compute_shader_derivatives: Vulkan_KHR_compute_shader_derivatives::new(instance, &mut get_proc_address),
			vk_khr_video_decode_av1: Vulkan_KHR_video_decode_av1::new(instance, &mut get_proc_address),
			vulkan_video_codec_av1std: Vulkan_video_codec_av1std::new(instance, &mut get_proc_address),
			vulkan_video_codec_av1std_decode: Vulkan_video_codec_av1std_decode::new(instance, &mut get_proc_address),
			vk_khr_video_encode_av1: Vulkan_KHR_video_encode_av1::new(instance, &mut get_proc_address),
			vulkan_video_codec_av1std_encode: Vulkan_video_codec_av1std_encode::new(instance, &mut get_proc_address),
			vk_khr_video_decode_vp9: Vulkan_KHR_video_decode_vp9::new(instance, &mut get_proc_address),
			vulkan_video_codec_vp9std: Vulkan_video_codec_vp9std::new(instance, &mut get_proc_address),
			vulkan_video_codec_vp9std_decode: Vulkan_video_codec_vp9std_decode::new(instance, &mut get_proc_address),
			vk_khr_video_maintenance1: Vulkan_KHR_video_maintenance1::new(instance, &mut get_proc_address),
			vk_khr_vertex_attribute_divisor: Vulkan_KHR_vertex_attribute_divisor::new(instance, &mut get_proc_address),
			vk_khr_load_store_op_none: Vulkan_KHR_load_store_op_none::new(instance, &mut get_proc_address),
			vk_khr_unified_image_layouts: Vulkan_KHR_unified_image_layouts::new(instance, &mut get_proc_address),
			vk_khr_shader_float_controls2: Vulkan_KHR_shader_float_controls2::new(instance, &mut get_proc_address),
			vk_khr_index_type_uint8: Vulkan_KHR_index_type_uint8::new(instance, &mut get_proc_address),
			vk_khr_line_rasterization: Vulkan_KHR_line_rasterization::new(instance, &mut get_proc_address),
			vk_khr_calibrated_timestamps: Vulkan_KHR_calibrated_timestamps::new(instance, &mut get_proc_address),
			vk_khr_shader_expect_assume: Vulkan_KHR_shader_expect_assume::new(instance, &mut get_proc_address),
			vk_khr_maintenance6: Vulkan_KHR_maintenance6::new(instance, &mut get_proc_address),
			vk_khr_video_encode_intra_refresh: Vulkan_KHR_video_encode_intra_refresh::new(instance, &mut get_proc_address),
			vk_khr_video_encode_quantization_map: Vulkan_KHR_video_encode_quantization_map::new(instance, &mut get_proc_address),
			vk_khr_shader_relaxed_extended_instruction: Vulkan_KHR_shader_relaxed_extended_instruction::new(instance, &mut get_proc_address),
			vk_khr_maintenance7: Vulkan_KHR_maintenance7::new(instance, &mut get_proc_address),
			vk_khr_maintenance8: Vulkan_KHR_maintenance8::new(instance, &mut get_proc_address),
			vk_khr_maintenance9: Vulkan_KHR_maintenance9::new(instance, &mut get_proc_address),
			vk_khr_video_maintenance2: Vulkan_KHR_video_maintenance2::new(instance, &mut get_proc_address),
			vk_khr_depth_clamp_zero_one: Vulkan_KHR_depth_clamp_zero_one::new(instance, &mut get_proc_address),
			vk_khr_robustness2: Vulkan_KHR_robustness2::new(instance, &mut get_proc_address),
			vk_khr_present_mode_fifo_latest_ready: Vulkan_KHR_present_mode_fifo_latest_ready::new(instance, &mut get_proc_address),
			vk_ext_debug_report: Vulkan_EXT_debug_report::new(instance, &mut get_proc_address),
			vk_nv_glsl_shader: Vulkan_NV_glsl_shader::new(instance, &mut get_proc_address),
			vk_ext_depth_range_unrestricted: Vulkan_EXT_depth_range_unrestricted::new(instance, &mut get_proc_address),
			vk_img_filter_cubic: Vulkan_IMG_filter_cubic::new(instance, &mut get_proc_address),
			vk_amd_rasterization_order: Vulkan_AMD_rasterization_order::new(instance, &mut get_proc_address),
			vk_amd_shader_trinary_minmax: Vulkan_AMD_shader_trinary_minmax::new(instance, &mut get_proc_address),
			vk_amd_shader_explicit_vertex_parameter: Vulkan_AMD_shader_explicit_vertex_parameter::new(instance, &mut get_proc_address),
			vk_ext_debug_marker: Vulkan_EXT_debug_marker::new(instance, &mut get_proc_address),
			vk_amd_gcn_shader: Vulkan_AMD_gcn_shader::new(instance, &mut get_proc_address),
			vk_nv_dedicated_allocation: Vulkan_NV_dedicated_allocation::new(instance, &mut get_proc_address),
			vk_ext_transform_feedback: Vulkan_EXT_transform_feedback::new(instance, &mut get_proc_address),
			vk_nvx_binary_import: Vulkan_NVX_binary_import::new(instance, &mut get_proc_address),
			vk_nvx_image_view_handle: Vulkan_NVX_image_view_handle::new(instance, &mut get_proc_address),
			vk_amd_draw_indirect_count: Vulkan_AMD_draw_indirect_count::new(instance, &mut get_proc_address),
			vk_amd_negative_viewport_height: Vulkan_AMD_negative_viewport_height::new(instance, &mut get_proc_address),
			vk_amd_gpu_shader_half_float: Vulkan_AMD_gpu_shader_half_float::new(instance, &mut get_proc_address),
			vk_amd_shader_ballot: Vulkan_AMD_shader_ballot::new(instance, &mut get_proc_address),
			vk_amd_texture_gather_bias_lod: Vulkan_AMD_texture_gather_bias_lod::new(instance, &mut get_proc_address),
			vk_amd_shader_info: Vulkan_AMD_shader_info::new(instance, &mut get_proc_address),
			vk_amd_shader_image_load_store_lod: Vulkan_AMD_shader_image_load_store_lod::new(instance, &mut get_proc_address),
			vk_nv_corner_sampled_image: Vulkan_NV_corner_sampled_image::new(instance, &mut get_proc_address),
			vk_img_format_pvrtc: Vulkan_IMG_format_pvrtc::new(instance, &mut get_proc_address),
			vk_nv_external_memory_capabilities: Vulkan_NV_external_memory_capabilities::new(instance, &mut get_proc_address),
			vk_nv_external_memory: Vulkan_NV_external_memory::new(instance, &mut get_proc_address),
			vk_ext_validation_flags: Vulkan_EXT_validation_flags::new(instance, &mut get_proc_address),
			vk_ext_shader_subgroup_ballot: Vulkan_EXT_shader_subgroup_ballot::new(instance, &mut get_proc_address),
			vk_ext_shader_subgroup_vote: Vulkan_EXT_shader_subgroup_vote::new(instance, &mut get_proc_address),
			vk_ext_texture_compression_astc_hdr: Vulkan_EXT_texture_compression_astc_hdr::new(instance, &mut get_proc_address),
			vk_ext_astc_decode_mode: Vulkan_EXT_astc_decode_mode::new(instance, &mut get_proc_address),
			vk_ext_pipeline_robustness: Vulkan_EXT_pipeline_robustness::new(instance, &mut get_proc_address),
			vk_ext_conditional_rendering: Vulkan_EXT_conditional_rendering::new(instance, &mut get_proc_address),
			vk_nv_clip_space_w_scaling: Vulkan_NV_clip_space_w_scaling::new(instance, &mut get_proc_address),
			vk_ext_direct_mode_display: Vulkan_EXT_direct_mode_display::new(instance, &mut get_proc_address),
			vk_ext_display_surface_counter: Vulkan_EXT_display_surface_counter::new(instance, &mut get_proc_address),
			vk_ext_display_control: Vulkan_EXT_display_control::new(instance, &mut get_proc_address),
			vk_google_display_timing: Vulkan_GOOGLE_display_timing::new(instance, &mut get_proc_address),
			vk_nv_sample_mask_override_coverage: Vulkan_NV_sample_mask_override_coverage::new(instance, &mut get_proc_address),
			vk_nv_geometry_shader_passthrough: Vulkan_NV_geometry_shader_passthrough::new(instance, &mut get_proc_address),
			vk_nv_viewport_array2: Vulkan_NV_viewport_array2::new(instance, &mut get_proc_address),
			vk_nvx_multiview_per_view_attributes: Vulkan_NVX_multiview_per_view_attributes::new(instance, &mut get_proc_address),
			vk_nv_viewport_swizzle: Vulkan_NV_viewport_swizzle::new(instance, &mut get_proc_address),
			vk_ext_discard_rectangles: Vulkan_EXT_discard_rectangles::new(instance, &mut get_proc_address),
			vk_ext_conservative_rasterization: Vulkan_EXT_conservative_rasterization::new(instance, &mut get_proc_address),
			vk_ext_depth_clip_enable: Vulkan_EXT_depth_clip_enable::new(instance, &mut get_proc_address),
			vk_ext_swapchain_colorspace: Vulkan_EXT_swapchain_colorspace::new(instance, &mut get_proc_address),
			vk_ext_hdr_metadata: Vulkan_EXT_hdr_metadata::new(instance, &mut get_proc_address),
			vk_img_relaxed_line_rasterization: Vulkan_IMG_relaxed_line_rasterization::new(instance, &mut get_proc_address),
			vk_ext_external_memory_dma_buf: Vulkan_EXT_external_memory_dma_buf::new(instance, &mut get_proc_address),
			vk_ext_queue_family_foreign: Vulkan_EXT_queue_family_foreign::new(instance, &mut get_proc_address),
			vk_ext_debug_utils: Vulkan_EXT_debug_utils::new(instance, &mut get_proc_address),
			vk_ext_sampler_filter_minmax: Vulkan_EXT_sampler_filter_minmax::new(instance, &mut get_proc_address),
			vk_amd_gpu_shader_int16: Vulkan_AMD_gpu_shader_int16::new(instance, &mut get_proc_address),
			vk_amd_mixed_attachment_samples: Vulkan_AMD_mixed_attachment_samples::new(instance, &mut get_proc_address),
			vk_amd_shader_fragment_mask: Vulkan_AMD_shader_fragment_mask::new(instance, &mut get_proc_address),
			vk_ext_inline_uniform_block: Vulkan_EXT_inline_uniform_block::new(instance, &mut get_proc_address),
			vk_ext_shader_stencil_export: Vulkan_EXT_shader_stencil_export::new(instance, &mut get_proc_address),
			vk_ext_sample_locations: Vulkan_EXT_sample_locations::new(instance, &mut get_proc_address),
			vk_ext_blend_operation_advanced: Vulkan_EXT_blend_operation_advanced::new(instance, &mut get_proc_address),
			vk_nv_fragment_coverage_to_color: Vulkan_NV_fragment_coverage_to_color::new(instance, &mut get_proc_address),
			vk_nv_framebuffer_mixed_samples: Vulkan_NV_framebuffer_mixed_samples::new(instance, &mut get_proc_address),
			vk_nv_fill_rectangle: Vulkan_NV_fill_rectangle::new(instance, &mut get_proc_address),
			vk_nv_shader_sm_builtins: Vulkan_NV_shader_sm_builtins::new(instance, &mut get_proc_address),
			vk_ext_post_depth_coverage: Vulkan_EXT_post_depth_coverage::new(instance, &mut get_proc_address),
			vk_ext_image_drm_format_modifier: Vulkan_EXT_image_drm_format_modifier::new(instance, &mut get_proc_address),
			vk_ext_validation_cache: Vulkan_EXT_validation_cache::new(instance, &mut get_proc_address),
			vk_ext_descriptor_indexing: Vulkan_EXT_descriptor_indexing::new(instance, &mut get_proc_address),
			vk_ext_shader_viewport_index_layer: Vulkan_EXT_shader_viewport_index_layer::new(instance, &mut get_proc_address),
			vk_nv_shading_rate_image: Vulkan_NV_shading_rate_image::new(instance, &mut get_proc_address),
			vk_nv_ray_tracing: Vulkan_NV_ray_tracing::new(instance, &mut get_proc_address),
			vk_nv_representative_fragment_test: Vulkan_NV_representative_fragment_test::new(instance, &mut get_proc_address),
			vk_ext_filter_cubic: Vulkan_EXT_filter_cubic::new(instance, &mut get_proc_address),
			vk_qcom_render_pass_shader_resolve: Vulkan_QCOM_render_pass_shader_resolve::new(instance, &mut get_proc_address),
			vk_ext_global_priority: Vulkan_EXT_global_priority::new(instance, &mut get_proc_address),
			vk_ext_external_memory_host: Vulkan_EXT_external_memory_host::new(instance, &mut get_proc_address),
			vk_amd_buffer_marker: Vulkan_AMD_buffer_marker::new(instance, &mut get_proc_address),
			vk_amd_pipeline_compiler_control: Vulkan_AMD_pipeline_compiler_control::new(instance, &mut get_proc_address),
			vk_ext_calibrated_timestamps: Vulkan_EXT_calibrated_timestamps::new(instance, &mut get_proc_address),
			vk_amd_shader_core_properties: Vulkan_AMD_shader_core_properties::new(instance, &mut get_proc_address),
			vk_amd_memory_overallocation_behavior: Vulkan_AMD_memory_overallocation_behavior::new(instance, &mut get_proc_address),
			vk_ext_vertex_attribute_divisor: Vulkan_EXT_vertex_attribute_divisor::new(instance, &mut get_proc_address),
			vk_ext_pipeline_creation_feedback: Vulkan_EXT_pipeline_creation_feedback::new(instance, &mut get_proc_address),
			vk_nv_shader_subgroup_partitioned: Vulkan_NV_shader_subgroup_partitioned::new(instance, &mut get_proc_address),
			vk_nv_compute_shader_derivatives: Vulkan_NV_compute_shader_derivatives::new(instance, &mut get_proc_address),
			vk_nv_mesh_shader: Vulkan_NV_mesh_shader::new(instance, &mut get_proc_address),
			vk_nv_fragment_shader_barycentric: Vulkan_NV_fragment_shader_barycentric::new(instance, &mut get_proc_address),
			vk_nv_shader_image_footprint: Vulkan_NV_shader_image_footprint::new(instance, &mut get_proc_address),
			vk_nv_scissor_exclusive: Vulkan_NV_scissor_exclusive::new(instance, &mut get_proc_address),
			vk_nv_device_diagnostic_checkpoints: Vulkan_NV_device_diagnostic_checkpoints::new(instance, &mut get_proc_address),
			vk_intel_shader_integer_functions2: Vulkan_INTEL_shader_integer_functions2::new(instance, &mut get_proc_address),
			vk_intel_performance_query: Vulkan_INTEL_performance_query::new(instance, &mut get_proc_address),
			vk_ext_pci_bus_info: Vulkan_EXT_pci_bus_info::new(instance, &mut get_proc_address),
			vk_amd_display_native_hdr: Vulkan_AMD_display_native_hdr::new(instance, &mut get_proc_address),
			vk_ext_fragment_density_map: Vulkan_EXT_fragment_density_map::new(instance, &mut get_proc_address),
			vk_ext_scalar_block_layout: Vulkan_EXT_scalar_block_layout::new(instance, &mut get_proc_address),
			vk_google_hlsl_functionality1: Vulkan_GOOGLE_hlsl_functionality1::new(instance, &mut get_proc_address),
			vk_google_decorate_string: Vulkan_GOOGLE_decorate_string::new(instance, &mut get_proc_address),
			vk_ext_subgroup_size_control: Vulkan_EXT_subgroup_size_control::new(instance, &mut get_proc_address),
			vk_amd_shader_core_properties2: Vulkan_AMD_shader_core_properties2::new(instance, &mut get_proc_address),
			vk_amd_device_coherent_memory: Vulkan_AMD_device_coherent_memory::new(instance, &mut get_proc_address),
			vk_ext_shader_image_atomic_int64: Vulkan_EXT_shader_image_atomic_int64::new(instance, &mut get_proc_address),
			vk_ext_memory_budget: Vulkan_EXT_memory_budget::new(instance, &mut get_proc_address),
			vk_ext_memory_priority: Vulkan_EXT_memory_priority::new(instance, &mut get_proc_address),
			vk_nv_dedicated_allocation_image_aliasing: Vulkan_NV_dedicated_allocation_image_aliasing::new(instance, &mut get_proc_address),
			vk_ext_buffer_device_address: Vulkan_EXT_buffer_device_address::new(instance, &mut get_proc_address),
			vk_ext_tooling_info: Vulkan_EXT_tooling_info::new(instance, &mut get_proc_address),
			vk_ext_separate_stencil_usage: Vulkan_EXT_separate_stencil_usage::new(instance, &mut get_proc_address),
			vk_ext_validation_features: Vulkan_EXT_validation_features::new(instance, &mut get_proc_address),
			vk_nv_cooperative_matrix: Vulkan_NV_cooperative_matrix::new(instance, &mut get_proc_address),
			vk_nv_coverage_reduction_mode: Vulkan_NV_coverage_reduction_mode::new(instance, &mut get_proc_address),
			vk_ext_fragment_shader_interlock: Vulkan_EXT_fragment_shader_interlock::new(instance, &mut get_proc_address),
			vk_ext_ycbcr_image_arrays: Vulkan_EXT_ycbcr_image_arrays::new(instance, &mut get_proc_address),
			vk_ext_provoking_vertex: Vulkan_EXT_provoking_vertex::new(instance, &mut get_proc_address),
			vk_ext_headless_surface: Vulkan_EXT_headless_surface::new(instance, &mut get_proc_address),
			vk_ext_line_rasterization: Vulkan_EXT_line_rasterization::new(instance, &mut get_proc_address),
			vk_ext_shader_atomic_float: Vulkan_EXT_shader_atomic_float::new(instance, &mut get_proc_address),
			vk_ext_host_query_reset: Vulkan_EXT_host_query_reset::new(instance, &mut get_proc_address),
			vk_ext_index_type_uint8: Vulkan_EXT_index_type_uint8::new(instance, &mut get_proc_address),
			vk_ext_extended_dynamic_state: Vulkan_EXT_extended_dynamic_state::new(instance, &mut get_proc_address),
			vk_ext_host_image_copy: Vulkan_EXT_host_image_copy::new(instance, &mut get_proc_address),
			vk_ext_map_memory_placed: Vulkan_EXT_map_memory_placed::new(instance, &mut get_proc_address),
			vk_ext_shader_atomic_float2: Vulkan_EXT_shader_atomic_float2::new(instance, &mut get_proc_address),
			vk_ext_surface_maintenance1: Vulkan_EXT_surface_maintenance1::new(instance, &mut get_proc_address),
			vk_ext_swapchain_maintenance1: Vulkan_EXT_swapchain_maintenance1::new(instance, &mut get_proc_address),
			vk_ext_shader_demote_to_helper_invocation: Vulkan_EXT_shader_demote_to_helper_invocation::new(instance, &mut get_proc_address),
			vk_nv_device_generated_commands: Vulkan_NV_device_generated_commands::new(instance, &mut get_proc_address),
			vk_nv_inherited_viewport_scissor: Vulkan_NV_inherited_viewport_scissor::new(instance, &mut get_proc_address),
			vk_ext_texel_buffer_alignment: Vulkan_EXT_texel_buffer_alignment::new(instance, &mut get_proc_address),
			vk_qcom_render_pass_transform: Vulkan_QCOM_render_pass_transform::new(instance, &mut get_proc_address),
			vk_ext_depth_bias_control: Vulkan_EXT_depth_bias_control::new(instance, &mut get_proc_address),
			vk_ext_device_memory_report: Vulkan_EXT_device_memory_report::new(instance, &mut get_proc_address),
			vk_ext_acquire_drm_display: Vulkan_EXT_acquire_drm_display::new(instance, &mut get_proc_address),
			vk_ext_robustness2: Vulkan_EXT_robustness2::new(instance, &mut get_proc_address),
			vk_ext_custom_border_color: Vulkan_EXT_custom_border_color::new(instance, &mut get_proc_address),
			vk_google_user_type: Vulkan_GOOGLE_user_type::new(instance, &mut get_proc_address),
			vk_nv_present_barrier: Vulkan_NV_present_barrier::new(instance, &mut get_proc_address),
			vk_ext_private_data: Vulkan_EXT_private_data::new(instance, &mut get_proc_address),
			vk_ext_pipeline_creation_cache_control: Vulkan_EXT_pipeline_creation_cache_control::new(instance, &mut get_proc_address),
			vk_nv_device_diagnostics_config: Vulkan_NV_device_diagnostics_config::new(instance, &mut get_proc_address),
			vk_qcom_render_pass_store_ops: Vulkan_QCOM_render_pass_store_ops::new(instance, &mut get_proc_address),
			vk_qcom_tile_shading: Vulkan_QCOM_tile_shading::new(instance, &mut get_proc_address),
			vk_nv_low_latency: Vulkan_NV_low_latency::new(instance, &mut get_proc_address),
			vk_ext_descriptor_buffer: Vulkan_EXT_descriptor_buffer::new(instance, &mut get_proc_address),
			vk_ext_graphics_pipeline_library: Vulkan_EXT_graphics_pipeline_library::new(instance, &mut get_proc_address),
			vk_amd_shader_early_and_late_fragment_tests: Vulkan_AMD_shader_early_and_late_fragment_tests::new(instance, &mut get_proc_address),
			vk_nv_fragment_shading_rate_enums: Vulkan_NV_fragment_shading_rate_enums::new(instance, &mut get_proc_address),
			vk_nv_ray_tracing_motion_blur: Vulkan_NV_ray_tracing_motion_blur::new(instance, &mut get_proc_address),
			vk_ext_ycbcr_2plane_444_formats: Vulkan_EXT_ycbcr_2plane_444_formats::new(instance, &mut get_proc_address),
			vk_ext_fragment_density_map2: Vulkan_EXT_fragment_density_map2::new(instance, &mut get_proc_address),
			vk_qcom_rotated_copy_commands: Vulkan_QCOM_rotated_copy_commands::new(instance, &mut get_proc_address),
			vk_ext_image_robustness: Vulkan_EXT_image_robustness::new(instance, &mut get_proc_address),
			vk_ext_image_compression_control: Vulkan_EXT_image_compression_control::new(instance, &mut get_proc_address),
			vk_ext_attachment_feedback_loop_layout: Vulkan_EXT_attachment_feedback_loop_layout::new(instance, &mut get_proc_address),
			vk_ext_4444_formats: Vulkan_EXT_4444_formats::new(instance, &mut get_proc_address),
			vk_ext_device_fault: Vulkan_EXT_device_fault::new(instance, &mut get_proc_address),
			vk_arm_rasterization_order_attachment_access: Vulkan_ARM_rasterization_order_attachment_access::new(instance, &mut get_proc_address),
			vk_ext_rgba10x6_formats: Vulkan_EXT_rgba10x6_formats::new(instance, &mut get_proc_address),
			vk_valve_mutable_descriptor_type: Vulkan_VALVE_mutable_descriptor_type::new(instance, &mut get_proc_address),
			vk_ext_vertex_input_dynamic_state: Vulkan_EXT_vertex_input_dynamic_state::new(instance, &mut get_proc_address),
			vk_ext_physical_device_drm: Vulkan_EXT_physical_device_drm::new(instance, &mut get_proc_address),
			vk_ext_device_address_binding_report: Vulkan_EXT_device_address_binding_report::new(instance, &mut get_proc_address),
			vk_ext_depth_clip_control: Vulkan_EXT_depth_clip_control::new(instance, &mut get_proc_address),
			vk_ext_primitive_topology_list_restart: Vulkan_EXT_primitive_topology_list_restart::new(instance, &mut get_proc_address),
			vk_ext_present_mode_fifo_latest_ready: Vulkan_EXT_present_mode_fifo_latest_ready::new(instance, &mut get_proc_address),
			vk_huawei_subpass_shading: Vulkan_HUAWEI_subpass_shading::new(instance, &mut get_proc_address),
			vk_huawei_invocation_mask: Vulkan_HUAWEI_invocation_mask::new(instance, &mut get_proc_address),
			vk_nv_external_memory_rdma: Vulkan_NV_external_memory_rdma::new(instance, &mut get_proc_address),
			vk_ext_pipeline_properties: Vulkan_EXT_pipeline_properties::new(instance, &mut get_proc_address),
			vk_ext_frame_boundary: Vulkan_EXT_frame_boundary::new(instance, &mut get_proc_address),
			vk_ext_multisampled_render_to_single_sampled: Vulkan_EXT_multisampled_render_to_single_sampled::new(instance, &mut get_proc_address),
			vk_ext_extended_dynamic_state2: Vulkan_EXT_extended_dynamic_state2::new(instance, &mut get_proc_address),
			vk_ext_color_write_enable: Vulkan_EXT_color_write_enable::new(instance, &mut get_proc_address),
			vk_ext_primitives_generated_query: Vulkan_EXT_primitives_generated_query::new(instance, &mut get_proc_address),
			vk_ext_global_priority_query: Vulkan_EXT_global_priority_query::new(instance, &mut get_proc_address),
			vk_ext_image_view_min_lod: Vulkan_EXT_image_view_min_lod::new(instance, &mut get_proc_address),
			vk_ext_multi_draw: Vulkan_EXT_multi_draw::new(instance, &mut get_proc_address),
			vk_ext_image_2d_view_of_3d: Vulkan_EXT_image_2d_view_of_3d::new(instance, &mut get_proc_address),
			vk_ext_shader_tile_image: Vulkan_EXT_shader_tile_image::new(instance, &mut get_proc_address),
			vk_ext_opacity_micromap: Vulkan_EXT_opacity_micromap::new(instance, &mut get_proc_address),
			vk_ext_load_store_op_none: Vulkan_EXT_load_store_op_none::new(instance, &mut get_proc_address),
			vk_huawei_cluster_culling_shader: Vulkan_HUAWEI_cluster_culling_shader::new(instance, &mut get_proc_address),
			vk_ext_border_color_swizzle: Vulkan_EXT_border_color_swizzle::new(instance, &mut get_proc_address),
			vk_ext_pageable_device_local_memory: Vulkan_EXT_pageable_device_local_memory::new(instance, &mut get_proc_address),
			vk_arm_shader_core_properties: Vulkan_ARM_shader_core_properties::new(instance, &mut get_proc_address),
			vk_arm_scheduling_controls: Vulkan_ARM_scheduling_controls::new(instance, &mut get_proc_address),
			vk_ext_image_sliced_view_of_3d: Vulkan_EXT_image_sliced_view_of_3d::new(instance, &mut get_proc_address),
			vk_valve_descriptor_set_host_mapping: Vulkan_VALVE_descriptor_set_host_mapping::new(instance, &mut get_proc_address),
			vk_ext_depth_clamp_zero_one: Vulkan_EXT_depth_clamp_zero_one::new(instance, &mut get_proc_address),
			vk_ext_non_seamless_cube_map: Vulkan_EXT_non_seamless_cube_map::new(instance, &mut get_proc_address),
			vk_arm_render_pass_striped: Vulkan_ARM_render_pass_striped::new(instance, &mut get_proc_address),
			vk_qcom_fragment_density_map_offset: Vulkan_QCOM_fragment_density_map_offset::new(instance, &mut get_proc_address),
			vk_nv_copy_memory_indirect: Vulkan_NV_copy_memory_indirect::new(instance, &mut get_proc_address),
			vk_nv_memory_decompression: Vulkan_NV_memory_decompression::new(instance, &mut get_proc_address),
			vk_nv_device_generated_commands_compute: Vulkan_NV_device_generated_commands_compute::new(instance, &mut get_proc_address),
			vk_nv_ray_tracing_linear_swept_spheres: Vulkan_NV_ray_tracing_linear_swept_spheres::new(instance, &mut get_proc_address),
			vk_nv_linear_color_attachment: Vulkan_NV_linear_color_attachment::new(instance, &mut get_proc_address),
			vk_google_surfaceless_query: Vulkan_GOOGLE_surfaceless_query::new(instance, &mut get_proc_address),
			vk_ext_image_compression_control_swapchain: Vulkan_EXT_image_compression_control_swapchain::new(instance, &mut get_proc_address),
			vk_qcom_image_processing: Vulkan_QCOM_image_processing::new(instance, &mut get_proc_address),
			vk_ext_nested_command_buffer: Vulkan_EXT_nested_command_buffer::new(instance, &mut get_proc_address),
			vk_ext_external_memory_acquire_unmodified: Vulkan_EXT_external_memory_acquire_unmodified::new(instance, &mut get_proc_address),
			vk_ext_extended_dynamic_state3: Vulkan_EXT_extended_dynamic_state3::new(instance, &mut get_proc_address),
			vk_ext_subpass_merge_feedback: Vulkan_EXT_subpass_merge_feedback::new(instance, &mut get_proc_address),
			vk_lunarg_direct_driver_loading: Vulkan_LUNARG_direct_driver_loading::new(instance, &mut get_proc_address),
			vk_arm_tensors: Vulkan_ARM_tensors::new(instance, &mut get_proc_address),
			vk_ext_shader_module_identifier: Vulkan_EXT_shader_module_identifier::new(instance, &mut get_proc_address),
			vk_ext_rasterization_order_attachment_access: Vulkan_EXT_rasterization_order_attachment_access::new(instance, &mut get_proc_address),
			vk_nv_optical_flow: Vulkan_NV_optical_flow::new(instance, &mut get_proc_address),
			vk_ext_legacy_dithering: Vulkan_EXT_legacy_dithering::new(instance, &mut get_proc_address),
			vk_ext_pipeline_protected_access: Vulkan_EXT_pipeline_protected_access::new(instance, &mut get_proc_address),
			vk_amd_anti_lag: Vulkan_AMD_anti_lag::new(instance, &mut get_proc_address),
			vk_ext_shader_object: Vulkan_EXT_shader_object::new(instance, &mut get_proc_address),
			vk_qcom_tile_properties: Vulkan_QCOM_tile_properties::new(instance, &mut get_proc_address),
			vk_sec_amigo_profiling: Vulkan_SEC_amigo_profiling::new(instance, &mut get_proc_address),
			vk_qcom_multiview_per_view_viewports: Vulkan_QCOM_multiview_per_view_viewports::new(instance, &mut get_proc_address),
			vk_nv_ray_tracing_invocation_reorder: Vulkan_NV_ray_tracing_invocation_reorder::new(instance, &mut get_proc_address),
			vk_nv_cooperative_vector: Vulkan_NV_cooperative_vector::new(instance, &mut get_proc_address),
			vk_nv_extended_sparse_address_space: Vulkan_NV_extended_sparse_address_space::new(instance, &mut get_proc_address),
			vk_ext_mutable_descriptor_type: Vulkan_EXT_mutable_descriptor_type::new(instance, &mut get_proc_address),
			vk_ext_legacy_vertex_attributes: Vulkan_EXT_legacy_vertex_attributes::new(instance, &mut get_proc_address),
			vk_ext_layer_settings: Vulkan_EXT_layer_settings::new(instance, &mut get_proc_address),
			vk_arm_shader_core_builtins: Vulkan_ARM_shader_core_builtins::new(instance, &mut get_proc_address),
			vk_ext_pipeline_library_group_handles: Vulkan_EXT_pipeline_library_group_handles::new(instance, &mut get_proc_address),
			vk_ext_dynamic_rendering_unused_attachments: Vulkan_EXT_dynamic_rendering_unused_attachments::new(instance, &mut get_proc_address),
			vk_nv_low_latency2: Vulkan_NV_low_latency2::new(instance, &mut get_proc_address),
			vk_arm_data_graph: Vulkan_ARM_data_graph::new(instance, &mut get_proc_address),
			vk_qcom_multiview_per_view_render_areas: Vulkan_QCOM_multiview_per_view_render_areas::new(instance, &mut get_proc_address),
			vk_nv_per_stage_descriptor_set: Vulkan_NV_per_stage_descriptor_set::new(instance, &mut get_proc_address),
			vk_qcom_image_processing2: Vulkan_QCOM_image_processing2::new(instance, &mut get_proc_address),
			vk_qcom_filter_cubic_weights: Vulkan_QCOM_filter_cubic_weights::new(instance, &mut get_proc_address),
			vk_qcom_ycbcr_degamma: Vulkan_QCOM_ycbcr_degamma::new(instance, &mut get_proc_address),
			vk_qcom_filter_cubic_clamp: Vulkan_QCOM_filter_cubic_clamp::new(instance, &mut get_proc_address),
			vk_ext_attachment_feedback_loop_dynamic_state: Vulkan_EXT_attachment_feedback_loop_dynamic_state::new(instance, &mut get_proc_address),
			vk_msft_layered_driver: Vulkan_MSFT_layered_driver::new(instance, &mut get_proc_address),
			vk_nv_descriptor_pool_overallocation: Vulkan_NV_descriptor_pool_overallocation::new(instance, &mut get_proc_address),
			vk_qcom_tile_memory_heap: Vulkan_QCOM_tile_memory_heap::new(instance, &mut get_proc_address),
			vk_nv_display_stereo: Vulkan_NV_display_stereo::new(instance, &mut get_proc_address),
			vk_nv_raw_access_chains: Vulkan_NV_raw_access_chains::new(instance, &mut get_proc_address),
			vk_nv_external_compute_queue: Vulkan_NV_external_compute_queue::new(instance, &mut get_proc_address),
			vk_nv_command_buffer_inheritance: Vulkan_NV_command_buffer_inheritance::new(instance, &mut get_proc_address),
			vk_nv_shader_atomic_float16_vector: Vulkan_NV_shader_atomic_float16_vector::new(instance, &mut get_proc_address),
			vk_ext_shader_replicated_composites: Vulkan_EXT_shader_replicated_composites::new(instance, &mut get_proc_address),
			vk_ext_shader_float8: Vulkan_EXT_shader_float8::new(instance, &mut get_proc_address),
			vk_nv_ray_tracing_validation: Vulkan_NV_ray_tracing_validation::new(instance, &mut get_proc_address),
			vk_nv_cluster_acceleration_structure: Vulkan_NV_cluster_acceleration_structure::new(instance, &mut get_proc_address),
			vk_nv_partitioned_acceleration_structure: Vulkan_NV_partitioned_acceleration_structure::new(instance, &mut get_proc_address),
			vk_ext_device_generated_commands: Vulkan_EXT_device_generated_commands::new(instance, &mut get_proc_address),
			vk_mesa_image_alignment_control: Vulkan_MESA_image_alignment_control::new(instance, &mut get_proc_address),
			vk_ext_depth_clamp_control: Vulkan_EXT_depth_clamp_control::new(instance, &mut get_proc_address),
			vk_huawei_hdr_vivid: Vulkan_HUAWEI_hdr_vivid::new(instance, &mut get_proc_address),
			vk_nv_cooperative_matrix2: Vulkan_NV_cooperative_matrix2::new(instance, &mut get_proc_address),
			vk_arm_pipeline_opacity_micromap: Vulkan_ARM_pipeline_opacity_micromap::new(instance, &mut get_proc_address),
			vk_ext_vertex_attribute_robustness: Vulkan_EXT_vertex_attribute_robustness::new(instance, &mut get_proc_address),
			vk_arm_format_pack: Vulkan_ARM_format_pack::new(instance, &mut get_proc_address),
			vk_valve_fragment_density_map_layered: Vulkan_VALVE_fragment_density_map_layered::new(instance, &mut get_proc_address),
			vk_nv_present_metering: Vulkan_NV_present_metering::new(instance, &mut get_proc_address),
			vk_ext_fragment_density_map_offset: Vulkan_EXT_fragment_density_map_offset::new(instance, &mut get_proc_address),
			vk_ext_zero_initialize_device_memory: Vulkan_EXT_zero_initialize_device_memory::new(instance, &mut get_proc_address),
			vk_sec_pipeline_cache_incremental_mode: Vulkan_SEC_pipeline_cache_incremental_mode::new(instance, &mut get_proc_address),
			vk_khr_acceleration_structure: Vulkan_KHR_acceleration_structure::new(instance, &mut get_proc_address),
			vk_khr_ray_tracing_pipeline: Vulkan_KHR_ray_tracing_pipeline::new(instance, &mut get_proc_address),
			vk_khr_ray_query: Vulkan_KHR_ray_query::new(instance, &mut get_proc_address),
			vk_ext_mesh_shader: Vulkan_EXT_mesh_shader::new(instance, &mut get_proc_address),
		}
	}
}
