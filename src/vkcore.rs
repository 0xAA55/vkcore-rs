
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]

use std::{
	collections::BTreeSet,
	ffi::{c_void, CStr, CString},
	fmt::{self, Debug, Formatter},
	mem::transmute,
	panic::{panic_any, catch_unwind, resume_unwind},
	ptr::{null, null_mut},
};

/// Make a version value
pub fn vk_make_version(major: u32, minor: u32, patch: u32) -> u32 {
	(major << 22) | (minor << 12) | patch
}
/// Make an API version value
pub fn vk_make_api_version(variant: u32, major: u32, minor: u32, patch: u32) -> u32 {
	(variant << 29) | (major << 22) | (minor << 12) | patch
}
/// Make a video standard version value
pub fn vk_make_video_std_version(major: u32, minor: u32, patch: u32) -> u32 {
	(major << 22) | (minor << 12) | patch
}

/// Convert a fixed-length `i8` array to a Rust string if it is a UTF-8 string; otherwise, return the hexadecimal sequences of the byte array
fn maybe_string<const N: usize>(input: &[i8; N]) -> String {
	match unsafe{CStr::from_ptr(input.as_ptr())}.to_str() {
		Ok(s) => s.to_owned(),
		Err(_) => format!("[{}]", input.iter().map(|b|format!("0x{:02X}", *b as u8)).collect::<Vec<String>>().join(", ")),
	}
}

/// The `Result` type for the Vulkan APIs
#[derive(Debug, Clone)]
pub enum VkError {
	NullFunctionPointer(&'static str),
	VkNotReady(&'static str),
	VkTimeout(&'static str),
	VkEventSet(&'static str),
	VkEventReset(&'static str),
	VkIncomplete(&'static str),
	VkErrorOutOfHostMemory(&'static str),
	VkErrorOutOfDeviceMemory(&'static str),
	VkErrorInitializationFailed(&'static str),
	VkErrorDeviceLost(&'static str),
	VkErrorMemoryMapFailed(&'static str),
	VkErrorLayerNotPresent(&'static str),
	VkErrorExtensionNotPresent(&'static str),
	VkErrorFeatureNotPresent(&'static str),
	VkErrorIncompatibleDriver(&'static str),
	VkErrorTooManyObjects(&'static str),
	VkErrorFormatNotSupported(&'static str),
	VkErrorFragmentedPool(&'static str),
	VkErrorUnknown(&'static str),
	VkErrorValidationFailed(&'static str),
	VkErrorOutOfPoolMemory(&'static str),
	VkErrorInvalidExternalHandle(&'static str),
	VkErrorFragmentation(&'static str),
	VkErrorInvalidOpaqueCaptureAddress(&'static str),
	VkPipelineCompileRequired(&'static str),
	VkErrorNotPermitted(&'static str),
	VkErrorSurfaceLostKhr(&'static str),
	VkErrorNativeWindowInUseKhr(&'static str),
	VkSuboptimalKhr(&'static str),
	VkErrorOutOfDateKhr(&'static str),
	VkErrorIncompatibleDisplayKhr(&'static str),
	VkErrorInvalidShaderNv(&'static str),
	VkErrorImageUsageNotSupportedKhr(&'static str),
	VkErrorVideoPictureLayoutNotSupportedKhr(&'static str),
	VkErrorVideoProfileOperationNotSupportedKhr(&'static str),
	VkErrorVideoProfileFormatNotSupportedKhr(&'static str),
	VkErrorVideoProfileCodecNotSupportedKhr(&'static str),
	VkErrorVideoStdVersionNotSupportedKhr(&'static str),
	VkErrorInvalidDrmFormatModifierPlaneLayoutExt(&'static str),
	VkErrorFullScreenExclusiveModeLostExt(&'static str),
	VkThreadIdleKhr(&'static str),
	VkThreadDoneKhr(&'static str),
	VkOperationDeferredKhr(&'static str),
	VkOperationNotDeferredKhr(&'static str),
	VkErrorInvalidVideoStdParametersKhr(&'static str),
	VkErrorCompressionExhaustedExt(&'static str),
	VkIncompatibleShaderBinaryExt(&'static str),
	VkPipelineBinaryMissingKhr(&'static str),
	VkErrorNotEnoughSpaceKhr(&'static str),
	VkResultMaxEnum(&'static str),
	UnknownError((VkResult, &'static str)),
}

/// Our result type for all of the Vulkan function wrappers
type Result<T> = std::result::Result<T, VkError>;

/// Translate the returned `Result<T>` from `std::panic::catch_unwind()` to our `Result<T>`
fn process_catch<T>(ret: std::thread::Result<T>) -> Result<T> {
	match ret {
		Ok(ret) => Ok(ret),
		Err(e) => {
			if let Some(e) = e.downcast_ref::<VkError>() {
				Err(e.clone())
			} else {
				resume_unwind(e)
			}
		}
	}
}

/// Convert a result returned from `std::panic::catch_unwind()` with `VkResult` to our `Result<()>` 
fn convert_result(function_name: &'static str, result: std::thread::Result<VkResult>) -> Result<()> {
	if let Ok(result) = result {
		match result {
			VkResult::VK_SUCCESS => Ok(()),
			VkResult::VK_NOT_READY => Err(VkError::VkNotReady(function_name)),
			VkResult::VK_TIMEOUT => Err(VkError::VkTimeout(function_name)),
			VkResult::VK_EVENT_SET => Err(VkError::VkEventSet(function_name)),
			VkResult::VK_EVENT_RESET => Err(VkError::VkEventReset(function_name)),
			VkResult::VK_INCOMPLETE => Err(VkError::VkIncomplete(function_name)),
			VkResult::VK_ERROR_OUT_OF_HOST_MEMORY => Err(VkError::VkErrorOutOfHostMemory(function_name)),
			VkResult::VK_ERROR_OUT_OF_DEVICE_MEMORY => Err(VkError::VkErrorOutOfDeviceMemory(function_name)),
			VkResult::VK_ERROR_INITIALIZATION_FAILED => Err(VkError::VkErrorInitializationFailed(function_name)),
			VkResult::VK_ERROR_DEVICE_LOST => Err(VkError::VkErrorDeviceLost(function_name)),
			VkResult::VK_ERROR_MEMORY_MAP_FAILED => Err(VkError::VkErrorMemoryMapFailed(function_name)),
			VkResult::VK_ERROR_LAYER_NOT_PRESENT => Err(VkError::VkErrorLayerNotPresent(function_name)),
			VkResult::VK_ERROR_EXTENSION_NOT_PRESENT => Err(VkError::VkErrorExtensionNotPresent(function_name)),
			VkResult::VK_ERROR_FEATURE_NOT_PRESENT => Err(VkError::VkErrorFeatureNotPresent(function_name)),
			VkResult::VK_ERROR_INCOMPATIBLE_DRIVER => Err(VkError::VkErrorIncompatibleDriver(function_name)),
			VkResult::VK_ERROR_TOO_MANY_OBJECTS => Err(VkError::VkErrorTooManyObjects(function_name)),
			VkResult::VK_ERROR_FORMAT_NOT_SUPPORTED => Err(VkError::VkErrorFormatNotSupported(function_name)),
			VkResult::VK_ERROR_FRAGMENTED_POOL => Err(VkError::VkErrorFragmentedPool(function_name)),
			VkResult::VK_ERROR_UNKNOWN => Err(VkError::VkErrorUnknown(function_name)),
			VkResult::VK_ERROR_VALIDATION_FAILED => Err(VkError::VkErrorValidationFailed(function_name)),
			VkResult::VK_ERROR_OUT_OF_POOL_MEMORY => Err(VkError::VkErrorOutOfPoolMemory(function_name)),
			VkResult::VK_ERROR_INVALID_EXTERNAL_HANDLE => Err(VkError::VkErrorInvalidExternalHandle(function_name)),
			VkResult::VK_ERROR_FRAGMENTATION => Err(VkError::VkErrorFragmentation(function_name)),
			VkResult::VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS => Err(VkError::VkErrorInvalidOpaqueCaptureAddress(function_name)),
			VkResult::VK_PIPELINE_COMPILE_REQUIRED => Err(VkError::VkPipelineCompileRequired(function_name)),
			VkResult::VK_ERROR_NOT_PERMITTED => Err(VkError::VkErrorNotPermitted(function_name)),
			VkResult::VK_ERROR_SURFACE_LOST_KHR => Err(VkError::VkErrorSurfaceLostKhr(function_name)),
			VkResult::VK_ERROR_NATIVE_WINDOW_IN_USE_KHR => Err(VkError::VkErrorNativeWindowInUseKhr(function_name)),
			VkResult::VK_SUBOPTIMAL_KHR => Err(VkError::VkSuboptimalKhr(function_name)),
			VkResult::VK_ERROR_OUT_OF_DATE_KHR => Err(VkError::VkErrorOutOfDateKhr(function_name)),
			VkResult::VK_ERROR_INCOMPATIBLE_DISPLAY_KHR => Err(VkError::VkErrorIncompatibleDisplayKhr(function_name)),
			VkResult::VK_ERROR_INVALID_SHADER_NV => Err(VkError::VkErrorInvalidShaderNv(function_name)),
			VkResult::VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR => Err(VkError::VkErrorImageUsageNotSupportedKhr(function_name)),
			VkResult::VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR => Err(VkError::VkErrorVideoPictureLayoutNotSupportedKhr(function_name)),
			VkResult::VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR => Err(VkError::VkErrorVideoProfileOperationNotSupportedKhr(function_name)),
			VkResult::VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR => Err(VkError::VkErrorVideoProfileFormatNotSupportedKhr(function_name)),
			VkResult::VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR => Err(VkError::VkErrorVideoProfileCodecNotSupportedKhr(function_name)),
			VkResult::VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR => Err(VkError::VkErrorVideoStdVersionNotSupportedKhr(function_name)),
			VkResult::VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT => Err(VkError::VkErrorInvalidDrmFormatModifierPlaneLayoutExt(function_name)),
			VkResult::VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT => Err(VkError::VkErrorFullScreenExclusiveModeLostExt(function_name)),
			VkResult::VK_THREAD_IDLE_KHR => Err(VkError::VkThreadIdleKhr(function_name)),
			VkResult::VK_THREAD_DONE_KHR => Err(VkError::VkThreadDoneKhr(function_name)),
			VkResult::VK_OPERATION_DEFERRED_KHR => Err(VkError::VkOperationDeferredKhr(function_name)),
			VkResult::VK_OPERATION_NOT_DEFERRED_KHR => Err(VkError::VkOperationNotDeferredKhr(function_name)),
			VkResult::VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR => Err(VkError::VkErrorInvalidVideoStdParametersKhr(function_name)),
			VkResult::VK_ERROR_COMPRESSION_EXHAUSTED_EXT => Err(VkError::VkErrorCompressionExhaustedExt(function_name)),
			VkResult::VK_INCOMPATIBLE_SHADER_BINARY_EXT => Err(VkError::VkIncompatibleShaderBinaryExt(function_name)),
			VkResult::VK_PIPELINE_BINARY_MISSING_KHR => Err(VkError::VkPipelineBinaryMissingKhr(function_name)),
			VkResult::VK_ERROR_NOT_ENOUGH_SPACE_KHR => Err(VkError::VkErrorNotEnoughSpaceKhr(function_name)),
			VkResult::VK_RESULT_MAX_ENUM => Err(VkError::VkResultMaxEnum(function_name)),
		}
	} else {
		Err(VkError::NullFunctionPointer(function_name))
	}
}

impl From<VkError> for VkResult {
	fn from(val: VkError) -> Self {
		match val {
			VkError::VkNotReady(_) => VkResult::VK_NOT_READY,
			VkError::VkTimeout(_) => VkResult::VK_TIMEOUT,
			VkError::VkEventSet(_) => VkResult::VK_EVENT_SET,
			VkError::VkEventReset(_) => VkResult::VK_EVENT_RESET,
			VkError::VkIncomplete(_) => VkResult::VK_INCOMPLETE,
			VkError::VkErrorOutOfHostMemory(_) => VkResult::VK_ERROR_OUT_OF_HOST_MEMORY,
			VkError::VkErrorOutOfDeviceMemory(_) => VkResult::VK_ERROR_OUT_OF_DEVICE_MEMORY,
			VkError::VkErrorInitializationFailed(_) => VkResult::VK_ERROR_INITIALIZATION_FAILED,
			VkError::VkErrorDeviceLost(_) => VkResult::VK_ERROR_DEVICE_LOST,
			VkError::VkErrorMemoryMapFailed(_) => VkResult::VK_ERROR_MEMORY_MAP_FAILED,
			VkError::VkErrorLayerNotPresent(_) => VkResult::VK_ERROR_LAYER_NOT_PRESENT,
			VkError::VkErrorExtensionNotPresent(_) => VkResult::VK_ERROR_EXTENSION_NOT_PRESENT,
			VkError::VkErrorFeatureNotPresent(_) => VkResult::VK_ERROR_FEATURE_NOT_PRESENT,
			VkError::VkErrorIncompatibleDriver(_) => VkResult::VK_ERROR_INCOMPATIBLE_DRIVER,
			VkError::VkErrorTooManyObjects(_) => VkResult::VK_ERROR_TOO_MANY_OBJECTS,
			VkError::VkErrorFormatNotSupported(_) => VkResult::VK_ERROR_FORMAT_NOT_SUPPORTED,
			VkError::VkErrorFragmentedPool(_) => VkResult::VK_ERROR_FRAGMENTED_POOL,
			VkError::VkErrorUnknown(_) => VkResult::VK_ERROR_UNKNOWN,
			VkError::VkErrorValidationFailed(_) => VkResult::VK_ERROR_VALIDATION_FAILED,
			VkError::VkErrorOutOfPoolMemory(_) => VkResult::VK_ERROR_OUT_OF_POOL_MEMORY,
			VkError::VkErrorInvalidExternalHandle(_) => VkResult::VK_ERROR_INVALID_EXTERNAL_HANDLE,
			VkError::VkErrorFragmentation(_) => VkResult::VK_ERROR_FRAGMENTATION,
			VkError::VkErrorInvalidOpaqueCaptureAddress(_) => VkResult::VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
			VkError::VkPipelineCompileRequired(_) => VkResult::VK_PIPELINE_COMPILE_REQUIRED,
			VkError::VkErrorNotPermitted(_) => VkResult::VK_ERROR_NOT_PERMITTED,
			VkError::VkErrorSurfaceLostKhr(_) => VkResult::VK_ERROR_SURFACE_LOST_KHR,
			VkError::VkErrorNativeWindowInUseKhr(_) => VkResult::VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,
			VkError::VkSuboptimalKhr(_) => VkResult::VK_SUBOPTIMAL_KHR,
			VkError::VkErrorOutOfDateKhr(_) => VkResult::VK_ERROR_OUT_OF_DATE_KHR,
			VkError::VkErrorIncompatibleDisplayKhr(_) => VkResult::VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,
			VkError::VkErrorInvalidShaderNv(_) => VkResult::VK_ERROR_INVALID_SHADER_NV,
			VkError::VkErrorImageUsageNotSupportedKhr(_) => VkResult::VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR,
			VkError::VkErrorVideoPictureLayoutNotSupportedKhr(_) => VkResult::VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,
			VkError::VkErrorVideoProfileOperationNotSupportedKhr(_) => VkResult::VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,
			VkError::VkErrorVideoProfileFormatNotSupportedKhr(_) => VkResult::VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,
			VkError::VkErrorVideoProfileCodecNotSupportedKhr(_) => VkResult::VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR,
			VkError::VkErrorVideoStdVersionNotSupportedKhr(_) => VkResult::VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR,
			VkError::VkErrorInvalidDrmFormatModifierPlaneLayoutExt(_) => VkResult::VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT,
			VkError::VkErrorFullScreenExclusiveModeLostExt(_) => VkResult::VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,
			VkError::VkThreadIdleKhr(_) => VkResult::VK_THREAD_IDLE_KHR,
			VkError::VkThreadDoneKhr(_) => VkResult::VK_THREAD_DONE_KHR,
			VkError::VkOperationDeferredKhr(_) => VkResult::VK_OPERATION_DEFERRED_KHR,
			VkError::VkOperationNotDeferredKhr(_) => VkResult::VK_OPERATION_NOT_DEFERRED_KHR,
			VkError::VkErrorInvalidVideoStdParametersKhr(_) => VkResult::VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR,
			VkError::VkErrorCompressionExhaustedExt(_) => VkResult::VK_ERROR_COMPRESSION_EXHAUSTED_EXT,
			VkError::VkIncompatibleShaderBinaryExt(_) => VkResult::VK_INCOMPATIBLE_SHADER_BINARY_EXT,
			VkError::VkPipelineBinaryMissingKhr(_) => VkResult::VK_PIPELINE_BINARY_MISSING_KHR,
			VkError::VkErrorNotEnoughSpaceKhr(_) => VkResult::VK_ERROR_NOT_ENOUGH_SPACE_KHR,
			VkError::VkResultMaxEnum(_) => VkResult::VK_RESULT_MAX_ENUM,
			_ => panic!("No `VkResult` value to `{val:?}`"),
		}
	}
}

/// constant `VK_USE_64_BIT_PTR_DEFINES` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_USE_64_BIT_PTR_DEFINES.html>
pub const VK_USE_64_BIT_PTR_DEFINES: u32 = 0;
/// constant `VK_NULL_HANDLE` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NULL_HANDLE.html>
pub const VK_NULL_HANDLE: u32 = 0;
/// constant `VK_API_VERSION_1_0` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_API_VERSION_1_0.html>
pub const VK_API_VERSION_1_0: u32 = 0x400000;
/// constant `VK_HEADER_VERSION` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_HEADER_VERSION.html>
pub const VK_HEADER_VERSION: u32 = 324;
/// constant `VK_HEADER_VERSION_COMPLETE` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_HEADER_VERSION_COMPLETE.html>
pub const VK_HEADER_VERSION_COMPLETE: u32 = 0x404144;
/// constant `VK_ATTACHMENT_UNUSED` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_ATTACHMENT_UNUSED.html>
pub const VK_ATTACHMENT_UNUSED: u32 = !0u32;
/// constant `VK_FALSE` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_FALSE.html>
pub const VK_FALSE: u32 = 0u32;
/// constant `VK_LOD_CLAMP_NONE` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_LOD_CLAMP_NONE.html>
pub const VK_LOD_CLAMP_NONE: f32 = 1000.0f32;
/// constant `VK_QUEUE_FAMILY_IGNORED` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QUEUE_FAMILY_IGNORED.html>
pub const VK_QUEUE_FAMILY_IGNORED: u32 = !0u32;
/// constant `VK_REMAINING_ARRAY_LAYERS` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_REMAINING_ARRAY_LAYERS.html>
pub const VK_REMAINING_ARRAY_LAYERS: u32 = !0u32;
/// constant `VK_REMAINING_MIP_LEVELS` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_REMAINING_MIP_LEVELS.html>
pub const VK_REMAINING_MIP_LEVELS: u32 = !0u32;
/// constant `VK_SUBPASS_EXTERNAL` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_SUBPASS_EXTERNAL.html>
pub const VK_SUBPASS_EXTERNAL: u32 = !0u32;
/// constant `VK_TRUE` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_TRUE.html>
pub const VK_TRUE: u32 = 1u32;
/// constant `VK_WHOLE_SIZE` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_WHOLE_SIZE.html>
pub const VK_WHOLE_SIZE: u64 = !0u64;
/// constant `VK_MAX_MEMORY_TYPES` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_MEMORY_TYPES.html>
pub const VK_MAX_MEMORY_TYPES: u32 = 32u32;
/// constant `VK_MAX_PHYSICAL_DEVICE_NAME_SIZE` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_PHYSICAL_DEVICE_NAME_SIZE.html>
pub const VK_MAX_PHYSICAL_DEVICE_NAME_SIZE: u32 = 256u32;
/// constant `VK_UUID_SIZE` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_UUID_SIZE.html>
pub const VK_UUID_SIZE: u32 = 16u32;
/// constant `VK_MAX_EXTENSION_NAME_SIZE` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_EXTENSION_NAME_SIZE.html>
pub const VK_MAX_EXTENSION_NAME_SIZE: u32 = 256u32;
/// constant `VK_MAX_DESCRIPTION_SIZE` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_DESCRIPTION_SIZE.html>
pub const VK_MAX_DESCRIPTION_SIZE: u32 = 256u32;
/// constant `VK_MAX_MEMORY_HEAPS` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_MEMORY_HEAPS.html>
pub const VK_MAX_MEMORY_HEAPS: u32 = 16u32;
/// type definition for Rust: `int8_t` = `i8`
/// - Reference: <https://en.cppreference.com/w/cpp/types/integer.html>
pub type int8_t = i8;
/// type definition for Rust: `int16_t` = `i16`
/// - Reference: <https://en.cppreference.com/w/cpp/types/integer.html>
pub type int16_t = i16;
/// type definition for Rust: `int32_t` = `i32`
/// - Reference: <https://en.cppreference.com/w/cpp/types/integer.html>
pub type int32_t = i32;
/// type definition for Rust: `int64_t` = `i64`
/// - Reference: <https://en.cppreference.com/w/cpp/types/integer.html>
pub type int64_t = i64;
/// type definition for Rust: `uint8_t` = `u8`
/// - Reference: <https://en.cppreference.com/w/cpp/types/integer.html>
pub type uint8_t = u8;
/// type definition for Rust: `uint16_t` = `u16`
/// - Reference: <https://en.cppreference.com/w/cpp/types/integer.html>
pub type uint16_t = u16;
/// type definition for Rust: `uint32_t` = `u32`
/// - Reference: <https://en.cppreference.com/w/cpp/types/integer.html>
pub type uint32_t = u32;
/// type definition for Rust: `uint64_t` = `u64`
/// - Reference: <https://en.cppreference.com/w/cpp/types/integer.html>
pub type uint64_t = u64;
/// type definition for Rust: `size_t` = `usize`
/// - Reference: <https://en.cppreference.com/w/cpp/types/integer.html>
pub type size_t = usize;
/// type definition for Rust: `char` = `i8`
/// - Reference: <https://en.cppreference.com/w/cpp/types/integer.html>
pub type char = i8;
/// type definition for Rust: `short` = `i16`
/// - Reference: <https://en.cppreference.com/w/cpp/types/integer.html>
pub type short = i16;
/// type definition for Rust: `int` = `i32`
/// - Reference: <https://en.cppreference.com/w/cpp/types/integer.html>
pub type int = i32;
/// type definition for Rust: `unsigned` = `u32`
/// - Reference: <https://en.cppreference.com/w/cpp/types/integer.html>
pub type unsigned = u32;
/// type definition for Rust: `long` = `i64`
/// - Reference: <https://en.cppreference.com/w/cpp/types/integer.html>
pub type long = i64;
/// type definition for Rust: `float` = `f32`
/// - Reference: <https://en.cppreference.com/w/cpp/types/integer.html>
pub type float = f32;
/// type definition for Rust: `double` = `f64`
/// - Reference: <https://en.cppreference.com/w/cpp/types/integer.html>
pub type double = f64;
/// type definition `VkBool32` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBool32.html>
pub type VkBool32 = u32;
/// type definition `VkDeviceAddress` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceAddress.html>
pub type VkDeviceAddress = u64;
/// type definition `VkDeviceSize` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceSize.html>
pub type VkDeviceSize = u64;
/// type definition `VkFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFlags.html>
pub type VkFlags = u32;
/// type definition `VkSampleMask` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSampleMask.html>
pub type VkSampleMask = u32;
/// type definition `VkAccessFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccessFlags.html>
pub type VkAccessFlags = VkFlags;
pub fn vk_access_flags_to_string(value: VkAccessFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(36);
	if (value & VkAccessFlagBits::VK_ACCESS_INDIRECT_COMMAND_READ_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_INDIRECT_COMMAND_READ_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_INDIRECT_COMMAND_READ_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_INDEX_READ_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_INDEX_READ_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_INDEX_READ_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_UNIFORM_READ_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_UNIFORM_READ_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_UNIFORM_READ_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_INPUT_ATTACHMENT_READ_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_INPUT_ATTACHMENT_READ_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_INPUT_ATTACHMENT_READ_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_SHADER_READ_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_SHADER_READ_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_SHADER_READ_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_SHADER_WRITE_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_SHADER_WRITE_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_SHADER_WRITE_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_READ_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_READ_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_READ_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_TRANSFER_READ_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_TRANSFER_READ_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_TRANSFER_READ_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_TRANSFER_WRITE_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_TRANSFER_WRITE_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_TRANSFER_WRITE_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_HOST_READ_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_HOST_READ_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_HOST_READ_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_HOST_WRITE_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_HOST_WRITE_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_HOST_WRITE_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_MEMORY_READ_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_MEMORY_READ_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_MEMORY_READ_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_MEMORY_WRITE_BIT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_MEMORY_WRITE_BIT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_MEMORY_WRITE_BIT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_NONE as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_NONE as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_NONE");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_NONE_KHR as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_NONE_KHR as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_NONE_KHR");
	}
	if (value & VkAccessFlagBits::VK_ACCESS_FLAG_BITS_MAX_ENUM as VkAccessFlags) == VkAccessFlagBits::VK_ACCESS_FLAG_BITS_MAX_ENUM as VkAccessFlags {
		flags.push("VkAccessFlagBits::VK_ACCESS_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkImageAspectFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageAspectFlags.html>
pub type VkImageAspectFlags = VkFlags;
pub fn vk_image_aspect_flags_to_string(value: VkImageAspectFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(17);
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_COLOR_BIT as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_COLOR_BIT as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_COLOR_BIT");
	}
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_DEPTH_BIT as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_DEPTH_BIT as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_DEPTH_BIT");
	}
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_STENCIL_BIT as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_STENCIL_BIT as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_STENCIL_BIT");
	}
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_METADATA_BIT as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_METADATA_BIT as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_METADATA_BIT");
	}
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_0_BIT as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_0_BIT as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_0_BIT");
	}
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_1_BIT as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_1_BIT as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_1_BIT");
	}
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_2_BIT as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_2_BIT as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_2_BIT");
	}
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_NONE as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_NONE as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_NONE");
	}
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT");
	}
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT");
	}
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT");
	}
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT");
	}
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_0_BIT_KHR as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_0_BIT_KHR as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_0_BIT_KHR");
	}
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_1_BIT_KHR as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_1_BIT_KHR as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_1_BIT_KHR");
	}
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_2_BIT_KHR as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_2_BIT_KHR as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_2_BIT_KHR");
	}
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_NONE_KHR as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_NONE_KHR as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_NONE_KHR");
	}
	if (value & VkImageAspectFlagBits::VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM as VkImageAspectFlags) == VkImageAspectFlagBits::VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM as VkImageAspectFlags {
		flags.push("VkImageAspectFlagBits::VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkFormatFeatureFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormatFeatureFlags.html>
pub type VkFormatFeatureFlags = VkFlags;
pub fn vk_format_feature_flags_to_string(value: VkFormatFeatureFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(43);
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_BLIT_SRC_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_BLIT_SRC_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_BLIT_SRC_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_BLIT_DST_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_BLIT_DST_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_BLIT_DST_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_SRC_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_SRC_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_SRC_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_DST_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_DST_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_DST_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_DISJOINT_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_DISJOINT_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_DISJOINT_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_DISJOINT_BIT_KHR as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_DISJOINT_BIT_KHR as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_DISJOINT_BIT_KHR");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR");
	}
	if (value & VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM as VkFormatFeatureFlags) == VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM as VkFormatFeatureFlags {
		flags.push("VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkImageCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateFlags.html>
pub type VkImageCreateFlags = VkFlags;
pub fn vk_image_create_flags_to_string(value: VkImageCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(28);
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_SPARSE_BINDING_BIT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_SPARSE_BINDING_BIT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_SPARSE_BINDING_BIT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_SPARSE_ALIASED_BIT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_SPARSE_ALIASED_BIT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_SPARSE_ALIASED_BIT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_ALIAS_BIT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_ALIAS_BIT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_ALIAS_BIT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_EXTENDED_USAGE_BIT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_EXTENDED_USAGE_BIT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_EXTENDED_USAGE_BIT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_PROTECTED_BIT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_PROTECTED_BIT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_PROTECTED_BIT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_DISJOINT_BIT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_DISJOINT_BIT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_DISJOINT_BIT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_DISJOINT_BIT_KHR as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_DISJOINT_BIT_KHR as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_DISJOINT_BIT_KHR");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_ALIAS_BIT_KHR as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_ALIAS_BIT_KHR as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_ALIAS_BIT_KHR");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM");
	}
	if (value & VkImageCreateFlagBits::VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM as VkImageCreateFlags) == VkImageCreateFlagBits::VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM as VkImageCreateFlags {
		flags.push("VkImageCreateFlagBits::VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkSampleCountFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSampleCountFlags.html>
pub type VkSampleCountFlags = VkFlags;
pub fn vk_sample_count_flags_to_string(value: VkSampleCountFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(8);
	if (value & VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT as VkSampleCountFlags) == VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT as VkSampleCountFlags {
		flags.push("VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT");
	}
	if (value & VkSampleCountFlagBits::VK_SAMPLE_COUNT_2_BIT as VkSampleCountFlags) == VkSampleCountFlagBits::VK_SAMPLE_COUNT_2_BIT as VkSampleCountFlags {
		flags.push("VkSampleCountFlagBits::VK_SAMPLE_COUNT_2_BIT");
	}
	if (value & VkSampleCountFlagBits::VK_SAMPLE_COUNT_4_BIT as VkSampleCountFlags) == VkSampleCountFlagBits::VK_SAMPLE_COUNT_4_BIT as VkSampleCountFlags {
		flags.push("VkSampleCountFlagBits::VK_SAMPLE_COUNT_4_BIT");
	}
	if (value & VkSampleCountFlagBits::VK_SAMPLE_COUNT_8_BIT as VkSampleCountFlags) == VkSampleCountFlagBits::VK_SAMPLE_COUNT_8_BIT as VkSampleCountFlags {
		flags.push("VkSampleCountFlagBits::VK_SAMPLE_COUNT_8_BIT");
	}
	if (value & VkSampleCountFlagBits::VK_SAMPLE_COUNT_16_BIT as VkSampleCountFlags) == VkSampleCountFlagBits::VK_SAMPLE_COUNT_16_BIT as VkSampleCountFlags {
		flags.push("VkSampleCountFlagBits::VK_SAMPLE_COUNT_16_BIT");
	}
	if (value & VkSampleCountFlagBits::VK_SAMPLE_COUNT_32_BIT as VkSampleCountFlags) == VkSampleCountFlagBits::VK_SAMPLE_COUNT_32_BIT as VkSampleCountFlags {
		flags.push("VkSampleCountFlagBits::VK_SAMPLE_COUNT_32_BIT");
	}
	if (value & VkSampleCountFlagBits::VK_SAMPLE_COUNT_64_BIT as VkSampleCountFlags) == VkSampleCountFlagBits::VK_SAMPLE_COUNT_64_BIT as VkSampleCountFlags {
		flags.push("VkSampleCountFlagBits::VK_SAMPLE_COUNT_64_BIT");
	}
	if (value & VkSampleCountFlagBits::VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM as VkSampleCountFlags) == VkSampleCountFlagBits::VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM as VkSampleCountFlags {
		flags.push("VkSampleCountFlagBits::VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkImageUsageFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageUsageFlags.html>
pub type VkImageUsageFlags = VkFlags;
pub fn vk_image_usage_flags_to_string(value: VkImageUsageFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(28);
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_TRANSFER_SRC_BIT as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_TRANSFER_SRC_BIT as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_TRANSFER_SRC_BIT");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_TRANSFER_DST_BIT as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_TRANSFER_DST_BIT as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_TRANSFER_DST_BIT");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_SAMPLED_BIT as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_SAMPLED_BIT as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_SAMPLED_BIT");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_STORAGE_BIT as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_STORAGE_BIT as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_STORAGE_BIT");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_HOST_TRANSFER_BIT as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_HOST_TRANSFER_BIT as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_HOST_TRANSFER_BIT");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT");
	}
	if (value & VkImageUsageFlagBits::VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM as VkImageUsageFlags) == VkImageUsageFlagBits::VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM as VkImageUsageFlags {
		flags.push("VkImageUsageFlagBits::VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkInstanceCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkInstanceCreateFlags.html>
pub type VkInstanceCreateFlags = VkFlags;
pub fn vk_instance_create_flags_to_string(value: VkInstanceCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(2);
	if (value & VkInstanceCreateFlagBits::VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR as VkInstanceCreateFlags) == VkInstanceCreateFlagBits::VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR as VkInstanceCreateFlags {
		flags.push("VkInstanceCreateFlagBits::VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR");
	}
	if (value & VkInstanceCreateFlagBits::VK_INSTANCE_CREATE_FLAG_BITS_MAX_ENUM as VkInstanceCreateFlags) == VkInstanceCreateFlagBits::VK_INSTANCE_CREATE_FLAG_BITS_MAX_ENUM as VkInstanceCreateFlags {
		flags.push("VkInstanceCreateFlagBits::VK_INSTANCE_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkMemoryHeapFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryHeapFlags.html>
pub type VkMemoryHeapFlags = VkFlags;
pub fn vk_memory_heap_flags_to_string(value: VkMemoryHeapFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(5);
	if (value & VkMemoryHeapFlagBits::VK_MEMORY_HEAP_DEVICE_LOCAL_BIT as VkMemoryHeapFlags) == VkMemoryHeapFlagBits::VK_MEMORY_HEAP_DEVICE_LOCAL_BIT as VkMemoryHeapFlags {
		flags.push("VkMemoryHeapFlagBits::VK_MEMORY_HEAP_DEVICE_LOCAL_BIT");
	}
	if (value & VkMemoryHeapFlagBits::VK_MEMORY_HEAP_MULTI_INSTANCE_BIT as VkMemoryHeapFlags) == VkMemoryHeapFlagBits::VK_MEMORY_HEAP_MULTI_INSTANCE_BIT as VkMemoryHeapFlags {
		flags.push("VkMemoryHeapFlagBits::VK_MEMORY_HEAP_MULTI_INSTANCE_BIT");
	}
	if (value & VkMemoryHeapFlagBits::VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM as VkMemoryHeapFlags) == VkMemoryHeapFlagBits::VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM as VkMemoryHeapFlags {
		flags.push("VkMemoryHeapFlagBits::VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM");
	}
	if (value & VkMemoryHeapFlagBits::VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR as VkMemoryHeapFlags) == VkMemoryHeapFlagBits::VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR as VkMemoryHeapFlags {
		flags.push("VkMemoryHeapFlagBits::VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR");
	}
	if (value & VkMemoryHeapFlagBits::VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM as VkMemoryHeapFlags) == VkMemoryHeapFlagBits::VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM as VkMemoryHeapFlags {
		flags.push("VkMemoryHeapFlagBits::VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkMemoryPropertyFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryPropertyFlags.html>
pub type VkMemoryPropertyFlags = VkFlags;
pub fn vk_memory_property_flags_to_string(value: VkMemoryPropertyFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(10);
	if (value & VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT as VkMemoryPropertyFlags) == VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT as VkMemoryPropertyFlags {
		flags.push("VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT");
	}
	if (value & VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT as VkMemoryPropertyFlags) == VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT as VkMemoryPropertyFlags {
		flags.push("VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT");
	}
	if (value & VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_COHERENT_BIT as VkMemoryPropertyFlags) == VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_COHERENT_BIT as VkMemoryPropertyFlags {
		flags.push("VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_COHERENT_BIT");
	}
	if (value & VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_CACHED_BIT as VkMemoryPropertyFlags) == VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_CACHED_BIT as VkMemoryPropertyFlags {
		flags.push("VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_CACHED_BIT");
	}
	if (value & VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT as VkMemoryPropertyFlags) == VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT as VkMemoryPropertyFlags {
		flags.push("VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT");
	}
	if (value & VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_PROTECTED_BIT as VkMemoryPropertyFlags) == VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_PROTECTED_BIT as VkMemoryPropertyFlags {
		flags.push("VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_PROTECTED_BIT");
	}
	if (value & VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD as VkMemoryPropertyFlags) == VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD as VkMemoryPropertyFlags {
		flags.push("VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD");
	}
	if (value & VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD as VkMemoryPropertyFlags) == VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD as VkMemoryPropertyFlags {
		flags.push("VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD");
	}
	if (value & VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV as VkMemoryPropertyFlags) == VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV as VkMemoryPropertyFlags {
		flags.push("VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV");
	}
	if (value & VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM as VkMemoryPropertyFlags) == VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM as VkMemoryPropertyFlags {
		flags.push("VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkQueueFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueFlags.html>
pub type VkQueueFlags = VkFlags;
pub fn vk_queue_flags_to_string(value: VkQueueFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(10);
	if (value & VkQueueFlagBits::VK_QUEUE_GRAPHICS_BIT as VkQueueFlags) == VkQueueFlagBits::VK_QUEUE_GRAPHICS_BIT as VkQueueFlags {
		flags.push("VkQueueFlagBits::VK_QUEUE_GRAPHICS_BIT");
	}
	if (value & VkQueueFlagBits::VK_QUEUE_COMPUTE_BIT as VkQueueFlags) == VkQueueFlagBits::VK_QUEUE_COMPUTE_BIT as VkQueueFlags {
		flags.push("VkQueueFlagBits::VK_QUEUE_COMPUTE_BIT");
	}
	if (value & VkQueueFlagBits::VK_QUEUE_TRANSFER_BIT as VkQueueFlags) == VkQueueFlagBits::VK_QUEUE_TRANSFER_BIT as VkQueueFlags {
		flags.push("VkQueueFlagBits::VK_QUEUE_TRANSFER_BIT");
	}
	if (value & VkQueueFlagBits::VK_QUEUE_SPARSE_BINDING_BIT as VkQueueFlags) == VkQueueFlagBits::VK_QUEUE_SPARSE_BINDING_BIT as VkQueueFlags {
		flags.push("VkQueueFlagBits::VK_QUEUE_SPARSE_BINDING_BIT");
	}
	if (value & VkQueueFlagBits::VK_QUEUE_PROTECTED_BIT as VkQueueFlags) == VkQueueFlagBits::VK_QUEUE_PROTECTED_BIT as VkQueueFlags {
		flags.push("VkQueueFlagBits::VK_QUEUE_PROTECTED_BIT");
	}
	if (value & VkQueueFlagBits::VK_QUEUE_VIDEO_DECODE_BIT_KHR as VkQueueFlags) == VkQueueFlagBits::VK_QUEUE_VIDEO_DECODE_BIT_KHR as VkQueueFlags {
		flags.push("VkQueueFlagBits::VK_QUEUE_VIDEO_DECODE_BIT_KHR");
	}
	if (value & VkQueueFlagBits::VK_QUEUE_VIDEO_ENCODE_BIT_KHR as VkQueueFlags) == VkQueueFlagBits::VK_QUEUE_VIDEO_ENCODE_BIT_KHR as VkQueueFlags {
		flags.push("VkQueueFlagBits::VK_QUEUE_VIDEO_ENCODE_BIT_KHR");
	}
	if (value & VkQueueFlagBits::VK_QUEUE_OPTICAL_FLOW_BIT_NV as VkQueueFlags) == VkQueueFlagBits::VK_QUEUE_OPTICAL_FLOW_BIT_NV as VkQueueFlags {
		flags.push("VkQueueFlagBits::VK_QUEUE_OPTICAL_FLOW_BIT_NV");
	}
	if (value & VkQueueFlagBits::VK_QUEUE_DATA_GRAPH_BIT_ARM as VkQueueFlags) == VkQueueFlagBits::VK_QUEUE_DATA_GRAPH_BIT_ARM as VkQueueFlags {
		flags.push("VkQueueFlagBits::VK_QUEUE_DATA_GRAPH_BIT_ARM");
	}
	if (value & VkQueueFlagBits::VK_QUEUE_FLAG_BITS_MAX_ENUM as VkQueueFlags) == VkQueueFlagBits::VK_QUEUE_FLAG_BITS_MAX_ENUM as VkQueueFlags {
		flags.push("VkQueueFlagBits::VK_QUEUE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkDeviceCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceCreateFlags.html>
pub type VkDeviceCreateFlags = VkFlags;
/// type definition `VkDeviceQueueCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceQueueCreateFlags.html>
pub type VkDeviceQueueCreateFlags = VkFlags;
pub fn vk_device_queue_create_flags_to_string(value: VkDeviceQueueCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(2);
	if (value & VkDeviceQueueCreateFlagBits::VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT as VkDeviceQueueCreateFlags) == VkDeviceQueueCreateFlagBits::VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT as VkDeviceQueueCreateFlags {
		flags.push("VkDeviceQueueCreateFlagBits::VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT");
	}
	if (value & VkDeviceQueueCreateFlagBits::VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM as VkDeviceQueueCreateFlags) == VkDeviceQueueCreateFlagBits::VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM as VkDeviceQueueCreateFlags {
		flags.push("VkDeviceQueueCreateFlagBits::VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkPipelineStageFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineStageFlags.html>
pub type VkPipelineStageFlags = VkFlags;
pub fn vk_pipeline_stage_flags_to_string(value: VkPipelineStageFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(35);
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_VERTEX_INPUT_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_VERTEX_INPUT_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_VERTEX_INPUT_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_VERTEX_SHADER_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_VERTEX_SHADER_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_VERTEX_SHADER_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TRANSFER_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TRANSFER_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TRANSFER_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_HOST_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_HOST_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_HOST_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_COMMANDS_BIT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_COMMANDS_BIT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_COMMANDS_BIT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_NONE as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_NONE as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_NONE");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_NONE_KHR as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_NONE_KHR as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_NONE_KHR");
	}
	if (value & VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM as VkPipelineStageFlags) == VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM as VkPipelineStageFlags {
		flags.push("VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkMemoryMapFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryMapFlags.html>
pub type VkMemoryMapFlags = VkFlags;
pub fn vk_memory_map_flags_to_string(value: VkMemoryMapFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(2);
	if (value & VkMemoryMapFlagBits::VK_MEMORY_MAP_PLACED_BIT_EXT as VkMemoryMapFlags) == VkMemoryMapFlagBits::VK_MEMORY_MAP_PLACED_BIT_EXT as VkMemoryMapFlags {
		flags.push("VkMemoryMapFlagBits::VK_MEMORY_MAP_PLACED_BIT_EXT");
	}
	if (value & VkMemoryMapFlagBits::VK_MEMORY_MAP_FLAG_BITS_MAX_ENUM as VkMemoryMapFlags) == VkMemoryMapFlagBits::VK_MEMORY_MAP_FLAG_BITS_MAX_ENUM as VkMemoryMapFlags {
		flags.push("VkMemoryMapFlagBits::VK_MEMORY_MAP_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkSparseMemoryBindFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSparseMemoryBindFlags.html>
pub type VkSparseMemoryBindFlags = VkFlags;
pub fn vk_sparse_memory_bind_flags_to_string(value: VkSparseMemoryBindFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(2);
	if (value & VkSparseMemoryBindFlagBits::VK_SPARSE_MEMORY_BIND_METADATA_BIT as VkSparseMemoryBindFlags) == VkSparseMemoryBindFlagBits::VK_SPARSE_MEMORY_BIND_METADATA_BIT as VkSparseMemoryBindFlags {
		flags.push("VkSparseMemoryBindFlagBits::VK_SPARSE_MEMORY_BIND_METADATA_BIT");
	}
	if (value & VkSparseMemoryBindFlagBits::VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM as VkSparseMemoryBindFlags) == VkSparseMemoryBindFlagBits::VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM as VkSparseMemoryBindFlags {
		flags.push("VkSparseMemoryBindFlagBits::VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkSparseImageFormatFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSparseImageFormatFlags.html>
pub type VkSparseImageFormatFlags = VkFlags;
pub fn vk_sparse_image_format_flags_to_string(value: VkSparseImageFormatFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(4);
	if (value & VkSparseImageFormatFlagBits::VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT as VkSparseImageFormatFlags) == VkSparseImageFormatFlagBits::VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT as VkSparseImageFormatFlags {
		flags.push("VkSparseImageFormatFlagBits::VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT");
	}
	if (value & VkSparseImageFormatFlagBits::VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT as VkSparseImageFormatFlags) == VkSparseImageFormatFlagBits::VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT as VkSparseImageFormatFlags {
		flags.push("VkSparseImageFormatFlagBits::VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT");
	}
	if (value & VkSparseImageFormatFlagBits::VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT as VkSparseImageFormatFlags) == VkSparseImageFormatFlagBits::VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT as VkSparseImageFormatFlags {
		flags.push("VkSparseImageFormatFlagBits::VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT");
	}
	if (value & VkSparseImageFormatFlagBits::VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM as VkSparseImageFormatFlags) == VkSparseImageFormatFlagBits::VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM as VkSparseImageFormatFlags {
		flags.push("VkSparseImageFormatFlagBits::VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkFenceCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFenceCreateFlags.html>
pub type VkFenceCreateFlags = VkFlags;
pub fn vk_fence_create_flags_to_string(value: VkFenceCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(2);
	if (value & VkFenceCreateFlagBits::VK_FENCE_CREATE_SIGNALED_BIT as VkFenceCreateFlags) == VkFenceCreateFlagBits::VK_FENCE_CREATE_SIGNALED_BIT as VkFenceCreateFlags {
		flags.push("VkFenceCreateFlagBits::VK_FENCE_CREATE_SIGNALED_BIT");
	}
	if (value & VkFenceCreateFlagBits::VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM as VkFenceCreateFlags) == VkFenceCreateFlagBits::VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM as VkFenceCreateFlags {
		flags.push("VkFenceCreateFlagBits::VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkSemaphoreCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreCreateFlags.html>
pub type VkSemaphoreCreateFlags = VkFlags;
/// type definition `VkEventCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkEventCreateFlags.html>
pub type VkEventCreateFlags = VkFlags;
pub fn vk_event_create_flags_to_string(value: VkEventCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(3);
	if (value & VkEventCreateFlagBits::VK_EVENT_CREATE_DEVICE_ONLY_BIT as VkEventCreateFlags) == VkEventCreateFlagBits::VK_EVENT_CREATE_DEVICE_ONLY_BIT as VkEventCreateFlags {
		flags.push("VkEventCreateFlagBits::VK_EVENT_CREATE_DEVICE_ONLY_BIT");
	}
	if (value & VkEventCreateFlagBits::VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR as VkEventCreateFlags) == VkEventCreateFlagBits::VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR as VkEventCreateFlags {
		flags.push("VkEventCreateFlagBits::VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR");
	}
	if (value & VkEventCreateFlagBits::VK_EVENT_CREATE_FLAG_BITS_MAX_ENUM as VkEventCreateFlags) == VkEventCreateFlagBits::VK_EVENT_CREATE_FLAG_BITS_MAX_ENUM as VkEventCreateFlags {
		flags.push("VkEventCreateFlagBits::VK_EVENT_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkQueryPipelineStatisticFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryPipelineStatisticFlags.html>
pub type VkQueryPipelineStatisticFlags = VkFlags;
pub fn vk_query_pipeline_statistic_flags_to_string(value: VkQueryPipelineStatisticFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(15);
	if (value & VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT as VkQueryPipelineStatisticFlags) == VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT as VkQueryPipelineStatisticFlags {
		flags.push("VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT");
	}
	if (value & VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT as VkQueryPipelineStatisticFlags) == VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT as VkQueryPipelineStatisticFlags {
		flags.push("VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT");
	}
	if (value & VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT as VkQueryPipelineStatisticFlags) == VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT as VkQueryPipelineStatisticFlags {
		flags.push("VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT");
	}
	if (value & VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT as VkQueryPipelineStatisticFlags) == VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT as VkQueryPipelineStatisticFlags {
		flags.push("VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT");
	}
	if (value & VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT as VkQueryPipelineStatisticFlags) == VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT as VkQueryPipelineStatisticFlags {
		flags.push("VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT");
	}
	if (value & VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT as VkQueryPipelineStatisticFlags) == VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT as VkQueryPipelineStatisticFlags {
		flags.push("VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT");
	}
	if (value & VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT as VkQueryPipelineStatisticFlags) == VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT as VkQueryPipelineStatisticFlags {
		flags.push("VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT");
	}
	if (value & VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT as VkQueryPipelineStatisticFlags) == VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT as VkQueryPipelineStatisticFlags {
		flags.push("VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT");
	}
	if (value & VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT as VkQueryPipelineStatisticFlags) == VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT as VkQueryPipelineStatisticFlags {
		flags.push("VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT");
	}
	if (value & VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT as VkQueryPipelineStatisticFlags) == VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT as VkQueryPipelineStatisticFlags {
		flags.push("VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT");
	}
	if (value & VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT as VkQueryPipelineStatisticFlags) == VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT as VkQueryPipelineStatisticFlags {
		flags.push("VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT");
	}
	if (value & VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT as VkQueryPipelineStatisticFlags) == VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT as VkQueryPipelineStatisticFlags {
		flags.push("VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT");
	}
	if (value & VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT as VkQueryPipelineStatisticFlags) == VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT as VkQueryPipelineStatisticFlags {
		flags.push("VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT");
	}
	if (value & VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI as VkQueryPipelineStatisticFlags) == VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI as VkQueryPipelineStatisticFlags {
		flags.push("VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI");
	}
	if (value & VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM as VkQueryPipelineStatisticFlags) == VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM as VkQueryPipelineStatisticFlags {
		flags.push("VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkQueryPoolCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryPoolCreateFlags.html>
pub type VkQueryPoolCreateFlags = VkFlags;
pub fn vk_query_pool_create_flags_to_string(value: VkQueryPoolCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(2);
	if (value & VkQueryPoolCreateFlagBits::VK_QUERY_POOL_CREATE_RESET_BIT_KHR as VkQueryPoolCreateFlags) == VkQueryPoolCreateFlagBits::VK_QUERY_POOL_CREATE_RESET_BIT_KHR as VkQueryPoolCreateFlags {
		flags.push("VkQueryPoolCreateFlagBits::VK_QUERY_POOL_CREATE_RESET_BIT_KHR");
	}
	if (value & VkQueryPoolCreateFlagBits::VK_QUERY_POOL_CREATE_FLAG_BITS_MAX_ENUM as VkQueryPoolCreateFlags) == VkQueryPoolCreateFlagBits::VK_QUERY_POOL_CREATE_FLAG_BITS_MAX_ENUM as VkQueryPoolCreateFlags {
		flags.push("VkQueryPoolCreateFlagBits::VK_QUERY_POOL_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkQueryResultFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryResultFlags.html>
pub type VkQueryResultFlags = VkFlags;
pub fn vk_query_result_flags_to_string(value: VkQueryResultFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(6);
	if (value & VkQueryResultFlagBits::VK_QUERY_RESULT_64_BIT as VkQueryResultFlags) == VkQueryResultFlagBits::VK_QUERY_RESULT_64_BIT as VkQueryResultFlags {
		flags.push("VkQueryResultFlagBits::VK_QUERY_RESULT_64_BIT");
	}
	if (value & VkQueryResultFlagBits::VK_QUERY_RESULT_WAIT_BIT as VkQueryResultFlags) == VkQueryResultFlagBits::VK_QUERY_RESULT_WAIT_BIT as VkQueryResultFlags {
		flags.push("VkQueryResultFlagBits::VK_QUERY_RESULT_WAIT_BIT");
	}
	if (value & VkQueryResultFlagBits::VK_QUERY_RESULT_WITH_AVAILABILITY_BIT as VkQueryResultFlags) == VkQueryResultFlagBits::VK_QUERY_RESULT_WITH_AVAILABILITY_BIT as VkQueryResultFlags {
		flags.push("VkQueryResultFlagBits::VK_QUERY_RESULT_WITH_AVAILABILITY_BIT");
	}
	if (value & VkQueryResultFlagBits::VK_QUERY_RESULT_PARTIAL_BIT as VkQueryResultFlags) == VkQueryResultFlagBits::VK_QUERY_RESULT_PARTIAL_BIT as VkQueryResultFlags {
		flags.push("VkQueryResultFlagBits::VK_QUERY_RESULT_PARTIAL_BIT");
	}
	if (value & VkQueryResultFlagBits::VK_QUERY_RESULT_WITH_STATUS_BIT_KHR as VkQueryResultFlags) == VkQueryResultFlagBits::VK_QUERY_RESULT_WITH_STATUS_BIT_KHR as VkQueryResultFlags {
		flags.push("VkQueryResultFlagBits::VK_QUERY_RESULT_WITH_STATUS_BIT_KHR");
	}
	if (value & VkQueryResultFlagBits::VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM as VkQueryResultFlags) == VkQueryResultFlagBits::VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM as VkQueryResultFlags {
		flags.push("VkQueryResultFlagBits::VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkBufferCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferCreateFlags.html>
pub type VkBufferCreateFlags = VkFlags;
pub fn vk_buffer_create_flags_to_string(value: VkBufferCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(10);
	if (value & VkBufferCreateFlagBits::VK_BUFFER_CREATE_SPARSE_BINDING_BIT as VkBufferCreateFlags) == VkBufferCreateFlagBits::VK_BUFFER_CREATE_SPARSE_BINDING_BIT as VkBufferCreateFlags {
		flags.push("VkBufferCreateFlagBits::VK_BUFFER_CREATE_SPARSE_BINDING_BIT");
	}
	if (value & VkBufferCreateFlagBits::VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT as VkBufferCreateFlags) == VkBufferCreateFlagBits::VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT as VkBufferCreateFlags {
		flags.push("VkBufferCreateFlagBits::VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT");
	}
	if (value & VkBufferCreateFlagBits::VK_BUFFER_CREATE_SPARSE_ALIASED_BIT as VkBufferCreateFlags) == VkBufferCreateFlagBits::VK_BUFFER_CREATE_SPARSE_ALIASED_BIT as VkBufferCreateFlags {
		flags.push("VkBufferCreateFlagBits::VK_BUFFER_CREATE_SPARSE_ALIASED_BIT");
	}
	if (value & VkBufferCreateFlagBits::VK_BUFFER_CREATE_PROTECTED_BIT as VkBufferCreateFlags) == VkBufferCreateFlagBits::VK_BUFFER_CREATE_PROTECTED_BIT as VkBufferCreateFlags {
		flags.push("VkBufferCreateFlagBits::VK_BUFFER_CREATE_PROTECTED_BIT");
	}
	if (value & VkBufferCreateFlagBits::VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT as VkBufferCreateFlags) == VkBufferCreateFlagBits::VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT as VkBufferCreateFlags {
		flags.push("VkBufferCreateFlagBits::VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT");
	}
	if (value & VkBufferCreateFlagBits::VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT as VkBufferCreateFlags) == VkBufferCreateFlagBits::VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT as VkBufferCreateFlags {
		flags.push("VkBufferCreateFlagBits::VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT");
	}
	if (value & VkBufferCreateFlagBits::VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR as VkBufferCreateFlags) == VkBufferCreateFlagBits::VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR as VkBufferCreateFlags {
		flags.push("VkBufferCreateFlagBits::VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR");
	}
	if (value & VkBufferCreateFlagBits::VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT as VkBufferCreateFlags) == VkBufferCreateFlagBits::VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT as VkBufferCreateFlags {
		flags.push("VkBufferCreateFlagBits::VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT");
	}
	if (value & VkBufferCreateFlagBits::VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR as VkBufferCreateFlags) == VkBufferCreateFlagBits::VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR as VkBufferCreateFlags {
		flags.push("VkBufferCreateFlagBits::VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR");
	}
	if (value & VkBufferCreateFlagBits::VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM as VkBufferCreateFlags) == VkBufferCreateFlagBits::VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM as VkBufferCreateFlags {
		flags.push("VkBufferCreateFlagBits::VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkBufferUsageFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferUsageFlags.html>
pub type VkBufferUsageFlags = VkFlags;
pub fn vk_buffer_usage_flags_to_string(value: VkBufferUsageFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(31);
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_SRC_BIT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_SRC_BIT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_SRC_BIT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_DST_BIT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_DST_BIT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_DST_BIT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_STORAGE_BUFFER_BIT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_STORAGE_BUFFER_BIT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_STORAGE_BUFFER_BIT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_INDEX_BUFFER_BIT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_INDEX_BUFFER_BIT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_INDEX_BUFFER_BIT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_VERTEX_BUFFER_BIT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_VERTEX_BUFFER_BIT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_VERTEX_BUFFER_BIT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_RAY_TRACING_BIT_NV as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_RAY_TRACING_BIT_NV as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_RAY_TRACING_BIT_NV");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR");
	}
	if (value & VkBufferUsageFlagBits::VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM as VkBufferUsageFlags) == VkBufferUsageFlagBits::VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM as VkBufferUsageFlags {
		flags.push("VkBufferUsageFlagBits::VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkBufferViewCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferViewCreateFlags.html>
pub type VkBufferViewCreateFlags = VkFlags;
/// type definition `VkImageViewCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageViewCreateFlags.html>
pub type VkImageViewCreateFlags = VkFlags;
pub fn vk_image_view_create_flags_to_string(value: VkImageViewCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(4);
	if (value & VkImageViewCreateFlagBits::VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT as VkImageViewCreateFlags) == VkImageViewCreateFlagBits::VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT as VkImageViewCreateFlags {
		flags.push("VkImageViewCreateFlagBits::VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT");
	}
	if (value & VkImageViewCreateFlagBits::VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT as VkImageViewCreateFlags) == VkImageViewCreateFlagBits::VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT as VkImageViewCreateFlags {
		flags.push("VkImageViewCreateFlagBits::VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT");
	}
	if (value & VkImageViewCreateFlagBits::VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT as VkImageViewCreateFlags) == VkImageViewCreateFlagBits::VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT as VkImageViewCreateFlags {
		flags.push("VkImageViewCreateFlagBits::VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT");
	}
	if (value & VkImageViewCreateFlagBits::VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM as VkImageViewCreateFlags) == VkImageViewCreateFlagBits::VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM as VkImageViewCreateFlags {
		flags.push("VkImageViewCreateFlagBits::VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkShaderModuleCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderModuleCreateFlags.html>
pub type VkShaderModuleCreateFlags = VkFlags;
/// type definition `VkPipelineCacheCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCacheCreateFlags.html>
pub type VkPipelineCacheCreateFlags = VkFlags;
pub fn vk_pipeline_cache_create_flags_to_string(value: VkPipelineCacheCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(4);
	if (value & VkPipelineCacheCreateFlagBits::VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT as VkPipelineCacheCreateFlags) == VkPipelineCacheCreateFlagBits::VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT as VkPipelineCacheCreateFlags {
		flags.push("VkPipelineCacheCreateFlagBits::VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT");
	}
	if (value & VkPipelineCacheCreateFlagBits::VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR as VkPipelineCacheCreateFlags) == VkPipelineCacheCreateFlagBits::VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR as VkPipelineCacheCreateFlags {
		flags.push("VkPipelineCacheCreateFlagBits::VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR");
	}
	if (value & VkPipelineCacheCreateFlagBits::VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT as VkPipelineCacheCreateFlags) == VkPipelineCacheCreateFlagBits::VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT as VkPipelineCacheCreateFlags {
		flags.push("VkPipelineCacheCreateFlagBits::VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT");
	}
	if (value & VkPipelineCacheCreateFlagBits::VK_PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM as VkPipelineCacheCreateFlags) == VkPipelineCacheCreateFlagBits::VK_PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM as VkPipelineCacheCreateFlags {
		flags.push("VkPipelineCacheCreateFlagBits::VK_PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkColorComponentFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkColorComponentFlags.html>
pub type VkColorComponentFlags = VkFlags;
pub fn vk_color_component_flags_to_string(value: VkColorComponentFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(5);
	if (value & VkColorComponentFlagBits::VK_COLOR_COMPONENT_R_BIT as VkColorComponentFlags) == VkColorComponentFlagBits::VK_COLOR_COMPONENT_R_BIT as VkColorComponentFlags {
		flags.push("VkColorComponentFlagBits::VK_COLOR_COMPONENT_R_BIT");
	}
	if (value & VkColorComponentFlagBits::VK_COLOR_COMPONENT_G_BIT as VkColorComponentFlags) == VkColorComponentFlagBits::VK_COLOR_COMPONENT_G_BIT as VkColorComponentFlags {
		flags.push("VkColorComponentFlagBits::VK_COLOR_COMPONENT_G_BIT");
	}
	if (value & VkColorComponentFlagBits::VK_COLOR_COMPONENT_B_BIT as VkColorComponentFlags) == VkColorComponentFlagBits::VK_COLOR_COMPONENT_B_BIT as VkColorComponentFlags {
		flags.push("VkColorComponentFlagBits::VK_COLOR_COMPONENT_B_BIT");
	}
	if (value & VkColorComponentFlagBits::VK_COLOR_COMPONENT_A_BIT as VkColorComponentFlags) == VkColorComponentFlagBits::VK_COLOR_COMPONENT_A_BIT as VkColorComponentFlags {
		flags.push("VkColorComponentFlagBits::VK_COLOR_COMPONENT_A_BIT");
	}
	if (value & VkColorComponentFlagBits::VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM as VkColorComponentFlags) == VkColorComponentFlagBits::VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM as VkColorComponentFlags {
		flags.push("VkColorComponentFlagBits::VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkPipelineCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreateFlags.html>
pub type VkPipelineCreateFlags = VkFlags;
pub fn vk_pipeline_create_flags_to_string(value: VkPipelineCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(42);
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DERIVATIVE_BIT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DERIVATIVE_BIT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DERIVATIVE_BIT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_BIT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_BIT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_BIT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_LIBRARY_BIT_KHR as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_LIBRARY_BIT_KHR as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_LIBRARY_BIT_KHR");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_BIT_KHR as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_BIT_KHR as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_BIT_KHR");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_KHR as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_KHR as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_KHR");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT");
	}
	if (value & VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM as VkPipelineCreateFlags) == VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM as VkPipelineCreateFlags {
		flags.push("VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkPipelineShaderStageCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineShaderStageCreateFlags.html>
pub type VkPipelineShaderStageCreateFlags = VkFlags;
pub fn vk_pipeline_shader_stage_create_flags_to_string(value: VkPipelineShaderStageCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(5);
	if (value & VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT as VkPipelineShaderStageCreateFlags) == VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT as VkPipelineShaderStageCreateFlags {
		flags.push("VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT");
	}
	if (value & VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT as VkPipelineShaderStageCreateFlags) == VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT as VkPipelineShaderStageCreateFlags {
		flags.push("VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT");
	}
	if (value & VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT as VkPipelineShaderStageCreateFlags) == VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT as VkPipelineShaderStageCreateFlags {
		flags.push("VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT");
	}
	if (value & VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT as VkPipelineShaderStageCreateFlags) == VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT as VkPipelineShaderStageCreateFlags {
		flags.push("VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT");
	}
	if (value & VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM as VkPipelineShaderStageCreateFlags) == VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM as VkPipelineShaderStageCreateFlags {
		flags.push("VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkCullModeFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCullModeFlags.html>
pub type VkCullModeFlags = VkFlags;
pub fn vk_cull_mode_flags_to_string(value: VkCullModeFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(5);
	if (value & VkCullModeFlagBits::VK_CULL_MODE_NONE as VkCullModeFlags) == VkCullModeFlagBits::VK_CULL_MODE_NONE as VkCullModeFlags {
		flags.push("VkCullModeFlagBits::VK_CULL_MODE_NONE");
	}
	if (value & VkCullModeFlagBits::VK_CULL_MODE_FRONT_BIT as VkCullModeFlags) == VkCullModeFlagBits::VK_CULL_MODE_FRONT_BIT as VkCullModeFlags {
		flags.push("VkCullModeFlagBits::VK_CULL_MODE_FRONT_BIT");
	}
	if (value & VkCullModeFlagBits::VK_CULL_MODE_BACK_BIT as VkCullModeFlags) == VkCullModeFlagBits::VK_CULL_MODE_BACK_BIT as VkCullModeFlags {
		flags.push("VkCullModeFlagBits::VK_CULL_MODE_BACK_BIT");
	}
	if (value & VkCullModeFlagBits::VK_CULL_MODE_FRONT_AND_BACK as VkCullModeFlags) == VkCullModeFlagBits::VK_CULL_MODE_FRONT_AND_BACK as VkCullModeFlags {
		flags.push("VkCullModeFlagBits::VK_CULL_MODE_FRONT_AND_BACK");
	}
	if (value & VkCullModeFlagBits::VK_CULL_MODE_FLAG_BITS_MAX_ENUM as VkCullModeFlags) == VkCullModeFlagBits::VK_CULL_MODE_FLAG_BITS_MAX_ENUM as VkCullModeFlags {
		flags.push("VkCullModeFlagBits::VK_CULL_MODE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkPipelineVertexInputStateCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineVertexInputStateCreateFlags.html>
pub type VkPipelineVertexInputStateCreateFlags = VkFlags;
/// type definition `VkPipelineInputAssemblyStateCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineInputAssemblyStateCreateFlags.html>
pub type VkPipelineInputAssemblyStateCreateFlags = VkFlags;
/// type definition `VkPipelineTessellationStateCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineTessellationStateCreateFlags.html>
pub type VkPipelineTessellationStateCreateFlags = VkFlags;
/// type definition `VkPipelineViewportStateCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineViewportStateCreateFlags.html>
pub type VkPipelineViewportStateCreateFlags = VkFlags;
/// type definition `VkPipelineRasterizationStateCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRasterizationStateCreateFlags.html>
pub type VkPipelineRasterizationStateCreateFlags = VkFlags;
/// type definition `VkPipelineMultisampleStateCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineMultisampleStateCreateFlags.html>
pub type VkPipelineMultisampleStateCreateFlags = VkFlags;
/// type definition `VkPipelineDepthStencilStateCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineDepthStencilStateCreateFlags.html>
pub type VkPipelineDepthStencilStateCreateFlags = VkFlags;
pub fn vk_pipeline_depth_stencil_state_create_flags_to_string(value: VkPipelineDepthStencilStateCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(5);
	if (value & VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT as VkPipelineDepthStencilStateCreateFlags) == VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT as VkPipelineDepthStencilStateCreateFlags {
		flags.push("VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT");
	}
	if (value & VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT as VkPipelineDepthStencilStateCreateFlags) == VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT as VkPipelineDepthStencilStateCreateFlags {
		flags.push("VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT");
	}
	if (value & VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM as VkPipelineDepthStencilStateCreateFlags) == VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM as VkPipelineDepthStencilStateCreateFlags {
		flags.push("VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM");
	}
	if (value & VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM as VkPipelineDepthStencilStateCreateFlags) == VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM as VkPipelineDepthStencilStateCreateFlags {
		flags.push("VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM");
	}
	if (value & VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_FLAG_BITS_MAX_ENUM as VkPipelineDepthStencilStateCreateFlags) == VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_FLAG_BITS_MAX_ENUM as VkPipelineDepthStencilStateCreateFlags {
		flags.push("VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkPipelineColorBlendStateCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineColorBlendStateCreateFlags.html>
pub type VkPipelineColorBlendStateCreateFlags = VkFlags;
pub fn vk_pipeline_color_blend_state_create_flags_to_string(value: VkPipelineColorBlendStateCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(3);
	if (value & VkPipelineColorBlendStateCreateFlagBits::VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT as VkPipelineColorBlendStateCreateFlags) == VkPipelineColorBlendStateCreateFlagBits::VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT as VkPipelineColorBlendStateCreateFlags {
		flags.push("VkPipelineColorBlendStateCreateFlagBits::VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT");
	}
	if (value & VkPipelineColorBlendStateCreateFlagBits::VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM as VkPipelineColorBlendStateCreateFlags) == VkPipelineColorBlendStateCreateFlagBits::VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM as VkPipelineColorBlendStateCreateFlags {
		flags.push("VkPipelineColorBlendStateCreateFlagBits::VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM");
	}
	if (value & VkPipelineColorBlendStateCreateFlagBits::VK_PIPELINE_COLOR_BLEND_STATE_CREATE_FLAG_BITS_MAX_ENUM as VkPipelineColorBlendStateCreateFlags) == VkPipelineColorBlendStateCreateFlagBits::VK_PIPELINE_COLOR_BLEND_STATE_CREATE_FLAG_BITS_MAX_ENUM as VkPipelineColorBlendStateCreateFlags {
		flags.push("VkPipelineColorBlendStateCreateFlagBits::VK_PIPELINE_COLOR_BLEND_STATE_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkPipelineDynamicStateCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineDynamicStateCreateFlags.html>
pub type VkPipelineDynamicStateCreateFlags = VkFlags;
/// type definition `VkPipelineLayoutCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateFlags.html>
pub type VkPipelineLayoutCreateFlags = VkFlags;
pub fn vk_pipeline_layout_create_flags_to_string(value: VkPipelineLayoutCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(2);
	if (value & VkPipelineLayoutCreateFlagBits::VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT as VkPipelineLayoutCreateFlags) == VkPipelineLayoutCreateFlagBits::VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT as VkPipelineLayoutCreateFlags {
		flags.push("VkPipelineLayoutCreateFlagBits::VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT");
	}
	if (value & VkPipelineLayoutCreateFlagBits::VK_PIPELINE_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM as VkPipelineLayoutCreateFlags) == VkPipelineLayoutCreateFlagBits::VK_PIPELINE_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM as VkPipelineLayoutCreateFlags {
		flags.push("VkPipelineLayoutCreateFlagBits::VK_PIPELINE_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkShaderStageFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderStageFlags.html>
pub type VkShaderStageFlags = VkFlags;
pub fn vk_shader_stage_flags_to_string(value: VkShaderStageFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(27);
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_VERTEX_BIT as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_VERTEX_BIT as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_VERTEX_BIT");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_GEOMETRY_BIT as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_GEOMETRY_BIT as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_GEOMETRY_BIT");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_FRAGMENT_BIT as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_FRAGMENT_BIT as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_FRAGMENT_BIT");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_ALL_GRAPHICS as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_ALL_GRAPHICS as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_ALL_GRAPHICS");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_ALL as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_ALL as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_ALL");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_RAYGEN_BIT_KHR as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_RAYGEN_BIT_KHR as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_RAYGEN_BIT_KHR");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_ANY_HIT_BIT_KHR as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_ANY_HIT_BIT_KHR as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_ANY_HIT_BIT_KHR");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_MISS_BIT_KHR as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_MISS_BIT_KHR as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_MISS_BIT_KHR");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_INTERSECTION_BIT_KHR as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_INTERSECTION_BIT_KHR as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_INTERSECTION_BIT_KHR");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_CALLABLE_BIT_KHR as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_CALLABLE_BIT_KHR as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_CALLABLE_BIT_KHR");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_TASK_BIT_EXT as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_TASK_BIT_EXT as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_TASK_BIT_EXT");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_MESH_BIT_EXT as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_MESH_BIT_EXT as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_MESH_BIT_EXT");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_RAYGEN_BIT_NV as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_RAYGEN_BIT_NV as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_RAYGEN_BIT_NV");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_ANY_HIT_BIT_NV as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_ANY_HIT_BIT_NV as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_ANY_HIT_BIT_NV");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_MISS_BIT_NV as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_MISS_BIT_NV as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_MISS_BIT_NV");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_INTERSECTION_BIT_NV as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_INTERSECTION_BIT_NV as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_INTERSECTION_BIT_NV");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_CALLABLE_BIT_NV as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_CALLABLE_BIT_NV as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_CALLABLE_BIT_NV");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_TASK_BIT_NV as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_TASK_BIT_NV as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_TASK_BIT_NV");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_MESH_BIT_NV as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_MESH_BIT_NV as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_MESH_BIT_NV");
	}
	if (value & VkShaderStageFlagBits::VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM as VkShaderStageFlags) == VkShaderStageFlagBits::VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM as VkShaderStageFlags {
		flags.push("VkShaderStageFlagBits::VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkSamplerCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerCreateFlags.html>
pub type VkSamplerCreateFlags = VkFlags;
pub fn vk_sampler_create_flags_to_string(value: VkSamplerCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(6);
	if (value & VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT as VkSamplerCreateFlags) == VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT as VkSamplerCreateFlags {
		flags.push("VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT");
	}
	if (value & VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT as VkSamplerCreateFlags) == VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT as VkSamplerCreateFlags {
		flags.push("VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT");
	}
	if (value & VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT as VkSamplerCreateFlags) == VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT as VkSamplerCreateFlags {
		flags.push("VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT");
	}
	if (value & VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT as VkSamplerCreateFlags) == VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT as VkSamplerCreateFlags {
		flags.push("VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT");
	}
	if (value & VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM as VkSamplerCreateFlags) == VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM as VkSamplerCreateFlags {
		flags.push("VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM");
	}
	if (value & VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM as VkSamplerCreateFlags) == VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM as VkSamplerCreateFlags {
		flags.push("VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkDescriptorPoolCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolCreateFlags.html>
pub type VkDescriptorPoolCreateFlags = VkFlags;
pub fn vk_descriptor_pool_create_flags_to_string(value: VkDescriptorPoolCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(8);
	if (value & VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT as VkDescriptorPoolCreateFlags) == VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT as VkDescriptorPoolCreateFlags {
		flags.push("VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT");
	}
	if (value & VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT as VkDescriptorPoolCreateFlags) == VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT as VkDescriptorPoolCreateFlags {
		flags.push("VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT");
	}
	if (value & VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT as VkDescriptorPoolCreateFlags) == VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT as VkDescriptorPoolCreateFlags {
		flags.push("VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT");
	}
	if (value & VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV as VkDescriptorPoolCreateFlags) == VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV as VkDescriptorPoolCreateFlags {
		flags.push("VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV");
	}
	if (value & VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV as VkDescriptorPoolCreateFlags) == VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV as VkDescriptorPoolCreateFlags {
		flags.push("VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV");
	}
	if (value & VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT as VkDescriptorPoolCreateFlags) == VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT as VkDescriptorPoolCreateFlags {
		flags.push("VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT");
	}
	if (value & VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE as VkDescriptorPoolCreateFlags) == VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE as VkDescriptorPoolCreateFlags {
		flags.push("VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE");
	}
	if (value & VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM as VkDescriptorPoolCreateFlags) == VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM as VkDescriptorPoolCreateFlags {
		flags.push("VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkDescriptorPoolResetFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolResetFlags.html>
pub type VkDescriptorPoolResetFlags = VkFlags;
/// type definition `VkDescriptorSetLayoutCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutCreateFlags.html>
pub type VkDescriptorSetLayoutCreateFlags = VkFlags;
pub fn vk_descriptor_set_layout_create_flags_to_string(value: VkDescriptorSetLayoutCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(11);
	if (value & VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT as VkDescriptorSetLayoutCreateFlags) == VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT as VkDescriptorSetLayoutCreateFlags {
		flags.push("VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT");
	}
	if (value & VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT as VkDescriptorSetLayoutCreateFlags) == VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT as VkDescriptorSetLayoutCreateFlags {
		flags.push("VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT");
	}
	if (value & VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT as VkDescriptorSetLayoutCreateFlags) == VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT as VkDescriptorSetLayoutCreateFlags {
		flags.push("VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT");
	}
	if (value & VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT as VkDescriptorSetLayoutCreateFlags) == VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT as VkDescriptorSetLayoutCreateFlags {
		flags.push("VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT");
	}
	if (value & VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV as VkDescriptorSetLayoutCreateFlags) == VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV as VkDescriptorSetLayoutCreateFlags {
		flags.push("VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV");
	}
	if (value & VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT as VkDescriptorSetLayoutCreateFlags) == VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT as VkDescriptorSetLayoutCreateFlags {
		flags.push("VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT");
	}
	if (value & VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV as VkDescriptorSetLayoutCreateFlags) == VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV as VkDescriptorSetLayoutCreateFlags {
		flags.push("VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV");
	}
	if (value & VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR as VkDescriptorSetLayoutCreateFlags) == VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR as VkDescriptorSetLayoutCreateFlags {
		flags.push("VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR");
	}
	if (value & VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT as VkDescriptorSetLayoutCreateFlags) == VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT as VkDescriptorSetLayoutCreateFlags {
		flags.push("VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT");
	}
	if (value & VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE as VkDescriptorSetLayoutCreateFlags) == VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE as VkDescriptorSetLayoutCreateFlags {
		flags.push("VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE");
	}
	if (value & VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM as VkDescriptorSetLayoutCreateFlags) == VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM as VkDescriptorSetLayoutCreateFlags {
		flags.push("VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkAttachmentDescriptionFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentDescriptionFlags.html>
pub type VkAttachmentDescriptionFlags = VkFlags;
pub fn vk_attachment_description_flags_to_string(value: VkAttachmentDescriptionFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(2);
	if (value & VkAttachmentDescriptionFlagBits::VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT as VkAttachmentDescriptionFlags) == VkAttachmentDescriptionFlagBits::VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT as VkAttachmentDescriptionFlags {
		flags.push("VkAttachmentDescriptionFlagBits::VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT");
	}
	if (value & VkAttachmentDescriptionFlagBits::VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM as VkAttachmentDescriptionFlags) == VkAttachmentDescriptionFlagBits::VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM as VkAttachmentDescriptionFlags {
		flags.push("VkAttachmentDescriptionFlagBits::VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkDependencyFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDependencyFlags.html>
pub type VkDependencyFlags = VkFlags;
pub fn vk_dependency_flags_to_string(value: VkDependencyFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(9);
	if (value & VkDependencyFlagBits::VK_DEPENDENCY_BY_REGION_BIT as VkDependencyFlags) == VkDependencyFlagBits::VK_DEPENDENCY_BY_REGION_BIT as VkDependencyFlags {
		flags.push("VkDependencyFlagBits::VK_DEPENDENCY_BY_REGION_BIT");
	}
	if (value & VkDependencyFlagBits::VK_DEPENDENCY_DEVICE_GROUP_BIT as VkDependencyFlags) == VkDependencyFlagBits::VK_DEPENDENCY_DEVICE_GROUP_BIT as VkDependencyFlags {
		flags.push("VkDependencyFlagBits::VK_DEPENDENCY_DEVICE_GROUP_BIT");
	}
	if (value & VkDependencyFlagBits::VK_DEPENDENCY_VIEW_LOCAL_BIT as VkDependencyFlags) == VkDependencyFlagBits::VK_DEPENDENCY_VIEW_LOCAL_BIT as VkDependencyFlags {
		flags.push("VkDependencyFlagBits::VK_DEPENDENCY_VIEW_LOCAL_BIT");
	}
	if (value & VkDependencyFlagBits::VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT as VkDependencyFlags) == VkDependencyFlagBits::VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT as VkDependencyFlags {
		flags.push("VkDependencyFlagBits::VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT");
	}
	if (value & VkDependencyFlagBits::VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR as VkDependencyFlags) == VkDependencyFlagBits::VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR as VkDependencyFlags {
		flags.push("VkDependencyFlagBits::VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR");
	}
	if (value & VkDependencyFlagBits::VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR as VkDependencyFlags) == VkDependencyFlagBits::VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR as VkDependencyFlags {
		flags.push("VkDependencyFlagBits::VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR");
	}
	if (value & VkDependencyFlagBits::VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR as VkDependencyFlags) == VkDependencyFlagBits::VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR as VkDependencyFlags {
		flags.push("VkDependencyFlagBits::VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR");
	}
	if (value & VkDependencyFlagBits::VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR as VkDependencyFlags) == VkDependencyFlagBits::VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR as VkDependencyFlags {
		flags.push("VkDependencyFlagBits::VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR");
	}
	if (value & VkDependencyFlagBits::VK_DEPENDENCY_FLAG_BITS_MAX_ENUM as VkDependencyFlags) == VkDependencyFlagBits::VK_DEPENDENCY_FLAG_BITS_MAX_ENUM as VkDependencyFlags {
		flags.push("VkDependencyFlagBits::VK_DEPENDENCY_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkFramebufferCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFramebufferCreateFlags.html>
pub type VkFramebufferCreateFlags = VkFlags;
pub fn vk_framebuffer_create_flags_to_string(value: VkFramebufferCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(3);
	if (value & VkFramebufferCreateFlagBits::VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT as VkFramebufferCreateFlags) == VkFramebufferCreateFlagBits::VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT as VkFramebufferCreateFlags {
		flags.push("VkFramebufferCreateFlagBits::VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT");
	}
	if (value & VkFramebufferCreateFlagBits::VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR as VkFramebufferCreateFlags) == VkFramebufferCreateFlagBits::VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR as VkFramebufferCreateFlags {
		flags.push("VkFramebufferCreateFlagBits::VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR");
	}
	if (value & VkFramebufferCreateFlagBits::VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM as VkFramebufferCreateFlags) == VkFramebufferCreateFlagBits::VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM as VkFramebufferCreateFlags {
		flags.push("VkFramebufferCreateFlagBits::VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkRenderPassCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassCreateFlags.html>
pub type VkRenderPassCreateFlags = VkFlags;
pub fn vk_render_pass_create_flags_to_string(value: VkRenderPassCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(3);
	if (value & VkRenderPassCreateFlagBits::VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM as VkRenderPassCreateFlags) == VkRenderPassCreateFlagBits::VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM as VkRenderPassCreateFlags {
		flags.push("VkRenderPassCreateFlagBits::VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM");
	}
	if (value & VkRenderPassCreateFlagBits::VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE as VkRenderPassCreateFlags) == VkRenderPassCreateFlagBits::VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE as VkRenderPassCreateFlags {
		flags.push("VkRenderPassCreateFlagBits::VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE");
	}
	if (value & VkRenderPassCreateFlagBits::VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM as VkRenderPassCreateFlags) == VkRenderPassCreateFlagBits::VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM as VkRenderPassCreateFlags {
		flags.push("VkRenderPassCreateFlagBits::VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkSubpassDescriptionFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassDescriptionFlags.html>
pub type VkSubpassDescriptionFlags = VkFlags;
pub fn vk_subpass_description_flags_to_string(value: VkSubpassDescriptionFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(13);
	if (value & VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX as VkSubpassDescriptionFlags) == VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX as VkSubpassDescriptionFlags {
		flags.push("VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX");
	}
	if (value & VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX as VkSubpassDescriptionFlags) == VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX as VkSubpassDescriptionFlags {
		flags.push("VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX");
	}
	if (value & VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM as VkSubpassDescriptionFlags) == VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM as VkSubpassDescriptionFlags {
		flags.push("VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM");
	}
	if (value & VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM as VkSubpassDescriptionFlags) == VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM as VkSubpassDescriptionFlags {
		flags.push("VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM");
	}
	if (value & VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM as VkSubpassDescriptionFlags) == VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM as VkSubpassDescriptionFlags {
		flags.push("VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM");
	}
	if (value & VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT as VkSubpassDescriptionFlags) == VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT as VkSubpassDescriptionFlags {
		flags.push("VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT");
	}
	if (value & VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT as VkSubpassDescriptionFlags) == VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT as VkSubpassDescriptionFlags {
		flags.push("VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT");
	}
	if (value & VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT as VkSubpassDescriptionFlags) == VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT as VkSubpassDescriptionFlags {
		flags.push("VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT");
	}
	if (value & VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT as VkSubpassDescriptionFlags) == VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT as VkSubpassDescriptionFlags {
		flags.push("VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT");
	}
	if (value & VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM as VkSubpassDescriptionFlags) == VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM as VkSubpassDescriptionFlags {
		flags.push("VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM");
	}
	if (value & VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM as VkSubpassDescriptionFlags) == VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM as VkSubpassDescriptionFlags {
		flags.push("VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM");
	}
	if (value & VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM as VkSubpassDescriptionFlags) == VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM as VkSubpassDescriptionFlags {
		flags.push("VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM");
	}
	if (value & VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM as VkSubpassDescriptionFlags) == VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM as VkSubpassDescriptionFlags {
		flags.push("VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkCommandPoolCreateFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandPoolCreateFlags.html>
pub type VkCommandPoolCreateFlags = VkFlags;
pub fn vk_command_pool_create_flags_to_string(value: VkCommandPoolCreateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(4);
	if (value & VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_TRANSIENT_BIT as VkCommandPoolCreateFlags) == VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_TRANSIENT_BIT as VkCommandPoolCreateFlags {
		flags.push("VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_TRANSIENT_BIT");
	}
	if (value & VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT as VkCommandPoolCreateFlags) == VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT as VkCommandPoolCreateFlags {
		flags.push("VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT");
	}
	if (value & VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_PROTECTED_BIT as VkCommandPoolCreateFlags) == VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_PROTECTED_BIT as VkCommandPoolCreateFlags {
		flags.push("VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_PROTECTED_BIT");
	}
	if (value & VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM as VkCommandPoolCreateFlags) == VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM as VkCommandPoolCreateFlags {
		flags.push("VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkCommandPoolResetFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandPoolResetFlags.html>
pub type VkCommandPoolResetFlags = VkFlags;
pub fn vk_command_pool_reset_flags_to_string(value: VkCommandPoolResetFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(2);
	if (value & VkCommandPoolResetFlagBits::VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT as VkCommandPoolResetFlags) == VkCommandPoolResetFlagBits::VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT as VkCommandPoolResetFlags {
		flags.push("VkCommandPoolResetFlagBits::VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT");
	}
	if (value & VkCommandPoolResetFlagBits::VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM as VkCommandPoolResetFlags) == VkCommandPoolResetFlagBits::VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM as VkCommandPoolResetFlags {
		flags.push("VkCommandPoolResetFlagBits::VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkCommandBufferUsageFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferUsageFlags.html>
pub type VkCommandBufferUsageFlags = VkFlags;
pub fn vk_command_buffer_usage_flags_to_string(value: VkCommandBufferUsageFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(4);
	if (value & VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT as VkCommandBufferUsageFlags) == VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT as VkCommandBufferUsageFlags {
		flags.push("VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT");
	}
	if (value & VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT as VkCommandBufferUsageFlags) == VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT as VkCommandBufferUsageFlags {
		flags.push("VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT");
	}
	if (value & VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT as VkCommandBufferUsageFlags) == VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT as VkCommandBufferUsageFlags {
		flags.push("VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT");
	}
	if (value & VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM as VkCommandBufferUsageFlags) == VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM as VkCommandBufferUsageFlags {
		flags.push("VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkQueryControlFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryControlFlags.html>
pub type VkQueryControlFlags = VkFlags;
pub fn vk_query_control_flags_to_string(value: VkQueryControlFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(2);
	if (value & VkQueryControlFlagBits::VK_QUERY_CONTROL_PRECISE_BIT as VkQueryControlFlags) == VkQueryControlFlagBits::VK_QUERY_CONTROL_PRECISE_BIT as VkQueryControlFlags {
		flags.push("VkQueryControlFlagBits::VK_QUERY_CONTROL_PRECISE_BIT");
	}
	if (value & VkQueryControlFlagBits::VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM as VkQueryControlFlags) == VkQueryControlFlagBits::VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM as VkQueryControlFlags {
		flags.push("VkQueryControlFlagBits::VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkCommandBufferResetFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferResetFlags.html>
pub type VkCommandBufferResetFlags = VkFlags;
pub fn vk_command_buffer_reset_flags_to_string(value: VkCommandBufferResetFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(2);
	if (value & VkCommandBufferResetFlagBits::VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT as VkCommandBufferResetFlags) == VkCommandBufferResetFlagBits::VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT as VkCommandBufferResetFlags {
		flags.push("VkCommandBufferResetFlagBits::VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT");
	}
	if (value & VkCommandBufferResetFlagBits::VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM as VkCommandBufferResetFlags) == VkCommandBufferResetFlagBits::VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM as VkCommandBufferResetFlags {
		flags.push("VkCommandBufferResetFlagBits::VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkStencilFaceFlags` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkStencilFaceFlags.html>
pub type VkStencilFaceFlags = VkFlags;
pub fn vk_stencil_face_flags_to_string(value: VkStencilFaceFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(5);
	if (value & VkStencilFaceFlagBits::VK_STENCIL_FACE_FRONT_BIT as VkStencilFaceFlags) == VkStencilFaceFlagBits::VK_STENCIL_FACE_FRONT_BIT as VkStencilFaceFlags {
		flags.push("VkStencilFaceFlagBits::VK_STENCIL_FACE_FRONT_BIT");
	}
	if (value & VkStencilFaceFlagBits::VK_STENCIL_FACE_BACK_BIT as VkStencilFaceFlags) == VkStencilFaceFlagBits::VK_STENCIL_FACE_BACK_BIT as VkStencilFaceFlags {
		flags.push("VkStencilFaceFlagBits::VK_STENCIL_FACE_BACK_BIT");
	}
	if (value & VkStencilFaceFlagBits::VK_STENCIL_FACE_FRONT_AND_BACK as VkStencilFaceFlags) == VkStencilFaceFlagBits::VK_STENCIL_FACE_FRONT_AND_BACK as VkStencilFaceFlags {
		flags.push("VkStencilFaceFlagBits::VK_STENCIL_FACE_FRONT_AND_BACK");
	}
	if (value & VkStencilFaceFlagBits::VK_STENCIL_FRONT_AND_BACK as VkStencilFaceFlags) == VkStencilFaceFlagBits::VK_STENCIL_FRONT_AND_BACK as VkStencilFaceFlags {
		flags.push("VkStencilFaceFlagBits::VK_STENCIL_FRONT_AND_BACK");
	}
	if (value & VkStencilFaceFlagBits::VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM as VkStencilFaceFlags) == VkStencilFaceFlagBits::VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM as VkStencilFaceFlags {
		flags.push("VkStencilFaceFlagBits::VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// Normal handle `VkInstance` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkInstance.html>
#[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkInstance_T {_unused: u32,}
pub type VkInstance = *const VkInstance_T;
/// Normal handle `VkPhysicalDevice` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevice.html>
#[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkPhysicalDevice_T {_unused: u32,}
pub type VkPhysicalDevice = *const VkPhysicalDevice_T;
/// Normal handle `VkDevice` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDevice.html>
#[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkDevice_T {_unused: u32,}
pub type VkDevice = *const VkDevice_T;
/// Normal handle `VkQueue` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueue.html>
#[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkQueue_T {_unused: u32,}
pub type VkQueue = *const VkQueue_T;
/// Normal handle `VkCommandBuffer` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBuffer.html>
#[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkCommandBuffer_T {_unused: u32,}
pub type VkCommandBuffer = *const VkCommandBuffer_T;
/// Non-dispatchable handle `VkBuffer` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBuffer.html
#[cfg(target_pointer_width = "32")] pub type VkBuffer = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkBuffer_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkBuffer = *const VkBuffer_T;
/// Non-dispatchable handle `VkImage` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImage.html
#[cfg(target_pointer_width = "32")] pub type VkImage = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkImage_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkImage = *const VkImage_T;
/// Non-dispatchable handle `VkSemaphore` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphore.html
#[cfg(target_pointer_width = "32")] pub type VkSemaphore = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkSemaphore_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkSemaphore = *const VkSemaphore_T;
/// Non-dispatchable handle `VkFence` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFence.html
#[cfg(target_pointer_width = "32")] pub type VkFence = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkFence_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkFence = *const VkFence_T;
/// Non-dispatchable handle `VkDeviceMemory` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceMemory.html
#[cfg(target_pointer_width = "32")] pub type VkDeviceMemory = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkDeviceMemory_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkDeviceMemory = *const VkDeviceMemory_T;
/// Non-dispatchable handle `VkEvent` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkEvent.html
#[cfg(target_pointer_width = "32")] pub type VkEvent = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkEvent_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkEvent = *const VkEvent_T;
/// Non-dispatchable handle `VkQueryPool` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryPool.html
#[cfg(target_pointer_width = "32")] pub type VkQueryPool = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkQueryPool_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkQueryPool = *const VkQueryPool_T;
/// Non-dispatchable handle `VkBufferView` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferView.html
#[cfg(target_pointer_width = "32")] pub type VkBufferView = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkBufferView_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkBufferView = *const VkBufferView_T;
/// Non-dispatchable handle `VkImageView` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageView.html
#[cfg(target_pointer_width = "32")] pub type VkImageView = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkImageView_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkImageView = *const VkImageView_T;
/// Non-dispatchable handle `VkShaderModule` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderModule.html
#[cfg(target_pointer_width = "32")] pub type VkShaderModule = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkShaderModule_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkShaderModule = *const VkShaderModule_T;
/// Non-dispatchable handle `VkPipelineCache` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCache.html
#[cfg(target_pointer_width = "32")] pub type VkPipelineCache = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkPipelineCache_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkPipelineCache = *const VkPipelineCache_T;
/// Non-dispatchable handle `VkPipelineLayout` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayout.html
#[cfg(target_pointer_width = "32")] pub type VkPipelineLayout = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkPipelineLayout_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkPipelineLayout = *const VkPipelineLayout_T;
/// Non-dispatchable handle `VkPipeline` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipeline.html
#[cfg(target_pointer_width = "32")] pub type VkPipeline = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkPipeline_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkPipeline = *const VkPipeline_T;
/// Non-dispatchable handle `VkRenderPass` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPass.html
#[cfg(target_pointer_width = "32")] pub type VkRenderPass = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkRenderPass_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkRenderPass = *const VkRenderPass_T;
/// Non-dispatchable handle `VkDescriptorSetLayout` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayout.html
#[cfg(target_pointer_width = "32")] pub type VkDescriptorSetLayout = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkDescriptorSetLayout_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkDescriptorSetLayout = *const VkDescriptorSetLayout_T;
/// Non-dispatchable handle `VkSampler` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSampler.html
#[cfg(target_pointer_width = "32")] pub type VkSampler = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkSampler_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkSampler = *const VkSampler_T;
/// Non-dispatchable handle `VkDescriptorSet` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSet.html
#[cfg(target_pointer_width = "32")] pub type VkDescriptorSet = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkDescriptorSet_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkDescriptorSet = *const VkDescriptorSet_T;
/// Non-dispatchable handle `VkDescriptorPool` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPool.html
#[cfg(target_pointer_width = "32")] pub type VkDescriptorPool = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkDescriptorPool_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkDescriptorPool = *const VkDescriptorPool_T;
/// Non-dispatchable handle `VkFramebuffer` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFramebuffer.html
#[cfg(target_pointer_width = "32")] pub type VkFramebuffer = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkFramebuffer_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkFramebuffer = *const VkFramebuffer_T;
/// Non-dispatchable handle `VkCommandPool` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandPool.html
#[cfg(target_pointer_width = "32")] pub type VkCommandPool = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkCommandPool_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkCommandPool = *const VkCommandPool_T;
/// enum `VkResult` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkResult.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkResult {
	VK_SUCCESS = 0,
	VK_NOT_READY = 1,
	VK_TIMEOUT = 2,
	VK_EVENT_SET = 3,
	VK_EVENT_RESET = 4,
	VK_INCOMPLETE = 5,
	VK_ERROR_OUT_OF_HOST_MEMORY = -1,
	VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
	VK_ERROR_INITIALIZATION_FAILED = -3,
	VK_ERROR_DEVICE_LOST = -4,
	VK_ERROR_MEMORY_MAP_FAILED = -5,
	VK_ERROR_LAYER_NOT_PRESENT = -6,
	VK_ERROR_EXTENSION_NOT_PRESENT = -7,
	VK_ERROR_FEATURE_NOT_PRESENT = -8,
	VK_ERROR_INCOMPATIBLE_DRIVER = -9,
	VK_ERROR_TOO_MANY_OBJECTS = -10,
	VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
	VK_ERROR_FRAGMENTED_POOL = -12,
	VK_ERROR_UNKNOWN = -13,
	VK_ERROR_VALIDATION_FAILED = -1000011001,
	VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
	VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
	VK_ERROR_FRAGMENTATION = -1000161000,
	VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
	VK_PIPELINE_COMPILE_REQUIRED = 1000297000,
	VK_ERROR_NOT_PERMITTED = -1000174001,
	VK_ERROR_SURFACE_LOST_KHR = -1000000000,
	VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
	VK_SUBOPTIMAL_KHR = 1000001003,
	VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
	VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
	VK_ERROR_INVALID_SHADER_NV = -1000012000,
	VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR = -1000023000,
	VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR = -1000023001,
	VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR = -1000023002,
	VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR = -1000023003,
	VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR = -1000023004,
	VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = -1000023005,
	VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
	VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
	VK_THREAD_IDLE_KHR = 1000268000,
	VK_THREAD_DONE_KHR = 1000268001,
	VK_OPERATION_DEFERRED_KHR = 1000268002,
	VK_OPERATION_NOT_DEFERRED_KHR = 1000268003,
	VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR = -1000299000,
	VK_ERROR_COMPRESSION_EXHAUSTED_EXT = -1000338000,
	VK_INCOMPATIBLE_SHADER_BINARY_EXT = 1000482000,
	VK_PIPELINE_BINARY_MISSING_KHR = 1000483000,
	VK_ERROR_NOT_ENOUGH_SPACE_KHR = -1000483000,
	VK_RESULT_MAX_ENUM = 0x7fffffff,
}
impl VkResult {
	pub const VK_ERROR_VALIDATION_FAILED_EXT: VkResult = VkResult::VK_ERROR_VALIDATION_FAILED;
	pub const VK_ERROR_OUT_OF_POOL_MEMORY_KHR: VkResult = VkResult::VK_ERROR_OUT_OF_POOL_MEMORY;
	pub const VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR: VkResult = VkResult::VK_ERROR_INVALID_EXTERNAL_HANDLE;
	pub const VK_ERROR_FRAGMENTATION_EXT: VkResult = VkResult::VK_ERROR_FRAGMENTATION;
	pub const VK_ERROR_NOT_PERMITTED_EXT: VkResult = VkResult::VK_ERROR_NOT_PERMITTED;
	pub const VK_ERROR_NOT_PERMITTED_KHR: VkResult = VkResult::VK_ERROR_NOT_PERMITTED;
	pub const VK_ERROR_INVALID_DEVICE_ADDRESS_EXT: VkResult = VkResult::VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
	pub const VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR: VkResult = VkResult::VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
	pub const VK_PIPELINE_COMPILE_REQUIRED_EXT: VkResult = VkResult::VK_PIPELINE_COMPILE_REQUIRED;
	pub const VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT: VkResult = VkResult::VK_PIPELINE_COMPILE_REQUIRED;
	pub const VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT: VkResult = VkResult::VK_INCOMPATIBLE_SHADER_BINARY_EXT;
}
/// enum `VkStructureType` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkStructureType.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkStructureType {
	VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
	VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
	VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
	VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
	VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
	VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
	VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
	VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
	VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
	VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
	VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
	VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
	VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
	VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
	VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
	VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
	VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
	VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
	VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
	VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
	VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
	VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
	VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
	VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
	VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
	VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
	VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
	VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
	VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
	VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
	VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
	VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
	VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
	VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
	VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
	VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
	VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
	VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
	VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
	VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 49,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 50,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 51,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 52,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000,
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 1000109000,
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 1000109001,
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 1000109002,
	VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 1000109003,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 1000109004,
	VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 1000109005,
	VK_STRUCTURE_TYPE_SUBPASS_END_INFO = 1000109006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000,
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000,
	VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000,
	VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002,
	VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000,
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001,
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001,
	VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 1000207002,
	VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003,
	VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 1000207004,
	VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 1000207005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000,
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001,
	VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002,
	VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES = 53,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES = 54,
	VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO = 1000192000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES = 1000215000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES = 1000245000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES = 1000276000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES = 1000295000,
	VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO = 1000295001,
	VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO = 1000295002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES = 1000297000,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 = 1000314000,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 = 1000314001,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 = 1000314002,
	VK_STRUCTURE_TYPE_DEPENDENCY_INFO = 1000314003,
	VK_STRUCTURE_TYPE_SUBMIT_INFO_2 = 1000314004,
	VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO = 1000314005,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO = 1000314006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES = 1000314007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES = 1000325000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES = 1000335000,
	VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 = 1000337000,
	VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 = 1000337001,
	VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 = 1000337002,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 = 1000337003,
	VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 = 1000337004,
	VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 = 1000337005,
	VK_STRUCTURE_TYPE_BUFFER_COPY_2 = 1000337006,
	VK_STRUCTURE_TYPE_IMAGE_COPY_2 = 1000337007,
	VK_STRUCTURE_TYPE_IMAGE_BLIT_2 = 1000337008,
	VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 = 1000337009,
	VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 = 1000337010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES = 1000225000,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO = 1000225001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES = 1000225002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES = 1000138000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES = 1000138001,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK = 1000138002,
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO = 1000138003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES = 1000066000,
	VK_STRUCTURE_TYPE_RENDERING_INFO = 1000044000,
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO = 1000044001,
	VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO = 1000044002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES = 1000044003,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO = 1000044004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES = 1000280000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES = 1000280001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES = 1000281001,
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 = 1000360000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES = 1000413000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES = 1000413001,
	VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS = 1000413002,
	VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS = 1000413003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES = 55,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES = 56,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO = 1000174000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES = 1000388000,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES = 1000388001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES = 1000416000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES = 1000528000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES = 1000544000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES = 1000259000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO = 1000259001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES = 1000259002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES = 1000525000,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO = 1000190001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES = 1000190002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES = 1000265000,
	VK_STRUCTURE_TYPE_MEMORY_MAP_INFO = 1000271000,
	VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO = 1000271001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES = 1000470000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES = 1000470001,
	VK_STRUCTURE_TYPE_RENDERING_AREA_INFO = 1000470003,
	VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO = 1000470004,
	VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2 = 1000338002,
	VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2 = 1000338003,
	VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO = 1000470005,
	VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO = 1000470006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES = 1000080000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES = 1000232000,
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO = 1000232001,
	VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO = 1000232002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES = 1000545000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES = 1000545001,
	VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS = 1000545002,
	VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO = 1000545003,
	VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO = 1000545004,
	VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO = 1000545005,
	VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO = 1000545006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES = 1000466000,
	VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO = 1000068000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES = 1000068001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES = 1000068002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES = 1000270000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES = 1000270001,
	VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY = 1000270002,
	VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY = 1000270003,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO = 1000270004,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO = 1000270005,
	VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO = 1000270006,
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO = 1000270007,
	VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE = 1000270008,
	VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY = 1000270009,
	VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
	VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
	VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
	VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
	VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
	VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
	VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
	VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
	VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
	VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
	VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
	VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
	VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
	VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
	VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
	VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
	VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR = 1000023000,
	VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR = 1000023001,
	VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR = 1000023002,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR = 1000023003,
	VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR = 1000023004,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR = 1000023005,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000023006,
	VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR = 1000023007,
	VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR = 1000023008,
	VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR = 1000023009,
	VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR = 1000023010,
	VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR = 1000023011,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR = 1000023012,
	VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR = 1000023013,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR = 1000023014,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR = 1000023015,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR = 1000023016,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR = 1000024000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR = 1000024001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR = 1000024002,
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
	VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX = 1000029000,
	VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX = 1000029001,
	VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX = 1000029002,
	VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX = 1000029004,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR = 1000038000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000038001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000038002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR = 1000038003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR = 1000038004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR = 1000038005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR = 1000038006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR = 1000038007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR = 1000038008,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR = 1000038009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR = 1000038010,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR = 1000038011,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR = 1000038012,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000038013,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR = 1000039000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000039001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000039002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR = 1000039003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR = 1000039004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR = 1000039005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR = 1000039006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR = 1000039007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR = 1000039009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR = 1000039010,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR = 1000039011,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR = 1000039012,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR = 1000039013,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000039014,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR = 1000040000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR = 1000040001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR = 1000040003,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000040004,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000040005,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR = 1000040006,
	VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
	VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
	VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
	VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
	VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
	VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
	VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
	VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
	VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
	VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
	VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
	VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
	VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
	VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
	VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
	VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
	VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
	VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
	VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
	VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
	VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG = 1000110000,
	VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
	VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
	VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
	VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
	VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
	VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
	VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
	VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003,
	VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004,
	VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 1000116005,
	VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
	VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
	VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000,
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
	VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003,
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
	VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
	VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
	VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
	VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
	VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
	VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID = 1000129006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX = 1000134000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX = 1000134001,
	VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX = 1000134002,
	VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX = 1000134003,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX = 1000134004,
	VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR = 1000141000,
	VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
	VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
	VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
	VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 1000150007,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 1000150000,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 1000150002,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 1000150003,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 1000150004,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 1000150005,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR = 1000150006,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR = 1000150009,
	VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR = 1000150010,
	VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 1000150011,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 1000150012,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR = 1000150013,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR = 1000150014,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 1000150017,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR = 1000150020,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR = 1000347000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR = 1000347001,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015,
	VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR = 1000348013,
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001,
	VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
	VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
	VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
	VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR = 1000163000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR = 1000163001,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
	VK_STRUCTURE_TYPE_GEOMETRY_NV = 1000165003,
	VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004,
	VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005,
	VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
	VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
	VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
	VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
	VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000,
	VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR = 1000187000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000187001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000187002,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR = 1000187003,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR = 1000187004,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR = 1000187005,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
	VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
	VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008,
	VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
	VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000,
	VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
	VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002,
	VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003,
	VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004,
	VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
	VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
	VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
	VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
	VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
	VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
	VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007,
	VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000,
	VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004,
	VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 1000234000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR = 1000235000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
	VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
	VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
	VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR = 1000248000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
	VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000,
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT = 1000254000,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT = 1000254001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT = 1000254002,
	VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
	VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
	VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000,
	VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT = 1000272000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT = 1000272001,
	VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT = 1000272002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 1000273000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 1000277000,
	VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 1000277001,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 1000277002,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV = 1000277003,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV = 1000277004,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV = 1000277005,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV = 1000277006,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV = 1000277007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 1000278000,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 1000278001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 1000282000,
	VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 1000282001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT = 1000283000,
	VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT = 1000283001,
	VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT = 1000283002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 1000284000,
	VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT = 1000284001,
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT = 1000284002,
	VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002,
	VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV = 1000292000,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV = 1000292001,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV = 1000292002,
	VK_STRUCTURE_TYPE_PRESENT_ID_KHR = 1000294000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR = 1000294001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR = 1000299000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR = 1000299001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR = 1000299002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR = 1000299003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR = 1000299004,
	VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR = 1000299005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR = 1000299007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299008,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR = 1000299009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000299010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 1000300000,
	VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 1000300001,
	VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV = 1000307000,
	VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV = 1000307001,
	VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV = 1000307002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV = 1000307003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV = 1000307004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM = 1000309000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM = 1000309001,
	VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM = 1000309002,
	VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM = 1000309003,
	VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM = 1000309004,
	VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM = 1000309005,
	VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV = 1000310000,
	VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT = 1000311000,
	VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT = 1000311001,
	VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT = 1000311002,
	VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT = 1000311003,
	VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT = 1000311004,
	VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT = 1000311005,
	VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT = 1000311006,
	VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT = 1000311007,
	VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT = 1000311008,
	VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT = 1000311009,
	VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311010,
	VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311011,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT = 1000316000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT = 1000316001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT = 1000316002,
	VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT = 1000316003,
	VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT = 1000316004,
	VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316005,
	VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316006,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316007,
	VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316008,
	VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT = 1000316010,
	VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT = 1000316011,
	VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT = 1000316012,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT = 1000320000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT = 1000320001,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT = 1000320002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD = 1000321000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR = 1000203000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR = 1000322000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR = 1000323000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 1000326000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 1000326001,
	VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 1000326002,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV = 1000327000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV = 1000327001,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV = 1000327002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT = 1000328000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT = 1000328001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 1000330000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001,
	VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM = 1000333000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 1000336000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT = 1000338000,
	VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT = 1000338001,
	VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT = 1000338004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT = 1000339000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT = 1000341000,
	VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT = 1000341001,
	VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT = 1000341002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT = 1000344000,
	VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 1000352000,
	VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 1000352001,
	VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 1000352002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT = 1000353000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT = 1000354000,
	VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT = 1000354001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000,
	VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001,
	VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002,
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365000,
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365001,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA = 1000366000,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA = 1000366001,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA = 1000366002,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA = 1000366003,
	VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA = 1000366004,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA = 1000366005,
	VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA = 1000366006,
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA = 1000366007,
	VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA = 1000366008,
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA = 1000366009,
	VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI = 1000369000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI = 1000369001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI = 1000369002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI = 1000370000,
	VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV = 1000371000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV = 1000371001,
	VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT = 1000372000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT = 1000372001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT = 1000375000,
	VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT = 1000375001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT = 1000376000,
	VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT = 1000376001,
	VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT = 1000376002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 1000377000,
	VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX = 1000378000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 1000381000,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 1000381001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT = 1000382000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR = 1000386000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT = 1000391000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT = 1000391001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT = 1000392000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT = 1000392001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT = 1000393000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT = 1000395000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT = 1000395001,
	VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT = 1000396000,
	VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT = 1000396001,
	VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT = 1000396002,
	VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT = 1000396003,
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT = 1000396004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT = 1000396005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT = 1000396006,
	VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT = 1000396007,
	VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT = 1000396008,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT = 1000396009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV = 1000397000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV = 1000397001,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV = 1000397002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI = 1000404000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI = 1000404001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI = 1000404002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 1000411000,
	VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM = 1000415000,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM = 1000417000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM = 1000417001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM = 1000417002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT = 1000418000,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT = 1000418001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE = 1000420000,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE = 1000420001,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE = 1000420002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT = 1000422000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM = 1000424000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM = 1000424001,
	VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM = 1000424002,
	VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM = 1000424003,
	VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM = 1000424004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV = 1000426000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV = 1000426001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV = 1000427000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV = 1000427001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV = 1000428000,
	VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV = 1000428001,
	VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV = 1000428002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV = 1000429008,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV = 1000429009,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV = 1000429010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV = 1000430000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR = 1000434000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT = 1000437000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM = 1000440000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM = 1000440001,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM = 1000440002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT = 1000451000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT = 1000451001,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT = 1000453000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT = 1000455000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT = 1000455001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT = 1000458000,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT = 1000458001,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000458002,
	VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT = 1000458003,
	VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG = 1000459000,
	VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG = 1000459001,
	VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM = 1000460000,
	VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM = 1000460001,
	VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM = 1000460002,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM = 1000460003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM = 1000460004,
	VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM = 1000460005,
	VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM = 1000460006,
	VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM = 1000460007,
	VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM = 1000460008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM = 1000460009,
	VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM = 1000460010,
	VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM = 1000460011,
	VK_STRUCTURE_TYPE_TENSOR_COPY_ARM = 1000460012,
	VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM = 1000460013,
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM = 1000460014,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM = 1000460015,
	VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM = 1000460016,
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM = 1000460017,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM = 1000460018,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM = 1000460019,
	VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM = 1000460020,
	VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM = 1000460021,
	VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM = 1000460022,
	VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM = 1000460023,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT = 1000462000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT = 1000462001,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT = 1000462002,
	VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT = 1000462003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT = 1000342000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV = 1000464000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV = 1000464001,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV = 1000464002,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV = 1000464003,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV = 1000464004,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV = 1000464005,
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV = 1000464010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT = 1000465000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID = 1000468000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID = 1000468001,
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID = 1000468002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD = 1000476000,
	VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD = 1000476001,
	VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD = 1000476002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DENSE_GEOMETRY_FORMAT_FEATURES_AMDX = 1000478000,
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DENSE_GEOMETRY_FORMAT_TRIANGLES_DATA_AMDX = 1000478001,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR = 1000479000,
	VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR = 1000479001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR = 1000479002,
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR = 1000480000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR = 1000480001,
	VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR = 1000480002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR = 1000481000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT = 1000482000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT = 1000482001,
	VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT = 1000482002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR = 1000483000,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR = 1000483001,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR = 1000483002,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR = 1000483003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR = 1000483004,
	VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR = 1000483005,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR = 1000483006,
	VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR = 1000483007,
	VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR = 1000483008,
	VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR = 1000483009,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM = 1000484000,
	VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM = 1000484001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC = 1000485000,
	VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC = 1000485001,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR = 1000274000,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR = 1000274001,
	VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR = 1000274002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR = 1000275000,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR = 1000275001,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR = 1000275002,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR = 1000275003,
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR = 1000275004,
	VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR = 1000275005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM = 1000488000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV = 1000490000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV = 1000490001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV = 1000491000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV = 1000491001,
	VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV = 1000491002,
	VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV = 1000491004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV = 1000492000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV = 1000492001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT = 1000351000,
	VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT = 1000351002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT = 1000495000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT = 1000495001,
	VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT = 1000496000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM = 1000497000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM = 1000497001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT = 1000498000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT = 1000499000,
	VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV = 1000505000,
	VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV = 1000505001,
	VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV = 1000505002,
	VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV = 1000505003,
	VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV = 1000505004,
	VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV = 1000505005,
	VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV = 1000505006,
	VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV = 1000505007,
	VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV = 1000505008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR = 1000506000,
	VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506002,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM = 1000507000,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM = 1000507001,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM = 1000507002,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM = 1000507003,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM = 1000507004,
	VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM = 1000507005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM = 1000507006,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM = 1000507007,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM = 1000507008,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM = 1000507009,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM = 1000507010,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM = 1000507011,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM = 1000507012,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM = 1000507013,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM = 1000507014,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM = 1000507016,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM = 1000507017,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM = 1000507018,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM = 1000507019,
	VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM = 1000507015,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM = 1000510000,
	VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM = 1000510001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR = 1000201000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR = 1000511000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR = 1000512000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR = 1000512001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR = 1000512003,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000512004,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR = 1000512005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR = 1000513000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000513001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR = 1000513002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR = 1000513003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR = 1000513004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR = 1000513005,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR = 1000513006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR = 1000513007,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR = 1000513008,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR = 1000513009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR = 1000513010,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR = 1000514000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR = 1000514001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR = 1000514002,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR = 1000514003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR = 1000515000,
	VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR = 1000515001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV = 1000516000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM = 1000518000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM = 1000518001,
	VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM = 1000518002,
	VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM = 1000519000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM = 1000519001,
	VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM = 1000519002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM = 1000520000,
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM = 1000520001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM = 1000521000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT = 1000524000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR = 1000527000,
	VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT = 1000527001,
	VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX = 1000529000,
	VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX = 1000529001,
	VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX = 1000529002,
	VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX = 1000529003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX = 1000529004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT = 1000530000,
	VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR = 1000184000,
	VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT = 1000545007,
	VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT = 1000545008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV = 1000546000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM = 1000547000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM = 1000547001,
	VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM = 1000547002,
	VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM = 1000547003,
	VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM = 1000547004,
	VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV = 1000551000,
	VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV = 1000551001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR = 1000552000,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR = 1000552001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR = 1000552002,
	VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR = 1000552003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR = 1000552004,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553000,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553001,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR = 1000553002,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000553005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR = 1000553009,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553003,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553004,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553006,
	VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553007,
	VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553008,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV = 1000555000,
	VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV = 1000556000,
	VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV = 1000556001,
	VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV = 1000556002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV = 1000556003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR = 1000558000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV = 1000559000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR = 1000562000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR = 1000562001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR = 1000562002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR = 1000562003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR = 1000562004,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV = 1000563000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT = 1000564000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT = 1000567000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV = 1000568000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV = 1000569000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV = 1000569001,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV = 1000569002,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV = 1000569003,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV = 1000569004,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV = 1000569005,
	VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV = 1000569006,
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000569007,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV = 1000570000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV = 1000570001,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV = 1000570002,
	VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV = 1000570003,
	VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV = 1000570004,
	VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV = 1000570005,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT = 1000572000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT = 1000572001,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT = 1000572002,
	VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT = 1000572003,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT = 1000572004,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT = 1000572006,
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT = 1000572007,
	VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT = 1000572008,
	VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT = 1000572009,
	VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT = 1000572010,
	VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT = 1000572011,
	VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT = 1000572012,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT = 1000572013,
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT = 1000572014,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR = 1000574000,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR = 1000574002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA = 1000575000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA = 1000575001,
	VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA = 1000575002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT = 1000582000,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT = 1000582001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR = 1000584000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR = 1000584001,
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR = 1000584002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR = 1000586000,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586001,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586002,
	VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586003,
	VK_STRUCTURE_TYPE_OH_SURFACE_CREATE_INFO_OHOS = 1000587000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI = 1000590000,
	VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI = 1000590001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV = 1000593000,
	VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV = 1000593001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV = 1000593002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM = 1000596000,
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT = 1000602000,
	VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT = 1000602001,
	VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT = 1000602002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR = 1000421000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT = 1000608000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM = 1000609000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE = 1000611000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE = 1000611001,
	VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE = 1000611002,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR = 1000286000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR = 1000286001,
	VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV = 1000613000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV = 1000613001,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT = 1000425000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT = 1000425001,
	VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT = 1000425002,
	VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT = 1000619003,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT = 1000620000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR = 1000361000,
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC = 1000637000,
	VK_STRUCTURE_TYPE_MAX_ENUM = 0x7fffffff,
}
impl VkStructureType {
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
	pub const VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
	pub const VK_STRUCTURE_TYPE_RENDERING_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDERING_INFO;
	pub const VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO;
	pub const VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
	pub const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO;
	pub const VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
	pub const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
	pub const VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
	pub const VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
	pub const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
	pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
	pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
	pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
	pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
	pub const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
	pub const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
	pub const VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
	pub const VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
	pub const VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
	pub const VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
	pub const VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
	pub const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO;
	pub const VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO;
	pub const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;
	pub const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2;
	pub const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2;
	pub const VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2;
	pub const VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2;
	pub const VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO;
	pub const VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_END_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
	pub const VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR;
	pub const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
	pub const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK;
	pub const VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
	pub const VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;
	pub const VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
	pub const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
	pub const VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
	pub const VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
	pub const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO;
	pub const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
	pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO;
	pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT;
	pub const VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
	pub const VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR;
	pub const VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES;
	pub const VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
	pub const VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
	pub const VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;
	pub const VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO;
	pub const VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES;
	pub const VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO;
	pub const VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
	pub const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT;
	pub const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
	pub const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
	pub const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
	pub const VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
	pub const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES;
	pub const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY;
	pub const VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY;
	pub const VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO;
	pub const VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO;
	pub const VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO;
	pub const VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO;
	pub const VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE;
	pub const VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY;
	pub const VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_MAP_INFO;
	pub const VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO;
	pub const VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR;
	pub const VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR;
	pub const VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR;
	pub const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR;
	pub const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR;
	pub const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR;
	pub const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR;
	pub const VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
	pub const VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
	pub const VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MEMORY_BARRIER_2;
	pub const VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2;
	pub const VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEPENDENCY_INFO;
	pub const VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBMIT_INFO_2;
	pub const VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO;
	pub const VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
	pub const VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2;
	pub const VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2;
	pub const VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2;
	pub const VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2;
	pub const VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2;
	pub const VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2;
	pub const VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_COPY_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_COPY_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_BLIT_2;
	pub const VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2;
	pub const VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
	pub const VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT;
	pub const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR;
	pub const VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES;
	pub const VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS;
	pub const VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT;
	pub const VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_RENDERING_AREA_INFO;
	pub const VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO;
	pub const VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2;
	pub const VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2;
	pub const VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES;
	pub const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES;
	pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES;
	pub const VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS;
	pub const VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO;
	pub const VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO;
	pub const VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO;
	pub const VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR: VkStructureType = VkStructureType::VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO;
}
/// enum `VkPipelineCacheHeaderVersion` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCacheHeaderVersion.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineCacheHeaderVersion {
	VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
	VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7fffffff,
}
/// enum `VkImageLayout` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageLayout.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageLayout {
	VK_IMAGE_LAYOUT_UNDEFINED = 0,
	VK_IMAGE_LAYOUT_GENERAL = 1,
	VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
	VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
	VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
	VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
	VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001,
	VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
	VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003,
	VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = 1000314000,
	VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = 1000314001,
	VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ = 1000232000,
	VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
	VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = 1000024000,
	VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = 1000024001,
	VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = 1000024002,
	VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
	VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
	VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = 1000299000,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = 1000299001,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = 1000299002,
	VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = 1000339000,
	VK_IMAGE_LAYOUT_TENSOR_ALIASING_ARM = 1000460000,
	VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR = 1000553000,
	VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT = 1000620000,
	VK_IMAGE_LAYOUT_MAX_ENUM = 0x7fffffff,
}
impl VkImageLayout {
	pub const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL;
	pub const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL;
	pub const VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR;
	pub const VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ;
	pub const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL;
	pub const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL;
	pub const VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL;
	pub const VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL;
	pub const VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL;
	pub const VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL;
}
/// enum `VkObjectType` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkObjectType.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkObjectType {
	VK_OBJECT_TYPE_UNKNOWN = 0,
	VK_OBJECT_TYPE_INSTANCE = 1,
	VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
	VK_OBJECT_TYPE_DEVICE = 3,
	VK_OBJECT_TYPE_QUEUE = 4,
	VK_OBJECT_TYPE_SEMAPHORE = 5,
	VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
	VK_OBJECT_TYPE_FENCE = 7,
	VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
	VK_OBJECT_TYPE_BUFFER = 9,
	VK_OBJECT_TYPE_IMAGE = 10,
	VK_OBJECT_TYPE_EVENT = 11,
	VK_OBJECT_TYPE_QUERY_POOL = 12,
	VK_OBJECT_TYPE_BUFFER_VIEW = 13,
	VK_OBJECT_TYPE_IMAGE_VIEW = 14,
	VK_OBJECT_TYPE_SHADER_MODULE = 15,
	VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
	VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
	VK_OBJECT_TYPE_RENDER_PASS = 18,
	VK_OBJECT_TYPE_PIPELINE = 19,
	VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
	VK_OBJECT_TYPE_SAMPLER = 21,
	VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
	VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
	VK_OBJECT_TYPE_FRAMEBUFFER = 24,
	VK_OBJECT_TYPE_COMMAND_POOL = 25,
	VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000,
	VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
	VK_OBJECT_TYPE_PRIVATE_DATA_SLOT = 1000295000,
	VK_OBJECT_TYPE_SURFACE_KHR = 1000000000,
	VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
	VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000,
	VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
	VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
	VK_OBJECT_TYPE_VIDEO_SESSION_KHR = 1000023000,
	VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR = 1000023001,
	VK_OBJECT_TYPE_CU_MODULE_NVX = 1000029000,
	VK_OBJECT_TYPE_CU_FUNCTION_NVX = 1000029001,
	VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000,
	VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
	VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000,
	VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
	VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL = 1000210000,
	VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR = 1000268000,
	VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV = 1000277000,
	VK_OBJECT_TYPE_CUDA_MODULE_NV = 1000307000,
	VK_OBJECT_TYPE_CUDA_FUNCTION_NV = 1000307001,
	VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA = 1000366000,
	VK_OBJECT_TYPE_MICROMAP_EXT = 1000396000,
	VK_OBJECT_TYPE_TENSOR_ARM = 1000460000,
	VK_OBJECT_TYPE_TENSOR_VIEW_ARM = 1000460001,
	VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV = 1000464000,
	VK_OBJECT_TYPE_SHADER_EXT = 1000482000,
	VK_OBJECT_TYPE_PIPELINE_BINARY_KHR = 1000483000,
	VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM = 1000507000,
	VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV = 1000556000,
	VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT = 1000572000,
	VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT = 1000572001,
	VK_OBJECT_TYPE_MAX_ENUM = 0x7fffffff,
}
impl VkObjectType {
	pub const VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR: VkObjectType = VkObjectType::VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE;
	pub const VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR: VkObjectType = VkObjectType::VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION;
	pub const VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT: VkObjectType = VkObjectType::VK_OBJECT_TYPE_PRIVATE_DATA_SLOT;
}
/// enum `VkVendorId` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVendorId.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVendorId {
	VK_VENDOR_ID_KHRONOS = 0x10000,
	VK_VENDOR_ID_VIV = 0x10001,
	VK_VENDOR_ID_VSI = 0x10002,
	VK_VENDOR_ID_KAZAN = 0x10003,
	VK_VENDOR_ID_CODEPLAY = 0x10004,
	VK_VENDOR_ID_MESA = 0x10005,
	VK_VENDOR_ID_POCL = 0x10006,
	VK_VENDOR_ID_MOBILEYE = 0x10007,
	VK_VENDOR_ID_MAX_ENUM = 0x7fffffff,
}
/// enum `VkSystemAllocationScope` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSystemAllocationScope.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSystemAllocationScope {
	VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
	VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
	VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
	VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
	VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
	VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7fffffff,
}
/// enum `VkInternalAllocationType` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkInternalAllocationType.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkInternalAllocationType {
	VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
	VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7fffffff,
}
/// enum `VkFormat` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormat.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFormat {
	VK_FORMAT_UNDEFINED = 0,
	VK_FORMAT_R4G4_UNORM_PACK8 = 1,
	VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
	VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
	VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
	VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
	VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
	VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
	VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
	VK_FORMAT_R8_UNORM = 9,
	VK_FORMAT_R8_SNORM = 10,
	VK_FORMAT_R8_USCALED = 11,
	VK_FORMAT_R8_SSCALED = 12,
	VK_FORMAT_R8_UINT = 13,
	VK_FORMAT_R8_SINT = 14,
	VK_FORMAT_R8_SRGB = 15,
	VK_FORMAT_R8G8_UNORM = 16,
	VK_FORMAT_R8G8_SNORM = 17,
	VK_FORMAT_R8G8_USCALED = 18,
	VK_FORMAT_R8G8_SSCALED = 19,
	VK_FORMAT_R8G8_UINT = 20,
	VK_FORMAT_R8G8_SINT = 21,
	VK_FORMAT_R8G8_SRGB = 22,
	VK_FORMAT_R8G8B8_UNORM = 23,
	VK_FORMAT_R8G8B8_SNORM = 24,
	VK_FORMAT_R8G8B8_USCALED = 25,
	VK_FORMAT_R8G8B8_SSCALED = 26,
	VK_FORMAT_R8G8B8_UINT = 27,
	VK_FORMAT_R8G8B8_SINT = 28,
	VK_FORMAT_R8G8B8_SRGB = 29,
	VK_FORMAT_B8G8R8_UNORM = 30,
	VK_FORMAT_B8G8R8_SNORM = 31,
	VK_FORMAT_B8G8R8_USCALED = 32,
	VK_FORMAT_B8G8R8_SSCALED = 33,
	VK_FORMAT_B8G8R8_UINT = 34,
	VK_FORMAT_B8G8R8_SINT = 35,
	VK_FORMAT_B8G8R8_SRGB = 36,
	VK_FORMAT_R8G8B8A8_UNORM = 37,
	VK_FORMAT_R8G8B8A8_SNORM = 38,
	VK_FORMAT_R8G8B8A8_USCALED = 39,
	VK_FORMAT_R8G8B8A8_SSCALED = 40,
	VK_FORMAT_R8G8B8A8_UINT = 41,
	VK_FORMAT_R8G8B8A8_SINT = 42,
	VK_FORMAT_R8G8B8A8_SRGB = 43,
	VK_FORMAT_B8G8R8A8_UNORM = 44,
	VK_FORMAT_B8G8R8A8_SNORM = 45,
	VK_FORMAT_B8G8R8A8_USCALED = 46,
	VK_FORMAT_B8G8R8A8_SSCALED = 47,
	VK_FORMAT_B8G8R8A8_UINT = 48,
	VK_FORMAT_B8G8R8A8_SINT = 49,
	VK_FORMAT_B8G8R8A8_SRGB = 50,
	VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
	VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
	VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
	VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
	VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
	VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
	VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
	VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
	VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
	VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
	VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
	VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
	VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
	VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
	VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
	VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
	VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
	VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
	VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
	VK_FORMAT_R16_UNORM = 70,
	VK_FORMAT_R16_SNORM = 71,
	VK_FORMAT_R16_USCALED = 72,
	VK_FORMAT_R16_SSCALED = 73,
	VK_FORMAT_R16_UINT = 74,
	VK_FORMAT_R16_SINT = 75,
	VK_FORMAT_R16_SFLOAT = 76,
	VK_FORMAT_R16G16_UNORM = 77,
	VK_FORMAT_R16G16_SNORM = 78,
	VK_FORMAT_R16G16_USCALED = 79,
	VK_FORMAT_R16G16_SSCALED = 80,
	VK_FORMAT_R16G16_UINT = 81,
	VK_FORMAT_R16G16_SINT = 82,
	VK_FORMAT_R16G16_SFLOAT = 83,
	VK_FORMAT_R16G16B16_UNORM = 84,
	VK_FORMAT_R16G16B16_SNORM = 85,
	VK_FORMAT_R16G16B16_USCALED = 86,
	VK_FORMAT_R16G16B16_SSCALED = 87,
	VK_FORMAT_R16G16B16_UINT = 88,
	VK_FORMAT_R16G16B16_SINT = 89,
	VK_FORMAT_R16G16B16_SFLOAT = 90,
	VK_FORMAT_R16G16B16A16_UNORM = 91,
	VK_FORMAT_R16G16B16A16_SNORM = 92,
	VK_FORMAT_R16G16B16A16_USCALED = 93,
	VK_FORMAT_R16G16B16A16_SSCALED = 94,
	VK_FORMAT_R16G16B16A16_UINT = 95,
	VK_FORMAT_R16G16B16A16_SINT = 96,
	VK_FORMAT_R16G16B16A16_SFLOAT = 97,
	VK_FORMAT_R32_UINT = 98,
	VK_FORMAT_R32_SINT = 99,
	VK_FORMAT_R32_SFLOAT = 100,
	VK_FORMAT_R32G32_UINT = 101,
	VK_FORMAT_R32G32_SINT = 102,
	VK_FORMAT_R32G32_SFLOAT = 103,
	VK_FORMAT_R32G32B32_UINT = 104,
	VK_FORMAT_R32G32B32_SINT = 105,
	VK_FORMAT_R32G32B32_SFLOAT = 106,
	VK_FORMAT_R32G32B32A32_UINT = 107,
	VK_FORMAT_R32G32B32A32_SINT = 108,
	VK_FORMAT_R32G32B32A32_SFLOAT = 109,
	VK_FORMAT_R64_UINT = 110,
	VK_FORMAT_R64_SINT = 111,
	VK_FORMAT_R64_SFLOAT = 112,
	VK_FORMAT_R64G64_UINT = 113,
	VK_FORMAT_R64G64_SINT = 114,
	VK_FORMAT_R64G64_SFLOAT = 115,
	VK_FORMAT_R64G64B64_UINT = 116,
	VK_FORMAT_R64G64B64_SINT = 117,
	VK_FORMAT_R64G64B64_SFLOAT = 118,
	VK_FORMAT_R64G64B64A64_UINT = 119,
	VK_FORMAT_R64G64B64A64_SINT = 120,
	VK_FORMAT_R64G64B64A64_SFLOAT = 121,
	VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
	VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
	VK_FORMAT_D16_UNORM = 124,
	VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
	VK_FORMAT_D32_SFLOAT = 126,
	VK_FORMAT_S8_UINT = 127,
	VK_FORMAT_D16_UNORM_S8_UINT = 128,
	VK_FORMAT_D24_UNORM_S8_UINT = 129,
	VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
	VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
	VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
	VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
	VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
	VK_FORMAT_BC2_UNORM_BLOCK = 135,
	VK_FORMAT_BC2_SRGB_BLOCK = 136,
	VK_FORMAT_BC3_UNORM_BLOCK = 137,
	VK_FORMAT_BC3_SRGB_BLOCK = 138,
	VK_FORMAT_BC4_UNORM_BLOCK = 139,
	VK_FORMAT_BC4_SNORM_BLOCK = 140,
	VK_FORMAT_BC5_UNORM_BLOCK = 141,
	VK_FORMAT_BC5_SNORM_BLOCK = 142,
	VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
	VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
	VK_FORMAT_BC7_UNORM_BLOCK = 145,
	VK_FORMAT_BC7_SRGB_BLOCK = 146,
	VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
	VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
	VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
	VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
	VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
	VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
	VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
	VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
	VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
	VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
	VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
	VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
	VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
	VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
	VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
	VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
	VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
	VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
	VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
	VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
	VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
	VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
	VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
	VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
	VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
	VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
	VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
	VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
	VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
	VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
	VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
	VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
	VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
	VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
	VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
	VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
	VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
	VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
	VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
	VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
	VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
	VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
	VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
	VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
	VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
	VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
	VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
	VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
	VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
	VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
	VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
	VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
	VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
	VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
	VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
	VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
	VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
	VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
	VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
	VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
	VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
	VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
	VK_FORMAT_G8_B8R8_2PLANE_444_UNORM = 1000330000,
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001,
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002,
	VK_FORMAT_G16_B16R16_2PLANE_444_UNORM = 1000330003,
	VK_FORMAT_A4R4G4B4_UNORM_PACK16 = 1000340000,
	VK_FORMAT_A4B4G4R4_UNORM_PACK16 = 1000340001,
	VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK = 1000066000,
	VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK = 1000066001,
	VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK = 1000066002,
	VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK = 1000066003,
	VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK = 1000066004,
	VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK = 1000066005,
	VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK = 1000066006,
	VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK = 1000066007,
	VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK = 1000066008,
	VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK = 1000066009,
	VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK = 1000066010,
	VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK = 1000066011,
	VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK = 1000066012,
	VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK = 1000066013,
	VK_FORMAT_A1B5G5R5_UNORM_PACK16 = 1000470000,
	VK_FORMAT_A8_UNORM = 1000470001,
	VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
	VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
	VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
	VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
	VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
	VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
	VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
	VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
	VK_FORMAT_R8_BOOL_ARM = 1000460000,
	VK_FORMAT_R16G16_SFIXED5_NV = 1000464000,
	VK_FORMAT_R10X6_UINT_PACK16_ARM = 1000609000,
	VK_FORMAT_R10X6G10X6_UINT_2PACK16_ARM = 1000609001,
	VK_FORMAT_R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM = 1000609002,
	VK_FORMAT_R12X4_UINT_PACK16_ARM = 1000609003,
	VK_FORMAT_R12X4G12X4_UINT_2PACK16_ARM = 1000609004,
	VK_FORMAT_R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM = 1000609005,
	VK_FORMAT_R14X2_UINT_PACK16_ARM = 1000609006,
	VK_FORMAT_R14X2G14X2_UINT_2PACK16_ARM = 1000609007,
	VK_FORMAT_R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM = 1000609008,
	VK_FORMAT_R14X2_UNORM_PACK16_ARM = 1000609009,
	VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM = 1000609010,
	VK_FORMAT_R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM = 1000609011,
	VK_FORMAT_G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM = 1000609012,
	VK_FORMAT_G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM = 1000609013,
	VK_FORMAT_MAX_ENUM = 0x7fffffff,
}
impl VkFormat {
	pub const VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK;
	pub const VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: VkFormat = VkFormat::VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK;
	pub const VK_FORMAT_G8B8G8R8_422_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G8B8G8R8_422_UNORM;
	pub const VK_FORMAT_B8G8R8G8_422_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_B8G8R8G8_422_UNORM;
	pub const VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM;
	pub const VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G8_B8R8_2PLANE_420_UNORM;
	pub const VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM;
	pub const VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G8_B8R8_2PLANE_422_UNORM;
	pub const VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM;
	pub const VK_FORMAT_R10X6_UNORM_PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_R10X6_UNORM_PACK16;
	pub const VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_R10X6G10X6_UNORM_2PACK16;
	pub const VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16;
	pub const VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16;
	pub const VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16;
	pub const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16;
	pub const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16;
	pub const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16;
	pub const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16;
	pub const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16;
	pub const VK_FORMAT_R12X4_UNORM_PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_R12X4_UNORM_PACK16;
	pub const VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_R12X4G12X4_UNORM_2PACK16;
	pub const VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16;
	pub const VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16;
	pub const VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16;
	pub const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16;
	pub const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16;
	pub const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16;
	pub const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16;
	pub const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16;
	pub const VK_FORMAT_G16B16G16R16_422_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G16B16G16R16_422_UNORM;
	pub const VK_FORMAT_B16G16R16G16_422_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_B16G16R16G16_422_UNORM;
	pub const VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM;
	pub const VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G16_B16R16_2PLANE_420_UNORM;
	pub const VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM;
	pub const VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G16_B16R16_2PLANE_422_UNORM;
	pub const VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM;
	pub const VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT: VkFormat = VkFormat::VK_FORMAT_G8_B8R8_2PLANE_444_UNORM;
	pub const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT: VkFormat = VkFormat::VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16;
	pub const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT: VkFormat = VkFormat::VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16;
	pub const VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT: VkFormat = VkFormat::VK_FORMAT_G16_B16R16_2PLANE_444_UNORM;
	pub const VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT: VkFormat = VkFormat::VK_FORMAT_A4R4G4B4_UNORM_PACK16;
	pub const VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT: VkFormat = VkFormat::VK_FORMAT_A4B4G4R4_UNORM_PACK16;
	pub const VK_FORMAT_R16G16_S10_5_NV: VkFormat = VkFormat::VK_FORMAT_R16G16_SFIXED5_NV;
	pub const VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR: VkFormat = VkFormat::VK_FORMAT_A1B5G5R5_UNORM_PACK16;
	pub const VK_FORMAT_A8_UNORM_KHR: VkFormat = VkFormat::VK_FORMAT_A8_UNORM;
}
/// enum `VkImageTiling` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageTiling.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageTiling {
	VK_IMAGE_TILING_OPTIMAL = 0,
	VK_IMAGE_TILING_LINEAR = 1,
	VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
	VK_IMAGE_TILING_MAX_ENUM = 0x7fffffff,
}
/// enum `VkImageType` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageType.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageType {
	VK_IMAGE_TYPE_1D = 0,
	VK_IMAGE_TYPE_2D = 1,
	VK_IMAGE_TYPE_3D = 2,
	VK_IMAGE_TYPE_MAX_ENUM = 0x7fffffff,
}
/// enum `VkPhysicalDeviceType` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceType.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPhysicalDeviceType {
	VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
	VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
	VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
	VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
	VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
	VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7fffffff,
}
/// enum `VkQueryType` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryType.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueryType {
	VK_QUERY_TYPE_OCCLUSION = 0,
	VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
	VK_QUERY_TYPE_TIMESTAMP = 2,
	VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR = 1000023000,
	VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
	VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR = 1000116000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR = 1000150000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR = 1000150001,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000,
	VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL = 1000210000,
	VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR = 1000299000,
	VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT = 1000328000,
	VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT = 1000382000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR = 1000386000,
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR = 1000386001,
	VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT = 1000396000,
	VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT = 1000396001,
	VK_QUERY_TYPE_MAX_ENUM = 0x7fffffff,
}
/// enum `VkSharingMode` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSharingMode.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSharingMode {
	VK_SHARING_MODE_EXCLUSIVE = 0,
	VK_SHARING_MODE_CONCURRENT = 1,
	VK_SHARING_MODE_MAX_ENUM = 0x7fffffff,
}
/// enum `VkComponentSwizzle` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkComponentSwizzle.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkComponentSwizzle {
	VK_COMPONENT_SWIZZLE_IDENTITY = 0,
	VK_COMPONENT_SWIZZLE_ZERO = 1,
	VK_COMPONENT_SWIZZLE_ONE = 2,
	VK_COMPONENT_SWIZZLE_R = 3,
	VK_COMPONENT_SWIZZLE_G = 4,
	VK_COMPONENT_SWIZZLE_B = 5,
	VK_COMPONENT_SWIZZLE_A = 6,
	VK_COMPONENT_SWIZZLE_MAX_ENUM = 0x7fffffff,
}
/// enum `VkImageViewType` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageViewType.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageViewType {
	VK_IMAGE_VIEW_TYPE_1D = 0,
	VK_IMAGE_VIEW_TYPE_2D = 1,
	VK_IMAGE_VIEW_TYPE_3D = 2,
	VK_IMAGE_VIEW_TYPE_CUBE = 3,
	VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
	VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
	VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
	VK_IMAGE_VIEW_TYPE_MAX_ENUM = 0x7fffffff,
}
/// enum `VkBlendFactor` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBlendFactor.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBlendFactor {
	VK_BLEND_FACTOR_ZERO = 0,
	VK_BLEND_FACTOR_ONE = 1,
	VK_BLEND_FACTOR_SRC_COLOR = 2,
	VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
	VK_BLEND_FACTOR_DST_COLOR = 4,
	VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
	VK_BLEND_FACTOR_SRC_ALPHA = 6,
	VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
	VK_BLEND_FACTOR_DST_ALPHA = 8,
	VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
	VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
	VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
	VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
	VK_BLEND_FACTOR_SRC1_COLOR = 15,
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
	VK_BLEND_FACTOR_SRC1_ALPHA = 17,
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
	VK_BLEND_FACTOR_MAX_ENUM = 0x7fffffff,
}
/// enum `VkBlendOp` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBlendOp.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBlendOp {
	VK_BLEND_OP_ADD = 0,
	VK_BLEND_OP_SUBTRACT = 1,
	VK_BLEND_OP_REVERSE_SUBTRACT = 2,
	VK_BLEND_OP_MIN = 3,
	VK_BLEND_OP_MAX = 4,
	VK_BLEND_OP_ZERO_EXT = 1000148000,
	VK_BLEND_OP_SRC_EXT = 1000148001,
	VK_BLEND_OP_DST_EXT = 1000148002,
	VK_BLEND_OP_SRC_OVER_EXT = 1000148003,
	VK_BLEND_OP_DST_OVER_EXT = 1000148004,
	VK_BLEND_OP_SRC_IN_EXT = 1000148005,
	VK_BLEND_OP_DST_IN_EXT = 1000148006,
	VK_BLEND_OP_SRC_OUT_EXT = 1000148007,
	VK_BLEND_OP_DST_OUT_EXT = 1000148008,
	VK_BLEND_OP_SRC_ATOP_EXT = 1000148009,
	VK_BLEND_OP_DST_ATOP_EXT = 1000148010,
	VK_BLEND_OP_XOR_EXT = 1000148011,
	VK_BLEND_OP_MULTIPLY_EXT = 1000148012,
	VK_BLEND_OP_SCREEN_EXT = 1000148013,
	VK_BLEND_OP_OVERLAY_EXT = 1000148014,
	VK_BLEND_OP_DARKEN_EXT = 1000148015,
	VK_BLEND_OP_LIGHTEN_EXT = 1000148016,
	VK_BLEND_OP_COLORDODGE_EXT = 1000148017,
	VK_BLEND_OP_COLORBURN_EXT = 1000148018,
	VK_BLEND_OP_HARDLIGHT_EXT = 1000148019,
	VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020,
	VK_BLEND_OP_DIFFERENCE_EXT = 1000148021,
	VK_BLEND_OP_EXCLUSION_EXT = 1000148022,
	VK_BLEND_OP_INVERT_EXT = 1000148023,
	VK_BLEND_OP_INVERT_RGB_EXT = 1000148024,
	VK_BLEND_OP_LINEARDODGE_EXT = 1000148025,
	VK_BLEND_OP_LINEARBURN_EXT = 1000148026,
	VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
	VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028,
	VK_BLEND_OP_PINLIGHT_EXT = 1000148029,
	VK_BLEND_OP_HARDMIX_EXT = 1000148030,
	VK_BLEND_OP_HSL_HUE_EXT = 1000148031,
	VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032,
	VK_BLEND_OP_HSL_COLOR_EXT = 1000148033,
	VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
	VK_BLEND_OP_PLUS_EXT = 1000148035,
	VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
	VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
	VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038,
	VK_BLEND_OP_MINUS_EXT = 1000148039,
	VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
	VK_BLEND_OP_CONTRAST_EXT = 1000148041,
	VK_BLEND_OP_INVERT_OVG_EXT = 1000148042,
	VK_BLEND_OP_RED_EXT = 1000148043,
	VK_BLEND_OP_GREEN_EXT = 1000148044,
	VK_BLEND_OP_BLUE_EXT = 1000148045,
	VK_BLEND_OP_MAX_ENUM = 0x7fffffff,
}
/// enum `VkCompareOp` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCompareOp.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCompareOp {
	VK_COMPARE_OP_NEVER = 0,
	VK_COMPARE_OP_LESS = 1,
	VK_COMPARE_OP_EQUAL = 2,
	VK_COMPARE_OP_LESS_OR_EQUAL = 3,
	VK_COMPARE_OP_GREATER = 4,
	VK_COMPARE_OP_NOT_EQUAL = 5,
	VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
	VK_COMPARE_OP_ALWAYS = 7,
	VK_COMPARE_OP_MAX_ENUM = 0x7fffffff,
}
/// enum `VkDynamicState` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDynamicState.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDynamicState {
	VK_DYNAMIC_STATE_VIEWPORT = 0,
	VK_DYNAMIC_STATE_SCISSOR = 1,
	VK_DYNAMIC_STATE_LINE_WIDTH = 2,
	VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
	VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
	VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
	VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
	VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
	VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
	VK_DYNAMIC_STATE_CULL_MODE = 1000267000,
	VK_DYNAMIC_STATE_FRONT_FACE = 1000267001,
	VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY = 1000267002,
	VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT = 1000267003,
	VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT = 1000267004,
	VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE = 1000267005,
	VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE = 1000267006,
	VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE = 1000267007,
	VK_DYNAMIC_STATE_DEPTH_COMPARE_OP = 1000267008,
	VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE = 1000267009,
	VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE = 1000267010,
	VK_DYNAMIC_STATE_STENCIL_OP = 1000267011,
	VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE = 1000377001,
	VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE = 1000377002,
	VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE = 1000377004,
	VK_DYNAMIC_STATE_LINE_STIPPLE = 1000259000,
	VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
	VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
	VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT = 1000099001,
	VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT = 1000099002,
	VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000,
	VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR = 1000347000,
	VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
	VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
	VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV = 1000205000,
	VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001,
	VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR = 1000226000,
	VK_DYNAMIC_STATE_VERTEX_INPUT_EXT = 1000352000,
	VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT = 1000377000,
	VK_DYNAMIC_STATE_LOGIC_OP_EXT = 1000377003,
	VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT = 1000381000,
	VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT = 1000455003,
	VK_DYNAMIC_STATE_POLYGON_MODE_EXT = 1000455004,
	VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT = 1000455005,
	VK_DYNAMIC_STATE_SAMPLE_MASK_EXT = 1000455006,
	VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT = 1000455007,
	VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT = 1000455008,
	VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT = 1000455009,
	VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT = 1000455010,
	VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT = 1000455011,
	VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT = 1000455012,
	VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT = 1000455002,
	VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT = 1000455013,
	VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT = 1000455014,
	VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT = 1000455015,
	VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT = 1000455016,
	VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT = 1000455017,
	VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT = 1000455018,
	VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT = 1000455019,
	VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT = 1000455020,
	VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT = 1000455021,
	VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT = 1000455022,
	VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV = 1000455023,
	VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV = 1000455024,
	VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV = 1000455025,
	VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV = 1000455026,
	VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV = 1000455027,
	VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV = 1000455028,
	VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV = 1000455029,
	VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV = 1000455030,
	VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV = 1000455031,
	VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV = 1000455032,
	VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT = 1000524000,
	VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT = 1000582000,
	VK_DYNAMIC_STATE_MAX_ENUM = 0x7fffffff,
}
impl VkDynamicState {
	pub const VK_DYNAMIC_STATE_LINE_STIPPLE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_LINE_STIPPLE;
	pub const VK_DYNAMIC_STATE_CULL_MODE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_CULL_MODE;
	pub const VK_DYNAMIC_STATE_FRONT_FACE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_FRONT_FACE;
	pub const VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY;
	pub const VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT;
	pub const VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT;
	pub const VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE;
	pub const VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE;
	pub const VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE;
	pub const VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_DEPTH_COMPARE_OP;
	pub const VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE;
	pub const VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE;
	pub const VK_DYNAMIC_STATE_STENCIL_OP_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_STENCIL_OP;
	pub const VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE;
	pub const VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE;
	pub const VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE;
	pub const VK_DYNAMIC_STATE_LINE_STIPPLE_KHR: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_LINE_STIPPLE;
}
/// enum `VkFrontFace` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFrontFace.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFrontFace {
	VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
	VK_FRONT_FACE_CLOCKWISE = 1,
	VK_FRONT_FACE_MAX_ENUM = 0x7fffffff,
}
/// enum `VkVertexInputRate` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVertexInputRate.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVertexInputRate {
	VK_VERTEX_INPUT_RATE_VERTEX = 0,
	VK_VERTEX_INPUT_RATE_INSTANCE = 1,
	VK_VERTEX_INPUT_RATE_MAX_ENUM = 0x7fffffff,
}
/// enum `VkPrimitiveTopology` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPrimitiveTopology.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPrimitiveTopology {
	VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
	VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
	VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7fffffff,
}
/// enum `VkPolygonMode` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPolygonMode.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPolygonMode {
	VK_POLYGON_MODE_FILL = 0,
	VK_POLYGON_MODE_LINE = 1,
	VK_POLYGON_MODE_POINT = 2,
	VK_POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000,
	VK_POLYGON_MODE_MAX_ENUM = 0x7fffffff,
}
/// enum `VkStencilOp` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkStencilOp.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkStencilOp {
	VK_STENCIL_OP_KEEP = 0,
	VK_STENCIL_OP_ZERO = 1,
	VK_STENCIL_OP_REPLACE = 2,
	VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
	VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
	VK_STENCIL_OP_INVERT = 5,
	VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
	VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
	VK_STENCIL_OP_MAX_ENUM = 0x7fffffff,
}
/// enum `VkLogicOp` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkLogicOp.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkLogicOp {
	VK_LOGIC_OP_CLEAR = 0,
	VK_LOGIC_OP_AND = 1,
	VK_LOGIC_OP_AND_REVERSE = 2,
	VK_LOGIC_OP_COPY = 3,
	VK_LOGIC_OP_AND_INVERTED = 4,
	VK_LOGIC_OP_NO_OP = 5,
	VK_LOGIC_OP_XOR = 6,
	VK_LOGIC_OP_OR = 7,
	VK_LOGIC_OP_NOR = 8,
	VK_LOGIC_OP_EQUIVALENT = 9,
	VK_LOGIC_OP_INVERT = 10,
	VK_LOGIC_OP_OR_REVERSE = 11,
	VK_LOGIC_OP_COPY_INVERTED = 12,
	VK_LOGIC_OP_OR_INVERTED = 13,
	VK_LOGIC_OP_NAND = 14,
	VK_LOGIC_OP_SET = 15,
	VK_LOGIC_OP_MAX_ENUM = 0x7fffffff,
}
/// enum `VkBorderColor` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBorderColor.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBorderColor {
	VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
	VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
	VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
	VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
	VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
	VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
	VK_BORDER_COLOR_FLOAT_CUSTOM_EXT = 1000287003,
	VK_BORDER_COLOR_INT_CUSTOM_EXT = 1000287004,
	VK_BORDER_COLOR_MAX_ENUM = 0x7fffffff,
}
/// enum `VkFilter` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFilter.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFilter {
	VK_FILTER_NEAREST = 0,
	VK_FILTER_LINEAR = 1,
	VK_FILTER_CUBIC_EXT = 1000015000,
	VK_FILTER_MAX_ENUM = 0x7fffffff,
}
impl VkFilter {
	pub const VK_FILTER_CUBIC_IMG: VkFilter = VkFilter::VK_FILTER_CUBIC_EXT;
}
/// enum `VkSamplerAddressMode` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerAddressMode.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSamplerAddressMode {
	VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
	VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
	VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
	VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7fffffff,
}
impl VkSamplerAddressMode {
	pub const VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR: VkSamplerAddressMode = VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE;
}
/// enum `VkSamplerMipmapMode` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerMipmapMode.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSamplerMipmapMode {
	VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
	VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
	VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7fffffff,
}
/// enum `VkDescriptorType` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorType.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDescriptorType {
	VK_DESCRIPTOR_TYPE_SAMPLER = 0,
	VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
	VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
	VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
	VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
	VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
	VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
	VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK = 1000138000,
	VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
	VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
	VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM = 1000440000,
	VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM = 1000440001,
	VK_DESCRIPTOR_TYPE_TENSOR_ARM = 1000460000,
	VK_DESCRIPTOR_TYPE_MUTABLE_EXT = 1000351000,
	VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV = 1000570000,
	VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7fffffff,
}
impl VkDescriptorType {
	pub const VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT: VkDescriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK;
	pub const VK_DESCRIPTOR_TYPE_MUTABLE_VALVE: VkDescriptorType = VkDescriptorType::VK_DESCRIPTOR_TYPE_MUTABLE_EXT;
}
/// enum `VkAttachmentLoadOp` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentLoadOp.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAttachmentLoadOp {
	VK_ATTACHMENT_LOAD_OP_LOAD = 0,
	VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
	VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
	VK_ATTACHMENT_LOAD_OP_NONE = 1000400000,
	VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7fffffff,
}
impl VkAttachmentLoadOp {
	pub const VK_ATTACHMENT_LOAD_OP_NONE_EXT: VkAttachmentLoadOp = VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_NONE;
	pub const VK_ATTACHMENT_LOAD_OP_NONE_KHR: VkAttachmentLoadOp = VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_NONE;
}
/// enum `VkAttachmentStoreOp` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentStoreOp.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAttachmentStoreOp {
	VK_ATTACHMENT_STORE_OP_STORE = 0,
	VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
	VK_ATTACHMENT_STORE_OP_NONE = 1000301000,
	VK_ATTACHMENT_STORE_OP_MAX_ENUM = 0x7fffffff,
}
impl VkAttachmentStoreOp {
	pub const VK_ATTACHMENT_STORE_OP_NONE_KHR: VkAttachmentStoreOp = VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_NONE;
	pub const VK_ATTACHMENT_STORE_OP_NONE_QCOM: VkAttachmentStoreOp = VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_NONE;
	pub const VK_ATTACHMENT_STORE_OP_NONE_EXT: VkAttachmentStoreOp = VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_NONE;
}
/// enum `VkPipelineBindPoint` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineBindPoint.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineBindPoint {
	VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
	VK_PIPELINE_BIND_POINT_COMPUTE = 1,
	VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX = 1000134000,
	VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR = 1000165000,
	VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI = 1000369003,
	VK_PIPELINE_BIND_POINT_DATA_GRAPH_ARM = 1000507000,
	VK_PIPELINE_BIND_POINT_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineBindPoint {
	pub const VK_PIPELINE_BIND_POINT_RAY_TRACING_NV: VkPipelineBindPoint = VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR;
}
/// enum `VkCommandBufferLevel` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferLevel.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCommandBufferLevel {
	VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
	VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
	VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7fffffff,
}
/// enum `VkIndexType` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndexType.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkIndexType {
	VK_INDEX_TYPE_UINT16 = 0,
	VK_INDEX_TYPE_UINT32 = 1,
	VK_INDEX_TYPE_UINT8 = 1000265000,
	VK_INDEX_TYPE_NONE_KHR = 1000165000,
	VK_INDEX_TYPE_MAX_ENUM = 0x7fffffff,
}
impl VkIndexType {
	pub const VK_INDEX_TYPE_NONE_NV: VkIndexType = VkIndexType::VK_INDEX_TYPE_NONE_KHR;
	pub const VK_INDEX_TYPE_UINT8_EXT: VkIndexType = VkIndexType::VK_INDEX_TYPE_UINT8;
	pub const VK_INDEX_TYPE_UINT8_KHR: VkIndexType = VkIndexType::VK_INDEX_TYPE_UINT8;
}
/// enum `VkSubpassContents` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassContents.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSubpassContents {
	VK_SUBPASS_CONTENTS_INLINE = 0,
	VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
	VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR = 1000451000,
	VK_SUBPASS_CONTENTS_MAX_ENUM = 0x7fffffff,
}
impl VkSubpassContents {
	pub const VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT: VkSubpassContents = VkSubpassContents::VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR;
}
/// enum `VkAccessFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccessFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAccessFlagBits {
	VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
	VK_ACCESS_INDEX_READ_BIT = 0x00000002,
	VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
	VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
	VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
	VK_ACCESS_SHADER_READ_BIT = 0x00000020,
	VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
	VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
	VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
	VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
	VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
	VK_ACCESS_HOST_READ_BIT = 0x00002000,
	VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
	VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
	VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
	VK_ACCESS_NONE = 0,
	VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000,
	VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000,
	VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000,
	VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000,
	VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000,
	VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000,
	VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000,
	VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000,
	VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x00800000,
	VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT = 0x00020000,
	VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT = 0x00040000,
	VK_ACCESS_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkAccessFlagBits {
	pub const VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV: VkAccessFlagBits = VkAccessFlagBits::VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR;
	pub const VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV: VkAccessFlagBits = VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR;
	pub const VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV: VkAccessFlagBits = VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR;
	pub const VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV: VkAccessFlagBits = VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT;
	pub const VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV: VkAccessFlagBits = VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT;
	pub const VK_ACCESS_NONE_KHR: VkAccessFlagBits = VkAccessFlagBits::VK_ACCESS_NONE;
}
/// enum `VkImageAspectFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageAspectFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageAspectFlagBits {
	VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
	VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
	VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
	VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
	VK_IMAGE_ASPECT_PLANE_0_BIT = 0x00000010,
	VK_IMAGE_ASPECT_PLANE_1_BIT = 0x00000020,
	VK_IMAGE_ASPECT_PLANE_2_BIT = 0x00000040,
	VK_IMAGE_ASPECT_NONE = 0,
	VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080,
	VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100,
	VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200,
	VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400,
	VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkImageAspectFlagBits {
	pub const VK_IMAGE_ASPECT_PLANE_0_BIT_KHR: VkImageAspectFlagBits = VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_0_BIT;
	pub const VK_IMAGE_ASPECT_PLANE_1_BIT_KHR: VkImageAspectFlagBits = VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_1_BIT;
	pub const VK_IMAGE_ASPECT_PLANE_2_BIT_KHR: VkImageAspectFlagBits = VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_2_BIT;
	pub const VK_IMAGE_ASPECT_NONE_KHR: VkImageAspectFlagBits = VkImageAspectFlagBits::VK_IMAGE_ASPECT_NONE;
}
/// enum `VkFormatFeatureFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormatFeatureFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFormatFeatureFlagBits {
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
	VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
	VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
	VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
	VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
	VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
	VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
	VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
	VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 0x00004000,
	VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 0x00008000,
	VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 0x00020000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x00080000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x00100000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x00200000,
	VK_FORMAT_FEATURE_DISJOINT_BIT = 0x00400000,
	VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 0x00800000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 0x00010000,
	VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR = 0x02000000,
	VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR = 0x04000000,
	VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x20000000,
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 0x00002000,
	VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x01000000,
	VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x40000000,
	VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR = 0x08000000,
	VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR = 0x10000000,
	VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkFormatFeatureFlagBits {
	pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT;
	pub const VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_SRC_BIT;
	pub const VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_DST_BIT;
	pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT;
	pub const VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT;
	pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT;
	pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT;
	pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT;
	pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT;
	pub const VK_FORMAT_FEATURE_DISJOINT_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_DISJOINT_BIT;
	pub const VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR: VkFormatFeatureFlagBits = VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT;
}
/// enum `VkImageCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageCreateFlagBits {
	VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
	VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
	VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
	VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
	VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
	VK_IMAGE_CREATE_ALIAS_BIT = 0x00000400,
	VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 0x00000040,
	VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 0x00000020,
	VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 0x00000080,
	VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 0x00000100,
	VK_IMAGE_CREATE_PROTECTED_BIT = 0x00000800,
	VK_IMAGE_CREATE_DISJOINT_BIT = 0x00000200,
	VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 0x00002000,
	VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x00001000,
	VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 0x00004000,
	VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00010000,
	VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT = 0x00040000,
	VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT = 0x00020000,
	VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR = 0x00100000,
	VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT = 0x00008000,
	VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkImageCreateFlagBits {
	pub const VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR: VkImageCreateFlagBits = VkImageCreateFlagBits::VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT;
	pub const VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR: VkImageCreateFlagBits = VkImageCreateFlagBits::VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT;
	pub const VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR: VkImageCreateFlagBits = VkImageCreateFlagBits::VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT;
	pub const VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR: VkImageCreateFlagBits = VkImageCreateFlagBits::VK_IMAGE_CREATE_EXTENDED_USAGE_BIT;
	pub const VK_IMAGE_CREATE_DISJOINT_BIT_KHR: VkImageCreateFlagBits = VkImageCreateFlagBits::VK_IMAGE_CREATE_DISJOINT_BIT;
	pub const VK_IMAGE_CREATE_ALIAS_BIT_KHR: VkImageCreateFlagBits = VkImageCreateFlagBits::VK_IMAGE_CREATE_ALIAS_BIT;
	pub const VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM: VkImageCreateFlagBits = VkImageCreateFlagBits::VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT;
}
/// enum `VkSampleCountFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSampleCountFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSampleCountFlagBits {
	VK_SAMPLE_COUNT_1_BIT = 0x00000001,
	VK_SAMPLE_COUNT_2_BIT = 0x00000002,
	VK_SAMPLE_COUNT_4_BIT = 0x00000004,
	VK_SAMPLE_COUNT_8_BIT = 0x00000008,
	VK_SAMPLE_COUNT_16_BIT = 0x00000010,
	VK_SAMPLE_COUNT_32_BIT = 0x00000020,
	VK_SAMPLE_COUNT_64_BIT = 0x00000040,
	VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkImageUsageFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageUsageFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageUsageFlagBits {
	VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
	VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
	VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
	VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
	VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
	VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
	VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
	VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
	VK_IMAGE_USAGE_HOST_TRANSFER_BIT = 0x00400000,
	VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00000400,
	VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00000800,
	VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR = 0x00001000,
	VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x00000200,
	VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00000100,
	VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00002000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00004000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR = 0x00008000,
	VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x00080000,
	VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI = 0x00040000,
	VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM = 0x00100000,
	VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM = 0x00200000,
	VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM = 0x00800000,
	VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM = 0x08000000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x02000000,
	VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR = 0x04000000,
	VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkImageUsageFlagBits {
	pub const VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV: VkImageUsageFlagBits = VkImageUsageFlagBits::VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
	pub const VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT: VkImageUsageFlagBits = VkImageUsageFlagBits::VK_IMAGE_USAGE_HOST_TRANSFER_BIT;
}
/// enum `VkInstanceCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkInstanceCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkInstanceCreateFlagBits {
	VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR = 0x00000001,
	VK_INSTANCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkMemoryHeapFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryHeapFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkMemoryHeapFlagBits {
	VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
	VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 0x00000002,
	VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM = 0x00000008,
	VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkMemoryHeapFlagBits {
	pub const VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR: VkMemoryHeapFlagBits = VkMemoryHeapFlagBits::VK_MEMORY_HEAP_MULTI_INSTANCE_BIT;
}
/// enum `VkMemoryPropertyFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryPropertyFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkMemoryPropertyFlagBits {
	VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
	VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
	VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
	VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
	VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
	VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x00000020,
	VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x00000040,
	VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x00000080,
	VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 0x00000100,
	VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkQueueFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueueFlagBits {
	VK_QUEUE_GRAPHICS_BIT = 0x00000001,
	VK_QUEUE_COMPUTE_BIT = 0x00000002,
	VK_QUEUE_TRANSFER_BIT = 0x00000004,
	VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
	VK_QUEUE_PROTECTED_BIT = 0x00000010,
	VK_QUEUE_VIDEO_DECODE_BIT_KHR = 0x00000020,
	VK_QUEUE_VIDEO_ENCODE_BIT_KHR = 0x00000040,
	VK_QUEUE_OPTICAL_FLOW_BIT_NV = 0x00000100,
	VK_QUEUE_DATA_GRAPH_BIT_ARM = 0x00000400,
	VK_QUEUE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkDeviceQueueCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceQueueCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceQueueCreateFlagBits {
	VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x00000001,
	VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkPipelineStageFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineStageFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineStageFlagBits {
	VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
	VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
	VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
	VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
	VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
	VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
	VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
	VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
	VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
	VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
	VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
	VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
	VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
	VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
	VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
	VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
	VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
	VK_PIPELINE_STAGE_NONE = 0,
	VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000,
	VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000,
	VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000,
	VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 0x00200000,
	VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000,
	VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000,
	VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT = 0x00080000,
	VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT = 0x00100000,
	VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT = 0x00020000,
	VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineStageFlagBits {
	pub const VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV: VkPipelineStageFlagBits = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
	pub const VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV: VkPipelineStageFlagBits = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR;
	pub const VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV: VkPipelineStageFlagBits = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR;
	pub const VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV: VkPipelineStageFlagBits = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT;
	pub const VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV: VkPipelineStageFlagBits = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT;
	pub const VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV: VkPipelineStageFlagBits = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT;
	pub const VK_PIPELINE_STAGE_NONE_KHR: VkPipelineStageFlagBits = VkPipelineStageFlagBits::VK_PIPELINE_STAGE_NONE;
}
/// enum `VkMemoryMapFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryMapFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkMemoryMapFlagBits {
	VK_MEMORY_MAP_PLACED_BIT_EXT = 0x00000001,
	VK_MEMORY_MAP_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkSparseMemoryBindFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSparseMemoryBindFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSparseMemoryBindFlagBits {
	VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
	VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkSparseImageFormatFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSparseImageFormatFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSparseImageFormatFlagBits {
	VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
	VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
	VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
	VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkFenceCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFenceCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFenceCreateFlagBits {
	VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
	VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkEventCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkEventCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkEventCreateFlagBits {
	VK_EVENT_CREATE_DEVICE_ONLY_BIT = 0x00000001,
	VK_EVENT_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkEventCreateFlagBits {
	pub const VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR: VkEventCreateFlagBits = VkEventCreateFlagBits::VK_EVENT_CREATE_DEVICE_ONLY_BIT;
}
/// enum `VkQueryPipelineStatisticFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryPipelineStatisticFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueryPipelineStatisticFlagBits {
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
	VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
	VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
	VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
	VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT = 0x00000800,
	VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT = 0x00001000,
	VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI = 0x00002000,
	VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkQueryPoolCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryPoolCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueryPoolCreateFlagBits {
	VK_QUERY_POOL_CREATE_RESET_BIT_KHR = 0x00000001,
	VK_QUERY_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkQueryResultFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryResultFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueryResultFlagBits {
	VK_QUERY_RESULT_64_BIT = 0x00000001,
	VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
	VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
	VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
	VK_QUERY_RESULT_WITH_STATUS_BIT_KHR = 0x00000010,
	VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkBufferCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBufferCreateFlagBits {
	VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
	VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
	VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
	VK_BUFFER_CREATE_PROTECTED_BIT = 0x00000008,
	VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x00000010,
	VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000020,
	VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR = 0x00000040,
	VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkBufferCreateFlagBits {
	pub const VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT: VkBufferCreateFlagBits = VkBufferCreateFlagBits::VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT;
	pub const VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR: VkBufferCreateFlagBits = VkBufferCreateFlagBits::VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT;
}
/// enum `VkBufferUsageFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferUsageFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBufferUsageFlagBits {
	VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
	VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
	VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
	VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
	VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
	VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
	VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
	VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
	VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
	VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 0x00020000,
	VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00002000,
	VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00004000,
	VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800,
	VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000,
	VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200,
	VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX = 0x02000000,
	VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 0x00080000,
	VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 0x00100000,
	VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = 0x00000400,
	VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00008000,
	VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00010000,
	VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = 0x00200000,
	VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = 0x00400000,
	VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 0x04000000,
	VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 0x00800000,
	VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT = 0x01000000,
	VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM = 0x08000000,
	VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkBufferUsageFlagBits {
	pub const VK_BUFFER_USAGE_RAY_TRACING_BIT_NV: VkBufferUsageFlagBits = VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR;
	pub const VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT: VkBufferUsageFlagBits = VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;
	pub const VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR: VkBufferUsageFlagBits = VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;
}
/// enum `VkImageViewCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageViewCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageViewCreateFlagBits {
	VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 0x00000001,
	VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000004,
	VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = 0x00000002,
	VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkPipelineCacheCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCacheCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineCacheCreateFlagBits {
	VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT = 0x00000001,
	VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR = 0x00000008,
	VK_PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineCacheCreateFlagBits {
	pub const VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT: VkPipelineCacheCreateFlagBits = VkPipelineCacheCreateFlagBits::VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT;
}
/// enum `VkColorComponentFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkColorComponentFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkColorComponentFlagBits {
	VK_COLOR_COMPONENT_R_BIT = 0x00000001,
	VK_COLOR_COMPONENT_G_BIT = 0x00000002,
	VK_COLOR_COMPONENT_B_BIT = 0x00000004,
	VK_COLOR_COMPONENT_A_BIT = 0x00000008,
	VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkPipelineCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineCreateFlagBits {
	VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
	VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
	VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
	VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x00000008,
	VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = 0x00000010,
	VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 0x00000100,
	VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT = 0x00000200,
	VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT = 0x08000000,
	VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT = 0x40000000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x00004000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x00008000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x00010000,
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 0x00020000,
	VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 0x00001000,
	VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x00002000,
	VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x00080000,
	VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 0x00000020,
	VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000,
	VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000,
	VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 0x00000040,
	VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080,
	VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x00040000,
	VK_PIPELINE_CREATE_LIBRARY_BIT_KHR = 0x00000800,
	VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 0x20000000,
	VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = 0x00800000,
	VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT = 0x00000400,
	VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV = 0x00100000,
	VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x02000000,
	VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x04000000,
	VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = 0x01000000,
	VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV = 0x10000000,
	VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineCreateFlagBits {
	pub const VK_PIPELINE_CREATE_DISPATCH_BASE: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_BIT;
	pub const VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT;
	pub const VK_PIPELINE_CREATE_DISPATCH_BASE_BIT_KHR: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_BIT;
	pub const VK_PIPELINE_CREATE_DISPATCH_BASE_KHR: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_BIT;
	pub const VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT;
	pub const VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;
	pub const VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT;
	pub const VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT;
	pub const VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT;
	pub const VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT: VkPipelineCreateFlagBits = VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT;
}
/// enum `VkPipelineShaderStageCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineShaderStageCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineShaderStageCreateFlagBits {
	VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = 0x00000001,
	VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = 0x00000002,
	VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineShaderStageCreateFlagBits {
	pub const VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT: VkPipelineShaderStageCreateFlagBits = VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT;
	pub const VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT: VkPipelineShaderStageCreateFlagBits = VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT;
}
/// enum `VkShaderStageFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderStageFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkShaderStageFlagBits {
	VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
	VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
	VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
	VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
	VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
	VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
	VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001f,
	VK_SHADER_STAGE_ALL = 0x7fffffff,
	VK_SHADER_STAGE_RAYGEN_BIT_KHR = 0x00000100,
	VK_SHADER_STAGE_ANY_HIT_BIT_KHR = 0x00000200,
	VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR = 0x00000400,
	VK_SHADER_STAGE_MISS_BIT_KHR = 0x00000800,
	VK_SHADER_STAGE_INTERSECTION_BIT_KHR = 0x00001000,
	VK_SHADER_STAGE_CALLABLE_BIT_KHR = 0x00002000,
	VK_SHADER_STAGE_TASK_BIT_EXT = 0x00000040,
	VK_SHADER_STAGE_MESH_BIT_EXT = 0x00000080,
	VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI = 0x00004000,
	VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI = 0x00080000,
}
impl VkShaderStageFlagBits {
	pub const VK_SHADER_STAGE_RAYGEN_BIT_NV: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_RAYGEN_BIT_KHR;
	pub const VK_SHADER_STAGE_ANY_HIT_BIT_NV: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_ANY_HIT_BIT_KHR;
	pub const VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR;
	pub const VK_SHADER_STAGE_MISS_BIT_NV: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_MISS_BIT_KHR;
	pub const VK_SHADER_STAGE_INTERSECTION_BIT_NV: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_INTERSECTION_BIT_KHR;
	pub const VK_SHADER_STAGE_CALLABLE_BIT_NV: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_CALLABLE_BIT_KHR;
	pub const VK_SHADER_STAGE_TASK_BIT_NV: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_TASK_BIT_EXT;
	pub const VK_SHADER_STAGE_MESH_BIT_NV: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_MESH_BIT_EXT;
	pub const VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM: VkShaderStageFlagBits = VkShaderStageFlagBits::VK_SHADER_STAGE_ALL;
}
/// enum `VkCullModeFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCullModeFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCullModeFlagBits {
	VK_CULL_MODE_NONE = 0,
	VK_CULL_MODE_FRONT_BIT = 0x00000001,
	VK_CULL_MODE_BACK_BIT = 0x00000002,
	VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
	VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkPipelineDepthStencilStateCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineDepthStencilStateCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineDepthStencilStateCreateFlagBits {
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 0x00000001,
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 0x00000002,
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineDepthStencilStateCreateFlagBits {
	pub const VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM: VkPipelineDepthStencilStateCreateFlagBits = VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT;
	pub const VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM: VkPipelineDepthStencilStateCreateFlagBits = VkPipelineDepthStencilStateCreateFlagBits::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT;
}
/// enum `VkPipelineColorBlendStateCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineColorBlendStateCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineColorBlendStateCreateFlagBits {
	VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT = 0x00000001,
	VK_PIPELINE_COLOR_BLEND_STATE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineColorBlendStateCreateFlagBits {
	pub const VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM: VkPipelineColorBlendStateCreateFlagBits = VkPipelineColorBlendStateCreateFlagBits::VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT;
}
/// enum `VkPipelineLayoutCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineLayoutCreateFlagBits {
	VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT = 0x00000002,
	VK_PIPELINE_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkSamplerCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSamplerCreateFlagBits {
	VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 0x00000001,
	VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 0x00000002,
	VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000008,
	VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT = 0x00000004,
	VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM = 0x00000010,
	VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkDescriptorPoolCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDescriptorPoolCreateFlagBits {
	VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
	VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = 0x00000002,
	VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT = 0x00000004,
	VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV = 0x00000008,
	VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV = 0x00000010,
	VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkDescriptorPoolCreateFlagBits {
	pub const VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT: VkDescriptorPoolCreateFlagBits = VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT;
	pub const VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE: VkDescriptorPoolCreateFlagBits = VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT;
}
/// enum `VkDescriptorSetLayoutCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDescriptorSetLayoutCreateFlagBits {
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 0x00000002,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT = 0x00000001,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 0x00000010,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT = 0x00000020,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x00000080,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT = 0x00000004,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV = 0x00000040,
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkDescriptorSetLayoutCreateFlagBits {
	pub const VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR: VkDescriptorSetLayoutCreateFlagBits = VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT;
	pub const VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT: VkDescriptorSetLayoutCreateFlagBits = VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT;
	pub const VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE: VkDescriptorSetLayoutCreateFlagBits = VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT;
}
/// enum `VkAttachmentDescriptionFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentDescriptionFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAttachmentDescriptionFlagBits {
	VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
	VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkDependencyFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDependencyFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDependencyFlagBits {
	VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
	VK_DEPENDENCY_DEVICE_GROUP_BIT = 0x00000004,
	VK_DEPENDENCY_VIEW_LOCAL_BIT = 0x00000002,
	VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = 0x00000008,
	VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR = 0x00000020,
	VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR = 0x00000040,
	VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkDependencyFlagBits {
	pub const VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR: VkDependencyFlagBits = VkDependencyFlagBits::VK_DEPENDENCY_VIEW_LOCAL_BIT;
	pub const VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR: VkDependencyFlagBits = VkDependencyFlagBits::VK_DEPENDENCY_DEVICE_GROUP_BIT;
}
/// enum `VkFramebufferCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFramebufferCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFramebufferCreateFlagBits {
	VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = 0x00000001,
	VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkFramebufferCreateFlagBits {
	pub const VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR: VkFramebufferCreateFlagBits = VkFramebufferCreateFlagBits::VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT;
}
/// enum `VkRenderPassCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkRenderPassCreateFlagBits {
	VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = 0x00000002,
	VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE = 0x00000004,
	VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkSubpassDescriptionFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassDescriptionFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSubpassDescriptionFlagBits {
	VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 0x00000001,
	VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 0x00000002,
	VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM = 0x00000004,
	VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM = 0x00000008,
	VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM = 0x00000100,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT = 0x00000010,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 0x00000020,
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 0x00000040,
	VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x00000080,
	VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkSubpassDescriptionFlagBits {
	pub const VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM: VkSubpassDescriptionFlagBits = VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT;
	pub const VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM: VkSubpassDescriptionFlagBits = VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT;
	pub const VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM: VkSubpassDescriptionFlagBits = VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT;
}
/// enum `VkCommandPoolCreateFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandPoolCreateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCommandPoolCreateFlagBits {
	VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
	VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
	VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 0x00000004,
	VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkCommandPoolResetFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandPoolResetFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCommandPoolResetFlagBits {
	VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
	VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkCommandBufferUsageFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferUsageFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCommandBufferUsageFlagBits {
	VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
	VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
	VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
	VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkQueryControlFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryControlFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueryControlFlagBits {
	VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
	VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkCommandBufferResetFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferResetFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCommandBufferResetFlagBits {
	VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
	VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkStencilFaceFlagBits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkStencilFaceFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkStencilFaceFlagBits {
	VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
	VK_STENCIL_FACE_BACK_BIT = 0x00000002,
	VK_STENCIL_FACE_FRONT_AND_BACK = 0x00000003,
	VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkStencilFaceFlagBits {
	pub const VK_STENCIL_FRONT_AND_BACK: VkStencilFaceFlagBits = VkStencilFaceFlagBits::VK_STENCIL_FACE_FRONT_AND_BACK;
}
/// union `VkClearColorValue` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClearColorValue.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkClearColorValue {
	pub float32: [f32; 4 as usize],
	pub int32: [i32; 4 as usize],
	pub uint32: [u32; 4 as usize],
}
impl Debug for VkClearColorValue {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClearColorValue")
		.field("float32", unsafe {&self.float32})
		.field("int32", unsafe {&self.int32})
		.field("uint32", unsafe {&self.uint32})
		.finish()
	}
}
/// union `VkClearValue` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClearValue.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkClearValue {
	pub color: VkClearColorValue,
	pub depthStencil: VkClearDepthStencilValue,
}
impl Debug for VkClearValue {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClearValue")
		.field("color", unsafe {&self.color})
		.field("depthStencil", unsafe {&self.depthStencil})
		.finish()
	}
}
/// struct `VkExtent2D` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExtent2D.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExtent2D {
	pub width: u32,
	pub height: u32,
}
impl Debug for VkExtent2D {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExtent2D")
		.field("width", &self.width)
		.field("height", &self.height)
		.finish()
	}
}
/// struct `VkExtent3D` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExtent3D.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExtent3D {
	pub width: u32,
	pub height: u32,
	pub depth: u32,
}
impl Debug for VkExtent3D {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExtent3D")
		.field("width", &self.width)
		.field("height", &self.height)
		.field("depth", &self.depth)
		.finish()
	}
}
/// struct `VkOffset2D` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOffset2D.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkOffset2D {
	pub x: i32,
	pub y: i32,
}
impl Debug for VkOffset2D {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkOffset2D")
		.field("x", &self.x)
		.field("y", &self.y)
		.finish()
	}
}
/// struct `VkOffset3D` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOffset3D.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkOffset3D {
	pub x: i32,
	pub y: i32,
	pub z: i32,
}
impl Debug for VkOffset3D {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkOffset3D")
		.field("x", &self.x)
		.field("y", &self.y)
		.field("z", &self.z)
		.finish()
	}
}
/// struct `VkRect2D` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRect2D.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRect2D {
	pub offset: VkOffset2D,
	pub extent: VkExtent2D,
}
impl Debug for VkRect2D {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRect2D")
		.field("offset", &self.offset)
		.field("extent", &self.extent)
		.finish()
	}
}
/// struct `VkBaseInStructure` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBaseInStructure.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBaseInStructure {
	pub sType: VkStructureType,
	pub pNext: *const VkBaseInStructure,
}
impl Debug for VkBaseInStructure {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBaseInStructure")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.finish()
	}
}
/// struct `VkBaseOutStructure` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBaseOutStructure.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBaseOutStructure {
	pub sType: VkStructureType,
	pub pNext: *mut VkBaseOutStructure,
}
impl Debug for VkBaseOutStructure {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBaseOutStructure")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.finish()
	}
}
/// struct `VkBufferMemoryBarrier` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferMemoryBarrier.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBufferMemoryBarrier {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcAccessMask: VkAccessFlags,
	pub dstAccessMask: VkAccessFlags,
	pub srcQueueFamilyIndex: u32,
	pub dstQueueFamilyIndex: u32,
	pub buffer: VkBuffer,
	pub offset: VkDeviceSize,
	pub size: VkDeviceSize,
}
impl Debug for VkBufferMemoryBarrier {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBufferMemoryBarrier")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcAccessMask", &format_args!("{}", vk_access_flags_to_string(self.srcAccessMask)))
		.field("dstAccessMask", &format_args!("{}", vk_access_flags_to_string(self.dstAccessMask)))
		.field("srcQueueFamilyIndex", &self.srcQueueFamilyIndex)
		.field("dstQueueFamilyIndex", &self.dstQueueFamilyIndex)
		.field("buffer", &self.buffer)
		.field("offset", &self.offset)
		.field("size", &self.size)
		.finish()
	}
}
/// struct `VkDispatchIndirectCommand` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDispatchIndirectCommand.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDispatchIndirectCommand {
	pub x: u32,
	pub y: u32,
	pub z: u32,
}
impl Debug for VkDispatchIndirectCommand {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDispatchIndirectCommand")
		.field("x", &self.x)
		.field("y", &self.y)
		.field("z", &self.z)
		.finish()
	}
}
/// struct `VkDrawIndexedIndirectCommand` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDrawIndexedIndirectCommand.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDrawIndexedIndirectCommand {
	pub indexCount: u32,
	pub instanceCount: u32,
	pub firstIndex: u32,
	pub vertexOffset: i32,
	pub firstInstance: u32,
}
impl Debug for VkDrawIndexedIndirectCommand {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDrawIndexedIndirectCommand")
		.field("indexCount", &self.indexCount)
		.field("instanceCount", &self.instanceCount)
		.field("firstIndex", &self.firstIndex)
		.field("vertexOffset", &self.vertexOffset)
		.field("firstInstance", &self.firstInstance)
		.finish()
	}
}
/// struct `VkDrawIndirectCommand` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDrawIndirectCommand.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDrawIndirectCommand {
	pub vertexCount: u32,
	pub instanceCount: u32,
	pub firstVertex: u32,
	pub firstInstance: u32,
}
impl Debug for VkDrawIndirectCommand {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDrawIndirectCommand")
		.field("vertexCount", &self.vertexCount)
		.field("instanceCount", &self.instanceCount)
		.field("firstVertex", &self.firstVertex)
		.field("firstInstance", &self.firstInstance)
		.finish()
	}
}
/// struct `VkImageSubresourceRange` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageSubresourceRange.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageSubresourceRange {
	pub aspectMask: VkImageAspectFlags,
	pub baseMipLevel: u32,
	pub levelCount: u32,
	pub baseArrayLayer: u32,
	pub layerCount: u32,
}
impl Debug for VkImageSubresourceRange {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageSubresourceRange")
		.field("aspectMask", &format_args!("{}", vk_image_aspect_flags_to_string(self.aspectMask)))
		.field("baseMipLevel", &self.baseMipLevel)
		.field("levelCount", &self.levelCount)
		.field("baseArrayLayer", &self.baseArrayLayer)
		.field("layerCount", &self.layerCount)
		.finish()
	}
}
/// struct `VkImageMemoryBarrier` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageMemoryBarrier {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcAccessMask: VkAccessFlags,
	pub dstAccessMask: VkAccessFlags,
	pub oldLayout: VkImageLayout,
	pub newLayout: VkImageLayout,
	pub srcQueueFamilyIndex: u32,
	pub dstQueueFamilyIndex: u32,
	pub image: VkImage,
	pub subresourceRange: VkImageSubresourceRange,
}
impl Debug for VkImageMemoryBarrier {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageMemoryBarrier")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcAccessMask", &format_args!("{}", vk_access_flags_to_string(self.srcAccessMask)))
		.field("dstAccessMask", &format_args!("{}", vk_access_flags_to_string(self.dstAccessMask)))
		.field("oldLayout", &self.oldLayout)
		.field("newLayout", &self.newLayout)
		.field("srcQueueFamilyIndex", &self.srcQueueFamilyIndex)
		.field("dstQueueFamilyIndex", &self.dstQueueFamilyIndex)
		.field("image", &self.image)
		.field("subresourceRange", &self.subresourceRange)
		.finish()
	}
}
/// struct `VkMemoryBarrier` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryBarrier.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryBarrier {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcAccessMask: VkAccessFlags,
	pub dstAccessMask: VkAccessFlags,
}
impl Debug for VkMemoryBarrier {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryBarrier")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcAccessMask", &format_args!("{}", vk_access_flags_to_string(self.srcAccessMask)))
		.field("dstAccessMask", &format_args!("{}", vk_access_flags_to_string(self.dstAccessMask)))
		.finish()
	}
}
/// struct `VkPipelineCacheHeaderVersionOne` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCacheHeaderVersionOne.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineCacheHeaderVersionOne {
	pub headerSize: u32,
	pub headerVersion: VkPipelineCacheHeaderVersion,
	pub vendorID: u32,
	pub deviceID: u32,
	pub pipelineCacheUUID: [u8; VK_UUID_SIZE as usize],
}
impl Debug for VkPipelineCacheHeaderVersionOne {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineCacheHeaderVersionOne")
		.field("headerSize", &self.headerSize)
		.field("headerVersion", &self.headerVersion)
		.field("vendorID", &self.vendorID)
		.field("deviceID", &self.deviceID)
		.field("pipelineCacheUUID", &self.pipelineCacheUUID)
		.finish()
	}
}
/// struct `VkAllocationCallbacks` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAllocationCallbacks.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAllocationCallbacks {
	pub pUserData: *mut c_void,
	pub pfnAllocation: PFN_vkAllocationFunction,
	pub pfnReallocation: PFN_vkReallocationFunction,
	pub pfnFree: PFN_vkFreeFunction,
	pub pfnInternalAllocation: PFN_vkInternalAllocationNotification,
	pub pfnInternalFree: PFN_vkInternalFreeNotification,
}
impl Debug for VkAllocationCallbacks {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAllocationCallbacks")
		.field("pUserData", &self.pUserData)
		.field("pfnAllocation", &self.pfnAllocation)
		.field("pfnReallocation", &self.pfnReallocation)
		.field("pfnFree", &self.pfnFree)
		.field("pfnInternalAllocation", &self.pfnInternalAllocation)
		.field("pfnInternalFree", &self.pfnInternalFree)
		.finish()
	}
}
/// struct `VkApplicationInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkApplicationInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkApplicationInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pApplicationName: *const i8,
	pub applicationVersion: u32,
	pub pEngineName: *const i8,
	pub engineVersion: u32,
	pub apiVersion: u32,
}
impl Debug for VkApplicationInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkApplicationInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pApplicationName", &self.pApplicationName)
		.field("applicationVersion", &self.applicationVersion)
		.field("pEngineName", &self.pEngineName)
		.field("engineVersion", &self.engineVersion)
		.field("apiVersion", &self.apiVersion)
		.finish()
	}
}
/// struct `VkFormatProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormatProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkFormatProperties {
	pub linearTilingFeatures: VkFormatFeatureFlags,
	pub optimalTilingFeatures: VkFormatFeatureFlags,
	pub bufferFeatures: VkFormatFeatureFlags,
}
impl Debug for VkFormatProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkFormatProperties")
		.field("linearTilingFeatures", &format_args!("{}", vk_format_feature_flags_to_string(self.linearTilingFeatures)))
		.field("optimalTilingFeatures", &format_args!("{}", vk_format_feature_flags_to_string(self.optimalTilingFeatures)))
		.field("bufferFeatures", &format_args!("{}", vk_format_feature_flags_to_string(self.bufferFeatures)))
		.finish()
	}
}
/// struct `VkImageFormatProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageFormatProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageFormatProperties {
	pub maxExtent: VkExtent3D,
	pub maxMipLevels: u32,
	pub maxArrayLayers: u32,
	pub sampleCounts: VkSampleCountFlags,
	pub maxResourceSize: VkDeviceSize,
}
impl Debug for VkImageFormatProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageFormatProperties")
		.field("maxExtent", &self.maxExtent)
		.field("maxMipLevels", &self.maxMipLevels)
		.field("maxArrayLayers", &self.maxArrayLayers)
		.field("sampleCounts", &format_args!("{}", vk_sample_count_flags_to_string(self.sampleCounts)))
		.field("maxResourceSize", &self.maxResourceSize)
		.finish()
	}
}
/// struct `VkInstanceCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkInstanceCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkInstanceCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkInstanceCreateFlags,
	pub pApplicationInfo: *const VkApplicationInfo,
	pub enabledLayerCount: u32,
	pub ppEnabledLayerNames: *const *const char,
	pub enabledExtensionCount: u32,
	pub ppEnabledExtensionNames: *const *const char,
}
impl Debug for VkInstanceCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkInstanceCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_instance_create_flags_to_string(self.flags)))
		.field("pApplicationInfo", &self.pApplicationInfo)
		.field("enabledLayerCount", &self.enabledLayerCount)
		.field("ppEnabledLayerNames", &self.ppEnabledLayerNames)
		.field("enabledExtensionCount", &self.enabledExtensionCount)
		.field("ppEnabledExtensionNames", &self.ppEnabledExtensionNames)
		.finish()
	}
}
/// struct `VkMemoryHeap` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryHeap.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryHeap {
	pub size: VkDeviceSize,
	pub flags: VkMemoryHeapFlags,
}
impl Debug for VkMemoryHeap {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryHeap")
		.field("size", &self.size)
		.field("flags", &format_args!("{}", vk_memory_heap_flags_to_string(self.flags)))
		.finish()
	}
}
/// struct `VkMemoryType` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryType.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryType {
	pub propertyFlags: VkMemoryPropertyFlags,
	pub heapIndex: u32,
}
impl Debug for VkMemoryType {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryType")
		.field("propertyFlags", &format_args!("{}", vk_memory_property_flags_to_string(self.propertyFlags)))
		.field("heapIndex", &self.heapIndex)
		.finish()
	}
}
/// struct `VkPhysicalDeviceFeatures` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFeatures {
	pub robustBufferAccess: VkBool32,
	pub fullDrawIndexUint32: VkBool32,
	pub imageCubeArray: VkBool32,
	pub independentBlend: VkBool32,
	pub geometryShader: VkBool32,
	pub tessellationShader: VkBool32,
	pub sampleRateShading: VkBool32,
	pub dualSrcBlend: VkBool32,
	pub logicOp: VkBool32,
	pub multiDrawIndirect: VkBool32,
	pub drawIndirectFirstInstance: VkBool32,
	pub depthClamp: VkBool32,
	pub depthBiasClamp: VkBool32,
	pub fillModeNonSolid: VkBool32,
	pub depthBounds: VkBool32,
	pub wideLines: VkBool32,
	pub largePoints: VkBool32,
	pub alphaToOne: VkBool32,
	pub multiViewport: VkBool32,
	pub samplerAnisotropy: VkBool32,
	pub textureCompressionETC2: VkBool32,
	pub textureCompressionASTC_LDR: VkBool32,
	pub textureCompressionBC: VkBool32,
	pub occlusionQueryPrecise: VkBool32,
	pub pipelineStatisticsQuery: VkBool32,
	pub vertexPipelineStoresAndAtomics: VkBool32,
	pub fragmentStoresAndAtomics: VkBool32,
	pub shaderTessellationAndGeometryPointSize: VkBool32,
	pub shaderImageGatherExtended: VkBool32,
	pub shaderStorageImageExtendedFormats: VkBool32,
	pub shaderStorageImageMultisample: VkBool32,
	pub shaderStorageImageReadWithoutFormat: VkBool32,
	pub shaderStorageImageWriteWithoutFormat: VkBool32,
	pub shaderUniformBufferArrayDynamicIndexing: VkBool32,
	pub shaderSampledImageArrayDynamicIndexing: VkBool32,
	pub shaderStorageBufferArrayDynamicIndexing: VkBool32,
	pub shaderStorageImageArrayDynamicIndexing: VkBool32,
	pub shaderClipDistance: VkBool32,
	pub shaderCullDistance: VkBool32,
	pub shaderFloat64: VkBool32,
	pub shaderInt64: VkBool32,
	pub shaderInt16: VkBool32,
	pub shaderResourceResidency: VkBool32,
	pub shaderResourceMinLod: VkBool32,
	pub sparseBinding: VkBool32,
	pub sparseResidencyBuffer: VkBool32,
	pub sparseResidencyImage2D: VkBool32,
	pub sparseResidencyImage3D: VkBool32,
	pub sparseResidency2Samples: VkBool32,
	pub sparseResidency4Samples: VkBool32,
	pub sparseResidency8Samples: VkBool32,
	pub sparseResidency16Samples: VkBool32,
	pub sparseResidencyAliased: VkBool32,
	pub variableMultisampleRate: VkBool32,
	pub inheritedQueries: VkBool32,
}
impl Debug for VkPhysicalDeviceFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFeatures")
		.field("robustBufferAccess", &self.robustBufferAccess)
		.field("fullDrawIndexUint32", &self.fullDrawIndexUint32)
		.field("imageCubeArray", &self.imageCubeArray)
		.field("independentBlend", &self.independentBlend)
		.field("geometryShader", &self.geometryShader)
		.field("tessellationShader", &self.tessellationShader)
		.field("sampleRateShading", &self.sampleRateShading)
		.field("dualSrcBlend", &self.dualSrcBlend)
		.field("logicOp", &self.logicOp)
		.field("multiDrawIndirect", &self.multiDrawIndirect)
		.field("drawIndirectFirstInstance", &self.drawIndirectFirstInstance)
		.field("depthClamp", &self.depthClamp)
		.field("depthBiasClamp", &self.depthBiasClamp)
		.field("fillModeNonSolid", &self.fillModeNonSolid)
		.field("depthBounds", &self.depthBounds)
		.field("wideLines", &self.wideLines)
		.field("largePoints", &self.largePoints)
		.field("alphaToOne", &self.alphaToOne)
		.field("multiViewport", &self.multiViewport)
		.field("samplerAnisotropy", &self.samplerAnisotropy)
		.field("textureCompressionETC2", &self.textureCompressionETC2)
		.field("textureCompressionASTC_LDR", &self.textureCompressionASTC_LDR)
		.field("textureCompressionBC", &self.textureCompressionBC)
		.field("occlusionQueryPrecise", &self.occlusionQueryPrecise)
		.field("pipelineStatisticsQuery", &self.pipelineStatisticsQuery)
		.field("vertexPipelineStoresAndAtomics", &self.vertexPipelineStoresAndAtomics)
		.field("fragmentStoresAndAtomics", &self.fragmentStoresAndAtomics)
		.field("shaderTessellationAndGeometryPointSize", &self.shaderTessellationAndGeometryPointSize)
		.field("shaderImageGatherExtended", &self.shaderImageGatherExtended)
		.field("shaderStorageImageExtendedFormats", &self.shaderStorageImageExtendedFormats)
		.field("shaderStorageImageMultisample", &self.shaderStorageImageMultisample)
		.field("shaderStorageImageReadWithoutFormat", &self.shaderStorageImageReadWithoutFormat)
		.field("shaderStorageImageWriteWithoutFormat", &self.shaderStorageImageWriteWithoutFormat)
		.field("shaderUniformBufferArrayDynamicIndexing", &self.shaderUniformBufferArrayDynamicIndexing)
		.field("shaderSampledImageArrayDynamicIndexing", &self.shaderSampledImageArrayDynamicIndexing)
		.field("shaderStorageBufferArrayDynamicIndexing", &self.shaderStorageBufferArrayDynamicIndexing)
		.field("shaderStorageImageArrayDynamicIndexing", &self.shaderStorageImageArrayDynamicIndexing)
		.field("shaderClipDistance", &self.shaderClipDistance)
		.field("shaderCullDistance", &self.shaderCullDistance)
		.field("shaderFloat64", &self.shaderFloat64)
		.field("shaderInt64", &self.shaderInt64)
		.field("shaderInt16", &self.shaderInt16)
		.field("shaderResourceResidency", &self.shaderResourceResidency)
		.field("shaderResourceMinLod", &self.shaderResourceMinLod)
		.field("sparseBinding", &self.sparseBinding)
		.field("sparseResidencyBuffer", &self.sparseResidencyBuffer)
		.field("sparseResidencyImage2D", &self.sparseResidencyImage2D)
		.field("sparseResidencyImage3D", &self.sparseResidencyImage3D)
		.field("sparseResidency2Samples", &self.sparseResidency2Samples)
		.field("sparseResidency4Samples", &self.sparseResidency4Samples)
		.field("sparseResidency8Samples", &self.sparseResidency8Samples)
		.field("sparseResidency16Samples", &self.sparseResidency16Samples)
		.field("sparseResidencyAliased", &self.sparseResidencyAliased)
		.field("variableMultisampleRate", &self.variableMultisampleRate)
		.field("inheritedQueries", &self.inheritedQueries)
		.finish()
	}
}
/// struct `VkPhysicalDeviceLimits` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLimits.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceLimits {
	pub maxImageDimension1D: u32,
	pub maxImageDimension2D: u32,
	pub maxImageDimension3D: u32,
	pub maxImageDimensionCube: u32,
	pub maxImageArrayLayers: u32,
	pub maxTexelBufferElements: u32,
	pub maxUniformBufferRange: u32,
	pub maxStorageBufferRange: u32,
	pub maxPushConstantsSize: u32,
	pub maxMemoryAllocationCount: u32,
	pub maxSamplerAllocationCount: u32,
	pub bufferImageGranularity: VkDeviceSize,
	pub sparseAddressSpaceSize: VkDeviceSize,
	pub maxBoundDescriptorSets: u32,
	pub maxPerStageDescriptorSamplers: u32,
	pub maxPerStageDescriptorUniformBuffers: u32,
	pub maxPerStageDescriptorStorageBuffers: u32,
	pub maxPerStageDescriptorSampledImages: u32,
	pub maxPerStageDescriptorStorageImages: u32,
	pub maxPerStageDescriptorInputAttachments: u32,
	pub maxPerStageResources: u32,
	pub maxDescriptorSetSamplers: u32,
	pub maxDescriptorSetUniformBuffers: u32,
	pub maxDescriptorSetUniformBuffersDynamic: u32,
	pub maxDescriptorSetStorageBuffers: u32,
	pub maxDescriptorSetStorageBuffersDynamic: u32,
	pub maxDescriptorSetSampledImages: u32,
	pub maxDescriptorSetStorageImages: u32,
	pub maxDescriptorSetInputAttachments: u32,
	pub maxVertexInputAttributes: u32,
	pub maxVertexInputBindings: u32,
	pub maxVertexInputAttributeOffset: u32,
	pub maxVertexInputBindingStride: u32,
	pub maxVertexOutputComponents: u32,
	pub maxTessellationGenerationLevel: u32,
	pub maxTessellationPatchSize: u32,
	pub maxTessellationControlPerVertexInputComponents: u32,
	pub maxTessellationControlPerVertexOutputComponents: u32,
	pub maxTessellationControlPerPatchOutputComponents: u32,
	pub maxTessellationControlTotalOutputComponents: u32,
	pub maxTessellationEvaluationInputComponents: u32,
	pub maxTessellationEvaluationOutputComponents: u32,
	pub maxGeometryShaderInvocations: u32,
	pub maxGeometryInputComponents: u32,
	pub maxGeometryOutputComponents: u32,
	pub maxGeometryOutputVertices: u32,
	pub maxGeometryTotalOutputComponents: u32,
	pub maxFragmentInputComponents: u32,
	pub maxFragmentOutputAttachments: u32,
	pub maxFragmentDualSrcAttachments: u32,
	pub maxFragmentCombinedOutputResources: u32,
	pub maxComputeSharedMemorySize: u32,
	pub maxComputeWorkGroupCount: [u32; 3 as usize],
	pub maxComputeWorkGroupInvocations: u32,
	pub maxComputeWorkGroupSize: [u32; 3 as usize],
	pub subPixelPrecisionBits: u32,
	pub subTexelPrecisionBits: u32,
	pub mipmapPrecisionBits: u32,
	pub maxDrawIndexedIndexValue: u32,
	pub maxDrawIndirectCount: u32,
	pub maxSamplerLodBias: f32,
	pub maxSamplerAnisotropy: f32,
	pub maxViewports: u32,
	pub maxViewportDimensions: [u32; 2 as usize],
	pub viewportBoundsRange: [f32; 2 as usize],
	pub viewportSubPixelBits: u32,
	pub minMemoryMapAlignment: usize,
	pub minTexelBufferOffsetAlignment: VkDeviceSize,
	pub minUniformBufferOffsetAlignment: VkDeviceSize,
	pub minStorageBufferOffsetAlignment: VkDeviceSize,
	pub minTexelOffset: i32,
	pub maxTexelOffset: u32,
	pub minTexelGatherOffset: i32,
	pub maxTexelGatherOffset: u32,
	pub minInterpolationOffset: f32,
	pub maxInterpolationOffset: f32,
	pub subPixelInterpolationOffsetBits: u32,
	pub maxFramebufferWidth: u32,
	pub maxFramebufferHeight: u32,
	pub maxFramebufferLayers: u32,
	pub framebufferColorSampleCounts: VkSampleCountFlags,
	pub framebufferDepthSampleCounts: VkSampleCountFlags,
	pub framebufferStencilSampleCounts: VkSampleCountFlags,
	pub framebufferNoAttachmentsSampleCounts: VkSampleCountFlags,
	pub maxColorAttachments: u32,
	pub sampledImageColorSampleCounts: VkSampleCountFlags,
	pub sampledImageIntegerSampleCounts: VkSampleCountFlags,
	pub sampledImageDepthSampleCounts: VkSampleCountFlags,
	pub sampledImageStencilSampleCounts: VkSampleCountFlags,
	pub storageImageSampleCounts: VkSampleCountFlags,
	pub maxSampleMaskWords: u32,
	pub timestampComputeAndGraphics: VkBool32,
	pub timestampPeriod: f32,
	pub maxClipDistances: u32,
	pub maxCullDistances: u32,
	pub maxCombinedClipAndCullDistances: u32,
	pub discreteQueuePriorities: u32,
	pub pointSizeRange: [f32; 2 as usize],
	pub lineWidthRange: [f32; 2 as usize],
	pub pointSizeGranularity: f32,
	pub lineWidthGranularity: f32,
	pub strictLines: VkBool32,
	pub standardSampleLocations: VkBool32,
	pub optimalBufferCopyOffsetAlignment: VkDeviceSize,
	pub optimalBufferCopyRowPitchAlignment: VkDeviceSize,
	pub nonCoherentAtomSize: VkDeviceSize,
}
impl Debug for VkPhysicalDeviceLimits {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceLimits")
		.field("maxImageDimension1D", &self.maxImageDimension1D)
		.field("maxImageDimension2D", &self.maxImageDimension2D)
		.field("maxImageDimension3D", &self.maxImageDimension3D)
		.field("maxImageDimensionCube", &self.maxImageDimensionCube)
		.field("maxImageArrayLayers", &self.maxImageArrayLayers)
		.field("maxTexelBufferElements", &self.maxTexelBufferElements)
		.field("maxUniformBufferRange", &self.maxUniformBufferRange)
		.field("maxStorageBufferRange", &self.maxStorageBufferRange)
		.field("maxPushConstantsSize", &self.maxPushConstantsSize)
		.field("maxMemoryAllocationCount", &self.maxMemoryAllocationCount)
		.field("maxSamplerAllocationCount", &self.maxSamplerAllocationCount)
		.field("bufferImageGranularity", &self.bufferImageGranularity)
		.field("sparseAddressSpaceSize", &self.sparseAddressSpaceSize)
		.field("maxBoundDescriptorSets", &self.maxBoundDescriptorSets)
		.field("maxPerStageDescriptorSamplers", &self.maxPerStageDescriptorSamplers)
		.field("maxPerStageDescriptorUniformBuffers", &self.maxPerStageDescriptorUniformBuffers)
		.field("maxPerStageDescriptorStorageBuffers", &self.maxPerStageDescriptorStorageBuffers)
		.field("maxPerStageDescriptorSampledImages", &self.maxPerStageDescriptorSampledImages)
		.field("maxPerStageDescriptorStorageImages", &self.maxPerStageDescriptorStorageImages)
		.field("maxPerStageDescriptorInputAttachments", &self.maxPerStageDescriptorInputAttachments)
		.field("maxPerStageResources", &self.maxPerStageResources)
		.field("maxDescriptorSetSamplers", &self.maxDescriptorSetSamplers)
		.field("maxDescriptorSetUniformBuffers", &self.maxDescriptorSetUniformBuffers)
		.field("maxDescriptorSetUniformBuffersDynamic", &self.maxDescriptorSetUniformBuffersDynamic)
		.field("maxDescriptorSetStorageBuffers", &self.maxDescriptorSetStorageBuffers)
		.field("maxDescriptorSetStorageBuffersDynamic", &self.maxDescriptorSetStorageBuffersDynamic)
		.field("maxDescriptorSetSampledImages", &self.maxDescriptorSetSampledImages)
		.field("maxDescriptorSetStorageImages", &self.maxDescriptorSetStorageImages)
		.field("maxDescriptorSetInputAttachments", &self.maxDescriptorSetInputAttachments)
		.field("maxVertexInputAttributes", &self.maxVertexInputAttributes)
		.field("maxVertexInputBindings", &self.maxVertexInputBindings)
		.field("maxVertexInputAttributeOffset", &self.maxVertexInputAttributeOffset)
		.field("maxVertexInputBindingStride", &self.maxVertexInputBindingStride)
		.field("maxVertexOutputComponents", &self.maxVertexOutputComponents)
		.field("maxTessellationGenerationLevel", &self.maxTessellationGenerationLevel)
		.field("maxTessellationPatchSize", &self.maxTessellationPatchSize)
		.field("maxTessellationControlPerVertexInputComponents", &self.maxTessellationControlPerVertexInputComponents)
		.field("maxTessellationControlPerVertexOutputComponents", &self.maxTessellationControlPerVertexOutputComponents)
		.field("maxTessellationControlPerPatchOutputComponents", &self.maxTessellationControlPerPatchOutputComponents)
		.field("maxTessellationControlTotalOutputComponents", &self.maxTessellationControlTotalOutputComponents)
		.field("maxTessellationEvaluationInputComponents", &self.maxTessellationEvaluationInputComponents)
		.field("maxTessellationEvaluationOutputComponents", &self.maxTessellationEvaluationOutputComponents)
		.field("maxGeometryShaderInvocations", &self.maxGeometryShaderInvocations)
		.field("maxGeometryInputComponents", &self.maxGeometryInputComponents)
		.field("maxGeometryOutputComponents", &self.maxGeometryOutputComponents)
		.field("maxGeometryOutputVertices", &self.maxGeometryOutputVertices)
		.field("maxGeometryTotalOutputComponents", &self.maxGeometryTotalOutputComponents)
		.field("maxFragmentInputComponents", &self.maxFragmentInputComponents)
		.field("maxFragmentOutputAttachments", &self.maxFragmentOutputAttachments)
		.field("maxFragmentDualSrcAttachments", &self.maxFragmentDualSrcAttachments)
		.field("maxFragmentCombinedOutputResources", &self.maxFragmentCombinedOutputResources)
		.field("maxComputeSharedMemorySize", &self.maxComputeSharedMemorySize)
		.field("maxComputeWorkGroupCount", &self.maxComputeWorkGroupCount)
		.field("maxComputeWorkGroupInvocations", &self.maxComputeWorkGroupInvocations)
		.field("maxComputeWorkGroupSize", &self.maxComputeWorkGroupSize)
		.field("subPixelPrecisionBits", &self.subPixelPrecisionBits)
		.field("subTexelPrecisionBits", &self.subTexelPrecisionBits)
		.field("mipmapPrecisionBits", &self.mipmapPrecisionBits)
		.field("maxDrawIndexedIndexValue", &self.maxDrawIndexedIndexValue)
		.field("maxDrawIndirectCount", &self.maxDrawIndirectCount)
		.field("maxSamplerLodBias", &self.maxSamplerLodBias)
		.field("maxSamplerAnisotropy", &self.maxSamplerAnisotropy)
		.field("maxViewports", &self.maxViewports)
		.field("maxViewportDimensions", &self.maxViewportDimensions)
		.field("viewportBoundsRange", &self.viewportBoundsRange)
		.field("viewportSubPixelBits", &self.viewportSubPixelBits)
		.field("minMemoryMapAlignment", &self.minMemoryMapAlignment)
		.field("minTexelBufferOffsetAlignment", &self.minTexelBufferOffsetAlignment)
		.field("minUniformBufferOffsetAlignment", &self.minUniformBufferOffsetAlignment)
		.field("minStorageBufferOffsetAlignment", &self.minStorageBufferOffsetAlignment)
		.field("minTexelOffset", &self.minTexelOffset)
		.field("maxTexelOffset", &self.maxTexelOffset)
		.field("minTexelGatherOffset", &self.minTexelGatherOffset)
		.field("maxTexelGatherOffset", &self.maxTexelGatherOffset)
		.field("minInterpolationOffset", &self.minInterpolationOffset)
		.field("maxInterpolationOffset", &self.maxInterpolationOffset)
		.field("subPixelInterpolationOffsetBits", &self.subPixelInterpolationOffsetBits)
		.field("maxFramebufferWidth", &self.maxFramebufferWidth)
		.field("maxFramebufferHeight", &self.maxFramebufferHeight)
		.field("maxFramebufferLayers", &self.maxFramebufferLayers)
		.field("framebufferColorSampleCounts", &format_args!("{}", vk_sample_count_flags_to_string(self.framebufferColorSampleCounts)))
		.field("framebufferDepthSampleCounts", &format_args!("{}", vk_sample_count_flags_to_string(self.framebufferDepthSampleCounts)))
		.field("framebufferStencilSampleCounts", &format_args!("{}", vk_sample_count_flags_to_string(self.framebufferStencilSampleCounts)))
		.field("framebufferNoAttachmentsSampleCounts", &format_args!("{}", vk_sample_count_flags_to_string(self.framebufferNoAttachmentsSampleCounts)))
		.field("maxColorAttachments", &self.maxColorAttachments)
		.field("sampledImageColorSampleCounts", &format_args!("{}", vk_sample_count_flags_to_string(self.sampledImageColorSampleCounts)))
		.field("sampledImageIntegerSampleCounts", &format_args!("{}", vk_sample_count_flags_to_string(self.sampledImageIntegerSampleCounts)))
		.field("sampledImageDepthSampleCounts", &format_args!("{}", vk_sample_count_flags_to_string(self.sampledImageDepthSampleCounts)))
		.field("sampledImageStencilSampleCounts", &format_args!("{}", vk_sample_count_flags_to_string(self.sampledImageStencilSampleCounts)))
		.field("storageImageSampleCounts", &format_args!("{}", vk_sample_count_flags_to_string(self.storageImageSampleCounts)))
		.field("maxSampleMaskWords", &self.maxSampleMaskWords)
		.field("timestampComputeAndGraphics", &self.timestampComputeAndGraphics)
		.field("timestampPeriod", &self.timestampPeriod)
		.field("maxClipDistances", &self.maxClipDistances)
		.field("maxCullDistances", &self.maxCullDistances)
		.field("maxCombinedClipAndCullDistances", &self.maxCombinedClipAndCullDistances)
		.field("discreteQueuePriorities", &self.discreteQueuePriorities)
		.field("pointSizeRange", &self.pointSizeRange)
		.field("lineWidthRange", &self.lineWidthRange)
		.field("pointSizeGranularity", &self.pointSizeGranularity)
		.field("lineWidthGranularity", &self.lineWidthGranularity)
		.field("strictLines", &self.strictLines)
		.field("standardSampleLocations", &self.standardSampleLocations)
		.field("optimalBufferCopyOffsetAlignment", &self.optimalBufferCopyOffsetAlignment)
		.field("optimalBufferCopyRowPitchAlignment", &self.optimalBufferCopyRowPitchAlignment)
		.field("nonCoherentAtomSize", &self.nonCoherentAtomSize)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMemoryProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMemoryProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMemoryProperties {
	pub memoryTypeCount: u32,
	pub memoryTypes: [VkMemoryType; VK_MAX_MEMORY_TYPES as usize],
	pub memoryHeapCount: u32,
	pub memoryHeaps: [VkMemoryHeap; VK_MAX_MEMORY_HEAPS as usize],
}
impl Debug for VkPhysicalDeviceMemoryProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMemoryProperties")
		.field("memoryTypeCount", &self.memoryTypeCount)
		.field("memoryTypes", &self.memoryTypes)
		.field("memoryHeapCount", &self.memoryHeapCount)
		.field("memoryHeaps", &self.memoryHeaps)
		.finish()
	}
}
/// struct `VkPhysicalDeviceSparseProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSparseProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSparseProperties {
	pub residencyStandard2DBlockShape: VkBool32,
	pub residencyStandard2DMultisampleBlockShape: VkBool32,
	pub residencyStandard3DBlockShape: VkBool32,
	pub residencyAlignedMipSize: VkBool32,
	pub residencyNonResidentStrict: VkBool32,
}
impl Debug for VkPhysicalDeviceSparseProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSparseProperties")
		.field("residencyStandard2DBlockShape", &self.residencyStandard2DBlockShape)
		.field("residencyStandard2DMultisampleBlockShape", &self.residencyStandard2DMultisampleBlockShape)
		.field("residencyStandard3DBlockShape", &self.residencyStandard3DBlockShape)
		.field("residencyAlignedMipSize", &self.residencyAlignedMipSize)
		.field("residencyNonResidentStrict", &self.residencyNonResidentStrict)
		.finish()
	}
}
/// struct `VkPhysicalDeviceProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceProperties {
	pub apiVersion: u32,
	pub driverVersion: u32,
	pub vendorID: u32,
	pub deviceID: u32,
	pub deviceType: VkPhysicalDeviceType,
	pub deviceName: [i8; VK_MAX_PHYSICAL_DEVICE_NAME_SIZE as usize],
	pub pipelineCacheUUID: [u8; VK_UUID_SIZE as usize],
	pub limits: VkPhysicalDeviceLimits,
	pub sparseProperties: VkPhysicalDeviceSparseProperties,
}
impl Debug for VkPhysicalDeviceProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceProperties")
		.field("apiVersion", &self.apiVersion)
		.field("driverVersion", &self.driverVersion)
		.field("vendorID", &self.vendorID)
		.field("deviceID", &self.deviceID)
		.field("deviceType", &self.deviceType)
		.field("deviceName", &format_args!("{}", maybe_string(&self.deviceName)))
		.field("pipelineCacheUUID", &self.pipelineCacheUUID)
		.field("limits", &self.limits)
		.field("sparseProperties", &self.sparseProperties)
		.finish()
	}
}
/// struct `VkQueueFamilyProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueFamilyProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkQueueFamilyProperties {
	pub queueFlags: VkQueueFlags,
	pub queueCount: u32,
	pub timestampValidBits: u32,
	pub minImageTransferGranularity: VkExtent3D,
}
impl Debug for VkQueueFamilyProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkQueueFamilyProperties")
		.field("queueFlags", &format_args!("{}", vk_queue_flags_to_string(self.queueFlags)))
		.field("queueCount", &self.queueCount)
		.field("timestampValidBits", &self.timestampValidBits)
		.field("minImageTransferGranularity", &self.minImageTransferGranularity)
		.finish()
	}
}
/// struct `VkDeviceQueueCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceQueueCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceQueueCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDeviceQueueCreateFlags,
	pub queueFamilyIndex: u32,
	pub queueCount: u32,
	pub pQueuePriorities: *const float,
}
impl Debug for VkDeviceQueueCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceQueueCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_device_queue_create_flags_to_string(self.flags)))
		.field("queueFamilyIndex", &self.queueFamilyIndex)
		.field("queueCount", &self.queueCount)
		.field("pQueuePriorities", &self.pQueuePriorities)
		.finish()
	}
}
/// struct `VkDeviceCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDeviceCreateFlags,
	pub queueCreateInfoCount: u32,
	pub pQueueCreateInfos: *const VkDeviceQueueCreateInfo,
	pub enabledLayerCount: u32,
	pub ppEnabledLayerNames: *const *const char,
	pub enabledExtensionCount: u32,
	pub ppEnabledExtensionNames: *const *const char,
	pub pEnabledFeatures: *const VkPhysicalDeviceFeatures,
}
impl Debug for VkDeviceCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("queueCreateInfoCount", &self.queueCreateInfoCount)
		.field("pQueueCreateInfos", &self.pQueueCreateInfos)
		.field("enabledLayerCount", &self.enabledLayerCount)
		.field("ppEnabledLayerNames", &self.ppEnabledLayerNames)
		.field("enabledExtensionCount", &self.enabledExtensionCount)
		.field("ppEnabledExtensionNames", &self.ppEnabledExtensionNames)
		.field("pEnabledFeatures", &self.pEnabledFeatures)
		.finish()
	}
}
/// struct `VkExtensionProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExtensionProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExtensionProperties {
	pub extensionName: [i8; VK_MAX_EXTENSION_NAME_SIZE as usize],
	pub specVersion: u32,
}
impl Debug for VkExtensionProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExtensionProperties")
		.field("extensionName", &format_args!("{}", maybe_string(&self.extensionName)))
		.field("specVersion", &self.specVersion)
		.finish()
	}
}
/// struct `VkLayerProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkLayerProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkLayerProperties {
	pub layerName: [i8; VK_MAX_EXTENSION_NAME_SIZE as usize],
	pub specVersion: u32,
	pub implementationVersion: u32,
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
}
impl Debug for VkLayerProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkLayerProperties")
		.field("layerName", &format_args!("{}", maybe_string(&self.layerName)))
		.field("specVersion", &self.specVersion)
		.field("implementationVersion", &self.implementationVersion)
		.field("description", &format_args!("{}", maybe_string(&self.description)))
		.finish()
	}
}
/// struct `VkSubmitInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubmitInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSubmitInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub waitSemaphoreCount: u32,
	pub pWaitSemaphores: *const VkSemaphore,
	pub pWaitDstStageMask: *const VkPipelineStageFlags,
	pub commandBufferCount: u32,
	pub pCommandBuffers: *const VkCommandBuffer,
	pub signalSemaphoreCount: u32,
	pub pSignalSemaphores: *const VkSemaphore,
}
impl Debug for VkSubmitInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSubmitInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("waitSemaphoreCount", &self.waitSemaphoreCount)
		.field("pWaitSemaphores", &self.pWaitSemaphores)
		.field("pWaitDstStageMask", &self.pWaitDstStageMask)
		.field("commandBufferCount", &self.commandBufferCount)
		.field("pCommandBuffers", &self.pCommandBuffers)
		.field("signalSemaphoreCount", &self.signalSemaphoreCount)
		.field("pSignalSemaphores", &self.pSignalSemaphores)
		.finish()
	}
}
/// struct `VkMappedMemoryRange` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMappedMemoryRange.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMappedMemoryRange {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub memory: VkDeviceMemory,
	pub offset: VkDeviceSize,
	pub size: VkDeviceSize,
}
impl Debug for VkMappedMemoryRange {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMappedMemoryRange")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("memory", &self.memory)
		.field("offset", &self.offset)
		.field("size", &self.size)
		.finish()
	}
}
/// struct `VkMemoryAllocateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryAllocateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryAllocateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub allocationSize: VkDeviceSize,
	pub memoryTypeIndex: u32,
}
impl Debug for VkMemoryAllocateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryAllocateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("allocationSize", &self.allocationSize)
		.field("memoryTypeIndex", &self.memoryTypeIndex)
		.finish()
	}
}
/// struct `VkMemoryRequirements` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryRequirements.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryRequirements {
	pub size: VkDeviceSize,
	pub alignment: VkDeviceSize,
	pub memoryTypeBits: u32,
}
impl Debug for VkMemoryRequirements {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryRequirements")
		.field("size", &self.size)
		.field("alignment", &self.alignment)
		.field("memoryTypeBits", &self.memoryTypeBits)
		.finish()
	}
}
/// struct `VkSparseMemoryBind` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSparseMemoryBind.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSparseMemoryBind {
	pub resourceOffset: VkDeviceSize,
	pub size: VkDeviceSize,
	pub memory: VkDeviceMemory,
	pub memoryOffset: VkDeviceSize,
	pub flags: VkSparseMemoryBindFlags,
}
impl Debug for VkSparseMemoryBind {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSparseMemoryBind")
		.field("resourceOffset", &self.resourceOffset)
		.field("size", &self.size)
		.field("memory", &self.memory)
		.field("memoryOffset", &self.memoryOffset)
		.field("flags", &format_args!("{}", vk_sparse_memory_bind_flags_to_string(self.flags)))
		.finish()
	}
}
/// struct `VkSparseBufferMemoryBindInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSparseBufferMemoryBindInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSparseBufferMemoryBindInfo {
	pub buffer: VkBuffer,
	pub bindCount: u32,
	pub pBinds: *const VkSparseMemoryBind,
}
impl Debug for VkSparseBufferMemoryBindInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSparseBufferMemoryBindInfo")
		.field("buffer", &self.buffer)
		.field("bindCount", &self.bindCount)
		.field("pBinds", &self.pBinds)
		.finish()
	}
}
/// struct `VkSparseImageOpaqueMemoryBindInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSparseImageOpaqueMemoryBindInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSparseImageOpaqueMemoryBindInfo {
	pub image: VkImage,
	pub bindCount: u32,
	pub pBinds: *const VkSparseMemoryBind,
}
impl Debug for VkSparseImageOpaqueMemoryBindInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSparseImageOpaqueMemoryBindInfo")
		.field("image", &self.image)
		.field("bindCount", &self.bindCount)
		.field("pBinds", &self.pBinds)
		.finish()
	}
}
/// struct `VkImageSubresource` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageSubresource.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageSubresource {
	pub aspectMask: VkImageAspectFlags,
	pub mipLevel: u32,
	pub arrayLayer: u32,
}
impl Debug for VkImageSubresource {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageSubresource")
		.field("aspectMask", &format_args!("{}", vk_image_aspect_flags_to_string(self.aspectMask)))
		.field("mipLevel", &self.mipLevel)
		.field("arrayLayer", &self.arrayLayer)
		.finish()
	}
}
/// struct `VkSparseImageMemoryBind` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSparseImageMemoryBind.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSparseImageMemoryBind {
	pub subresource: VkImageSubresource,
	pub offset: VkOffset3D,
	pub extent: VkExtent3D,
	pub memory: VkDeviceMemory,
	pub memoryOffset: VkDeviceSize,
	pub flags: VkSparseMemoryBindFlags,
}
impl Debug for VkSparseImageMemoryBind {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSparseImageMemoryBind")
		.field("subresource", &self.subresource)
		.field("offset", &self.offset)
		.field("extent", &self.extent)
		.field("memory", &self.memory)
		.field("memoryOffset", &self.memoryOffset)
		.field("flags", &format_args!("{}", vk_sparse_memory_bind_flags_to_string(self.flags)))
		.finish()
	}
}
/// struct `VkSparseImageMemoryBindInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSparseImageMemoryBindInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSparseImageMemoryBindInfo {
	pub image: VkImage,
	pub bindCount: u32,
	pub pBinds: *const VkSparseImageMemoryBind,
}
impl Debug for VkSparseImageMemoryBindInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSparseImageMemoryBindInfo")
		.field("image", &self.image)
		.field("bindCount", &self.bindCount)
		.field("pBinds", &self.pBinds)
		.finish()
	}
}
/// struct `VkBindSparseInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindSparseInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindSparseInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub waitSemaphoreCount: u32,
	pub pWaitSemaphores: *const VkSemaphore,
	pub bufferBindCount: u32,
	pub pBufferBinds: *const VkSparseBufferMemoryBindInfo,
	pub imageOpaqueBindCount: u32,
	pub pImageOpaqueBinds: *const VkSparseImageOpaqueMemoryBindInfo,
	pub imageBindCount: u32,
	pub pImageBinds: *const VkSparseImageMemoryBindInfo,
	pub signalSemaphoreCount: u32,
	pub pSignalSemaphores: *const VkSemaphore,
}
impl Debug for VkBindSparseInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindSparseInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("waitSemaphoreCount", &self.waitSemaphoreCount)
		.field("pWaitSemaphores", &self.pWaitSemaphores)
		.field("bufferBindCount", &self.bufferBindCount)
		.field("pBufferBinds", &self.pBufferBinds)
		.field("imageOpaqueBindCount", &self.imageOpaqueBindCount)
		.field("pImageOpaqueBinds", &self.pImageOpaqueBinds)
		.field("imageBindCount", &self.imageBindCount)
		.field("pImageBinds", &self.pImageBinds)
		.field("signalSemaphoreCount", &self.signalSemaphoreCount)
		.field("pSignalSemaphores", &self.pSignalSemaphores)
		.finish()
	}
}
/// struct `VkSparseImageFormatProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSparseImageFormatProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSparseImageFormatProperties {
	pub aspectMask: VkImageAspectFlags,
	pub imageGranularity: VkExtent3D,
	pub flags: VkSparseImageFormatFlags,
}
impl Debug for VkSparseImageFormatProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSparseImageFormatProperties")
		.field("aspectMask", &format_args!("{}", vk_image_aspect_flags_to_string(self.aspectMask)))
		.field("imageGranularity", &self.imageGranularity)
		.field("flags", &format_args!("{}", vk_sparse_image_format_flags_to_string(self.flags)))
		.finish()
	}
}
/// struct `VkSparseImageMemoryRequirements` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSparseImageMemoryRequirements.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSparseImageMemoryRequirements {
	pub formatProperties: VkSparseImageFormatProperties,
	pub imageMipTailFirstLod: u32,
	pub imageMipTailSize: VkDeviceSize,
	pub imageMipTailOffset: VkDeviceSize,
	pub imageMipTailStride: VkDeviceSize,
}
impl Debug for VkSparseImageMemoryRequirements {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSparseImageMemoryRequirements")
		.field("formatProperties", &self.formatProperties)
		.field("imageMipTailFirstLod", &self.imageMipTailFirstLod)
		.field("imageMipTailSize", &self.imageMipTailSize)
		.field("imageMipTailOffset", &self.imageMipTailOffset)
		.field("imageMipTailStride", &self.imageMipTailStride)
		.finish()
	}
}
/// struct `VkFenceCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFenceCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkFenceCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkFenceCreateFlags,
}
impl Debug for VkFenceCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkFenceCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_fence_create_flags_to_string(self.flags)))
		.finish()
	}
}
/// struct `VkSemaphoreCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSemaphoreCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkSemaphoreCreateFlags,
}
impl Debug for VkSemaphoreCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSemaphoreCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.finish()
	}
}
/// struct `VkEventCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkEventCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkEventCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkEventCreateFlags,
}
impl Debug for VkEventCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkEventCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_event_create_flags_to_string(self.flags)))
		.finish()
	}
}
/// struct `VkQueryPoolCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryPoolCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkQueryPoolCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkQueryPoolCreateFlags,
	pub queryType: VkQueryType,
	pub queryCount: u32,
	pub pipelineStatistics: VkQueryPipelineStatisticFlags,
}
impl Debug for VkQueryPoolCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkQueryPoolCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_query_pool_create_flags_to_string(self.flags)))
		.field("queryType", &self.queryType)
		.field("queryCount", &self.queryCount)
		.field("pipelineStatistics", &format_args!("{}", vk_query_pipeline_statistic_flags_to_string(self.pipelineStatistics)))
		.finish()
	}
}
/// struct `VkBufferCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBufferCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkBufferCreateFlags,
	pub size: VkDeviceSize,
	pub usage: VkBufferUsageFlags,
	pub sharingMode: VkSharingMode,
	pub queueFamilyIndexCount: u32,
	pub pQueueFamilyIndices: *const uint32_t,
}
impl Debug for VkBufferCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBufferCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_buffer_create_flags_to_string(self.flags)))
		.field("size", &self.size)
		.field("usage", &format_args!("{}", vk_buffer_usage_flags_to_string(self.usage)))
		.field("sharingMode", &self.sharingMode)
		.field("queueFamilyIndexCount", &self.queueFamilyIndexCount)
		.field("pQueueFamilyIndices", &self.pQueueFamilyIndices)
		.finish()
	}
}
/// struct `VkBufferViewCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferViewCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBufferViewCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkBufferViewCreateFlags,
	pub buffer: VkBuffer,
	pub format: VkFormat,
	pub offset: VkDeviceSize,
	pub range: VkDeviceSize,
}
impl Debug for VkBufferViewCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBufferViewCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("buffer", &self.buffer)
		.field("format", &self.format)
		.field("offset", &self.offset)
		.field("range", &self.range)
		.finish()
	}
}
/// struct `VkImageCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkImageCreateFlags,
	pub imageType: VkImageType,
	pub format: VkFormat,
	pub extent: VkExtent3D,
	pub mipLevels: u32,
	pub arrayLayers: u32,
	pub samples: VkSampleCountFlagBits,
	pub tiling: VkImageTiling,
	pub usage: VkImageUsageFlags,
	pub sharingMode: VkSharingMode,
	pub queueFamilyIndexCount: u32,
	pub pQueueFamilyIndices: *const uint32_t,
	pub initialLayout: VkImageLayout,
}
impl Debug for VkImageCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_image_create_flags_to_string(self.flags)))
		.field("imageType", &self.imageType)
		.field("format", &self.format)
		.field("extent", &self.extent)
		.field("mipLevels", &self.mipLevels)
		.field("arrayLayers", &self.arrayLayers)
		.field("samples", &self.samples)
		.field("tiling", &self.tiling)
		.field("usage", &format_args!("{}", vk_image_usage_flags_to_string(self.usage)))
		.field("sharingMode", &self.sharingMode)
		.field("queueFamilyIndexCount", &self.queueFamilyIndexCount)
		.field("pQueueFamilyIndices", &self.pQueueFamilyIndices)
		.field("initialLayout", &self.initialLayout)
		.finish()
	}
}
/// struct `VkSubresourceLayout` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubresourceLayout.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSubresourceLayout {
	pub offset: VkDeviceSize,
	pub size: VkDeviceSize,
	pub rowPitch: VkDeviceSize,
	pub arrayPitch: VkDeviceSize,
	pub depthPitch: VkDeviceSize,
}
impl Debug for VkSubresourceLayout {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSubresourceLayout")
		.field("offset", &self.offset)
		.field("size", &self.size)
		.field("rowPitch", &self.rowPitch)
		.field("arrayPitch", &self.arrayPitch)
		.field("depthPitch", &self.depthPitch)
		.finish()
	}
}
/// struct `VkComponentMapping` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkComponentMapping.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkComponentMapping {
	pub r: VkComponentSwizzle,
	pub g: VkComponentSwizzle,
	pub b: VkComponentSwizzle,
	pub a: VkComponentSwizzle,
}
impl Debug for VkComponentMapping {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkComponentMapping")
		.field("r", &self.r)
		.field("g", &self.g)
		.field("b", &self.b)
		.field("a", &self.a)
		.finish()
	}
}
/// struct `VkImageViewCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageViewCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageViewCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkImageViewCreateFlags,
	pub image: VkImage,
	pub viewType: VkImageViewType,
	pub format: VkFormat,
	pub components: VkComponentMapping,
	pub subresourceRange: VkImageSubresourceRange,
}
impl Debug for VkImageViewCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageViewCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_image_view_create_flags_to_string(self.flags)))
		.field("image", &self.image)
		.field("viewType", &self.viewType)
		.field("format", &self.format)
		.field("components", &self.components)
		.field("subresourceRange", &self.subresourceRange)
		.finish()
	}
}
/// struct `VkShaderModuleCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderModuleCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkShaderModuleCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkShaderModuleCreateFlags,
	pub codeSize: usize,
	pub pCode: *const uint32_t,
}
impl Debug for VkShaderModuleCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkShaderModuleCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("codeSize", &self.codeSize)
		.field("pCode", &self.pCode)
		.finish()
	}
}
/// struct `VkPipelineCacheCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCacheCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineCacheCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCacheCreateFlags,
	pub initialDataSize: usize,
	pub pInitialData: *const c_void,
}
impl Debug for VkPipelineCacheCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineCacheCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_pipeline_cache_create_flags_to_string(self.flags)))
		.field("initialDataSize", &self.initialDataSize)
		.field("pInitialData", &self.pInitialData)
		.finish()
	}
}
/// struct `VkSpecializationMapEntry` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSpecializationMapEntry.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSpecializationMapEntry {
	pub constantID: u32,
	pub offset: u32,
	pub size: usize,
}
impl Debug for VkSpecializationMapEntry {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSpecializationMapEntry")
		.field("constantID", &self.constantID)
		.field("offset", &self.offset)
		.field("size", &self.size)
		.finish()
	}
}
/// struct `VkSpecializationInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSpecializationInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSpecializationInfo {
	pub mapEntryCount: u32,
	pub pMapEntries: *const VkSpecializationMapEntry,
	pub dataSize: usize,
	pub pData: *const c_void,
}
impl Debug for VkSpecializationInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSpecializationInfo")
		.field("mapEntryCount", &self.mapEntryCount)
		.field("pMapEntries", &self.pMapEntries)
		.field("dataSize", &self.dataSize)
		.field("pData", &self.pData)
		.finish()
	}
}
/// struct `VkPipelineShaderStageCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineShaderStageCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineShaderStageCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineShaderStageCreateFlags,
	pub stage: VkShaderStageFlagBits,
	pub module: VkShaderModule,
	pub pName: *const i8,
	pub pSpecializationInfo: *const VkSpecializationInfo,
}
impl Debug for VkPipelineShaderStageCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineShaderStageCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_pipeline_shader_stage_create_flags_to_string(self.flags)))
		.field("stage", &self.stage)
		.field("module", &self.module)
		.field("pName", &self.pName)
		.field("pSpecializationInfo", &self.pSpecializationInfo)
		.finish()
	}
}
/// struct `VkComputePipelineCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkComputePipelineCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkComputePipelineCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCreateFlags,
	pub stage: VkPipelineShaderStageCreateInfo,
	pub layout: VkPipelineLayout,
	pub basePipelineHandle: VkPipeline,
	pub basePipelineIndex: i32,
}
impl Debug for VkComputePipelineCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkComputePipelineCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_pipeline_create_flags_to_string(self.flags)))
		.field("stage", &self.stage)
		.field("layout", &self.layout)
		.field("basePipelineHandle", &self.basePipelineHandle)
		.field("basePipelineIndex", &self.basePipelineIndex)
		.finish()
	}
}
/// struct `VkVertexInputBindingDescription` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVertexInputBindingDescription.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVertexInputBindingDescription {
	pub binding: u32,
	pub stride: u32,
	pub inputRate: VkVertexInputRate,
}
impl Debug for VkVertexInputBindingDescription {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVertexInputBindingDescription")
		.field("binding", &self.binding)
		.field("stride", &self.stride)
		.field("inputRate", &self.inputRate)
		.finish()
	}
}
/// struct `VkVertexInputAttributeDescription` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVertexInputAttributeDescription.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVertexInputAttributeDescription {
	pub location: u32,
	pub binding: u32,
	pub format: VkFormat,
	pub offset: u32,
}
impl Debug for VkVertexInputAttributeDescription {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVertexInputAttributeDescription")
		.field("location", &self.location)
		.field("binding", &self.binding)
		.field("format", &self.format)
		.field("offset", &self.offset)
		.finish()
	}
}
/// struct `VkPipelineVertexInputStateCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineVertexInputStateCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineVertexInputStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineVertexInputStateCreateFlags,
	pub vertexBindingDescriptionCount: u32,
	pub pVertexBindingDescriptions: *const VkVertexInputBindingDescription,
	pub vertexAttributeDescriptionCount: u32,
	pub pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription,
}
impl Debug for VkPipelineVertexInputStateCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineVertexInputStateCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("vertexBindingDescriptionCount", &self.vertexBindingDescriptionCount)
		.field("pVertexBindingDescriptions", &self.pVertexBindingDescriptions)
		.field("vertexAttributeDescriptionCount", &self.vertexAttributeDescriptionCount)
		.field("pVertexAttributeDescriptions", &self.pVertexAttributeDescriptions)
		.finish()
	}
}
/// struct `VkPipelineInputAssemblyStateCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineInputAssemblyStateCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineInputAssemblyStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineInputAssemblyStateCreateFlags,
	pub topology: VkPrimitiveTopology,
	pub primitiveRestartEnable: VkBool32,
}
impl Debug for VkPipelineInputAssemblyStateCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineInputAssemblyStateCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("topology", &self.topology)
		.field("primitiveRestartEnable", &self.primitiveRestartEnable)
		.finish()
	}
}
/// struct `VkPipelineTessellationStateCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineTessellationStateCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineTessellationStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineTessellationStateCreateFlags,
	pub patchControlPoints: u32,
}
impl Debug for VkPipelineTessellationStateCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineTessellationStateCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("patchControlPoints", &self.patchControlPoints)
		.finish()
	}
}
/// struct `VkViewport` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkViewport.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkViewport {
	pub x: f32,
	pub y: f32,
	pub width: f32,
	pub height: f32,
	pub minDepth: f32,
	pub maxDepth: f32,
}
impl Debug for VkViewport {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkViewport")
		.field("x", &self.x)
		.field("y", &self.y)
		.field("width", &self.width)
		.field("height", &self.height)
		.field("minDepth", &self.minDepth)
		.field("maxDepth", &self.maxDepth)
		.finish()
	}
}
/// struct `VkPipelineViewportStateCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineViewportStateCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineViewportStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineViewportStateCreateFlags,
	pub viewportCount: u32,
	pub pViewports: *const VkViewport,
	pub scissorCount: u32,
	pub pScissors: *const VkRect2D,
}
impl Debug for VkPipelineViewportStateCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineViewportStateCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("viewportCount", &self.viewportCount)
		.field("pViewports", &self.pViewports)
		.field("scissorCount", &self.scissorCount)
		.field("pScissors", &self.pScissors)
		.finish()
	}
}
/// struct `VkPipelineRasterizationStateCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRasterizationStateCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineRasterizationStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineRasterizationStateCreateFlags,
	pub depthClampEnable: VkBool32,
	pub rasterizerDiscardEnable: VkBool32,
	pub polygonMode: VkPolygonMode,
	pub cullMode: VkCullModeFlags,
	pub frontFace: VkFrontFace,
	pub depthBiasEnable: VkBool32,
	pub depthBiasConstantFactor: f32,
	pub depthBiasClamp: f32,
	pub depthBiasSlopeFactor: f32,
	pub lineWidth: f32,
}
impl Debug for VkPipelineRasterizationStateCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineRasterizationStateCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("depthClampEnable", &self.depthClampEnable)
		.field("rasterizerDiscardEnable", &self.rasterizerDiscardEnable)
		.field("polygonMode", &self.polygonMode)
		.field("cullMode", &format_args!("{}", vk_cull_mode_flags_to_string(self.cullMode)))
		.field("frontFace", &self.frontFace)
		.field("depthBiasEnable", &self.depthBiasEnable)
		.field("depthBiasConstantFactor", &self.depthBiasConstantFactor)
		.field("depthBiasClamp", &self.depthBiasClamp)
		.field("depthBiasSlopeFactor", &self.depthBiasSlopeFactor)
		.field("lineWidth", &self.lineWidth)
		.finish()
	}
}
/// struct `VkPipelineMultisampleStateCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineMultisampleStateCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineMultisampleStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineMultisampleStateCreateFlags,
	pub rasterizationSamples: VkSampleCountFlagBits,
	pub sampleShadingEnable: VkBool32,
	pub minSampleShading: f32,
	pub pSampleMask: *const VkSampleMask,
	pub alphaToCoverageEnable: VkBool32,
	pub alphaToOneEnable: VkBool32,
}
impl Debug for VkPipelineMultisampleStateCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineMultisampleStateCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("rasterizationSamples", &self.rasterizationSamples)
		.field("sampleShadingEnable", &self.sampleShadingEnable)
		.field("minSampleShading", &self.minSampleShading)
		.field("pSampleMask", &self.pSampleMask)
		.field("alphaToCoverageEnable", &self.alphaToCoverageEnable)
		.field("alphaToOneEnable", &self.alphaToOneEnable)
		.finish()
	}
}
/// struct `VkStencilOpState` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkStencilOpState.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkStencilOpState {
	pub failOp: VkStencilOp,
	pub passOp: VkStencilOp,
	pub depthFailOp: VkStencilOp,
	pub compareOp: VkCompareOp,
	pub compareMask: u32,
	pub writeMask: u32,
	pub reference: u32,
}
impl Debug for VkStencilOpState {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkStencilOpState")
		.field("failOp", &self.failOp)
		.field("passOp", &self.passOp)
		.field("depthFailOp", &self.depthFailOp)
		.field("compareOp", &self.compareOp)
		.field("compareMask", &self.compareMask)
		.field("writeMask", &self.writeMask)
		.field("reference", &self.reference)
		.finish()
	}
}
/// struct `VkPipelineDepthStencilStateCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineDepthStencilStateCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineDepthStencilStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineDepthStencilStateCreateFlags,
	pub depthTestEnable: VkBool32,
	pub depthWriteEnable: VkBool32,
	pub depthCompareOp: VkCompareOp,
	pub depthBoundsTestEnable: VkBool32,
	pub stencilTestEnable: VkBool32,
	pub front: VkStencilOpState,
	pub back: VkStencilOpState,
	pub minDepthBounds: f32,
	pub maxDepthBounds: f32,
}
impl Debug for VkPipelineDepthStencilStateCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineDepthStencilStateCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_pipeline_depth_stencil_state_create_flags_to_string(self.flags)))
		.field("depthTestEnable", &self.depthTestEnable)
		.field("depthWriteEnable", &self.depthWriteEnable)
		.field("depthCompareOp", &self.depthCompareOp)
		.field("depthBoundsTestEnable", &self.depthBoundsTestEnable)
		.field("stencilTestEnable", &self.stencilTestEnable)
		.field("front", &self.front)
		.field("back", &self.back)
		.field("minDepthBounds", &self.minDepthBounds)
		.field("maxDepthBounds", &self.maxDepthBounds)
		.finish()
	}
}
/// struct `VkPipelineColorBlendAttachmentState` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineColorBlendAttachmentState.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineColorBlendAttachmentState {
	pub blendEnable: VkBool32,
	pub srcColorBlendFactor: VkBlendFactor,
	pub dstColorBlendFactor: VkBlendFactor,
	pub colorBlendOp: VkBlendOp,
	pub srcAlphaBlendFactor: VkBlendFactor,
	pub dstAlphaBlendFactor: VkBlendFactor,
	pub alphaBlendOp: VkBlendOp,
	pub colorWriteMask: VkColorComponentFlags,
}
impl Debug for VkPipelineColorBlendAttachmentState {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineColorBlendAttachmentState")
		.field("blendEnable", &self.blendEnable)
		.field("srcColorBlendFactor", &self.srcColorBlendFactor)
		.field("dstColorBlendFactor", &self.dstColorBlendFactor)
		.field("colorBlendOp", &self.colorBlendOp)
		.field("srcAlphaBlendFactor", &self.srcAlphaBlendFactor)
		.field("dstAlphaBlendFactor", &self.dstAlphaBlendFactor)
		.field("alphaBlendOp", &self.alphaBlendOp)
		.field("colorWriteMask", &format_args!("{}", vk_color_component_flags_to_string(self.colorWriteMask)))
		.finish()
	}
}
/// struct `VkPipelineColorBlendStateCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineColorBlendStateCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineColorBlendStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineColorBlendStateCreateFlags,
	pub logicOpEnable: VkBool32,
	pub logicOp: VkLogicOp,
	pub attachmentCount: u32,
	pub pAttachments: *const VkPipelineColorBlendAttachmentState,
	pub blendConstants: [f32; 4 as usize],
}
impl Debug for VkPipelineColorBlendStateCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineColorBlendStateCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_pipeline_color_blend_state_create_flags_to_string(self.flags)))
		.field("logicOpEnable", &self.logicOpEnable)
		.field("logicOp", &self.logicOp)
		.field("attachmentCount", &self.attachmentCount)
		.field("pAttachments", &self.pAttachments)
		.field("blendConstants", &self.blendConstants)
		.finish()
	}
}
/// struct `VkPipelineDynamicStateCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineDynamicStateCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineDynamicStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineDynamicStateCreateFlags,
	pub dynamicStateCount: u32,
	pub pDynamicStates: *const VkDynamicState,
}
impl Debug for VkPipelineDynamicStateCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineDynamicStateCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("dynamicStateCount", &self.dynamicStateCount)
		.field("pDynamicStates", &self.pDynamicStates)
		.finish()
	}
}
/// struct `VkGraphicsPipelineCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGraphicsPipelineCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkGraphicsPipelineCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCreateFlags,
	pub stageCount: u32,
	pub pStages: *const VkPipelineShaderStageCreateInfo,
	pub pVertexInputState: *const VkPipelineVertexInputStateCreateInfo,
	pub pInputAssemblyState: *const VkPipelineInputAssemblyStateCreateInfo,
	pub pTessellationState: *const VkPipelineTessellationStateCreateInfo,
	pub pViewportState: *const VkPipelineViewportStateCreateInfo,
	pub pRasterizationState: *const VkPipelineRasterizationStateCreateInfo,
	pub pMultisampleState: *const VkPipelineMultisampleStateCreateInfo,
	pub pDepthStencilState: *const VkPipelineDepthStencilStateCreateInfo,
	pub pColorBlendState: *const VkPipelineColorBlendStateCreateInfo,
	pub pDynamicState: *const VkPipelineDynamicStateCreateInfo,
	pub layout: VkPipelineLayout,
	pub renderPass: VkRenderPass,
	pub subpass: u32,
	pub basePipelineHandle: VkPipeline,
	pub basePipelineIndex: i32,
}
impl Debug for VkGraphicsPipelineCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkGraphicsPipelineCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_pipeline_create_flags_to_string(self.flags)))
		.field("stageCount", &self.stageCount)
		.field("pStages", &self.pStages)
		.field("pVertexInputState", &self.pVertexInputState)
		.field("pInputAssemblyState", &self.pInputAssemblyState)
		.field("pTessellationState", &self.pTessellationState)
		.field("pViewportState", &self.pViewportState)
		.field("pRasterizationState", &self.pRasterizationState)
		.field("pMultisampleState", &self.pMultisampleState)
		.field("pDepthStencilState", &self.pDepthStencilState)
		.field("pColorBlendState", &self.pColorBlendState)
		.field("pDynamicState", &self.pDynamicState)
		.field("layout", &self.layout)
		.field("renderPass", &self.renderPass)
		.field("subpass", &self.subpass)
		.field("basePipelineHandle", &self.basePipelineHandle)
		.field("basePipelineIndex", &self.basePipelineIndex)
		.finish()
	}
}
/// struct `VkPushConstantRange` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPushConstantRange.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPushConstantRange {
	pub stageFlags: VkShaderStageFlags,
	pub offset: u32,
	pub size: u32,
}
impl Debug for VkPushConstantRange {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPushConstantRange")
		.field("stageFlags", &format_args!("{}", vk_shader_stage_flags_to_string(self.stageFlags)))
		.field("offset", &self.offset)
		.field("size", &self.size)
		.finish()
	}
}
/// struct `VkPipelineLayoutCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayoutCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineLayoutCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineLayoutCreateFlags,
	pub setLayoutCount: u32,
	pub pSetLayouts: *const VkDescriptorSetLayout,
	pub pushConstantRangeCount: u32,
	pub pPushConstantRanges: *const VkPushConstantRange,
}
impl Debug for VkPipelineLayoutCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineLayoutCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_pipeline_layout_create_flags_to_string(self.flags)))
		.field("setLayoutCount", &self.setLayoutCount)
		.field("pSetLayouts", &self.pSetLayouts)
		.field("pushConstantRangeCount", &self.pushConstantRangeCount)
		.field("pPushConstantRanges", &self.pPushConstantRanges)
		.finish()
	}
}
/// struct `VkSamplerCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSamplerCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkSamplerCreateFlags,
	pub magFilter: VkFilter,
	pub minFilter: VkFilter,
	pub mipmapMode: VkSamplerMipmapMode,
	pub addressModeU: VkSamplerAddressMode,
	pub addressModeV: VkSamplerAddressMode,
	pub addressModeW: VkSamplerAddressMode,
	pub mipLodBias: f32,
	pub anisotropyEnable: VkBool32,
	pub maxAnisotropy: f32,
	pub compareEnable: VkBool32,
	pub compareOp: VkCompareOp,
	pub minLod: f32,
	pub maxLod: f32,
	pub borderColor: VkBorderColor,
	pub unnormalizedCoordinates: VkBool32,
}
impl Debug for VkSamplerCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSamplerCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_sampler_create_flags_to_string(self.flags)))
		.field("magFilter", &self.magFilter)
		.field("minFilter", &self.minFilter)
		.field("mipmapMode", &self.mipmapMode)
		.field("addressModeU", &self.addressModeU)
		.field("addressModeV", &self.addressModeV)
		.field("addressModeW", &self.addressModeW)
		.field("mipLodBias", &self.mipLodBias)
		.field("anisotropyEnable", &self.anisotropyEnable)
		.field("maxAnisotropy", &self.maxAnisotropy)
		.field("compareEnable", &self.compareEnable)
		.field("compareOp", &self.compareOp)
		.field("minLod", &self.minLod)
		.field("maxLod", &self.maxLod)
		.field("borderColor", &self.borderColor)
		.field("unnormalizedCoordinates", &self.unnormalizedCoordinates)
		.finish()
	}
}
/// struct `VkCopyDescriptorSet` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyDescriptorSet.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyDescriptorSet {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcSet: VkDescriptorSet,
	pub srcBinding: u32,
	pub srcArrayElement: u32,
	pub dstSet: VkDescriptorSet,
	pub dstBinding: u32,
	pub dstArrayElement: u32,
	pub descriptorCount: u32,
}
impl Debug for VkCopyDescriptorSet {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyDescriptorSet")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcSet", &self.srcSet)
		.field("srcBinding", &self.srcBinding)
		.field("srcArrayElement", &self.srcArrayElement)
		.field("dstSet", &self.dstSet)
		.field("dstBinding", &self.dstBinding)
		.field("dstArrayElement", &self.dstArrayElement)
		.field("descriptorCount", &self.descriptorCount)
		.finish()
	}
}
/// struct `VkDescriptorBufferInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorBufferInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorBufferInfo {
	pub buffer: VkBuffer,
	pub offset: VkDeviceSize,
	pub range: VkDeviceSize,
}
impl Debug for VkDescriptorBufferInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorBufferInfo")
		.field("buffer", &self.buffer)
		.field("offset", &self.offset)
		.field("range", &self.range)
		.finish()
	}
}
/// struct `VkDescriptorImageInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorImageInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorImageInfo {
	pub sampler: VkSampler,
	pub imageView: VkImageView,
	pub imageLayout: VkImageLayout,
}
impl Debug for VkDescriptorImageInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorImageInfo")
		.field("sampler", &self.sampler)
		.field("imageView", &self.imageView)
		.field("imageLayout", &self.imageLayout)
		.finish()
	}
}
/// struct `VkDescriptorPoolSize` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolSize.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorPoolSize {
	pub type_: VkDescriptorType,
	pub descriptorCount: u32,
}
impl Debug for VkDescriptorPoolSize {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorPoolSize")
		.field("type_", &self.type_)
		.field("descriptorCount", &self.descriptorCount)
		.finish()
	}
}
/// struct `VkDescriptorPoolCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorPoolCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDescriptorPoolCreateFlags,
	pub maxSets: u32,
	pub poolSizeCount: u32,
	pub pPoolSizes: *const VkDescriptorPoolSize,
}
impl Debug for VkDescriptorPoolCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorPoolCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_descriptor_pool_create_flags_to_string(self.flags)))
		.field("maxSets", &self.maxSets)
		.field("poolSizeCount", &self.poolSizeCount)
		.field("pPoolSizes", &self.pPoolSizes)
		.finish()
	}
}
/// struct `VkDescriptorSetAllocateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetAllocateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorSetAllocateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub descriptorPool: VkDescriptorPool,
	pub descriptorSetCount: u32,
	pub pSetLayouts: *const VkDescriptorSetLayout,
}
impl Debug for VkDescriptorSetAllocateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorSetAllocateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("descriptorPool", &self.descriptorPool)
		.field("descriptorSetCount", &self.descriptorSetCount)
		.field("pSetLayouts", &self.pSetLayouts)
		.finish()
	}
}
/// struct `VkDescriptorSetLayoutBinding` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutBinding.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorSetLayoutBinding {
	pub binding: u32,
	pub descriptorType: VkDescriptorType,
	pub descriptorCount: u32,
	pub stageFlags: VkShaderStageFlags,
	pub pImmutableSamplers: *const VkSampler,
}
impl Debug for VkDescriptorSetLayoutBinding {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorSetLayoutBinding")
		.field("binding", &self.binding)
		.field("descriptorType", &self.descriptorType)
		.field("descriptorCount", &self.descriptorCount)
		.field("stageFlags", &format_args!("{}", vk_shader_stage_flags_to_string(self.stageFlags)))
		.field("pImmutableSamplers", &self.pImmutableSamplers)
		.finish()
	}
}
/// struct `VkDescriptorSetLayoutCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorSetLayoutCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDescriptorSetLayoutCreateFlags,
	pub bindingCount: u32,
	pub pBindings: *const VkDescriptorSetLayoutBinding,
}
impl Debug for VkDescriptorSetLayoutCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorSetLayoutCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_descriptor_set_layout_create_flags_to_string(self.flags)))
		.field("bindingCount", &self.bindingCount)
		.field("pBindings", &self.pBindings)
		.finish()
	}
}
/// struct `VkWriteDescriptorSet` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSet.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkWriteDescriptorSet {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dstSet: VkDescriptorSet,
	pub dstBinding: u32,
	pub dstArrayElement: u32,
	pub descriptorCount: u32,
	pub descriptorType: VkDescriptorType,
	pub pImageInfo: *const VkDescriptorImageInfo,
	pub pBufferInfo: *const VkDescriptorBufferInfo,
	pub pTexelBufferView: *const VkBufferView,
}
impl Debug for VkWriteDescriptorSet {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkWriteDescriptorSet")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dstSet", &self.dstSet)
		.field("dstBinding", &self.dstBinding)
		.field("dstArrayElement", &self.dstArrayElement)
		.field("descriptorCount", &self.descriptorCount)
		.field("descriptorType", &self.descriptorType)
		.field("pImageInfo", &self.pImageInfo)
		.field("pBufferInfo", &self.pBufferInfo)
		.field("pTexelBufferView", &self.pTexelBufferView)
		.finish()
	}
}
/// struct `VkAttachmentDescription` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentDescription.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAttachmentDescription {
	pub flags: VkAttachmentDescriptionFlags,
	pub format: VkFormat,
	pub samples: VkSampleCountFlagBits,
	pub loadOp: VkAttachmentLoadOp,
	pub storeOp: VkAttachmentStoreOp,
	pub stencilLoadOp: VkAttachmentLoadOp,
	pub stencilStoreOp: VkAttachmentStoreOp,
	pub initialLayout: VkImageLayout,
	pub finalLayout: VkImageLayout,
}
impl Debug for VkAttachmentDescription {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAttachmentDescription")
		.field("flags", &format_args!("{}", vk_attachment_description_flags_to_string(self.flags)))
		.field("format", &self.format)
		.field("samples", &self.samples)
		.field("loadOp", &self.loadOp)
		.field("storeOp", &self.storeOp)
		.field("stencilLoadOp", &self.stencilLoadOp)
		.field("stencilStoreOp", &self.stencilStoreOp)
		.field("initialLayout", &self.initialLayout)
		.field("finalLayout", &self.finalLayout)
		.finish()
	}
}
/// struct `VkAttachmentReference` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentReference.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAttachmentReference {
	pub attachment: u32,
	pub layout: VkImageLayout,
}
impl Debug for VkAttachmentReference {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAttachmentReference")
		.field("attachment", &self.attachment)
		.field("layout", &self.layout)
		.finish()
	}
}
/// struct `VkFramebufferCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFramebufferCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkFramebufferCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkFramebufferCreateFlags,
	pub renderPass: VkRenderPass,
	pub attachmentCount: u32,
	pub pAttachments: *const VkImageView,
	pub width: u32,
	pub height: u32,
	pub layers: u32,
}
impl Debug for VkFramebufferCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkFramebufferCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_framebuffer_create_flags_to_string(self.flags)))
		.field("renderPass", &self.renderPass)
		.field("attachmentCount", &self.attachmentCount)
		.field("pAttachments", &self.pAttachments)
		.field("width", &self.width)
		.field("height", &self.height)
		.field("layers", &self.layers)
		.finish()
	}
}
/// struct `VkSubpassDescription` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassDescription.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSubpassDescription {
	pub flags: VkSubpassDescriptionFlags,
	pub pipelineBindPoint: VkPipelineBindPoint,
	pub inputAttachmentCount: u32,
	pub pInputAttachments: *const VkAttachmentReference,
	pub colorAttachmentCount: u32,
	pub pColorAttachments: *const VkAttachmentReference,
	pub pResolveAttachments: *const VkAttachmentReference,
	pub pDepthStencilAttachment: *const VkAttachmentReference,
	pub preserveAttachmentCount: u32,
	pub pPreserveAttachments: *const uint32_t,
}
impl Debug for VkSubpassDescription {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSubpassDescription")
		.field("flags", &format_args!("{}", vk_subpass_description_flags_to_string(self.flags)))
		.field("pipelineBindPoint", &self.pipelineBindPoint)
		.field("inputAttachmentCount", &self.inputAttachmentCount)
		.field("pInputAttachments", &self.pInputAttachments)
		.field("colorAttachmentCount", &self.colorAttachmentCount)
		.field("pColorAttachments", &self.pColorAttachments)
		.field("pResolveAttachments", &self.pResolveAttachments)
		.field("pDepthStencilAttachment", &self.pDepthStencilAttachment)
		.field("preserveAttachmentCount", &self.preserveAttachmentCount)
		.field("pPreserveAttachments", &self.pPreserveAttachments)
		.finish()
	}
}
/// struct `VkSubpassDependency` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassDependency.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSubpassDependency {
	pub srcSubpass: u32,
	pub dstSubpass: u32,
	pub srcStageMask: VkPipelineStageFlags,
	pub dstStageMask: VkPipelineStageFlags,
	pub srcAccessMask: VkAccessFlags,
	pub dstAccessMask: VkAccessFlags,
	pub dependencyFlags: VkDependencyFlags,
}
impl Debug for VkSubpassDependency {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSubpassDependency")
		.field("srcSubpass", &self.srcSubpass)
		.field("dstSubpass", &self.dstSubpass)
		.field("srcStageMask", &format_args!("{}", vk_pipeline_stage_flags_to_string(self.srcStageMask)))
		.field("dstStageMask", &format_args!("{}", vk_pipeline_stage_flags_to_string(self.dstStageMask)))
		.field("srcAccessMask", &format_args!("{}", vk_access_flags_to_string(self.srcAccessMask)))
		.field("dstAccessMask", &format_args!("{}", vk_access_flags_to_string(self.dstAccessMask)))
		.field("dependencyFlags", &format_args!("{}", vk_dependency_flags_to_string(self.dependencyFlags)))
		.finish()
	}
}
/// struct `VkRenderPassCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkRenderPassCreateFlags,
	pub attachmentCount: u32,
	pub pAttachments: *const VkAttachmentDescription,
	pub subpassCount: u32,
	pub pSubpasses: *const VkSubpassDescription,
	pub dependencyCount: u32,
	pub pDependencies: *const VkSubpassDependency,
}
impl Debug for VkRenderPassCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_render_pass_create_flags_to_string(self.flags)))
		.field("attachmentCount", &self.attachmentCount)
		.field("pAttachments", &self.pAttachments)
		.field("subpassCount", &self.subpassCount)
		.field("pSubpasses", &self.pSubpasses)
		.field("dependencyCount", &self.dependencyCount)
		.field("pDependencies", &self.pDependencies)
		.finish()
	}
}
/// struct `VkCommandPoolCreateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandPoolCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCommandPoolCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkCommandPoolCreateFlags,
	pub queueFamilyIndex: u32,
}
impl Debug for VkCommandPoolCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCommandPoolCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_command_pool_create_flags_to_string(self.flags)))
		.field("queueFamilyIndex", &self.queueFamilyIndex)
		.finish()
	}
}
/// struct `VkCommandBufferAllocateInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferAllocateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCommandBufferAllocateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub commandPool: VkCommandPool,
	pub level: VkCommandBufferLevel,
	pub commandBufferCount: u32,
}
impl Debug for VkCommandBufferAllocateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCommandBufferAllocateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("commandPool", &self.commandPool)
		.field("level", &self.level)
		.field("commandBufferCount", &self.commandBufferCount)
		.finish()
	}
}
/// struct `VkCommandBufferInheritanceInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferInheritanceInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCommandBufferInheritanceInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub renderPass: VkRenderPass,
	pub subpass: u32,
	pub framebuffer: VkFramebuffer,
	pub occlusionQueryEnable: VkBool32,
	pub queryFlags: VkQueryControlFlags,
	pub pipelineStatistics: VkQueryPipelineStatisticFlags,
}
impl Debug for VkCommandBufferInheritanceInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCommandBufferInheritanceInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("renderPass", &self.renderPass)
		.field("subpass", &self.subpass)
		.field("framebuffer", &self.framebuffer)
		.field("occlusionQueryEnable", &self.occlusionQueryEnable)
		.field("queryFlags", &format_args!("{}", vk_query_control_flags_to_string(self.queryFlags)))
		.field("pipelineStatistics", &format_args!("{}", vk_query_pipeline_statistic_flags_to_string(self.pipelineStatistics)))
		.finish()
	}
}
/// struct `VkCommandBufferBeginInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferBeginInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCommandBufferBeginInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkCommandBufferUsageFlags,
	pub pInheritanceInfo: *const VkCommandBufferInheritanceInfo,
}
impl Debug for VkCommandBufferBeginInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCommandBufferBeginInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_command_buffer_usage_flags_to_string(self.flags)))
		.field("pInheritanceInfo", &self.pInheritanceInfo)
		.finish()
	}
}
/// struct `VkBufferCopy` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferCopy.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBufferCopy {
	pub srcOffset: VkDeviceSize,
	pub dstOffset: VkDeviceSize,
	pub size: VkDeviceSize,
}
impl Debug for VkBufferCopy {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBufferCopy")
		.field("srcOffset", &self.srcOffset)
		.field("dstOffset", &self.dstOffset)
		.field("size", &self.size)
		.finish()
	}
}
/// struct `VkImageSubresourceLayers` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageSubresourceLayers.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageSubresourceLayers {
	pub aspectMask: VkImageAspectFlags,
	pub mipLevel: u32,
	pub baseArrayLayer: u32,
	pub layerCount: u32,
}
impl Debug for VkImageSubresourceLayers {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageSubresourceLayers")
		.field("aspectMask", &format_args!("{}", vk_image_aspect_flags_to_string(self.aspectMask)))
		.field("mipLevel", &self.mipLevel)
		.field("baseArrayLayer", &self.baseArrayLayer)
		.field("layerCount", &self.layerCount)
		.finish()
	}
}
/// struct `VkBufferImageCopy` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferImageCopy.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBufferImageCopy {
	pub bufferOffset: VkDeviceSize,
	pub bufferRowLength: u32,
	pub bufferImageHeight: u32,
	pub imageSubresource: VkImageSubresourceLayers,
	pub imageOffset: VkOffset3D,
	pub imageExtent: VkExtent3D,
}
impl Debug for VkBufferImageCopy {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBufferImageCopy")
		.field("bufferOffset", &self.bufferOffset)
		.field("bufferRowLength", &self.bufferRowLength)
		.field("bufferImageHeight", &self.bufferImageHeight)
		.field("imageSubresource", &self.imageSubresource)
		.field("imageOffset", &self.imageOffset)
		.field("imageExtent", &self.imageExtent)
		.finish()
	}
}
/// struct `VkClearDepthStencilValue` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClearDepthStencilValue.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkClearDepthStencilValue {
	pub depth: f32,
	pub stencil: u32,
}
impl Debug for VkClearDepthStencilValue {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClearDepthStencilValue")
		.field("depth", &self.depth)
		.field("stencil", &self.stencil)
		.finish()
	}
}
/// struct `VkClearAttachment` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClearAttachment.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkClearAttachment {
	pub aspectMask: VkImageAspectFlags,
	pub colorAttachment: u32,
	pub clearValue: VkClearValue,
}
impl Debug for VkClearAttachment {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClearAttachment")
		.field("aspectMask", &format_args!("{}", vk_image_aspect_flags_to_string(self.aspectMask)))
		.field("colorAttachment", &self.colorAttachment)
		.field("clearValue", &self.clearValue)
		.finish()
	}
}
/// struct `VkClearRect` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClearRect.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkClearRect {
	pub rect: VkRect2D,
	pub baseArrayLayer: u32,
	pub layerCount: u32,
}
impl Debug for VkClearRect {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClearRect")
		.field("rect", &self.rect)
		.field("baseArrayLayer", &self.baseArrayLayer)
		.field("layerCount", &self.layerCount)
		.finish()
	}
}
/// struct `VkImageBlit` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageBlit.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageBlit {
	pub srcSubresource: VkImageSubresourceLayers,
	pub srcOffsets: [VkOffset3D; 2 as usize],
	pub dstSubresource: VkImageSubresourceLayers,
	pub dstOffsets: [VkOffset3D; 2 as usize],
}
impl Debug for VkImageBlit {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageBlit")
		.field("srcSubresource", &self.srcSubresource)
		.field("srcOffsets", &self.srcOffsets)
		.field("dstSubresource", &self.dstSubresource)
		.field("dstOffsets", &self.dstOffsets)
		.finish()
	}
}
/// struct `VkImageCopy` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCopy.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageCopy {
	pub srcSubresource: VkImageSubresourceLayers,
	pub srcOffset: VkOffset3D,
	pub dstSubresource: VkImageSubresourceLayers,
	pub dstOffset: VkOffset3D,
	pub extent: VkExtent3D,
}
impl Debug for VkImageCopy {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageCopy")
		.field("srcSubresource", &self.srcSubresource)
		.field("srcOffset", &self.srcOffset)
		.field("dstSubresource", &self.dstSubresource)
		.field("dstOffset", &self.dstOffset)
		.field("extent", &self.extent)
		.finish()
	}
}
/// struct `VkImageResolve` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageResolve.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageResolve {
	pub srcSubresource: VkImageSubresourceLayers,
	pub srcOffset: VkOffset3D,
	pub dstSubresource: VkImageSubresourceLayers,
	pub dstOffset: VkOffset3D,
	pub extent: VkExtent3D,
}
impl Debug for VkImageResolve {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageResolve")
		.field("srcSubresource", &self.srcSubresource)
		.field("srcOffset", &self.srcOffset)
		.field("dstSubresource", &self.dstSubresource)
		.field("dstOffset", &self.dstOffset)
		.field("extent", &self.extent)
		.finish()
	}
}
/// struct `VkRenderPassBeginInfo` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassBeginInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassBeginInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub renderPass: VkRenderPass,
	pub framebuffer: VkFramebuffer,
	pub renderArea: VkRect2D,
	pub clearValueCount: u32,
	pub pClearValues: *const VkClearValue,
}
impl Debug for VkRenderPassBeginInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassBeginInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("renderPass", &self.renderPass)
		.field("framebuffer", &self.framebuffer)
		.field("renderArea", &self.renderArea)
		.field("clearValueCount", &self.clearValueCount)
		.field("pClearValues", &self.pClearValues)
		.finish()
	}
}
/// function prototype `PFN_vkAllocationFunction` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocationFunction.html>
type PFN_vkAllocationFunction = extern "system" fn(pUserData: *mut c_void, size: usize, alignment: usize, allocationScope: VkSystemAllocationScope) -> *mut c_void;
/// function prototype `PFN_vkFreeFunction` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeFunction.html>
type PFN_vkFreeFunction = extern "system" fn(pUserData: *mut c_void, pMemory: *mut c_void);
/// function prototype `PFN_vkInternalAllocationNotification` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkInternalAllocationNotification.html>
type PFN_vkInternalAllocationNotification = extern "system" fn(pUserData: *mut c_void, size: usize, allocationType: VkInternalAllocationType, allocationScope: VkSystemAllocationScope);
/// function prototype `PFN_vkInternalFreeNotification` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkInternalFreeNotification.html>
type PFN_vkInternalFreeNotification = extern "system" fn(pUserData: *mut c_void, size: usize, allocationType: VkInternalAllocationType, allocationScope: VkSystemAllocationScope);
/// function prototype `PFN_vkReallocationFunction` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkReallocationFunction.html>
type PFN_vkReallocationFunction = extern "system" fn(pUserData: *mut c_void, pOriginal: *mut c_void, size: usize, alignment: usize, allocationScope: VkSystemAllocationScope) -> *mut c_void;
/// function prototype `PFN_vkVoidFunction` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkVoidFunction.html>
type PFN_vkVoidFunction = extern "system" fn();
/// function prototype `PFN_vkCreateInstance` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateInstance.html>
type PFN_vkCreateInstance = extern "system" fn(pCreateInfo: *const VkInstanceCreateInfo, pAllocator: *const VkAllocationCallbacks, pInstance: *mut VkInstance) -> VkResult;
/// function prototype `PFN_vkDestroyInstance` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyInstance.html>
type PFN_vkDestroyInstance = extern "system" fn(instance: VkInstance, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkEnumeratePhysicalDevices` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDevices.html>
type PFN_vkEnumeratePhysicalDevices = extern "system" fn(instance: VkInstance, pPhysicalDeviceCount: *mut uint32_t, pPhysicalDevices: *mut VkPhysicalDevice) -> VkResult;
/// function prototype `PFN_vkGetPhysicalDeviceFeatures` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures.html>
type PFN_vkGetPhysicalDeviceFeatures = extern "system" fn(physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures);
/// function prototype `PFN_vkGetPhysicalDeviceFormatProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFormatProperties.html>
type PFN_vkGetPhysicalDeviceFormatProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties);
/// function prototype `PFN_vkGetPhysicalDeviceImageFormatProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceImageFormatProperties.html>
type PFN_vkGetPhysicalDeviceImageFormatProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, pImageFormatProperties: *mut VkImageFormatProperties) -> VkResult;
/// function prototype `PFN_vkGetPhysicalDeviceProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceProperties.html>
type PFN_vkGetPhysicalDeviceProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties);
/// function prototype `PFN_vkGetPhysicalDeviceQueueFamilyProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties.html>
type PFN_vkGetPhysicalDeviceQueueFamilyProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties);
/// function prototype `PFN_vkGetPhysicalDeviceMemoryProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMemoryProperties.html>
type PFN_vkGetPhysicalDeviceMemoryProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties);
/// function prototype `PFN_vkGetInstanceProcAddr` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetInstanceProcAddr.html>
type PFN_vkGetInstanceProcAddr = extern "system" fn(instance: VkInstance, pName: *const i8) -> PFN_vkVoidFunction;
/// function prototype `PFN_vkGetDeviceProcAddr` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceProcAddr.html>
type PFN_vkGetDeviceProcAddr = extern "system" fn(device: VkDevice, pName: *const i8) -> PFN_vkVoidFunction;
/// function prototype `PFN_vkCreateDevice` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDevice.html>
type PFN_vkCreateDevice = extern "system" fn(physicalDevice: VkPhysicalDevice, pCreateInfo: *const VkDeviceCreateInfo, pAllocator: *const VkAllocationCallbacks, pDevice: *mut VkDevice) -> VkResult;
/// function prototype `PFN_vkDestroyDevice` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDevice.html>
type PFN_vkDestroyDevice = extern "system" fn(device: VkDevice, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkEnumerateInstanceExtensionProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateInstanceExtensionProperties.html>
type PFN_vkEnumerateInstanceExtensionProperties = extern "system" fn(pLayerName: *const i8, pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> VkResult;
/// function prototype `PFN_vkEnumerateDeviceExtensionProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateDeviceExtensionProperties.html>
type PFN_vkEnumerateDeviceExtensionProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pLayerName: *const i8, pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> VkResult;
/// function prototype `PFN_vkEnumerateInstanceLayerProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateInstanceLayerProperties.html>
type PFN_vkEnumerateInstanceLayerProperties = extern "system" fn(pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> VkResult;
/// function prototype `PFN_vkEnumerateDeviceLayerProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateDeviceLayerProperties.html>
type PFN_vkEnumerateDeviceLayerProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> VkResult;
/// function prototype `PFN_vkGetDeviceQueue` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceQueue.html>
type PFN_vkGetDeviceQueue = extern "system" fn(device: VkDevice, queueFamilyIndex: u32, queueIndex: u32, pQueue: *mut VkQueue);
/// function prototype `PFN_vkQueueSubmit` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueSubmit.html>
type PFN_vkQueueSubmit = extern "system" fn(queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo, fence: VkFence) -> VkResult;
/// function prototype `PFN_vkQueueWaitIdle` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueWaitIdle.html>
type PFN_vkQueueWaitIdle = extern "system" fn(queue: VkQueue) -> VkResult;
/// function prototype `PFN_vkDeviceWaitIdle` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDeviceWaitIdle.html>
type PFN_vkDeviceWaitIdle = extern "system" fn(device: VkDevice) -> VkResult;
/// function prototype `PFN_vkAllocateMemory` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateMemory.html>
type PFN_vkAllocateMemory = extern "system" fn(device: VkDevice, pAllocateInfo: *const VkMemoryAllocateInfo, pAllocator: *const VkAllocationCallbacks, pMemory: *mut VkDeviceMemory) -> VkResult;
/// function prototype `PFN_vkFreeMemory` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeMemory.html>
type PFN_vkFreeMemory = extern "system" fn(device: VkDevice, memory: VkDeviceMemory, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkMapMemory` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkMapMemory.html>
type PFN_vkMapMemory = extern "system" fn(device: VkDevice, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize, flags: VkMemoryMapFlags, ppData: *mut *mut c_void) -> VkResult;
/// function prototype `PFN_vkUnmapMemory` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkUnmapMemory.html>
type PFN_vkUnmapMemory = extern "system" fn(device: VkDevice, memory: VkDeviceMemory);
/// function prototype `PFN_vkFlushMappedMemoryRanges` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkFlushMappedMemoryRanges.html>
type PFN_vkFlushMappedMemoryRanges = extern "system" fn(device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *const VkMappedMemoryRange) -> VkResult;
/// function prototype `PFN_vkInvalidateMappedMemoryRanges` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkInvalidateMappedMemoryRanges.html>
type PFN_vkInvalidateMappedMemoryRanges = extern "system" fn(device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *const VkMappedMemoryRange) -> VkResult;
/// function prototype `PFN_vkGetDeviceMemoryCommitment` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceMemoryCommitment.html>
type PFN_vkGetDeviceMemoryCommitment = extern "system" fn(device: VkDevice, memory: VkDeviceMemory, pCommittedMemoryInBytes: *mut VkDeviceSize);
/// function prototype `PFN_vkBindBufferMemory` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindBufferMemory.html>
type PFN_vkBindBufferMemory = extern "system" fn(device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> VkResult;
/// function prototype `PFN_vkBindImageMemory` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindImageMemory.html>
type PFN_vkBindImageMemory = extern "system" fn(device: VkDevice, image: VkImage, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> VkResult;
/// function prototype `PFN_vkGetBufferMemoryRequirements` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferMemoryRequirements.html>
type PFN_vkGetBufferMemoryRequirements = extern "system" fn(device: VkDevice, buffer: VkBuffer, pMemoryRequirements: *mut VkMemoryRequirements);
/// function prototype `PFN_vkGetImageMemoryRequirements` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageMemoryRequirements.html>
type PFN_vkGetImageMemoryRequirements = extern "system" fn(device: VkDevice, image: VkImage, pMemoryRequirements: *mut VkMemoryRequirements);
/// function prototype `PFN_vkGetImageSparseMemoryRequirements` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSparseMemoryRequirements.html>
type PFN_vkGetImageSparseMemoryRequirements = extern "system" fn(device: VkDevice, image: VkImage, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements);
/// function prototype `PFN_vkGetPhysicalDeviceSparseImageFormatProperties` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSparseImageFormatProperties.html>
type PFN_vkGetPhysicalDeviceSparseImageFormatProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties);
/// function prototype `PFN_vkQueueBindSparse` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueBindSparse.html>
type PFN_vkQueueBindSparse = extern "system" fn(queue: VkQueue, bindInfoCount: u32, pBindInfo: *const VkBindSparseInfo, fence: VkFence) -> VkResult;
/// function prototype `PFN_vkCreateFence` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateFence.html>
type PFN_vkCreateFence = extern "system" fn(device: VkDevice, pCreateInfo: *const VkFenceCreateInfo, pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence) -> VkResult;
/// function prototype `PFN_vkDestroyFence` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyFence.html>
type PFN_vkDestroyFence = extern "system" fn(device: VkDevice, fence: VkFence, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkResetFences` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetFences.html>
type PFN_vkResetFences = extern "system" fn(device: VkDevice, fenceCount: u32, pFences: *const VkFence) -> VkResult;
/// function prototype `PFN_vkGetFenceStatus` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetFenceStatus.html>
type PFN_vkGetFenceStatus = extern "system" fn(device: VkDevice, fence: VkFence) -> VkResult;
/// function prototype `PFN_vkWaitForFences` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitForFences.html>
type PFN_vkWaitForFences = extern "system" fn(device: VkDevice, fenceCount: u32, pFences: *const VkFence, waitAll: VkBool32, timeout: u64) -> VkResult;
/// function prototype `PFN_vkCreateSemaphore` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSemaphore.html>
type PFN_vkCreateSemaphore = extern "system" fn(device: VkDevice, pCreateInfo: *const VkSemaphoreCreateInfo, pAllocator: *const VkAllocationCallbacks, pSemaphore: *mut VkSemaphore) -> VkResult;
/// function prototype `PFN_vkDestroySemaphore` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySemaphore.html>
type PFN_vkDestroySemaphore = extern "system" fn(device: VkDevice, semaphore: VkSemaphore, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCreateEvent` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateEvent.html>
type PFN_vkCreateEvent = extern "system" fn(device: VkDevice, pCreateInfo: *const VkEventCreateInfo, pAllocator: *const VkAllocationCallbacks, pEvent: *mut VkEvent) -> VkResult;
/// function prototype `PFN_vkDestroyEvent` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyEvent.html>
type PFN_vkDestroyEvent = extern "system" fn(device: VkDevice, event: VkEvent, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkGetEventStatus` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetEventStatus.html>
type PFN_vkGetEventStatus = extern "system" fn(device: VkDevice, event: VkEvent) -> VkResult;
/// function prototype `PFN_vkSetEvent` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetEvent.html>
type PFN_vkSetEvent = extern "system" fn(device: VkDevice, event: VkEvent) -> VkResult;
/// function prototype `PFN_vkResetEvent` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetEvent.html>
type PFN_vkResetEvent = extern "system" fn(device: VkDevice, event: VkEvent) -> VkResult;
/// function prototype `PFN_vkCreateQueryPool` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateQueryPool.html>
type PFN_vkCreateQueryPool = extern "system" fn(device: VkDevice, pCreateInfo: *const VkQueryPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pQueryPool: *mut VkQueryPool) -> VkResult;
/// function prototype `PFN_vkDestroyQueryPool` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyQueryPool.html>
type PFN_vkDestroyQueryPool = extern "system" fn(device: VkDevice, queryPool: VkQueryPool, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkGetQueryPoolResults` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetQueryPoolResults.html>
type PFN_vkGetQueryPoolResults = extern "system" fn(device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dataSize: usize, pData: *mut c_void, stride: VkDeviceSize, flags: VkQueryResultFlags) -> VkResult;
/// function prototype `PFN_vkCreateBuffer` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateBuffer.html>
type PFN_vkCreateBuffer = extern "system" fn(device: VkDevice, pCreateInfo: *const VkBufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pBuffer: *mut VkBuffer) -> VkResult;
/// function prototype `PFN_vkDestroyBuffer` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyBuffer.html>
type PFN_vkDestroyBuffer = extern "system" fn(device: VkDevice, buffer: VkBuffer, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCreateBufferView` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateBufferView.html>
type PFN_vkCreateBufferView = extern "system" fn(device: VkDevice, pCreateInfo: *const VkBufferViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkBufferView) -> VkResult;
/// function prototype `PFN_vkDestroyBufferView` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyBufferView.html>
type PFN_vkDestroyBufferView = extern "system" fn(device: VkDevice, bufferView: VkBufferView, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCreateImage` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateImage.html>
type PFN_vkCreateImage = extern "system" fn(device: VkDevice, pCreateInfo: *const VkImageCreateInfo, pAllocator: *const VkAllocationCallbacks, pImage: *mut VkImage) -> VkResult;
/// function prototype `PFN_vkDestroyImage` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyImage.html>
type PFN_vkDestroyImage = extern "system" fn(device: VkDevice, image: VkImage, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkGetImageSubresourceLayout` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout.html>
type PFN_vkGetImageSubresourceLayout = extern "system" fn(device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource, pLayout: *mut VkSubresourceLayout);
/// function prototype `PFN_vkCreateImageView` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateImageView.html>
type PFN_vkCreateImageView = extern "system" fn(device: VkDevice, pCreateInfo: *const VkImageViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkImageView) -> VkResult;
/// function prototype `PFN_vkDestroyImageView` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyImageView.html>
type PFN_vkDestroyImageView = extern "system" fn(device: VkDevice, imageView: VkImageView, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCreateShaderModule` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateShaderModule.html>
type PFN_vkCreateShaderModule = extern "system" fn(device: VkDevice, pCreateInfo: *const VkShaderModuleCreateInfo, pAllocator: *const VkAllocationCallbacks, pShaderModule: *mut VkShaderModule) -> VkResult;
/// function prototype `PFN_vkDestroyShaderModule` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyShaderModule.html>
type PFN_vkDestroyShaderModule = extern "system" fn(device: VkDevice, shaderModule: VkShaderModule, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCreatePipelineCache` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineCache.html>
type PFN_vkCreatePipelineCache = extern "system" fn(device: VkDevice, pCreateInfo: *const VkPipelineCacheCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineCache: *mut VkPipelineCache) -> VkResult;
/// function prototype `PFN_vkDestroyPipelineCache` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineCache.html>
type PFN_vkDestroyPipelineCache = extern "system" fn(device: VkDevice, pipelineCache: VkPipelineCache, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkGetPipelineCacheData` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineCacheData.html>
type PFN_vkGetPipelineCacheData = extern "system" fn(device: VkDevice, pipelineCache: VkPipelineCache, pDataSize: *mut size_t, pData: *mut c_void) -> VkResult;
/// function prototype `PFN_vkMergePipelineCaches` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkMergePipelineCaches.html>
type PFN_vkMergePipelineCaches = extern "system" fn(device: VkDevice, dstCache: VkPipelineCache, srcCacheCount: u32, pSrcCaches: *const VkPipelineCache) -> VkResult;
/// function prototype `PFN_vkCreateGraphicsPipelines` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateGraphicsPipelines.html>
type PFN_vkCreateGraphicsPipelines = extern "system" fn(device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkGraphicsPipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult;
/// function prototype `PFN_vkCreateComputePipelines` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateComputePipelines.html>
type PFN_vkCreateComputePipelines = extern "system" fn(device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkComputePipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult;
/// function prototype `PFN_vkDestroyPipeline` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipeline.html>
type PFN_vkDestroyPipeline = extern "system" fn(device: VkDevice, pipeline: VkPipeline, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCreatePipelineLayout` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineLayout.html>
type PFN_vkCreatePipelineLayout = extern "system" fn(device: VkDevice, pCreateInfo: *const VkPipelineLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineLayout: *mut VkPipelineLayout) -> VkResult;
/// function prototype `PFN_vkDestroyPipelineLayout` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineLayout.html>
type PFN_vkDestroyPipelineLayout = extern "system" fn(device: VkDevice, pipelineLayout: VkPipelineLayout, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCreateSampler` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSampler.html>
type PFN_vkCreateSampler = extern "system" fn(device: VkDevice, pCreateInfo: *const VkSamplerCreateInfo, pAllocator: *const VkAllocationCallbacks, pSampler: *mut VkSampler) -> VkResult;
/// function prototype `PFN_vkDestroySampler` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySampler.html>
type PFN_vkDestroySampler = extern "system" fn(device: VkDevice, sampler: VkSampler, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCreateDescriptorSetLayout` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorSetLayout.html>
type PFN_vkCreateDescriptorSetLayout = extern "system" fn(device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pSetLayout: *mut VkDescriptorSetLayout) -> VkResult;
/// function prototype `PFN_vkDestroyDescriptorSetLayout` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorSetLayout.html>
type PFN_vkDestroyDescriptorSetLayout = extern "system" fn(device: VkDevice, descriptorSetLayout: VkDescriptorSetLayout, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCreateDescriptorPool` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorPool.html>
type PFN_vkCreateDescriptorPool = extern "system" fn(device: VkDevice, pCreateInfo: *const VkDescriptorPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorPool: *mut VkDescriptorPool) -> VkResult;
/// function prototype `PFN_vkDestroyDescriptorPool` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorPool.html>
type PFN_vkDestroyDescriptorPool = extern "system" fn(device: VkDevice, descriptorPool: VkDescriptorPool, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkResetDescriptorPool` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetDescriptorPool.html>
type PFN_vkResetDescriptorPool = extern "system" fn(device: VkDevice, descriptorPool: VkDescriptorPool, flags: VkDescriptorPoolResetFlags) -> VkResult;
/// function prototype `PFN_vkAllocateDescriptorSets` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateDescriptorSets.html>
type PFN_vkAllocateDescriptorSets = extern "system" fn(device: VkDevice, pAllocateInfo: *const VkDescriptorSetAllocateInfo, pDescriptorSets: *mut VkDescriptorSet) -> VkResult;
/// function prototype `PFN_vkFreeDescriptorSets` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeDescriptorSets.html>
type PFN_vkFreeDescriptorSets = extern "system" fn(device: VkDevice, descriptorPool: VkDescriptorPool, descriptorSetCount: u32, pDescriptorSets: *const VkDescriptorSet) -> VkResult;
/// function prototype `PFN_vkUpdateDescriptorSets` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSets.html>
type PFN_vkUpdateDescriptorSets = extern "system" fn(device: VkDevice, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: *const VkCopyDescriptorSet);
/// function prototype `PFN_vkCreateFramebuffer` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateFramebuffer.html>
type PFN_vkCreateFramebuffer = extern "system" fn(device: VkDevice, pCreateInfo: *const VkFramebufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pFramebuffer: *mut VkFramebuffer) -> VkResult;
/// function prototype `PFN_vkDestroyFramebuffer` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyFramebuffer.html>
type PFN_vkDestroyFramebuffer = extern "system" fn(device: VkDevice, framebuffer: VkFramebuffer, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCreateRenderPass` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRenderPass.html>
type PFN_vkCreateRenderPass = extern "system" fn(device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult;
/// function prototype `PFN_vkDestroyRenderPass` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyRenderPass.html>
type PFN_vkDestroyRenderPass = extern "system" fn(device: VkDevice, renderPass: VkRenderPass, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkGetRenderAreaGranularity` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRenderAreaGranularity.html>
type PFN_vkGetRenderAreaGranularity = extern "system" fn(device: VkDevice, renderPass: VkRenderPass, pGranularity: *mut VkExtent2D);
/// function prototype `PFN_vkCreateCommandPool` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCommandPool.html>
type PFN_vkCreateCommandPool = extern "system" fn(device: VkDevice, pCreateInfo: *const VkCommandPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pCommandPool: *mut VkCommandPool) -> VkResult;
/// function prototype `PFN_vkDestroyCommandPool` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCommandPool.html>
type PFN_vkDestroyCommandPool = extern "system" fn(device: VkDevice, commandPool: VkCommandPool, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkResetCommandPool` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetCommandPool.html>
type PFN_vkResetCommandPool = extern "system" fn(device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolResetFlags) -> VkResult;
/// function prototype `PFN_vkAllocateCommandBuffers` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateCommandBuffers.html>
type PFN_vkAllocateCommandBuffers = extern "system" fn(device: VkDevice, pAllocateInfo: *const VkCommandBufferAllocateInfo, pCommandBuffers: *mut VkCommandBuffer) -> VkResult;
/// function prototype `PFN_vkFreeCommandBuffers` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeCommandBuffers.html>
type PFN_vkFreeCommandBuffers = extern "system" fn(device: VkDevice, commandPool: VkCommandPool, commandBufferCount: u32, pCommandBuffers: *const VkCommandBuffer);
/// function prototype `PFN_vkBeginCommandBuffer` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBeginCommandBuffer.html>
type PFN_vkBeginCommandBuffer = extern "system" fn(commandBuffer: VkCommandBuffer, pBeginInfo: *const VkCommandBufferBeginInfo) -> VkResult;
/// function prototype `PFN_vkEndCommandBuffer` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEndCommandBuffer.html>
type PFN_vkEndCommandBuffer = extern "system" fn(commandBuffer: VkCommandBuffer) -> VkResult;
/// function prototype `PFN_vkResetCommandBuffer` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetCommandBuffer.html>
type PFN_vkResetCommandBuffer = extern "system" fn(commandBuffer: VkCommandBuffer, flags: VkCommandBufferResetFlags) -> VkResult;
/// function prototype `PFN_vkCmdBindPipeline` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindPipeline.html>
type PFN_vkCmdBindPipeline = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline);
/// function prototype `PFN_vkCmdSetViewport` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewport.html>
type PFN_vkCmdSetViewport = extern "system" fn(commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: *const VkViewport);
/// function prototype `PFN_vkCmdSetScissor` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetScissor.html>
type PFN_vkCmdSetScissor = extern "system" fn(commandBuffer: VkCommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: *const VkRect2D);
/// function prototype `PFN_vkCmdSetLineWidth` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLineWidth.html>
type PFN_vkCmdSetLineWidth = extern "system" fn(commandBuffer: VkCommandBuffer, lineWidth: f32);
/// function prototype `PFN_vkCmdSetDepthBias` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBias.html>
type PFN_vkCmdSetDepthBias = extern "system" fn(commandBuffer: VkCommandBuffer, depthBiasConstantFactor: f32, depthBiasClamp: f32, depthBiasSlopeFactor: f32);
/// function prototype `PFN_vkCmdSetBlendConstants` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetBlendConstants.html>
type PFN_vkCmdSetBlendConstants = extern "system" fn(commandBuffer: VkCommandBuffer, blendConstants: &[float; 4 as usize]);
/// function prototype `PFN_vkCmdSetDepthBounds` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBounds.html>
type PFN_vkCmdSetDepthBounds = extern "system" fn(commandBuffer: VkCommandBuffer, minDepthBounds: f32, maxDepthBounds: f32);
/// function prototype `PFN_vkCmdSetStencilCompareMask` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilCompareMask.html>
type PFN_vkCmdSetStencilCompareMask = extern "system" fn(commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, compareMask: u32);
/// function prototype `PFN_vkCmdSetStencilWriteMask` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilWriteMask.html>
type PFN_vkCmdSetStencilWriteMask = extern "system" fn(commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, writeMask: u32);
/// function prototype `PFN_vkCmdSetStencilReference` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilReference.html>
type PFN_vkCmdSetStencilReference = extern "system" fn(commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, reference: u32);
/// function prototype `PFN_vkCmdBindDescriptorSets` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorSets.html>
type PFN_vkCmdBindDescriptorSets = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: *const VkDescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: *const uint32_t);
/// function prototype `PFN_vkCmdBindIndexBuffer` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindIndexBuffer.html>
type PFN_vkCmdBindIndexBuffer = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, indexType: VkIndexType);
/// function prototype `PFN_vkCmdBindVertexBuffers` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindVertexBuffers.html>
type PFN_vkCmdBindVertexBuffers = extern "system" fn(commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize);
/// function prototype `PFN_vkCmdDraw` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDraw.html>
type PFN_vkCmdDraw = extern "system" fn(commandBuffer: VkCommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32);
/// function prototype `PFN_vkCmdDrawIndexed` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexed.html>
type PFN_vkCmdDrawIndexed = extern "system" fn(commandBuffer: VkCommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: i32, firstInstance: u32);
/// function prototype `PFN_vkCmdDrawIndirect` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndirect.html>
type PFN_vkCmdDrawIndirect = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32);
/// function prototype `PFN_vkCmdDrawIndexedIndirect` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexedIndirect.html>
type PFN_vkCmdDrawIndexedIndirect = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32);
/// function prototype `PFN_vkCmdDispatch` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatch.html>
type PFN_vkCmdDispatch = extern "system" fn(commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32);
/// function prototype `PFN_vkCmdDispatchIndirect` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchIndirect.html>
type PFN_vkCmdDispatchIndirect = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize);
/// function prototype `PFN_vkCmdCopyBuffer` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBuffer.html>
type PFN_vkCmdCopyBuffer = extern "system" fn(commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstBuffer: VkBuffer, regionCount: u32, pRegions: *const VkBufferCopy);
/// function prototype `PFN_vkCmdCopyImage` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImage.html>
type PFN_vkCmdCopyImage = extern "system" fn(commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageCopy);
/// function prototype `PFN_vkCmdBlitImage` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage.html>
type PFN_vkCmdBlitImage = extern "system" fn(commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageBlit, filter: VkFilter);
/// function prototype `PFN_vkCmdCopyBufferToImage` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage.html>
type PFN_vkCmdCopyBufferToImage = extern "system" fn(commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkBufferImageCopy);
/// function prototype `PFN_vkCmdCopyImageToBuffer` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer.html>
type PFN_vkCmdCopyImageToBuffer = extern "system" fn(commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstBuffer: VkBuffer, regionCount: u32, pRegions: *const VkBufferImageCopy);
/// function prototype `PFN_vkCmdUpdateBuffer` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdUpdateBuffer.html>
type PFN_vkCmdUpdateBuffer = extern "system" fn(commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, dataSize: VkDeviceSize, pData: *const c_void);
/// function prototype `PFN_vkCmdFillBuffer` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdFillBuffer.html>
type PFN_vkCmdFillBuffer = extern "system" fn(commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, size: VkDeviceSize, data: u32);
/// function prototype `PFN_vkCmdClearColorImage` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdClearColorImage.html>
type PFN_vkCmdClearColorImage = extern "system" fn(commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pColor: *const VkClearColorValue, rangeCount: u32, pRanges: *const VkImageSubresourceRange);
/// function prototype `PFN_vkCmdClearDepthStencilImage` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdClearDepthStencilImage.html>
type PFN_vkCmdClearDepthStencilImage = extern "system" fn(commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pDepthStencil: *const VkClearDepthStencilValue, rangeCount: u32, pRanges: *const VkImageSubresourceRange);
/// function prototype `PFN_vkCmdClearAttachments` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdClearAttachments.html>
type PFN_vkCmdClearAttachments = extern "system" fn(commandBuffer: VkCommandBuffer, attachmentCount: u32, pAttachments: *const VkClearAttachment, rectCount: u32, pRects: *const VkClearRect);
/// function prototype `PFN_vkCmdResolveImage` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResolveImage.html>
type PFN_vkCmdResolveImage = extern "system" fn(commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageResolve);
/// function prototype `PFN_vkCmdSetEvent` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetEvent.html>
type PFN_vkCmdSetEvent = extern "system" fn(commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags);
/// function prototype `PFN_vkCmdResetEvent` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResetEvent.html>
type PFN_vkCmdResetEvent = extern "system" fn(commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags);
/// function prototype `PFN_vkCmdWaitEvents` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWaitEvents.html>
type PFN_vkCmdWaitEvents = extern "system" fn(commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const VkImageMemoryBarrier);
/// function prototype `PFN_vkCmdPipelineBarrier` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPipelineBarrier.html>
type PFN_vkCmdPipelineBarrier = extern "system" fn(commandBuffer: VkCommandBuffer, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, dependencyFlags: VkDependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const VkImageMemoryBarrier);
/// function prototype `PFN_vkCmdBeginQuery` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginQuery.html>
type PFN_vkCmdBeginQuery = extern "system" fn(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags);
/// function prototype `PFN_vkCmdEndQuery` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndQuery.html>
type PFN_vkCmdEndQuery = extern "system" fn(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32);
/// function prototype `PFN_vkCmdResetQueryPool` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResetQueryPool.html>
type PFN_vkCmdResetQueryPool = extern "system" fn(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32);
/// function prototype `PFN_vkCmdWriteTimestamp` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteTimestamp.html>
type PFN_vkCmdWriteTimestamp = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, queryPool: VkQueryPool, query: u32);
/// function prototype `PFN_vkCmdCopyQueryPoolResults` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyQueryPoolResults.html>
type PFN_vkCmdCopyQueryPoolResults = extern "system" fn(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, stride: VkDeviceSize, flags: VkQueryResultFlags);
/// function prototype `PFN_vkCmdPushConstants` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushConstants.html>
type PFN_vkCmdPushConstants = extern "system" fn(commandBuffer: VkCommandBuffer, layout: VkPipelineLayout, stageFlags: VkShaderStageFlags, offset: u32, size: u32, pValues: *const c_void);
/// function prototype `PFN_vkCmdBeginRenderPass` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderPass.html>
type PFN_vkCmdBeginRenderPass = extern "system" fn(commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, contents: VkSubpassContents);
/// function prototype `PFN_vkCmdNextSubpass` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdNextSubpass.html>
type PFN_vkCmdNextSubpass = extern "system" fn(commandBuffer: VkCommandBuffer, contents: VkSubpassContents);
/// function prototype `PFN_vkCmdEndRenderPass` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRenderPass.html>
type PFN_vkCmdEndRenderPass = extern "system" fn(commandBuffer: VkCommandBuffer);
/// function prototype `PFN_vkCmdExecuteCommands` from VK_VERSION_1_0
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdExecuteCommands.html>
type PFN_vkCmdExecuteCommands = extern "system" fn(commandBuffer: VkCommandBuffer, commandBufferCount: u32, pCommandBuffers: *const VkCommandBuffer);
/// The dummy function for `vkCreateInstance` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateInstance(_: *const VkInstanceCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkInstance) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateInstance"))
}
/// The dummy function for `vkDestroyInstance` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyInstance(_: VkInstance, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyInstance"))
}
/// The dummy function for `vkEnumeratePhysicalDevices` from `VK_VERSION_1_0`
extern "system" fn dummy_vkEnumeratePhysicalDevices(_: VkInstance, _: *mut uint32_t, _: *mut VkPhysicalDevice) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkEnumeratePhysicalDevices"))
}
/// The dummy function for `vkGetPhysicalDeviceFeatures` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetPhysicalDeviceFeatures(_: VkPhysicalDevice, _: *mut VkPhysicalDeviceFeatures) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceFeatures"))
}
/// The dummy function for `vkGetPhysicalDeviceFormatProperties` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetPhysicalDeviceFormatProperties(_: VkPhysicalDevice, _: VkFormat, _: *mut VkFormatProperties) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceFormatProperties"))
}
/// The dummy function for `vkGetPhysicalDeviceImageFormatProperties` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetPhysicalDeviceImageFormatProperties(_: VkPhysicalDevice, _: VkFormat, _: VkImageType, _: VkImageTiling, _: VkImageUsageFlags, _: VkImageCreateFlags, _: *mut VkImageFormatProperties) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceImageFormatProperties"))
}
/// The dummy function for `vkGetPhysicalDeviceProperties` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetPhysicalDeviceProperties(_: VkPhysicalDevice, _: *mut VkPhysicalDeviceProperties) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceProperties"))
}
/// The dummy function for `vkGetPhysicalDeviceQueueFamilyProperties` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetPhysicalDeviceQueueFamilyProperties(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkQueueFamilyProperties) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceQueueFamilyProperties"))
}
/// The dummy function for `vkGetPhysicalDeviceMemoryProperties` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetPhysicalDeviceMemoryProperties(_: VkPhysicalDevice, _: *mut VkPhysicalDeviceMemoryProperties) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceMemoryProperties"))
}
/// The dummy function for `vkGetInstanceProcAddr` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetInstanceProcAddr(_: VkInstance, _: *const i8) -> PFN_vkVoidFunction {
	panic_any(VkError::NullFunctionPointer("vkGetInstanceProcAddr"))
}
/// The dummy function for `vkGetDeviceProcAddr` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetDeviceProcAddr(_: VkDevice, _: *const i8) -> PFN_vkVoidFunction {
	panic_any(VkError::NullFunctionPointer("vkGetDeviceProcAddr"))
}
/// The dummy function for `vkCreateDevice` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateDevice(_: VkPhysicalDevice, _: *const VkDeviceCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkDevice) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateDevice"))
}
/// The dummy function for `vkDestroyDevice` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyDevice(_: VkDevice, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyDevice"))
}
/// The dummy function for `vkEnumerateInstanceExtensionProperties` from `VK_VERSION_1_0`
extern "system" fn dummy_vkEnumerateInstanceExtensionProperties(_: *const i8, _: *mut uint32_t, _: *mut VkExtensionProperties) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkEnumerateInstanceExtensionProperties"))
}
/// The dummy function for `vkEnumerateDeviceExtensionProperties` from `VK_VERSION_1_0`
extern "system" fn dummy_vkEnumerateDeviceExtensionProperties(_: VkPhysicalDevice, _: *const i8, _: *mut uint32_t, _: *mut VkExtensionProperties) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkEnumerateDeviceExtensionProperties"))
}
/// The dummy function for `vkEnumerateInstanceLayerProperties` from `VK_VERSION_1_0`
extern "system" fn dummy_vkEnumerateInstanceLayerProperties(_: *mut uint32_t, _: *mut VkLayerProperties) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkEnumerateInstanceLayerProperties"))
}
/// The dummy function for `vkEnumerateDeviceLayerProperties` from `VK_VERSION_1_0`
extern "system" fn dummy_vkEnumerateDeviceLayerProperties(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkLayerProperties) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkEnumerateDeviceLayerProperties"))
}
/// The dummy function for `vkGetDeviceQueue` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetDeviceQueue(_: VkDevice, _: u32, _: u32, _: *mut VkQueue) {
	panic_any(VkError::NullFunctionPointer("vkGetDeviceQueue"))
}
/// The dummy function for `vkQueueSubmit` from `VK_VERSION_1_0`
extern "system" fn dummy_vkQueueSubmit(_: VkQueue, _: u32, _: *const VkSubmitInfo, _: VkFence) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkQueueSubmit"))
}
/// The dummy function for `vkQueueWaitIdle` from `VK_VERSION_1_0`
extern "system" fn dummy_vkQueueWaitIdle(_: VkQueue) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkQueueWaitIdle"))
}
/// The dummy function for `vkDeviceWaitIdle` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDeviceWaitIdle(_: VkDevice) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkDeviceWaitIdle"))
}
/// The dummy function for `vkAllocateMemory` from `VK_VERSION_1_0`
extern "system" fn dummy_vkAllocateMemory(_: VkDevice, _: *const VkMemoryAllocateInfo, _: *const VkAllocationCallbacks, _: *mut VkDeviceMemory) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkAllocateMemory"))
}
/// The dummy function for `vkFreeMemory` from `VK_VERSION_1_0`
extern "system" fn dummy_vkFreeMemory(_: VkDevice, _: VkDeviceMemory, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkFreeMemory"))
}
/// The dummy function for `vkMapMemory` from `VK_VERSION_1_0`
extern "system" fn dummy_vkMapMemory(_: VkDevice, _: VkDeviceMemory, _: VkDeviceSize, _: VkDeviceSize, _: VkMemoryMapFlags, _: *mut *mut c_void) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkMapMemory"))
}
/// The dummy function for `vkUnmapMemory` from `VK_VERSION_1_0`
extern "system" fn dummy_vkUnmapMemory(_: VkDevice, _: VkDeviceMemory) {
	panic_any(VkError::NullFunctionPointer("vkUnmapMemory"))
}
/// The dummy function for `vkFlushMappedMemoryRanges` from `VK_VERSION_1_0`
extern "system" fn dummy_vkFlushMappedMemoryRanges(_: VkDevice, _: u32, _: *const VkMappedMemoryRange) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkFlushMappedMemoryRanges"))
}
/// The dummy function for `vkInvalidateMappedMemoryRanges` from `VK_VERSION_1_0`
extern "system" fn dummy_vkInvalidateMappedMemoryRanges(_: VkDevice, _: u32, _: *const VkMappedMemoryRange) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkInvalidateMappedMemoryRanges"))
}
/// The dummy function for `vkGetDeviceMemoryCommitment` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetDeviceMemoryCommitment(_: VkDevice, _: VkDeviceMemory, _: *mut VkDeviceSize) {
	panic_any(VkError::NullFunctionPointer("vkGetDeviceMemoryCommitment"))
}
/// The dummy function for `vkBindBufferMemory` from `VK_VERSION_1_0`
extern "system" fn dummy_vkBindBufferMemory(_: VkDevice, _: VkBuffer, _: VkDeviceMemory, _: VkDeviceSize) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkBindBufferMemory"))
}
/// The dummy function for `vkBindImageMemory` from `VK_VERSION_1_0`
extern "system" fn dummy_vkBindImageMemory(_: VkDevice, _: VkImage, _: VkDeviceMemory, _: VkDeviceSize) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkBindImageMemory"))
}
/// The dummy function for `vkGetBufferMemoryRequirements` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetBufferMemoryRequirements(_: VkDevice, _: VkBuffer, _: *mut VkMemoryRequirements) {
	panic_any(VkError::NullFunctionPointer("vkGetBufferMemoryRequirements"))
}
/// The dummy function for `vkGetImageMemoryRequirements` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetImageMemoryRequirements(_: VkDevice, _: VkImage, _: *mut VkMemoryRequirements) {
	panic_any(VkError::NullFunctionPointer("vkGetImageMemoryRequirements"))
}
/// The dummy function for `vkGetImageSparseMemoryRequirements` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetImageSparseMemoryRequirements(_: VkDevice, _: VkImage, _: *mut uint32_t, _: *mut VkSparseImageMemoryRequirements) {
	panic_any(VkError::NullFunctionPointer("vkGetImageSparseMemoryRequirements"))
}
/// The dummy function for `vkGetPhysicalDeviceSparseImageFormatProperties` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetPhysicalDeviceSparseImageFormatProperties(_: VkPhysicalDevice, _: VkFormat, _: VkImageType, _: VkSampleCountFlagBits, _: VkImageUsageFlags, _: VkImageTiling, _: *mut uint32_t, _: *mut VkSparseImageFormatProperties) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceSparseImageFormatProperties"))
}
/// The dummy function for `vkQueueBindSparse` from `VK_VERSION_1_0`
extern "system" fn dummy_vkQueueBindSparse(_: VkQueue, _: u32, _: *const VkBindSparseInfo, _: VkFence) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkQueueBindSparse"))
}
/// The dummy function for `vkCreateFence` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateFence(_: VkDevice, _: *const VkFenceCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkFence) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateFence"))
}
/// The dummy function for `vkDestroyFence` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyFence(_: VkDevice, _: VkFence, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyFence"))
}
/// The dummy function for `vkResetFences` from `VK_VERSION_1_0`
extern "system" fn dummy_vkResetFences(_: VkDevice, _: u32, _: *const VkFence) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkResetFences"))
}
/// The dummy function for `vkGetFenceStatus` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetFenceStatus(_: VkDevice, _: VkFence) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetFenceStatus"))
}
/// The dummy function for `vkWaitForFences` from `VK_VERSION_1_0`
extern "system" fn dummy_vkWaitForFences(_: VkDevice, _: u32, _: *const VkFence, _: VkBool32, _: u64) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkWaitForFences"))
}
/// The dummy function for `vkCreateSemaphore` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateSemaphore(_: VkDevice, _: *const VkSemaphoreCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkSemaphore) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateSemaphore"))
}
/// The dummy function for `vkDestroySemaphore` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroySemaphore(_: VkDevice, _: VkSemaphore, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroySemaphore"))
}
/// The dummy function for `vkCreateEvent` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateEvent(_: VkDevice, _: *const VkEventCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkEvent) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateEvent"))
}
/// The dummy function for `vkDestroyEvent` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyEvent(_: VkDevice, _: VkEvent, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyEvent"))
}
/// The dummy function for `vkGetEventStatus` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetEventStatus(_: VkDevice, _: VkEvent) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetEventStatus"))
}
/// The dummy function for `vkSetEvent` from `VK_VERSION_1_0`
extern "system" fn dummy_vkSetEvent(_: VkDevice, _: VkEvent) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkSetEvent"))
}
/// The dummy function for `vkResetEvent` from `VK_VERSION_1_0`
extern "system" fn dummy_vkResetEvent(_: VkDevice, _: VkEvent) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkResetEvent"))
}
/// The dummy function for `vkCreateQueryPool` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateQueryPool(_: VkDevice, _: *const VkQueryPoolCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkQueryPool) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateQueryPool"))
}
/// The dummy function for `vkDestroyQueryPool` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyQueryPool(_: VkDevice, _: VkQueryPool, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyQueryPool"))
}
/// The dummy function for `vkGetQueryPoolResults` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetQueryPoolResults(_: VkDevice, _: VkQueryPool, _: u32, _: u32, _: usize, _: *mut c_void, _: VkDeviceSize, _: VkQueryResultFlags) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetQueryPoolResults"))
}
/// The dummy function for `vkCreateBuffer` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateBuffer(_: VkDevice, _: *const VkBufferCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkBuffer) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateBuffer"))
}
/// The dummy function for `vkDestroyBuffer` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyBuffer(_: VkDevice, _: VkBuffer, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyBuffer"))
}
/// The dummy function for `vkCreateBufferView` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateBufferView(_: VkDevice, _: *const VkBufferViewCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkBufferView) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateBufferView"))
}
/// The dummy function for `vkDestroyBufferView` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyBufferView(_: VkDevice, _: VkBufferView, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyBufferView"))
}
/// The dummy function for `vkCreateImage` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateImage(_: VkDevice, _: *const VkImageCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkImage) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateImage"))
}
/// The dummy function for `vkDestroyImage` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyImage(_: VkDevice, _: VkImage, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyImage"))
}
/// The dummy function for `vkGetImageSubresourceLayout` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetImageSubresourceLayout(_: VkDevice, _: VkImage, _: *const VkImageSubresource, _: *mut VkSubresourceLayout) {
	panic_any(VkError::NullFunctionPointer("vkGetImageSubresourceLayout"))
}
/// The dummy function for `vkCreateImageView` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateImageView(_: VkDevice, _: *const VkImageViewCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkImageView) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateImageView"))
}
/// The dummy function for `vkDestroyImageView` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyImageView(_: VkDevice, _: VkImageView, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyImageView"))
}
/// The dummy function for `vkCreateShaderModule` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateShaderModule(_: VkDevice, _: *const VkShaderModuleCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkShaderModule) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateShaderModule"))
}
/// The dummy function for `vkDestroyShaderModule` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyShaderModule(_: VkDevice, _: VkShaderModule, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyShaderModule"))
}
/// The dummy function for `vkCreatePipelineCache` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreatePipelineCache(_: VkDevice, _: *const VkPipelineCacheCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkPipelineCache) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreatePipelineCache"))
}
/// The dummy function for `vkDestroyPipelineCache` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyPipelineCache(_: VkDevice, _: VkPipelineCache, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyPipelineCache"))
}
/// The dummy function for `vkGetPipelineCacheData` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetPipelineCacheData(_: VkDevice, _: VkPipelineCache, _: *mut size_t, _: *mut c_void) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPipelineCacheData"))
}
/// The dummy function for `vkMergePipelineCaches` from `VK_VERSION_1_0`
extern "system" fn dummy_vkMergePipelineCaches(_: VkDevice, _: VkPipelineCache, _: u32, _: *const VkPipelineCache) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkMergePipelineCaches"))
}
/// The dummy function for `vkCreateGraphicsPipelines` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateGraphicsPipelines(_: VkDevice, _: VkPipelineCache, _: u32, _: *const VkGraphicsPipelineCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkPipeline) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateGraphicsPipelines"))
}
/// The dummy function for `vkCreateComputePipelines` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateComputePipelines(_: VkDevice, _: VkPipelineCache, _: u32, _: *const VkComputePipelineCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkPipeline) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateComputePipelines"))
}
/// The dummy function for `vkDestroyPipeline` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyPipeline(_: VkDevice, _: VkPipeline, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyPipeline"))
}
/// The dummy function for `vkCreatePipelineLayout` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreatePipelineLayout(_: VkDevice, _: *const VkPipelineLayoutCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkPipelineLayout) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreatePipelineLayout"))
}
/// The dummy function for `vkDestroyPipelineLayout` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyPipelineLayout(_: VkDevice, _: VkPipelineLayout, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyPipelineLayout"))
}
/// The dummy function for `vkCreateSampler` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateSampler(_: VkDevice, _: *const VkSamplerCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkSampler) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateSampler"))
}
/// The dummy function for `vkDestroySampler` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroySampler(_: VkDevice, _: VkSampler, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroySampler"))
}
/// The dummy function for `vkCreateDescriptorSetLayout` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateDescriptorSetLayout(_: VkDevice, _: *const VkDescriptorSetLayoutCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkDescriptorSetLayout) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateDescriptorSetLayout"))
}
/// The dummy function for `vkDestroyDescriptorSetLayout` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyDescriptorSetLayout(_: VkDevice, _: VkDescriptorSetLayout, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyDescriptorSetLayout"))
}
/// The dummy function for `vkCreateDescriptorPool` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateDescriptorPool(_: VkDevice, _: *const VkDescriptorPoolCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkDescriptorPool) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateDescriptorPool"))
}
/// The dummy function for `vkDestroyDescriptorPool` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyDescriptorPool(_: VkDevice, _: VkDescriptorPool, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyDescriptorPool"))
}
/// The dummy function for `vkResetDescriptorPool` from `VK_VERSION_1_0`
extern "system" fn dummy_vkResetDescriptorPool(_: VkDevice, _: VkDescriptorPool, _: VkDescriptorPoolResetFlags) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkResetDescriptorPool"))
}
/// The dummy function for `vkAllocateDescriptorSets` from `VK_VERSION_1_0`
extern "system" fn dummy_vkAllocateDescriptorSets(_: VkDevice, _: *const VkDescriptorSetAllocateInfo, _: *mut VkDescriptorSet) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkAllocateDescriptorSets"))
}
/// The dummy function for `vkFreeDescriptorSets` from `VK_VERSION_1_0`
extern "system" fn dummy_vkFreeDescriptorSets(_: VkDevice, _: VkDescriptorPool, _: u32, _: *const VkDescriptorSet) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkFreeDescriptorSets"))
}
/// The dummy function for `vkUpdateDescriptorSets` from `VK_VERSION_1_0`
extern "system" fn dummy_vkUpdateDescriptorSets(_: VkDevice, _: u32, _: *const VkWriteDescriptorSet, _: u32, _: *const VkCopyDescriptorSet) {
	panic_any(VkError::NullFunctionPointer("vkUpdateDescriptorSets"))
}
/// The dummy function for `vkCreateFramebuffer` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateFramebuffer(_: VkDevice, _: *const VkFramebufferCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkFramebuffer) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateFramebuffer"))
}
/// The dummy function for `vkDestroyFramebuffer` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyFramebuffer(_: VkDevice, _: VkFramebuffer, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyFramebuffer"))
}
/// The dummy function for `vkCreateRenderPass` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateRenderPass(_: VkDevice, _: *const VkRenderPassCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkRenderPass) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateRenderPass"))
}
/// The dummy function for `vkDestroyRenderPass` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyRenderPass(_: VkDevice, _: VkRenderPass, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyRenderPass"))
}
/// The dummy function for `vkGetRenderAreaGranularity` from `VK_VERSION_1_0`
extern "system" fn dummy_vkGetRenderAreaGranularity(_: VkDevice, _: VkRenderPass, _: *mut VkExtent2D) {
	panic_any(VkError::NullFunctionPointer("vkGetRenderAreaGranularity"))
}
/// The dummy function for `vkCreateCommandPool` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCreateCommandPool(_: VkDevice, _: *const VkCommandPoolCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkCommandPool) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateCommandPool"))
}
/// The dummy function for `vkDestroyCommandPool` from `VK_VERSION_1_0`
extern "system" fn dummy_vkDestroyCommandPool(_: VkDevice, _: VkCommandPool, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyCommandPool"))
}
/// The dummy function for `vkResetCommandPool` from `VK_VERSION_1_0`
extern "system" fn dummy_vkResetCommandPool(_: VkDevice, _: VkCommandPool, _: VkCommandPoolResetFlags) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkResetCommandPool"))
}
/// The dummy function for `vkAllocateCommandBuffers` from `VK_VERSION_1_0`
extern "system" fn dummy_vkAllocateCommandBuffers(_: VkDevice, _: *const VkCommandBufferAllocateInfo, _: *mut VkCommandBuffer) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkAllocateCommandBuffers"))
}
/// The dummy function for `vkFreeCommandBuffers` from `VK_VERSION_1_0`
extern "system" fn dummy_vkFreeCommandBuffers(_: VkDevice, _: VkCommandPool, _: u32, _: *const VkCommandBuffer) {
	panic_any(VkError::NullFunctionPointer("vkFreeCommandBuffers"))
}
/// The dummy function for `vkBeginCommandBuffer` from `VK_VERSION_1_0`
extern "system" fn dummy_vkBeginCommandBuffer(_: VkCommandBuffer, _: *const VkCommandBufferBeginInfo) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkBeginCommandBuffer"))
}
/// The dummy function for `vkEndCommandBuffer` from `VK_VERSION_1_0`
extern "system" fn dummy_vkEndCommandBuffer(_: VkCommandBuffer) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkEndCommandBuffer"))
}
/// The dummy function for `vkResetCommandBuffer` from `VK_VERSION_1_0`
extern "system" fn dummy_vkResetCommandBuffer(_: VkCommandBuffer, _: VkCommandBufferResetFlags) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkResetCommandBuffer"))
}
/// The dummy function for `vkCmdBindPipeline` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdBindPipeline(_: VkCommandBuffer, _: VkPipelineBindPoint, _: VkPipeline) {
	panic_any(VkError::NullFunctionPointer("vkCmdBindPipeline"))
}
/// The dummy function for `vkCmdSetViewport` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdSetViewport(_: VkCommandBuffer, _: u32, _: u32, _: *const VkViewport) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetViewport"))
}
/// The dummy function for `vkCmdSetScissor` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdSetScissor(_: VkCommandBuffer, _: u32, _: u32, _: *const VkRect2D) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetScissor"))
}
/// The dummy function for `vkCmdSetLineWidth` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdSetLineWidth(_: VkCommandBuffer, _: f32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetLineWidth"))
}
/// The dummy function for `vkCmdSetDepthBias` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdSetDepthBias(_: VkCommandBuffer, _: f32, _: f32, _: f32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetDepthBias"))
}
/// The dummy function for `vkCmdSetBlendConstants` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdSetBlendConstants(_: VkCommandBuffer, _: &[float; 4 as usize]) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetBlendConstants"))
}
/// The dummy function for `vkCmdSetDepthBounds` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdSetDepthBounds(_: VkCommandBuffer, _: f32, _: f32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetDepthBounds"))
}
/// The dummy function for `vkCmdSetStencilCompareMask` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdSetStencilCompareMask(_: VkCommandBuffer, _: VkStencilFaceFlags, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetStencilCompareMask"))
}
/// The dummy function for `vkCmdSetStencilWriteMask` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdSetStencilWriteMask(_: VkCommandBuffer, _: VkStencilFaceFlags, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetStencilWriteMask"))
}
/// The dummy function for `vkCmdSetStencilReference` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdSetStencilReference(_: VkCommandBuffer, _: VkStencilFaceFlags, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetStencilReference"))
}
/// The dummy function for `vkCmdBindDescriptorSets` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdBindDescriptorSets(_: VkCommandBuffer, _: VkPipelineBindPoint, _: VkPipelineLayout, _: u32, _: u32, _: *const VkDescriptorSet, _: u32, _: *const uint32_t) {
	panic_any(VkError::NullFunctionPointer("vkCmdBindDescriptorSets"))
}
/// The dummy function for `vkCmdBindIndexBuffer` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdBindIndexBuffer(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkIndexType) {
	panic_any(VkError::NullFunctionPointer("vkCmdBindIndexBuffer"))
}
/// The dummy function for `vkCmdBindVertexBuffers` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdBindVertexBuffers(_: VkCommandBuffer, _: u32, _: u32, _: *const VkBuffer, _: *const VkDeviceSize) {
	panic_any(VkError::NullFunctionPointer("vkCmdBindVertexBuffers"))
}
/// The dummy function for `vkCmdDraw` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdDraw(_: VkCommandBuffer, _: u32, _: u32, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdDraw"))
}
/// The dummy function for `vkCmdDrawIndexed` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdDrawIndexed(_: VkCommandBuffer, _: u32, _: u32, _: u32, _: i32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdDrawIndexed"))
}
/// The dummy function for `vkCmdDrawIndirect` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdDrawIndirect(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdDrawIndirect"))
}
/// The dummy function for `vkCmdDrawIndexedIndirect` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdDrawIndexedIndirect(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdDrawIndexedIndirect"))
}
/// The dummy function for `vkCmdDispatch` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdDispatch(_: VkCommandBuffer, _: u32, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdDispatch"))
}
/// The dummy function for `vkCmdDispatchIndirect` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdDispatchIndirect(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize) {
	panic_any(VkError::NullFunctionPointer("vkCmdDispatchIndirect"))
}
/// The dummy function for `vkCmdCopyBuffer` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdCopyBuffer(_: VkCommandBuffer, _: VkBuffer, _: VkBuffer, _: u32, _: *const VkBufferCopy) {
	panic_any(VkError::NullFunctionPointer("vkCmdCopyBuffer"))
}
/// The dummy function for `vkCmdCopyImage` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdCopyImage(_: VkCommandBuffer, _: VkImage, _: VkImageLayout, _: VkImage, _: VkImageLayout, _: u32, _: *const VkImageCopy) {
	panic_any(VkError::NullFunctionPointer("vkCmdCopyImage"))
}
/// The dummy function for `vkCmdBlitImage` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdBlitImage(_: VkCommandBuffer, _: VkImage, _: VkImageLayout, _: VkImage, _: VkImageLayout, _: u32, _: *const VkImageBlit, _: VkFilter) {
	panic_any(VkError::NullFunctionPointer("vkCmdBlitImage"))
}
/// The dummy function for `vkCmdCopyBufferToImage` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdCopyBufferToImage(_: VkCommandBuffer, _: VkBuffer, _: VkImage, _: VkImageLayout, _: u32, _: *const VkBufferImageCopy) {
	panic_any(VkError::NullFunctionPointer("vkCmdCopyBufferToImage"))
}
/// The dummy function for `vkCmdCopyImageToBuffer` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdCopyImageToBuffer(_: VkCommandBuffer, _: VkImage, _: VkImageLayout, _: VkBuffer, _: u32, _: *const VkBufferImageCopy) {
	panic_any(VkError::NullFunctionPointer("vkCmdCopyImageToBuffer"))
}
/// The dummy function for `vkCmdUpdateBuffer` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdUpdateBuffer(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkDeviceSize, _: *const c_void) {
	panic_any(VkError::NullFunctionPointer("vkCmdUpdateBuffer"))
}
/// The dummy function for `vkCmdFillBuffer` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdFillBuffer(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkDeviceSize, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdFillBuffer"))
}
/// The dummy function for `vkCmdClearColorImage` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdClearColorImage(_: VkCommandBuffer, _: VkImage, _: VkImageLayout, _: *const VkClearColorValue, _: u32, _: *const VkImageSubresourceRange) {
	panic_any(VkError::NullFunctionPointer("vkCmdClearColorImage"))
}
/// The dummy function for `vkCmdClearDepthStencilImage` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdClearDepthStencilImage(_: VkCommandBuffer, _: VkImage, _: VkImageLayout, _: *const VkClearDepthStencilValue, _: u32, _: *const VkImageSubresourceRange) {
	panic_any(VkError::NullFunctionPointer("vkCmdClearDepthStencilImage"))
}
/// The dummy function for `vkCmdClearAttachments` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdClearAttachments(_: VkCommandBuffer, _: u32, _: *const VkClearAttachment, _: u32, _: *const VkClearRect) {
	panic_any(VkError::NullFunctionPointer("vkCmdClearAttachments"))
}
/// The dummy function for `vkCmdResolveImage` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdResolveImage(_: VkCommandBuffer, _: VkImage, _: VkImageLayout, _: VkImage, _: VkImageLayout, _: u32, _: *const VkImageResolve) {
	panic_any(VkError::NullFunctionPointer("vkCmdResolveImage"))
}
/// The dummy function for `vkCmdSetEvent` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdSetEvent(_: VkCommandBuffer, _: VkEvent, _: VkPipelineStageFlags) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetEvent"))
}
/// The dummy function for `vkCmdResetEvent` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdResetEvent(_: VkCommandBuffer, _: VkEvent, _: VkPipelineStageFlags) {
	panic_any(VkError::NullFunctionPointer("vkCmdResetEvent"))
}
/// The dummy function for `vkCmdWaitEvents` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdWaitEvents(_: VkCommandBuffer, _: u32, _: *const VkEvent, _: VkPipelineStageFlags, _: VkPipelineStageFlags, _: u32, _: *const VkMemoryBarrier, _: u32, _: *const VkBufferMemoryBarrier, _: u32, _: *const VkImageMemoryBarrier) {
	panic_any(VkError::NullFunctionPointer("vkCmdWaitEvents"))
}
/// The dummy function for `vkCmdPipelineBarrier` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdPipelineBarrier(_: VkCommandBuffer, _: VkPipelineStageFlags, _: VkPipelineStageFlags, _: VkDependencyFlags, _: u32, _: *const VkMemoryBarrier, _: u32, _: *const VkBufferMemoryBarrier, _: u32, _: *const VkImageMemoryBarrier) {
	panic_any(VkError::NullFunctionPointer("vkCmdPipelineBarrier"))
}
/// The dummy function for `vkCmdBeginQuery` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdBeginQuery(_: VkCommandBuffer, _: VkQueryPool, _: u32, _: VkQueryControlFlags) {
	panic_any(VkError::NullFunctionPointer("vkCmdBeginQuery"))
}
/// The dummy function for `vkCmdEndQuery` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdEndQuery(_: VkCommandBuffer, _: VkQueryPool, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdEndQuery"))
}
/// The dummy function for `vkCmdResetQueryPool` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdResetQueryPool(_: VkCommandBuffer, _: VkQueryPool, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdResetQueryPool"))
}
/// The dummy function for `vkCmdWriteTimestamp` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdWriteTimestamp(_: VkCommandBuffer, _: VkPipelineStageFlagBits, _: VkQueryPool, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdWriteTimestamp"))
}
/// The dummy function for `vkCmdCopyQueryPoolResults` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdCopyQueryPoolResults(_: VkCommandBuffer, _: VkQueryPool, _: u32, _: u32, _: VkBuffer, _: VkDeviceSize, _: VkDeviceSize, _: VkQueryResultFlags) {
	panic_any(VkError::NullFunctionPointer("vkCmdCopyQueryPoolResults"))
}
/// The dummy function for `vkCmdPushConstants` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdPushConstants(_: VkCommandBuffer, _: VkPipelineLayout, _: VkShaderStageFlags, _: u32, _: u32, _: *const c_void) {
	panic_any(VkError::NullFunctionPointer("vkCmdPushConstants"))
}
/// The dummy function for `vkCmdBeginRenderPass` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdBeginRenderPass(_: VkCommandBuffer, _: *const VkRenderPassBeginInfo, _: VkSubpassContents) {
	panic_any(VkError::NullFunctionPointer("vkCmdBeginRenderPass"))
}
/// The dummy function for `vkCmdNextSubpass` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdNextSubpass(_: VkCommandBuffer, _: VkSubpassContents) {
	panic_any(VkError::NullFunctionPointer("vkCmdNextSubpass"))
}
/// The dummy function for `vkCmdEndRenderPass` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdEndRenderPass(_: VkCommandBuffer) {
	panic_any(VkError::NullFunctionPointer("vkCmdEndRenderPass"))
}
/// The dummy function for `vkCmdExecuteCommands` from `VK_VERSION_1_0`
extern "system" fn dummy_vkCmdExecuteCommands(_: VkCommandBuffer, _: u32, _: *const VkCommandBuffer) {
	panic_any(VkError::NullFunctionPointer("vkCmdExecuteCommands"))
}
/// trait for `VK_VERSION_1_0`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_VERSION_1_0.html>
pub trait VK_VERSION_1_0: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateInstance.html>
	fn vkCreateInstance(&self, pCreateInfo: *const VkInstanceCreateInfo, pAllocator: *const VkAllocationCallbacks, pInstance: *mut VkInstance) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyInstance.html>
	fn vkDestroyInstance(&self, instance: VkInstance, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDevices.html>
	fn vkEnumeratePhysicalDevices(&self, instance: VkInstance, pPhysicalDeviceCount: *mut uint32_t, pPhysicalDevices: *mut VkPhysicalDevice) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures.html>
	fn vkGetPhysicalDeviceFeatures(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFormatProperties.html>
	fn vkGetPhysicalDeviceFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceImageFormatProperties.html>
	fn vkGetPhysicalDeviceImageFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, pImageFormatProperties: *mut VkImageFormatProperties) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceProperties.html>
	fn vkGetPhysicalDeviceProperties(&self, physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties.html>
	fn vkGetPhysicalDeviceQueueFamilyProperties(&self, physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMemoryProperties.html>
	fn vkGetPhysicalDeviceMemoryProperties(&self, physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetInstanceProcAddr.html>
	fn vkGetInstanceProcAddr(&self, instance: VkInstance, pName: *const i8) -> Result<PFN_vkVoidFunction>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceProcAddr.html>
	fn vkGetDeviceProcAddr(&self, device: VkDevice, pName: *const i8) -> Result<PFN_vkVoidFunction>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDevice.html>
	fn vkCreateDevice(&self, physicalDevice: VkPhysicalDevice, pCreateInfo: *const VkDeviceCreateInfo, pAllocator: *const VkAllocationCallbacks, pDevice: *mut VkDevice) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDevice.html>
	fn vkDestroyDevice(&self, device: VkDevice, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateInstanceExtensionProperties.html>
	fn vkEnumerateInstanceExtensionProperties(&self, pLayerName: *const i8, pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateDeviceExtensionProperties.html>
	fn vkEnumerateDeviceExtensionProperties(&self, physicalDevice: VkPhysicalDevice, pLayerName: *const i8, pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateInstanceLayerProperties.html>
	fn vkEnumerateInstanceLayerProperties(&self, pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateDeviceLayerProperties.html>
	fn vkEnumerateDeviceLayerProperties(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceQueue.html>
	fn vkGetDeviceQueue(&self, device: VkDevice, queueFamilyIndex: u32, queueIndex: u32, pQueue: *mut VkQueue) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueSubmit.html>
	fn vkQueueSubmit(&self, queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo, fence: VkFence) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueWaitIdle.html>
	fn vkQueueWaitIdle(&self, queue: VkQueue) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDeviceWaitIdle.html>
	fn vkDeviceWaitIdle(&self, device: VkDevice) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateMemory.html>
	fn vkAllocateMemory(&self, device: VkDevice, pAllocateInfo: *const VkMemoryAllocateInfo, pAllocator: *const VkAllocationCallbacks, pMemory: *mut VkDeviceMemory) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeMemory.html>
	fn vkFreeMemory(&self, device: VkDevice, memory: VkDeviceMemory, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkMapMemory.html>
	fn vkMapMemory(&self, device: VkDevice, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize, flags: VkMemoryMapFlags, ppData: *mut *mut c_void) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkUnmapMemory.html>
	fn vkUnmapMemory(&self, device: VkDevice, memory: VkDeviceMemory) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkFlushMappedMemoryRanges.html>
	fn vkFlushMappedMemoryRanges(&self, device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *const VkMappedMemoryRange) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkInvalidateMappedMemoryRanges.html>
	fn vkInvalidateMappedMemoryRanges(&self, device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *const VkMappedMemoryRange) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceMemoryCommitment.html>
	fn vkGetDeviceMemoryCommitment(&self, device: VkDevice, memory: VkDeviceMemory, pCommittedMemoryInBytes: *mut VkDeviceSize) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindBufferMemory.html>
	fn vkBindBufferMemory(&self, device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindImageMemory.html>
	fn vkBindImageMemory(&self, device: VkDevice, image: VkImage, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferMemoryRequirements.html>
	fn vkGetBufferMemoryRequirements(&self, device: VkDevice, buffer: VkBuffer, pMemoryRequirements: *mut VkMemoryRequirements) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageMemoryRequirements.html>
	fn vkGetImageMemoryRequirements(&self, device: VkDevice, image: VkImage, pMemoryRequirements: *mut VkMemoryRequirements) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSparseMemoryRequirements.html>
	fn vkGetImageSparseMemoryRequirements(&self, device: VkDevice, image: VkImage, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSparseImageFormatProperties.html>
	fn vkGetPhysicalDeviceSparseImageFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueBindSparse.html>
	fn vkQueueBindSparse(&self, queue: VkQueue, bindInfoCount: u32, pBindInfo: *const VkBindSparseInfo, fence: VkFence) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateFence.html>
	fn vkCreateFence(&self, device: VkDevice, pCreateInfo: *const VkFenceCreateInfo, pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyFence.html>
	fn vkDestroyFence(&self, device: VkDevice, fence: VkFence, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetFences.html>
	fn vkResetFences(&self, device: VkDevice, fenceCount: u32, pFences: *const VkFence) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetFenceStatus.html>
	fn vkGetFenceStatus(&self, device: VkDevice, fence: VkFence) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitForFences.html>
	fn vkWaitForFences(&self, device: VkDevice, fenceCount: u32, pFences: *const VkFence, waitAll: VkBool32, timeout: u64) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSemaphore.html>
	fn vkCreateSemaphore(&self, device: VkDevice, pCreateInfo: *const VkSemaphoreCreateInfo, pAllocator: *const VkAllocationCallbacks, pSemaphore: *mut VkSemaphore) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySemaphore.html>
	fn vkDestroySemaphore(&self, device: VkDevice, semaphore: VkSemaphore, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateEvent.html>
	fn vkCreateEvent(&self, device: VkDevice, pCreateInfo: *const VkEventCreateInfo, pAllocator: *const VkAllocationCallbacks, pEvent: *mut VkEvent) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyEvent.html>
	fn vkDestroyEvent(&self, device: VkDevice, event: VkEvent, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetEventStatus.html>
	fn vkGetEventStatus(&self, device: VkDevice, event: VkEvent) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetEvent.html>
	fn vkSetEvent(&self, device: VkDevice, event: VkEvent) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetEvent.html>
	fn vkResetEvent(&self, device: VkDevice, event: VkEvent) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateQueryPool.html>
	fn vkCreateQueryPool(&self, device: VkDevice, pCreateInfo: *const VkQueryPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pQueryPool: *mut VkQueryPool) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyQueryPool.html>
	fn vkDestroyQueryPool(&self, device: VkDevice, queryPool: VkQueryPool, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetQueryPoolResults.html>
	fn vkGetQueryPoolResults(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dataSize: usize, pData: *mut c_void, stride: VkDeviceSize, flags: VkQueryResultFlags) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateBuffer.html>
	fn vkCreateBuffer(&self, device: VkDevice, pCreateInfo: *const VkBufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pBuffer: *mut VkBuffer) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyBuffer.html>
	fn vkDestroyBuffer(&self, device: VkDevice, buffer: VkBuffer, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateBufferView.html>
	fn vkCreateBufferView(&self, device: VkDevice, pCreateInfo: *const VkBufferViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkBufferView) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyBufferView.html>
	fn vkDestroyBufferView(&self, device: VkDevice, bufferView: VkBufferView, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateImage.html>
	fn vkCreateImage(&self, device: VkDevice, pCreateInfo: *const VkImageCreateInfo, pAllocator: *const VkAllocationCallbacks, pImage: *mut VkImage) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyImage.html>
	fn vkDestroyImage(&self, device: VkDevice, image: VkImage, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout.html>
	fn vkGetImageSubresourceLayout(&self, device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource, pLayout: *mut VkSubresourceLayout) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateImageView.html>
	fn vkCreateImageView(&self, device: VkDevice, pCreateInfo: *const VkImageViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkImageView) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyImageView.html>
	fn vkDestroyImageView(&self, device: VkDevice, imageView: VkImageView, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateShaderModule.html>
	fn vkCreateShaderModule(&self, device: VkDevice, pCreateInfo: *const VkShaderModuleCreateInfo, pAllocator: *const VkAllocationCallbacks, pShaderModule: *mut VkShaderModule) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyShaderModule.html>
	fn vkDestroyShaderModule(&self, device: VkDevice, shaderModule: VkShaderModule, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineCache.html>
	fn vkCreatePipelineCache(&self, device: VkDevice, pCreateInfo: *const VkPipelineCacheCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineCache: *mut VkPipelineCache) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineCache.html>
	fn vkDestroyPipelineCache(&self, device: VkDevice, pipelineCache: VkPipelineCache, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineCacheData.html>
	fn vkGetPipelineCacheData(&self, device: VkDevice, pipelineCache: VkPipelineCache, pDataSize: *mut size_t, pData: *mut c_void) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkMergePipelineCaches.html>
	fn vkMergePipelineCaches(&self, device: VkDevice, dstCache: VkPipelineCache, srcCacheCount: u32, pSrcCaches: *const VkPipelineCache) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateGraphicsPipelines.html>
	fn vkCreateGraphicsPipelines(&self, device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkGraphicsPipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateComputePipelines.html>
	fn vkCreateComputePipelines(&self, device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkComputePipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipeline.html>
	fn vkDestroyPipeline(&self, device: VkDevice, pipeline: VkPipeline, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineLayout.html>
	fn vkCreatePipelineLayout(&self, device: VkDevice, pCreateInfo: *const VkPipelineLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineLayout: *mut VkPipelineLayout) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineLayout.html>
	fn vkDestroyPipelineLayout(&self, device: VkDevice, pipelineLayout: VkPipelineLayout, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSampler.html>
	fn vkCreateSampler(&self, device: VkDevice, pCreateInfo: *const VkSamplerCreateInfo, pAllocator: *const VkAllocationCallbacks, pSampler: *mut VkSampler) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySampler.html>
	fn vkDestroySampler(&self, device: VkDevice, sampler: VkSampler, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorSetLayout.html>
	fn vkCreateDescriptorSetLayout(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pSetLayout: *mut VkDescriptorSetLayout) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorSetLayout.html>
	fn vkDestroyDescriptorSetLayout(&self, device: VkDevice, descriptorSetLayout: VkDescriptorSetLayout, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorPool.html>
	fn vkCreateDescriptorPool(&self, device: VkDevice, pCreateInfo: *const VkDescriptorPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorPool: *mut VkDescriptorPool) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorPool.html>
	fn vkDestroyDescriptorPool(&self, device: VkDevice, descriptorPool: VkDescriptorPool, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetDescriptorPool.html>
	fn vkResetDescriptorPool(&self, device: VkDevice, descriptorPool: VkDescriptorPool, flags: VkDescriptorPoolResetFlags) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateDescriptorSets.html>
	fn vkAllocateDescriptorSets(&self, device: VkDevice, pAllocateInfo: *const VkDescriptorSetAllocateInfo, pDescriptorSets: *mut VkDescriptorSet) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeDescriptorSets.html>
	fn vkFreeDescriptorSets(&self, device: VkDevice, descriptorPool: VkDescriptorPool, descriptorSetCount: u32, pDescriptorSets: *const VkDescriptorSet) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSets.html>
	fn vkUpdateDescriptorSets(&self, device: VkDevice, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: *const VkCopyDescriptorSet) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateFramebuffer.html>
	fn vkCreateFramebuffer(&self, device: VkDevice, pCreateInfo: *const VkFramebufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pFramebuffer: *mut VkFramebuffer) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyFramebuffer.html>
	fn vkDestroyFramebuffer(&self, device: VkDevice, framebuffer: VkFramebuffer, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRenderPass.html>
	fn vkCreateRenderPass(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyRenderPass.html>
	fn vkDestroyRenderPass(&self, device: VkDevice, renderPass: VkRenderPass, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRenderAreaGranularity.html>
	fn vkGetRenderAreaGranularity(&self, device: VkDevice, renderPass: VkRenderPass, pGranularity: *mut VkExtent2D) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCommandPool.html>
	fn vkCreateCommandPool(&self, device: VkDevice, pCreateInfo: *const VkCommandPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pCommandPool: *mut VkCommandPool) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCommandPool.html>
	fn vkDestroyCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetCommandPool.html>
	fn vkResetCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolResetFlags) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateCommandBuffers.html>
	fn vkAllocateCommandBuffers(&self, device: VkDevice, pAllocateInfo: *const VkCommandBufferAllocateInfo, pCommandBuffers: *mut VkCommandBuffer) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeCommandBuffers.html>
	fn vkFreeCommandBuffers(&self, device: VkDevice, commandPool: VkCommandPool, commandBufferCount: u32, pCommandBuffers: *const VkCommandBuffer) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBeginCommandBuffer.html>
	fn vkBeginCommandBuffer(&self, commandBuffer: VkCommandBuffer, pBeginInfo: *const VkCommandBufferBeginInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEndCommandBuffer.html>
	fn vkEndCommandBuffer(&self, commandBuffer: VkCommandBuffer) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetCommandBuffer.html>
	fn vkResetCommandBuffer(&self, commandBuffer: VkCommandBuffer, flags: VkCommandBufferResetFlags) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindPipeline.html>
	fn vkCmdBindPipeline(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewport.html>
	fn vkCmdSetViewport(&self, commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: *const VkViewport) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetScissor.html>
	fn vkCmdSetScissor(&self, commandBuffer: VkCommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: *const VkRect2D) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLineWidth.html>
	fn vkCmdSetLineWidth(&self, commandBuffer: VkCommandBuffer, lineWidth: f32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBias.html>
	fn vkCmdSetDepthBias(&self, commandBuffer: VkCommandBuffer, depthBiasConstantFactor: f32, depthBiasClamp: f32, depthBiasSlopeFactor: f32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetBlendConstants.html>
	fn vkCmdSetBlendConstants(&self, commandBuffer: VkCommandBuffer, blendConstants: &[float; 4 as usize]) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBounds.html>
	fn vkCmdSetDepthBounds(&self, commandBuffer: VkCommandBuffer, minDepthBounds: f32, maxDepthBounds: f32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilCompareMask.html>
	fn vkCmdSetStencilCompareMask(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, compareMask: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilWriteMask.html>
	fn vkCmdSetStencilWriteMask(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, writeMask: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilReference.html>
	fn vkCmdSetStencilReference(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, reference: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorSets.html>
	fn vkCmdBindDescriptorSets(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: *const VkDescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: *const uint32_t) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindIndexBuffer.html>
	fn vkCmdBindIndexBuffer(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, indexType: VkIndexType) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindVertexBuffers.html>
	fn vkCmdBindVertexBuffers(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDraw.html>
	fn vkCmdDraw(&self, commandBuffer: VkCommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexed.html>
	fn vkCmdDrawIndexed(&self, commandBuffer: VkCommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: i32, firstInstance: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndirect.html>
	fn vkCmdDrawIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexedIndirect.html>
	fn vkCmdDrawIndexedIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatch.html>
	fn vkCmdDispatch(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchIndirect.html>
	fn vkCmdDispatchIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBuffer.html>
	fn vkCmdCopyBuffer(&self, commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstBuffer: VkBuffer, regionCount: u32, pRegions: *const VkBufferCopy) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImage.html>
	fn vkCmdCopyImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageCopy) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage.html>
	fn vkCmdBlitImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageBlit, filter: VkFilter) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage.html>
	fn vkCmdCopyBufferToImage(&self, commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkBufferImageCopy) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer.html>
	fn vkCmdCopyImageToBuffer(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstBuffer: VkBuffer, regionCount: u32, pRegions: *const VkBufferImageCopy) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdUpdateBuffer.html>
	fn vkCmdUpdateBuffer(&self, commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, dataSize: VkDeviceSize, pData: *const c_void) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdFillBuffer.html>
	fn vkCmdFillBuffer(&self, commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, size: VkDeviceSize, data: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdClearColorImage.html>
	fn vkCmdClearColorImage(&self, commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pColor: *const VkClearColorValue, rangeCount: u32, pRanges: *const VkImageSubresourceRange) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdClearDepthStencilImage.html>
	fn vkCmdClearDepthStencilImage(&self, commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pDepthStencil: *const VkClearDepthStencilValue, rangeCount: u32, pRanges: *const VkImageSubresourceRange) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdClearAttachments.html>
	fn vkCmdClearAttachments(&self, commandBuffer: VkCommandBuffer, attachmentCount: u32, pAttachments: *const VkClearAttachment, rectCount: u32, pRects: *const VkClearRect) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResolveImage.html>
	fn vkCmdResolveImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageResolve) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetEvent.html>
	fn vkCmdSetEvent(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResetEvent.html>
	fn vkCmdResetEvent(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWaitEvents.html>
	fn vkCmdWaitEvents(&self, commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const VkImageMemoryBarrier) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPipelineBarrier.html>
	fn vkCmdPipelineBarrier(&self, commandBuffer: VkCommandBuffer, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, dependencyFlags: VkDependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const VkImageMemoryBarrier) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginQuery.html>
	fn vkCmdBeginQuery(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndQuery.html>
	fn vkCmdEndQuery(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResetQueryPool.html>
	fn vkCmdResetQueryPool(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteTimestamp.html>
	fn vkCmdWriteTimestamp(&self, commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, queryPool: VkQueryPool, query: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyQueryPoolResults.html>
	fn vkCmdCopyQueryPoolResults(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, stride: VkDeviceSize, flags: VkQueryResultFlags) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushConstants.html>
	fn vkCmdPushConstants(&self, commandBuffer: VkCommandBuffer, layout: VkPipelineLayout, stageFlags: VkShaderStageFlags, offset: u32, size: u32, pValues: *const c_void) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderPass.html>
	fn vkCmdBeginRenderPass(&self, commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, contents: VkSubpassContents) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdNextSubpass.html>
	fn vkCmdNextSubpass(&self, commandBuffer: VkCommandBuffer, contents: VkSubpassContents) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRenderPass.html>
	fn vkCmdEndRenderPass(&self, commandBuffer: VkCommandBuffer) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdExecuteCommands.html>
	fn vkCmdExecuteCommands(&self, commandBuffer: VkCommandBuffer, commandBufferCount: u32, pCommandBuffers: *const VkCommandBuffer) -> Result<()>;
}
/// struct for `VK_VERSION_1_0`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_VERSION_1_0 {
	vk_create_instance: PFN_vkCreateInstance,
	vk_destroy_instance: PFN_vkDestroyInstance,
	vk_enumerate_physical_devices: PFN_vkEnumeratePhysicalDevices,
	vk_get_physical_device_features: PFN_vkGetPhysicalDeviceFeatures,
	vk_get_physical_device_format_properties: PFN_vkGetPhysicalDeviceFormatProperties,
	vk_get_physical_device_image_format_properties: PFN_vkGetPhysicalDeviceImageFormatProperties,
	vk_get_physical_device_properties: PFN_vkGetPhysicalDeviceProperties,
	vk_get_physical_device_queue_family_properties: PFN_vkGetPhysicalDeviceQueueFamilyProperties,
	vk_get_physical_device_memory_properties: PFN_vkGetPhysicalDeviceMemoryProperties,
	vk_get_instance_proc_addr: PFN_vkGetInstanceProcAddr,
	vk_get_device_proc_addr: PFN_vkGetDeviceProcAddr,
	vk_create_device: PFN_vkCreateDevice,
	vk_destroy_device: PFN_vkDestroyDevice,
	vk_enumerate_instance_extension_properties: PFN_vkEnumerateInstanceExtensionProperties,
	vk_enumerate_device_extension_properties: PFN_vkEnumerateDeviceExtensionProperties,
	vk_enumerate_instance_layer_properties: PFN_vkEnumerateInstanceLayerProperties,
	vk_enumerate_device_layer_properties: PFN_vkEnumerateDeviceLayerProperties,
	vk_get_device_queue: PFN_vkGetDeviceQueue,
	vk_queue_submit: PFN_vkQueueSubmit,
	vk_queue_wait_idle: PFN_vkQueueWaitIdle,
	vk_device_wait_idle: PFN_vkDeviceWaitIdle,
	vk_allocate_memory: PFN_vkAllocateMemory,
	vk_free_memory: PFN_vkFreeMemory,
	vk_map_memory: PFN_vkMapMemory,
	vk_unmap_memory: PFN_vkUnmapMemory,
	vk_flush_mapped_memory_ranges: PFN_vkFlushMappedMemoryRanges,
	vk_invalidate_mapped_memory_ranges: PFN_vkInvalidateMappedMemoryRanges,
	vk_get_device_memory_commitment: PFN_vkGetDeviceMemoryCommitment,
	vk_bind_buffer_memory: PFN_vkBindBufferMemory,
	vk_bind_image_memory: PFN_vkBindImageMemory,
	vk_get_buffer_memory_requirements: PFN_vkGetBufferMemoryRequirements,
	vk_get_image_memory_requirements: PFN_vkGetImageMemoryRequirements,
	vk_get_image_sparse_memory_requirements: PFN_vkGetImageSparseMemoryRequirements,
	vk_get_physical_device_sparse_image_format_properties: PFN_vkGetPhysicalDeviceSparseImageFormatProperties,
	vk_queue_bind_sparse: PFN_vkQueueBindSparse,
	vk_create_fence: PFN_vkCreateFence,
	vk_destroy_fence: PFN_vkDestroyFence,
	vk_reset_fences: PFN_vkResetFences,
	vk_get_fence_status: PFN_vkGetFenceStatus,
	vk_wait_for_fences: PFN_vkWaitForFences,
	vk_create_semaphore: PFN_vkCreateSemaphore,
	vk_destroy_semaphore: PFN_vkDestroySemaphore,
	vk_create_event: PFN_vkCreateEvent,
	vk_destroy_event: PFN_vkDestroyEvent,
	vk_get_event_status: PFN_vkGetEventStatus,
	vk_set_event: PFN_vkSetEvent,
	vk_reset_event: PFN_vkResetEvent,
	vk_create_query_pool: PFN_vkCreateQueryPool,
	vk_destroy_query_pool: PFN_vkDestroyQueryPool,
	vk_get_query_pool_results: PFN_vkGetQueryPoolResults,
	vk_create_buffer: PFN_vkCreateBuffer,
	vk_destroy_buffer: PFN_vkDestroyBuffer,
	vk_create_buffer_view: PFN_vkCreateBufferView,
	vk_destroy_buffer_view: PFN_vkDestroyBufferView,
	vk_create_image: PFN_vkCreateImage,
	vk_destroy_image: PFN_vkDestroyImage,
	vk_get_image_subresource_layout: PFN_vkGetImageSubresourceLayout,
	vk_create_image_view: PFN_vkCreateImageView,
	vk_destroy_image_view: PFN_vkDestroyImageView,
	vk_create_shader_module: PFN_vkCreateShaderModule,
	vk_destroy_shader_module: PFN_vkDestroyShaderModule,
	vk_create_pipeline_cache: PFN_vkCreatePipelineCache,
	vk_destroy_pipeline_cache: PFN_vkDestroyPipelineCache,
	vk_get_pipeline_cache_data: PFN_vkGetPipelineCacheData,
	vk_merge_pipeline_caches: PFN_vkMergePipelineCaches,
	vk_create_graphics_pipelines: PFN_vkCreateGraphicsPipelines,
	vk_create_compute_pipelines: PFN_vkCreateComputePipelines,
	vk_destroy_pipeline: PFN_vkDestroyPipeline,
	vk_create_pipeline_layout: PFN_vkCreatePipelineLayout,
	vk_destroy_pipeline_layout: PFN_vkDestroyPipelineLayout,
	vk_create_sampler: PFN_vkCreateSampler,
	vk_destroy_sampler: PFN_vkDestroySampler,
	vk_create_descriptor_set_layout: PFN_vkCreateDescriptorSetLayout,
	vk_destroy_descriptor_set_layout: PFN_vkDestroyDescriptorSetLayout,
	vk_create_descriptor_pool: PFN_vkCreateDescriptorPool,
	vk_destroy_descriptor_pool: PFN_vkDestroyDescriptorPool,
	vk_reset_descriptor_pool: PFN_vkResetDescriptorPool,
	vk_allocate_descriptor_sets: PFN_vkAllocateDescriptorSets,
	vk_free_descriptor_sets: PFN_vkFreeDescriptorSets,
	vk_update_descriptor_sets: PFN_vkUpdateDescriptorSets,
	vk_create_framebuffer: PFN_vkCreateFramebuffer,
	vk_destroy_framebuffer: PFN_vkDestroyFramebuffer,
	vk_create_render_pass: PFN_vkCreateRenderPass,
	vk_destroy_render_pass: PFN_vkDestroyRenderPass,
	vk_get_render_area_granularity: PFN_vkGetRenderAreaGranularity,
	vk_create_command_pool: PFN_vkCreateCommandPool,
	vk_destroy_command_pool: PFN_vkDestroyCommandPool,
	vk_reset_command_pool: PFN_vkResetCommandPool,
	vk_allocate_command_buffers: PFN_vkAllocateCommandBuffers,
	vk_free_command_buffers: PFN_vkFreeCommandBuffers,
	vk_begin_command_buffer: PFN_vkBeginCommandBuffer,
	vk_end_command_buffer: PFN_vkEndCommandBuffer,
	vk_reset_command_buffer: PFN_vkResetCommandBuffer,
	vk_cmd_bind_pipeline: PFN_vkCmdBindPipeline,
	vk_cmd_set_viewport: PFN_vkCmdSetViewport,
	vk_cmd_set_scissor: PFN_vkCmdSetScissor,
	vk_cmd_set_line_width: PFN_vkCmdSetLineWidth,
	vk_cmd_set_depth_bias: PFN_vkCmdSetDepthBias,
	vk_cmd_set_blend_constants: PFN_vkCmdSetBlendConstants,
	vk_cmd_set_depth_bounds: PFN_vkCmdSetDepthBounds,
	vk_cmd_set_stencil_compare_mask: PFN_vkCmdSetStencilCompareMask,
	vk_cmd_set_stencil_write_mask: PFN_vkCmdSetStencilWriteMask,
	vk_cmd_set_stencil_reference: PFN_vkCmdSetStencilReference,
	vk_cmd_bind_descriptor_sets: PFN_vkCmdBindDescriptorSets,
	vk_cmd_bind_index_buffer: PFN_vkCmdBindIndexBuffer,
	vk_cmd_bind_vertex_buffers: PFN_vkCmdBindVertexBuffers,
	vk_cmd_draw: PFN_vkCmdDraw,
	vk_cmd_draw_indexed: PFN_vkCmdDrawIndexed,
	vk_cmd_draw_indirect: PFN_vkCmdDrawIndirect,
	vk_cmd_draw_indexed_indirect: PFN_vkCmdDrawIndexedIndirect,
	vk_cmd_dispatch: PFN_vkCmdDispatch,
	vk_cmd_dispatch_indirect: PFN_vkCmdDispatchIndirect,
	vk_cmd_copy_buffer: PFN_vkCmdCopyBuffer,
	vk_cmd_copy_image: PFN_vkCmdCopyImage,
	vk_cmd_blit_image: PFN_vkCmdBlitImage,
	vk_cmd_copy_buffer_to_image: PFN_vkCmdCopyBufferToImage,
	vk_cmd_copy_image_to_buffer: PFN_vkCmdCopyImageToBuffer,
	vk_cmd_update_buffer: PFN_vkCmdUpdateBuffer,
	vk_cmd_fill_buffer: PFN_vkCmdFillBuffer,
	vk_cmd_clear_color_image: PFN_vkCmdClearColorImage,
	vk_cmd_clear_depth_stencil_image: PFN_vkCmdClearDepthStencilImage,
	vk_cmd_clear_attachments: PFN_vkCmdClearAttachments,
	vk_cmd_resolve_image: PFN_vkCmdResolveImage,
	vk_cmd_set_event: PFN_vkCmdSetEvent,
	vk_cmd_reset_event: PFN_vkCmdResetEvent,
	vk_cmd_wait_events: PFN_vkCmdWaitEvents,
	vk_cmd_pipeline_barrier: PFN_vkCmdPipelineBarrier,
	vk_cmd_begin_query: PFN_vkCmdBeginQuery,
	vk_cmd_end_query: PFN_vkCmdEndQuery,
	vk_cmd_reset_query_pool: PFN_vkCmdResetQueryPool,
	vk_cmd_write_timestamp: PFN_vkCmdWriteTimestamp,
	vk_cmd_copy_query_pool_results: PFN_vkCmdCopyQueryPoolResults,
	vk_cmd_push_constants: PFN_vkCmdPushConstants,
	vk_cmd_begin_render_pass: PFN_vkCmdBeginRenderPass,
	vk_cmd_next_subpass: PFN_vkCmdNextSubpass,
	vk_cmd_end_render_pass: PFN_vkCmdEndRenderPass,
	vk_cmd_execute_commands: PFN_vkCmdExecuteCommands,
}
impl VK_VERSION_1_0 for Vulkan_VERSION_1_0 {
	fn vkCreateInstance(&self, pCreateInfo: *const VkInstanceCreateInfo, pAllocator: *const VkAllocationCallbacks, pInstance: *mut VkInstance) -> Result<()> {
		convert_result("vkCreateInstance", catch_unwind(||((self.vk_create_instance)(pCreateInfo, pAllocator, pInstance))))
	}
	fn vkDestroyInstance(&self, instance: VkInstance, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_instance)(instance, pAllocator))))
	}
	fn vkEnumeratePhysicalDevices(&self, instance: VkInstance, pPhysicalDeviceCount: *mut uint32_t, pPhysicalDevices: *mut VkPhysicalDevice) -> Result<()> {
		convert_result("vkEnumeratePhysicalDevices", catch_unwind(||((self.vk_enumerate_physical_devices)(instance, pPhysicalDeviceCount, pPhysicalDevices))))
	}
	fn vkGetPhysicalDeviceFeatures(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_features)(physicalDevice, pFeatures))))
	}
	fn vkGetPhysicalDeviceFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_format_properties)(physicalDevice, format, pFormatProperties))))
	}
	fn vkGetPhysicalDeviceImageFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, pImageFormatProperties: *mut VkImageFormatProperties) -> Result<()> {
		convert_result("vkGetPhysicalDeviceImageFormatProperties", catch_unwind(||((self.vk_get_physical_device_image_format_properties)(physicalDevice, format, type_, tiling, usage, flags, pImageFormatProperties))))
	}
	fn vkGetPhysicalDeviceProperties(&self, physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_properties)(physicalDevice, pProperties))))
	}
	fn vkGetPhysicalDeviceQueueFamilyProperties(&self, physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_queue_family_properties)(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties))))
	}
	fn vkGetPhysicalDeviceMemoryProperties(&self, physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_memory_properties)(physicalDevice, pMemoryProperties))))
	}
	fn vkGetInstanceProcAddr(&self, instance: VkInstance, pName: *const i8) -> Result<PFN_vkVoidFunction> {
		process_catch(catch_unwind(||((self.vk_get_instance_proc_addr)(instance, pName))))
	}
	fn vkGetDeviceProcAddr(&self, device: VkDevice, pName: *const i8) -> Result<PFN_vkVoidFunction> {
		process_catch(catch_unwind(||((self.vk_get_device_proc_addr)(device, pName))))
	}
	fn vkCreateDevice(&self, physicalDevice: VkPhysicalDevice, pCreateInfo: *const VkDeviceCreateInfo, pAllocator: *const VkAllocationCallbacks, pDevice: *mut VkDevice) -> Result<()> {
		convert_result("vkCreateDevice", catch_unwind(||((self.vk_create_device)(physicalDevice, pCreateInfo, pAllocator, pDevice))))
	}
	fn vkDestroyDevice(&self, device: VkDevice, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_device)(device, pAllocator))))
	}
	fn vkEnumerateInstanceExtensionProperties(&self, pLayerName: *const i8, pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> Result<()> {
		convert_result("vkEnumerateInstanceExtensionProperties", catch_unwind(||((self.vk_enumerate_instance_extension_properties)(pLayerName, pPropertyCount, pProperties))))
	}
	fn vkEnumerateDeviceExtensionProperties(&self, physicalDevice: VkPhysicalDevice, pLayerName: *const i8, pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> Result<()> {
		convert_result("vkEnumerateDeviceExtensionProperties", catch_unwind(||((self.vk_enumerate_device_extension_properties)(physicalDevice, pLayerName, pPropertyCount, pProperties))))
	}
	fn vkEnumerateInstanceLayerProperties(&self, pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> Result<()> {
		convert_result("vkEnumerateInstanceLayerProperties", catch_unwind(||((self.vk_enumerate_instance_layer_properties)(pPropertyCount, pProperties))))
	}
	fn vkEnumerateDeviceLayerProperties(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> Result<()> {
		convert_result("vkEnumerateDeviceLayerProperties", catch_unwind(||((self.vk_enumerate_device_layer_properties)(physicalDevice, pPropertyCount, pProperties))))
	}
	fn vkGetDeviceQueue(&self, device: VkDevice, queueFamilyIndex: u32, queueIndex: u32, pQueue: *mut VkQueue) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_device_queue)(device, queueFamilyIndex, queueIndex, pQueue))))
	}
	fn vkQueueSubmit(&self, queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo, fence: VkFence) -> Result<()> {
		convert_result("vkQueueSubmit", catch_unwind(||((self.vk_queue_submit)(queue, submitCount, pSubmits, fence))))
	}
	fn vkQueueWaitIdle(&self, queue: VkQueue) -> Result<()> {
		convert_result("vkQueueWaitIdle", catch_unwind(||((self.vk_queue_wait_idle)(queue))))
	}
	fn vkDeviceWaitIdle(&self, device: VkDevice) -> Result<()> {
		convert_result("vkDeviceWaitIdle", catch_unwind(||((self.vk_device_wait_idle)(device))))
	}
	fn vkAllocateMemory(&self, device: VkDevice, pAllocateInfo: *const VkMemoryAllocateInfo, pAllocator: *const VkAllocationCallbacks, pMemory: *mut VkDeviceMemory) -> Result<()> {
		convert_result("vkAllocateMemory", catch_unwind(||((self.vk_allocate_memory)(device, pAllocateInfo, pAllocator, pMemory))))
	}
	fn vkFreeMemory(&self, device: VkDevice, memory: VkDeviceMemory, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_free_memory)(device, memory, pAllocator))))
	}
	fn vkMapMemory(&self, device: VkDevice, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize, flags: VkMemoryMapFlags, ppData: *mut *mut c_void) -> Result<()> {
		convert_result("vkMapMemory", catch_unwind(||((self.vk_map_memory)(device, memory, offset, size, flags, ppData))))
	}
	fn vkUnmapMemory(&self, device: VkDevice, memory: VkDeviceMemory) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_unmap_memory)(device, memory))))
	}
	fn vkFlushMappedMemoryRanges(&self, device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *const VkMappedMemoryRange) -> Result<()> {
		convert_result("vkFlushMappedMemoryRanges", catch_unwind(||((self.vk_flush_mapped_memory_ranges)(device, memoryRangeCount, pMemoryRanges))))
	}
	fn vkInvalidateMappedMemoryRanges(&self, device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *const VkMappedMemoryRange) -> Result<()> {
		convert_result("vkInvalidateMappedMemoryRanges", catch_unwind(||((self.vk_invalidate_mapped_memory_ranges)(device, memoryRangeCount, pMemoryRanges))))
	}
	fn vkGetDeviceMemoryCommitment(&self, device: VkDevice, memory: VkDeviceMemory, pCommittedMemoryInBytes: *mut VkDeviceSize) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_device_memory_commitment)(device, memory, pCommittedMemoryInBytes))))
	}
	fn vkBindBufferMemory(&self, device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> Result<()> {
		convert_result("vkBindBufferMemory", catch_unwind(||((self.vk_bind_buffer_memory)(device, buffer, memory, memoryOffset))))
	}
	fn vkBindImageMemory(&self, device: VkDevice, image: VkImage, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> Result<()> {
		convert_result("vkBindImageMemory", catch_unwind(||((self.vk_bind_image_memory)(device, image, memory, memoryOffset))))
	}
	fn vkGetBufferMemoryRequirements(&self, device: VkDevice, buffer: VkBuffer, pMemoryRequirements: *mut VkMemoryRequirements) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_buffer_memory_requirements)(device, buffer, pMemoryRequirements))))
	}
	fn vkGetImageMemoryRequirements(&self, device: VkDevice, image: VkImage, pMemoryRequirements: *mut VkMemoryRequirements) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_image_memory_requirements)(device, image, pMemoryRequirements))))
	}
	fn vkGetImageSparseMemoryRequirements(&self, device: VkDevice, image: VkImage, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_image_sparse_memory_requirements)(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements))))
	}
	fn vkGetPhysicalDeviceSparseImageFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_sparse_image_format_properties)(physicalDevice, format, type_, samples, usage, tiling, pPropertyCount, pProperties))))
	}
	fn vkQueueBindSparse(&self, queue: VkQueue, bindInfoCount: u32, pBindInfo: *const VkBindSparseInfo, fence: VkFence) -> Result<()> {
		convert_result("vkQueueBindSparse", catch_unwind(||((self.vk_queue_bind_sparse)(queue, bindInfoCount, pBindInfo, fence))))
	}
	fn vkCreateFence(&self, device: VkDevice, pCreateInfo: *const VkFenceCreateInfo, pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence) -> Result<()> {
		convert_result("vkCreateFence", catch_unwind(||((self.vk_create_fence)(device, pCreateInfo, pAllocator, pFence))))
	}
	fn vkDestroyFence(&self, device: VkDevice, fence: VkFence, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_fence)(device, fence, pAllocator))))
	}
	fn vkResetFences(&self, device: VkDevice, fenceCount: u32, pFences: *const VkFence) -> Result<()> {
		convert_result("vkResetFences", catch_unwind(||((self.vk_reset_fences)(device, fenceCount, pFences))))
	}
	fn vkGetFenceStatus(&self, device: VkDevice, fence: VkFence) -> Result<()> {
		convert_result("vkGetFenceStatus", catch_unwind(||((self.vk_get_fence_status)(device, fence))))
	}
	fn vkWaitForFences(&self, device: VkDevice, fenceCount: u32, pFences: *const VkFence, waitAll: VkBool32, timeout: u64) -> Result<()> {
		convert_result("vkWaitForFences", catch_unwind(||((self.vk_wait_for_fences)(device, fenceCount, pFences, waitAll, timeout))))
	}
	fn vkCreateSemaphore(&self, device: VkDevice, pCreateInfo: *const VkSemaphoreCreateInfo, pAllocator: *const VkAllocationCallbacks, pSemaphore: *mut VkSemaphore) -> Result<()> {
		convert_result("vkCreateSemaphore", catch_unwind(||((self.vk_create_semaphore)(device, pCreateInfo, pAllocator, pSemaphore))))
	}
	fn vkDestroySemaphore(&self, device: VkDevice, semaphore: VkSemaphore, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_semaphore)(device, semaphore, pAllocator))))
	}
	fn vkCreateEvent(&self, device: VkDevice, pCreateInfo: *const VkEventCreateInfo, pAllocator: *const VkAllocationCallbacks, pEvent: *mut VkEvent) -> Result<()> {
		convert_result("vkCreateEvent", catch_unwind(||((self.vk_create_event)(device, pCreateInfo, pAllocator, pEvent))))
	}
	fn vkDestroyEvent(&self, device: VkDevice, event: VkEvent, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_event)(device, event, pAllocator))))
	}
	fn vkGetEventStatus(&self, device: VkDevice, event: VkEvent) -> Result<()> {
		convert_result("vkGetEventStatus", catch_unwind(||((self.vk_get_event_status)(device, event))))
	}
	fn vkSetEvent(&self, device: VkDevice, event: VkEvent) -> Result<()> {
		convert_result("vkSetEvent", catch_unwind(||((self.vk_set_event)(device, event))))
	}
	fn vkResetEvent(&self, device: VkDevice, event: VkEvent) -> Result<()> {
		convert_result("vkResetEvent", catch_unwind(||((self.vk_reset_event)(device, event))))
	}
	fn vkCreateQueryPool(&self, device: VkDevice, pCreateInfo: *const VkQueryPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pQueryPool: *mut VkQueryPool) -> Result<()> {
		convert_result("vkCreateQueryPool", catch_unwind(||((self.vk_create_query_pool)(device, pCreateInfo, pAllocator, pQueryPool))))
	}
	fn vkDestroyQueryPool(&self, device: VkDevice, queryPool: VkQueryPool, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_query_pool)(device, queryPool, pAllocator))))
	}
	fn vkGetQueryPoolResults(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dataSize: usize, pData: *mut c_void, stride: VkDeviceSize, flags: VkQueryResultFlags) -> Result<()> {
		convert_result("vkGetQueryPoolResults", catch_unwind(||((self.vk_get_query_pool_results)(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags))))
	}
	fn vkCreateBuffer(&self, device: VkDevice, pCreateInfo: *const VkBufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pBuffer: *mut VkBuffer) -> Result<()> {
		convert_result("vkCreateBuffer", catch_unwind(||((self.vk_create_buffer)(device, pCreateInfo, pAllocator, pBuffer))))
	}
	fn vkDestroyBuffer(&self, device: VkDevice, buffer: VkBuffer, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_buffer)(device, buffer, pAllocator))))
	}
	fn vkCreateBufferView(&self, device: VkDevice, pCreateInfo: *const VkBufferViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkBufferView) -> Result<()> {
		convert_result("vkCreateBufferView", catch_unwind(||((self.vk_create_buffer_view)(device, pCreateInfo, pAllocator, pView))))
	}
	fn vkDestroyBufferView(&self, device: VkDevice, bufferView: VkBufferView, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_buffer_view)(device, bufferView, pAllocator))))
	}
	fn vkCreateImage(&self, device: VkDevice, pCreateInfo: *const VkImageCreateInfo, pAllocator: *const VkAllocationCallbacks, pImage: *mut VkImage) -> Result<()> {
		convert_result("vkCreateImage", catch_unwind(||((self.vk_create_image)(device, pCreateInfo, pAllocator, pImage))))
	}
	fn vkDestroyImage(&self, device: VkDevice, image: VkImage, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_image)(device, image, pAllocator))))
	}
	fn vkGetImageSubresourceLayout(&self, device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource, pLayout: *mut VkSubresourceLayout) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_image_subresource_layout)(device, image, pSubresource, pLayout))))
	}
	fn vkCreateImageView(&self, device: VkDevice, pCreateInfo: *const VkImageViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkImageView) -> Result<()> {
		convert_result("vkCreateImageView", catch_unwind(||((self.vk_create_image_view)(device, pCreateInfo, pAllocator, pView))))
	}
	fn vkDestroyImageView(&self, device: VkDevice, imageView: VkImageView, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_image_view)(device, imageView, pAllocator))))
	}
	fn vkCreateShaderModule(&self, device: VkDevice, pCreateInfo: *const VkShaderModuleCreateInfo, pAllocator: *const VkAllocationCallbacks, pShaderModule: *mut VkShaderModule) -> Result<()> {
		convert_result("vkCreateShaderModule", catch_unwind(||((self.vk_create_shader_module)(device, pCreateInfo, pAllocator, pShaderModule))))
	}
	fn vkDestroyShaderModule(&self, device: VkDevice, shaderModule: VkShaderModule, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_shader_module)(device, shaderModule, pAllocator))))
	}
	fn vkCreatePipelineCache(&self, device: VkDevice, pCreateInfo: *const VkPipelineCacheCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineCache: *mut VkPipelineCache) -> Result<()> {
		convert_result("vkCreatePipelineCache", catch_unwind(||((self.vk_create_pipeline_cache)(device, pCreateInfo, pAllocator, pPipelineCache))))
	}
	fn vkDestroyPipelineCache(&self, device: VkDevice, pipelineCache: VkPipelineCache, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_pipeline_cache)(device, pipelineCache, pAllocator))))
	}
	fn vkGetPipelineCacheData(&self, device: VkDevice, pipelineCache: VkPipelineCache, pDataSize: *mut size_t, pData: *mut c_void) -> Result<()> {
		convert_result("vkGetPipelineCacheData", catch_unwind(||((self.vk_get_pipeline_cache_data)(device, pipelineCache, pDataSize, pData))))
	}
	fn vkMergePipelineCaches(&self, device: VkDevice, dstCache: VkPipelineCache, srcCacheCount: u32, pSrcCaches: *const VkPipelineCache) -> Result<()> {
		convert_result("vkMergePipelineCaches", catch_unwind(||((self.vk_merge_pipeline_caches)(device, dstCache, srcCacheCount, pSrcCaches))))
	}
	fn vkCreateGraphicsPipelines(&self, device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkGraphicsPipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> Result<()> {
		convert_result("vkCreateGraphicsPipelines", catch_unwind(||((self.vk_create_graphics_pipelines)(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines))))
	}
	fn vkCreateComputePipelines(&self, device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkComputePipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> Result<()> {
		convert_result("vkCreateComputePipelines", catch_unwind(||((self.vk_create_compute_pipelines)(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines))))
	}
	fn vkDestroyPipeline(&self, device: VkDevice, pipeline: VkPipeline, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_pipeline)(device, pipeline, pAllocator))))
	}
	fn vkCreatePipelineLayout(&self, device: VkDevice, pCreateInfo: *const VkPipelineLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineLayout: *mut VkPipelineLayout) -> Result<()> {
		convert_result("vkCreatePipelineLayout", catch_unwind(||((self.vk_create_pipeline_layout)(device, pCreateInfo, pAllocator, pPipelineLayout))))
	}
	fn vkDestroyPipelineLayout(&self, device: VkDevice, pipelineLayout: VkPipelineLayout, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_pipeline_layout)(device, pipelineLayout, pAllocator))))
	}
	fn vkCreateSampler(&self, device: VkDevice, pCreateInfo: *const VkSamplerCreateInfo, pAllocator: *const VkAllocationCallbacks, pSampler: *mut VkSampler) -> Result<()> {
		convert_result("vkCreateSampler", catch_unwind(||((self.vk_create_sampler)(device, pCreateInfo, pAllocator, pSampler))))
	}
	fn vkDestroySampler(&self, device: VkDevice, sampler: VkSampler, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_sampler)(device, sampler, pAllocator))))
	}
	fn vkCreateDescriptorSetLayout(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pSetLayout: *mut VkDescriptorSetLayout) -> Result<()> {
		convert_result("vkCreateDescriptorSetLayout", catch_unwind(||((self.vk_create_descriptor_set_layout)(device, pCreateInfo, pAllocator, pSetLayout))))
	}
	fn vkDestroyDescriptorSetLayout(&self, device: VkDevice, descriptorSetLayout: VkDescriptorSetLayout, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_descriptor_set_layout)(device, descriptorSetLayout, pAllocator))))
	}
	fn vkCreateDescriptorPool(&self, device: VkDevice, pCreateInfo: *const VkDescriptorPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorPool: *mut VkDescriptorPool) -> Result<()> {
		convert_result("vkCreateDescriptorPool", catch_unwind(||((self.vk_create_descriptor_pool)(device, pCreateInfo, pAllocator, pDescriptorPool))))
	}
	fn vkDestroyDescriptorPool(&self, device: VkDevice, descriptorPool: VkDescriptorPool, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_descriptor_pool)(device, descriptorPool, pAllocator))))
	}
	fn vkResetDescriptorPool(&self, device: VkDevice, descriptorPool: VkDescriptorPool, flags: VkDescriptorPoolResetFlags) -> Result<()> {
		convert_result("vkResetDescriptorPool", catch_unwind(||((self.vk_reset_descriptor_pool)(device, descriptorPool, flags))))
	}
	fn vkAllocateDescriptorSets(&self, device: VkDevice, pAllocateInfo: *const VkDescriptorSetAllocateInfo, pDescriptorSets: *mut VkDescriptorSet) -> Result<()> {
		convert_result("vkAllocateDescriptorSets", catch_unwind(||((self.vk_allocate_descriptor_sets)(device, pAllocateInfo, pDescriptorSets))))
	}
	fn vkFreeDescriptorSets(&self, device: VkDevice, descriptorPool: VkDescriptorPool, descriptorSetCount: u32, pDescriptorSets: *const VkDescriptorSet) -> Result<()> {
		convert_result("vkFreeDescriptorSets", catch_unwind(||((self.vk_free_descriptor_sets)(device, descriptorPool, descriptorSetCount, pDescriptorSets))))
	}
	fn vkUpdateDescriptorSets(&self, device: VkDevice, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: *const VkCopyDescriptorSet) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_update_descriptor_sets)(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies))))
	}
	fn vkCreateFramebuffer(&self, device: VkDevice, pCreateInfo: *const VkFramebufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pFramebuffer: *mut VkFramebuffer) -> Result<()> {
		convert_result("vkCreateFramebuffer", catch_unwind(||((self.vk_create_framebuffer)(device, pCreateInfo, pAllocator, pFramebuffer))))
	}
	fn vkDestroyFramebuffer(&self, device: VkDevice, framebuffer: VkFramebuffer, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_framebuffer)(device, framebuffer, pAllocator))))
	}
	fn vkCreateRenderPass(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> Result<()> {
		convert_result("vkCreateRenderPass", catch_unwind(||((self.vk_create_render_pass)(device, pCreateInfo, pAllocator, pRenderPass))))
	}
	fn vkDestroyRenderPass(&self, device: VkDevice, renderPass: VkRenderPass, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_render_pass)(device, renderPass, pAllocator))))
	}
	fn vkGetRenderAreaGranularity(&self, device: VkDevice, renderPass: VkRenderPass, pGranularity: *mut VkExtent2D) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_render_area_granularity)(device, renderPass, pGranularity))))
	}
	fn vkCreateCommandPool(&self, device: VkDevice, pCreateInfo: *const VkCommandPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pCommandPool: *mut VkCommandPool) -> Result<()> {
		convert_result("vkCreateCommandPool", catch_unwind(||((self.vk_create_command_pool)(device, pCreateInfo, pAllocator, pCommandPool))))
	}
	fn vkDestroyCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_command_pool)(device, commandPool, pAllocator))))
	}
	fn vkResetCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolResetFlags) -> Result<()> {
		convert_result("vkResetCommandPool", catch_unwind(||((self.vk_reset_command_pool)(device, commandPool, flags))))
	}
	fn vkAllocateCommandBuffers(&self, device: VkDevice, pAllocateInfo: *const VkCommandBufferAllocateInfo, pCommandBuffers: *mut VkCommandBuffer) -> Result<()> {
		convert_result("vkAllocateCommandBuffers", catch_unwind(||((self.vk_allocate_command_buffers)(device, pAllocateInfo, pCommandBuffers))))
	}
	fn vkFreeCommandBuffers(&self, device: VkDevice, commandPool: VkCommandPool, commandBufferCount: u32, pCommandBuffers: *const VkCommandBuffer) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_free_command_buffers)(device, commandPool, commandBufferCount, pCommandBuffers))))
	}
	fn vkBeginCommandBuffer(&self, commandBuffer: VkCommandBuffer, pBeginInfo: *const VkCommandBufferBeginInfo) -> Result<()> {
		convert_result("vkBeginCommandBuffer", catch_unwind(||((self.vk_begin_command_buffer)(commandBuffer, pBeginInfo))))
	}
	fn vkEndCommandBuffer(&self, commandBuffer: VkCommandBuffer) -> Result<()> {
		convert_result("vkEndCommandBuffer", catch_unwind(||((self.vk_end_command_buffer)(commandBuffer))))
	}
	fn vkResetCommandBuffer(&self, commandBuffer: VkCommandBuffer, flags: VkCommandBufferResetFlags) -> Result<()> {
		convert_result("vkResetCommandBuffer", catch_unwind(||((self.vk_reset_command_buffer)(commandBuffer, flags))))
	}
	fn vkCmdBindPipeline(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_bind_pipeline)(commandBuffer, pipelineBindPoint, pipeline))))
	}
	fn vkCmdSetViewport(&self, commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: *const VkViewport) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_viewport)(commandBuffer, firstViewport, viewportCount, pViewports))))
	}
	fn vkCmdSetScissor(&self, commandBuffer: VkCommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: *const VkRect2D) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_scissor)(commandBuffer, firstScissor, scissorCount, pScissors))))
	}
	fn vkCmdSetLineWidth(&self, commandBuffer: VkCommandBuffer, lineWidth: f32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_line_width)(commandBuffer, lineWidth))))
	}
	fn vkCmdSetDepthBias(&self, commandBuffer: VkCommandBuffer, depthBiasConstantFactor: f32, depthBiasClamp: f32, depthBiasSlopeFactor: f32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_depth_bias)(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor))))
	}
	fn vkCmdSetBlendConstants(&self, commandBuffer: VkCommandBuffer, blendConstants: &[float; 4 as usize]) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_blend_constants)(commandBuffer, blendConstants))))
	}
	fn vkCmdSetDepthBounds(&self, commandBuffer: VkCommandBuffer, minDepthBounds: f32, maxDepthBounds: f32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_depth_bounds)(commandBuffer, minDepthBounds, maxDepthBounds))))
	}
	fn vkCmdSetStencilCompareMask(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, compareMask: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_stencil_compare_mask)(commandBuffer, faceMask, compareMask))))
	}
	fn vkCmdSetStencilWriteMask(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, writeMask: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_stencil_write_mask)(commandBuffer, faceMask, writeMask))))
	}
	fn vkCmdSetStencilReference(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, reference: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_stencil_reference)(commandBuffer, faceMask, reference))))
	}
	fn vkCmdBindDescriptorSets(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: *const VkDescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: *const uint32_t) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_bind_descriptor_sets)(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets))))
	}
	fn vkCmdBindIndexBuffer(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, indexType: VkIndexType) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_bind_index_buffer)(commandBuffer, buffer, offset, indexType))))
	}
	fn vkCmdBindVertexBuffers(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_bind_vertex_buffers)(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets))))
	}
	fn vkCmdDraw(&self, commandBuffer: VkCommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_draw)(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance))))
	}
	fn vkCmdDrawIndexed(&self, commandBuffer: VkCommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: i32, firstInstance: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_draw_indexed)(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance))))
	}
	fn vkCmdDrawIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_draw_indirect)(commandBuffer, buffer, offset, drawCount, stride))))
	}
	fn vkCmdDrawIndexedIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_draw_indexed_indirect)(commandBuffer, buffer, offset, drawCount, stride))))
	}
	fn vkCmdDispatch(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_dispatch)(commandBuffer, groupCountX, groupCountY, groupCountZ))))
	}
	fn vkCmdDispatchIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_dispatch_indirect)(commandBuffer, buffer, offset))))
	}
	fn vkCmdCopyBuffer(&self, commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstBuffer: VkBuffer, regionCount: u32, pRegions: *const VkBufferCopy) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_copy_buffer)(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions))))
	}
	fn vkCmdCopyImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageCopy) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_copy_image)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions))))
	}
	fn vkCmdBlitImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageBlit, filter: VkFilter) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_blit_image)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter))))
	}
	fn vkCmdCopyBufferToImage(&self, commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkBufferImageCopy) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_copy_buffer_to_image)(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions))))
	}
	fn vkCmdCopyImageToBuffer(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstBuffer: VkBuffer, regionCount: u32, pRegions: *const VkBufferImageCopy) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_copy_image_to_buffer)(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions))))
	}
	fn vkCmdUpdateBuffer(&self, commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, dataSize: VkDeviceSize, pData: *const c_void) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_update_buffer)(commandBuffer, dstBuffer, dstOffset, dataSize, pData))))
	}
	fn vkCmdFillBuffer(&self, commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, size: VkDeviceSize, data: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_fill_buffer)(commandBuffer, dstBuffer, dstOffset, size, data))))
	}
	fn vkCmdClearColorImage(&self, commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pColor: *const VkClearColorValue, rangeCount: u32, pRanges: *const VkImageSubresourceRange) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_clear_color_image)(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges))))
	}
	fn vkCmdClearDepthStencilImage(&self, commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pDepthStencil: *const VkClearDepthStencilValue, rangeCount: u32, pRanges: *const VkImageSubresourceRange) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_clear_depth_stencil_image)(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges))))
	}
	fn vkCmdClearAttachments(&self, commandBuffer: VkCommandBuffer, attachmentCount: u32, pAttachments: *const VkClearAttachment, rectCount: u32, pRects: *const VkClearRect) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_clear_attachments)(commandBuffer, attachmentCount, pAttachments, rectCount, pRects))))
	}
	fn vkCmdResolveImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageResolve) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_resolve_image)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions))))
	}
	fn vkCmdSetEvent(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_event)(commandBuffer, event, stageMask))))
	}
	fn vkCmdResetEvent(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_reset_event)(commandBuffer, event, stageMask))))
	}
	fn vkCmdWaitEvents(&self, commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const VkImageMemoryBarrier) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_wait_events)(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers))))
	}
	fn vkCmdPipelineBarrier(&self, commandBuffer: VkCommandBuffer, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, dependencyFlags: VkDependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const VkImageMemoryBarrier) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_pipeline_barrier)(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers))))
	}
	fn vkCmdBeginQuery(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_begin_query)(commandBuffer, queryPool, query, flags))))
	}
	fn vkCmdEndQuery(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_end_query)(commandBuffer, queryPool, query))))
	}
	fn vkCmdResetQueryPool(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_reset_query_pool)(commandBuffer, queryPool, firstQuery, queryCount))))
	}
	fn vkCmdWriteTimestamp(&self, commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, queryPool: VkQueryPool, query: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_write_timestamp)(commandBuffer, pipelineStage, queryPool, query))))
	}
	fn vkCmdCopyQueryPoolResults(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, stride: VkDeviceSize, flags: VkQueryResultFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_copy_query_pool_results)(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags))))
	}
	fn vkCmdPushConstants(&self, commandBuffer: VkCommandBuffer, layout: VkPipelineLayout, stageFlags: VkShaderStageFlags, offset: u32, size: u32, pValues: *const c_void) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_push_constants)(commandBuffer, layout, stageFlags, offset, size, pValues))))
	}
	fn vkCmdBeginRenderPass(&self, commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, contents: VkSubpassContents) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_begin_render_pass)(commandBuffer, pRenderPassBegin, contents))))
	}
	fn vkCmdNextSubpass(&self, commandBuffer: VkCommandBuffer, contents: VkSubpassContents) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_next_subpass)(commandBuffer, contents))))
	}
	fn vkCmdEndRenderPass(&self, commandBuffer: VkCommandBuffer) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_end_render_pass)(commandBuffer))))
	}
	fn vkCmdExecuteCommands(&self, commandBuffer: VkCommandBuffer, commandBufferCount: u32, pCommandBuffers: *const VkCommandBuffer) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_execute_commands)(commandBuffer, commandBufferCount, pCommandBuffers))))
	}
}
impl Default for Vulkan_VERSION_1_0 {
	fn default() -> Self {
		Self {
			vk_create_instance: dummy_vkCreateInstance,
			vk_destroy_instance: dummy_vkDestroyInstance,
			vk_enumerate_physical_devices: dummy_vkEnumeratePhysicalDevices,
			vk_get_physical_device_features: dummy_vkGetPhysicalDeviceFeatures,
			vk_get_physical_device_format_properties: dummy_vkGetPhysicalDeviceFormatProperties,
			vk_get_physical_device_image_format_properties: dummy_vkGetPhysicalDeviceImageFormatProperties,
			vk_get_physical_device_properties: dummy_vkGetPhysicalDeviceProperties,
			vk_get_physical_device_queue_family_properties: dummy_vkGetPhysicalDeviceQueueFamilyProperties,
			vk_get_physical_device_memory_properties: dummy_vkGetPhysicalDeviceMemoryProperties,
			vk_get_instance_proc_addr: dummy_vkGetInstanceProcAddr,
			vk_get_device_proc_addr: dummy_vkGetDeviceProcAddr,
			vk_create_device: dummy_vkCreateDevice,
			vk_destroy_device: dummy_vkDestroyDevice,
			vk_enumerate_instance_extension_properties: dummy_vkEnumerateInstanceExtensionProperties,
			vk_enumerate_device_extension_properties: dummy_vkEnumerateDeviceExtensionProperties,
			vk_enumerate_instance_layer_properties: dummy_vkEnumerateInstanceLayerProperties,
			vk_enumerate_device_layer_properties: dummy_vkEnumerateDeviceLayerProperties,
			vk_get_device_queue: dummy_vkGetDeviceQueue,
			vk_queue_submit: dummy_vkQueueSubmit,
			vk_queue_wait_idle: dummy_vkQueueWaitIdle,
			vk_device_wait_idle: dummy_vkDeviceWaitIdle,
			vk_allocate_memory: dummy_vkAllocateMemory,
			vk_free_memory: dummy_vkFreeMemory,
			vk_map_memory: dummy_vkMapMemory,
			vk_unmap_memory: dummy_vkUnmapMemory,
			vk_flush_mapped_memory_ranges: dummy_vkFlushMappedMemoryRanges,
			vk_invalidate_mapped_memory_ranges: dummy_vkInvalidateMappedMemoryRanges,
			vk_get_device_memory_commitment: dummy_vkGetDeviceMemoryCommitment,
			vk_bind_buffer_memory: dummy_vkBindBufferMemory,
			vk_bind_image_memory: dummy_vkBindImageMemory,
			vk_get_buffer_memory_requirements: dummy_vkGetBufferMemoryRequirements,
			vk_get_image_memory_requirements: dummy_vkGetImageMemoryRequirements,
			vk_get_image_sparse_memory_requirements: dummy_vkGetImageSparseMemoryRequirements,
			vk_get_physical_device_sparse_image_format_properties: dummy_vkGetPhysicalDeviceSparseImageFormatProperties,
			vk_queue_bind_sparse: dummy_vkQueueBindSparse,
			vk_create_fence: dummy_vkCreateFence,
			vk_destroy_fence: dummy_vkDestroyFence,
			vk_reset_fences: dummy_vkResetFences,
			vk_get_fence_status: dummy_vkGetFenceStatus,
			vk_wait_for_fences: dummy_vkWaitForFences,
			vk_create_semaphore: dummy_vkCreateSemaphore,
			vk_destroy_semaphore: dummy_vkDestroySemaphore,
			vk_create_event: dummy_vkCreateEvent,
			vk_destroy_event: dummy_vkDestroyEvent,
			vk_get_event_status: dummy_vkGetEventStatus,
			vk_set_event: dummy_vkSetEvent,
			vk_reset_event: dummy_vkResetEvent,
			vk_create_query_pool: dummy_vkCreateQueryPool,
			vk_destroy_query_pool: dummy_vkDestroyQueryPool,
			vk_get_query_pool_results: dummy_vkGetQueryPoolResults,
			vk_create_buffer: dummy_vkCreateBuffer,
			vk_destroy_buffer: dummy_vkDestroyBuffer,
			vk_create_buffer_view: dummy_vkCreateBufferView,
			vk_destroy_buffer_view: dummy_vkDestroyBufferView,
			vk_create_image: dummy_vkCreateImage,
			vk_destroy_image: dummy_vkDestroyImage,
			vk_get_image_subresource_layout: dummy_vkGetImageSubresourceLayout,
			vk_create_image_view: dummy_vkCreateImageView,
			vk_destroy_image_view: dummy_vkDestroyImageView,
			vk_create_shader_module: dummy_vkCreateShaderModule,
			vk_destroy_shader_module: dummy_vkDestroyShaderModule,
			vk_create_pipeline_cache: dummy_vkCreatePipelineCache,
			vk_destroy_pipeline_cache: dummy_vkDestroyPipelineCache,
			vk_get_pipeline_cache_data: dummy_vkGetPipelineCacheData,
			vk_merge_pipeline_caches: dummy_vkMergePipelineCaches,
			vk_create_graphics_pipelines: dummy_vkCreateGraphicsPipelines,
			vk_create_compute_pipelines: dummy_vkCreateComputePipelines,
			vk_destroy_pipeline: dummy_vkDestroyPipeline,
			vk_create_pipeline_layout: dummy_vkCreatePipelineLayout,
			vk_destroy_pipeline_layout: dummy_vkDestroyPipelineLayout,
			vk_create_sampler: dummy_vkCreateSampler,
			vk_destroy_sampler: dummy_vkDestroySampler,
			vk_create_descriptor_set_layout: dummy_vkCreateDescriptorSetLayout,
			vk_destroy_descriptor_set_layout: dummy_vkDestroyDescriptorSetLayout,
			vk_create_descriptor_pool: dummy_vkCreateDescriptorPool,
			vk_destroy_descriptor_pool: dummy_vkDestroyDescriptorPool,
			vk_reset_descriptor_pool: dummy_vkResetDescriptorPool,
			vk_allocate_descriptor_sets: dummy_vkAllocateDescriptorSets,
			vk_free_descriptor_sets: dummy_vkFreeDescriptorSets,
			vk_update_descriptor_sets: dummy_vkUpdateDescriptorSets,
			vk_create_framebuffer: dummy_vkCreateFramebuffer,
			vk_destroy_framebuffer: dummy_vkDestroyFramebuffer,
			vk_create_render_pass: dummy_vkCreateRenderPass,
			vk_destroy_render_pass: dummy_vkDestroyRenderPass,
			vk_get_render_area_granularity: dummy_vkGetRenderAreaGranularity,
			vk_create_command_pool: dummy_vkCreateCommandPool,
			vk_destroy_command_pool: dummy_vkDestroyCommandPool,
			vk_reset_command_pool: dummy_vkResetCommandPool,
			vk_allocate_command_buffers: dummy_vkAllocateCommandBuffers,
			vk_free_command_buffers: dummy_vkFreeCommandBuffers,
			vk_begin_command_buffer: dummy_vkBeginCommandBuffer,
			vk_end_command_buffer: dummy_vkEndCommandBuffer,
			vk_reset_command_buffer: dummy_vkResetCommandBuffer,
			vk_cmd_bind_pipeline: dummy_vkCmdBindPipeline,
			vk_cmd_set_viewport: dummy_vkCmdSetViewport,
			vk_cmd_set_scissor: dummy_vkCmdSetScissor,
			vk_cmd_set_line_width: dummy_vkCmdSetLineWidth,
			vk_cmd_set_depth_bias: dummy_vkCmdSetDepthBias,
			vk_cmd_set_blend_constants: dummy_vkCmdSetBlendConstants,
			vk_cmd_set_depth_bounds: dummy_vkCmdSetDepthBounds,
			vk_cmd_set_stencil_compare_mask: dummy_vkCmdSetStencilCompareMask,
			vk_cmd_set_stencil_write_mask: dummy_vkCmdSetStencilWriteMask,
			vk_cmd_set_stencil_reference: dummy_vkCmdSetStencilReference,
			vk_cmd_bind_descriptor_sets: dummy_vkCmdBindDescriptorSets,
			vk_cmd_bind_index_buffer: dummy_vkCmdBindIndexBuffer,
			vk_cmd_bind_vertex_buffers: dummy_vkCmdBindVertexBuffers,
			vk_cmd_draw: dummy_vkCmdDraw,
			vk_cmd_draw_indexed: dummy_vkCmdDrawIndexed,
			vk_cmd_draw_indirect: dummy_vkCmdDrawIndirect,
			vk_cmd_draw_indexed_indirect: dummy_vkCmdDrawIndexedIndirect,
			vk_cmd_dispatch: dummy_vkCmdDispatch,
			vk_cmd_dispatch_indirect: dummy_vkCmdDispatchIndirect,
			vk_cmd_copy_buffer: dummy_vkCmdCopyBuffer,
			vk_cmd_copy_image: dummy_vkCmdCopyImage,
			vk_cmd_blit_image: dummy_vkCmdBlitImage,
			vk_cmd_copy_buffer_to_image: dummy_vkCmdCopyBufferToImage,
			vk_cmd_copy_image_to_buffer: dummy_vkCmdCopyImageToBuffer,
			vk_cmd_update_buffer: dummy_vkCmdUpdateBuffer,
			vk_cmd_fill_buffer: dummy_vkCmdFillBuffer,
			vk_cmd_clear_color_image: dummy_vkCmdClearColorImage,
			vk_cmd_clear_depth_stencil_image: dummy_vkCmdClearDepthStencilImage,
			vk_cmd_clear_attachments: dummy_vkCmdClearAttachments,
			vk_cmd_resolve_image: dummy_vkCmdResolveImage,
			vk_cmd_set_event: dummy_vkCmdSetEvent,
			vk_cmd_reset_event: dummy_vkCmdResetEvent,
			vk_cmd_wait_events: dummy_vkCmdWaitEvents,
			vk_cmd_pipeline_barrier: dummy_vkCmdPipelineBarrier,
			vk_cmd_begin_query: dummy_vkCmdBeginQuery,
			vk_cmd_end_query: dummy_vkCmdEndQuery,
			vk_cmd_reset_query_pool: dummy_vkCmdResetQueryPool,
			vk_cmd_write_timestamp: dummy_vkCmdWriteTimestamp,
			vk_cmd_copy_query_pool_results: dummy_vkCmdCopyQueryPoolResults,
			vk_cmd_push_constants: dummy_vkCmdPushConstants,
			vk_cmd_begin_render_pass: dummy_vkCmdBeginRenderPass,
			vk_cmd_next_subpass: dummy_vkCmdNextSubpass,
			vk_cmd_end_render_pass: dummy_vkCmdEndRenderPass,
			vk_cmd_execute_commands: dummy_vkCmdExecuteCommands,
		}
	}
}
impl Vulkan_VERSION_1_0 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_instance: {let proc = get_instance_proc_address(instance, "vkCreateInstance"); if proc == null() {dummy_vkCreateInstance} else {unsafe {transmute(proc)}}},
			vk_destroy_instance: {let proc = get_instance_proc_address(instance, "vkDestroyInstance"); if proc == null() {dummy_vkDestroyInstance} else {unsafe {transmute(proc)}}},
			vk_enumerate_physical_devices: {let proc = get_instance_proc_address(instance, "vkEnumeratePhysicalDevices"); if proc == null() {dummy_vkEnumeratePhysicalDevices} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_features: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceFeatures"); if proc == null() {dummy_vkGetPhysicalDeviceFeatures} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_format_properties: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceFormatProperties"); if proc == null() {dummy_vkGetPhysicalDeviceFormatProperties} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_image_format_properties: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceImageFormatProperties"); if proc == null() {dummy_vkGetPhysicalDeviceImageFormatProperties} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_properties: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceProperties"); if proc == null() {dummy_vkGetPhysicalDeviceProperties} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_queue_family_properties: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceQueueFamilyProperties"); if proc == null() {dummy_vkGetPhysicalDeviceQueueFamilyProperties} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_memory_properties: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceMemoryProperties"); if proc == null() {dummy_vkGetPhysicalDeviceMemoryProperties} else {unsafe {transmute(proc)}}},
			vk_get_instance_proc_addr: {let proc = get_instance_proc_address(instance, "vkGetInstanceProcAddr"); if proc == null() {dummy_vkGetInstanceProcAddr} else {unsafe {transmute(proc)}}},
			vk_get_device_proc_addr: {let proc = get_instance_proc_address(instance, "vkGetDeviceProcAddr"); if proc == null() {dummy_vkGetDeviceProcAddr} else {unsafe {transmute(proc)}}},
			vk_create_device: {let proc = get_instance_proc_address(instance, "vkCreateDevice"); if proc == null() {dummy_vkCreateDevice} else {unsafe {transmute(proc)}}},
			vk_destroy_device: {let proc = get_instance_proc_address(instance, "vkDestroyDevice"); if proc == null() {dummy_vkDestroyDevice} else {unsafe {transmute(proc)}}},
			vk_enumerate_instance_extension_properties: {let proc = get_instance_proc_address(instance, "vkEnumerateInstanceExtensionProperties"); if proc == null() {dummy_vkEnumerateInstanceExtensionProperties} else {unsafe {transmute(proc)}}},
			vk_enumerate_device_extension_properties: {let proc = get_instance_proc_address(instance, "vkEnumerateDeviceExtensionProperties"); if proc == null() {dummy_vkEnumerateDeviceExtensionProperties} else {unsafe {transmute(proc)}}},
			vk_enumerate_instance_layer_properties: {let proc = get_instance_proc_address(instance, "vkEnumerateInstanceLayerProperties"); if proc == null() {dummy_vkEnumerateInstanceLayerProperties} else {unsafe {transmute(proc)}}},
			vk_enumerate_device_layer_properties: {let proc = get_instance_proc_address(instance, "vkEnumerateDeviceLayerProperties"); if proc == null() {dummy_vkEnumerateDeviceLayerProperties} else {unsafe {transmute(proc)}}},
			vk_get_device_queue: {let proc = get_instance_proc_address(instance, "vkGetDeviceQueue"); if proc == null() {dummy_vkGetDeviceQueue} else {unsafe {transmute(proc)}}},
			vk_queue_submit: {let proc = get_instance_proc_address(instance, "vkQueueSubmit"); if proc == null() {dummy_vkQueueSubmit} else {unsafe {transmute(proc)}}},
			vk_queue_wait_idle: {let proc = get_instance_proc_address(instance, "vkQueueWaitIdle"); if proc == null() {dummy_vkQueueWaitIdle} else {unsafe {transmute(proc)}}},
			vk_device_wait_idle: {let proc = get_instance_proc_address(instance, "vkDeviceWaitIdle"); if proc == null() {dummy_vkDeviceWaitIdle} else {unsafe {transmute(proc)}}},
			vk_allocate_memory: {let proc = get_instance_proc_address(instance, "vkAllocateMemory"); if proc == null() {dummy_vkAllocateMemory} else {unsafe {transmute(proc)}}},
			vk_free_memory: {let proc = get_instance_proc_address(instance, "vkFreeMemory"); if proc == null() {dummy_vkFreeMemory} else {unsafe {transmute(proc)}}},
			vk_map_memory: {let proc = get_instance_proc_address(instance, "vkMapMemory"); if proc == null() {dummy_vkMapMemory} else {unsafe {transmute(proc)}}},
			vk_unmap_memory: {let proc = get_instance_proc_address(instance, "vkUnmapMemory"); if proc == null() {dummy_vkUnmapMemory} else {unsafe {transmute(proc)}}},
			vk_flush_mapped_memory_ranges: {let proc = get_instance_proc_address(instance, "vkFlushMappedMemoryRanges"); if proc == null() {dummy_vkFlushMappedMemoryRanges} else {unsafe {transmute(proc)}}},
			vk_invalidate_mapped_memory_ranges: {let proc = get_instance_proc_address(instance, "vkInvalidateMappedMemoryRanges"); if proc == null() {dummy_vkInvalidateMappedMemoryRanges} else {unsafe {transmute(proc)}}},
			vk_get_device_memory_commitment: {let proc = get_instance_proc_address(instance, "vkGetDeviceMemoryCommitment"); if proc == null() {dummy_vkGetDeviceMemoryCommitment} else {unsafe {transmute(proc)}}},
			vk_bind_buffer_memory: {let proc = get_instance_proc_address(instance, "vkBindBufferMemory"); if proc == null() {dummy_vkBindBufferMemory} else {unsafe {transmute(proc)}}},
			vk_bind_image_memory: {let proc = get_instance_proc_address(instance, "vkBindImageMemory"); if proc == null() {dummy_vkBindImageMemory} else {unsafe {transmute(proc)}}},
			vk_get_buffer_memory_requirements: {let proc = get_instance_proc_address(instance, "vkGetBufferMemoryRequirements"); if proc == null() {dummy_vkGetBufferMemoryRequirements} else {unsafe {transmute(proc)}}},
			vk_get_image_memory_requirements: {let proc = get_instance_proc_address(instance, "vkGetImageMemoryRequirements"); if proc == null() {dummy_vkGetImageMemoryRequirements} else {unsafe {transmute(proc)}}},
			vk_get_image_sparse_memory_requirements: {let proc = get_instance_proc_address(instance, "vkGetImageSparseMemoryRequirements"); if proc == null() {dummy_vkGetImageSparseMemoryRequirements} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_sparse_image_format_properties: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceSparseImageFormatProperties"); if proc == null() {dummy_vkGetPhysicalDeviceSparseImageFormatProperties} else {unsafe {transmute(proc)}}},
			vk_queue_bind_sparse: {let proc = get_instance_proc_address(instance, "vkQueueBindSparse"); if proc == null() {dummy_vkQueueBindSparse} else {unsafe {transmute(proc)}}},
			vk_create_fence: {let proc = get_instance_proc_address(instance, "vkCreateFence"); if proc == null() {dummy_vkCreateFence} else {unsafe {transmute(proc)}}},
			vk_destroy_fence: {let proc = get_instance_proc_address(instance, "vkDestroyFence"); if proc == null() {dummy_vkDestroyFence} else {unsafe {transmute(proc)}}},
			vk_reset_fences: {let proc = get_instance_proc_address(instance, "vkResetFences"); if proc == null() {dummy_vkResetFences} else {unsafe {transmute(proc)}}},
			vk_get_fence_status: {let proc = get_instance_proc_address(instance, "vkGetFenceStatus"); if proc == null() {dummy_vkGetFenceStatus} else {unsafe {transmute(proc)}}},
			vk_wait_for_fences: {let proc = get_instance_proc_address(instance, "vkWaitForFences"); if proc == null() {dummy_vkWaitForFences} else {unsafe {transmute(proc)}}},
			vk_create_semaphore: {let proc = get_instance_proc_address(instance, "vkCreateSemaphore"); if proc == null() {dummy_vkCreateSemaphore} else {unsafe {transmute(proc)}}},
			vk_destroy_semaphore: {let proc = get_instance_proc_address(instance, "vkDestroySemaphore"); if proc == null() {dummy_vkDestroySemaphore} else {unsafe {transmute(proc)}}},
			vk_create_event: {let proc = get_instance_proc_address(instance, "vkCreateEvent"); if proc == null() {dummy_vkCreateEvent} else {unsafe {transmute(proc)}}},
			vk_destroy_event: {let proc = get_instance_proc_address(instance, "vkDestroyEvent"); if proc == null() {dummy_vkDestroyEvent} else {unsafe {transmute(proc)}}},
			vk_get_event_status: {let proc = get_instance_proc_address(instance, "vkGetEventStatus"); if proc == null() {dummy_vkGetEventStatus} else {unsafe {transmute(proc)}}},
			vk_set_event: {let proc = get_instance_proc_address(instance, "vkSetEvent"); if proc == null() {dummy_vkSetEvent} else {unsafe {transmute(proc)}}},
			vk_reset_event: {let proc = get_instance_proc_address(instance, "vkResetEvent"); if proc == null() {dummy_vkResetEvent} else {unsafe {transmute(proc)}}},
			vk_create_query_pool: {let proc = get_instance_proc_address(instance, "vkCreateQueryPool"); if proc == null() {dummy_vkCreateQueryPool} else {unsafe {transmute(proc)}}},
			vk_destroy_query_pool: {let proc = get_instance_proc_address(instance, "vkDestroyQueryPool"); if proc == null() {dummy_vkDestroyQueryPool} else {unsafe {transmute(proc)}}},
			vk_get_query_pool_results: {let proc = get_instance_proc_address(instance, "vkGetQueryPoolResults"); if proc == null() {dummy_vkGetQueryPoolResults} else {unsafe {transmute(proc)}}},
			vk_create_buffer: {let proc = get_instance_proc_address(instance, "vkCreateBuffer"); if proc == null() {dummy_vkCreateBuffer} else {unsafe {transmute(proc)}}},
			vk_destroy_buffer: {let proc = get_instance_proc_address(instance, "vkDestroyBuffer"); if proc == null() {dummy_vkDestroyBuffer} else {unsafe {transmute(proc)}}},
			vk_create_buffer_view: {let proc = get_instance_proc_address(instance, "vkCreateBufferView"); if proc == null() {dummy_vkCreateBufferView} else {unsafe {transmute(proc)}}},
			vk_destroy_buffer_view: {let proc = get_instance_proc_address(instance, "vkDestroyBufferView"); if proc == null() {dummy_vkDestroyBufferView} else {unsafe {transmute(proc)}}},
			vk_create_image: {let proc = get_instance_proc_address(instance, "vkCreateImage"); if proc == null() {dummy_vkCreateImage} else {unsafe {transmute(proc)}}},
			vk_destroy_image: {let proc = get_instance_proc_address(instance, "vkDestroyImage"); if proc == null() {dummy_vkDestroyImage} else {unsafe {transmute(proc)}}},
			vk_get_image_subresource_layout: {let proc = get_instance_proc_address(instance, "vkGetImageSubresourceLayout"); if proc == null() {dummy_vkGetImageSubresourceLayout} else {unsafe {transmute(proc)}}},
			vk_create_image_view: {let proc = get_instance_proc_address(instance, "vkCreateImageView"); if proc == null() {dummy_vkCreateImageView} else {unsafe {transmute(proc)}}},
			vk_destroy_image_view: {let proc = get_instance_proc_address(instance, "vkDestroyImageView"); if proc == null() {dummy_vkDestroyImageView} else {unsafe {transmute(proc)}}},
			vk_create_shader_module: {let proc = get_instance_proc_address(instance, "vkCreateShaderModule"); if proc == null() {dummy_vkCreateShaderModule} else {unsafe {transmute(proc)}}},
			vk_destroy_shader_module: {let proc = get_instance_proc_address(instance, "vkDestroyShaderModule"); if proc == null() {dummy_vkDestroyShaderModule} else {unsafe {transmute(proc)}}},
			vk_create_pipeline_cache: {let proc = get_instance_proc_address(instance, "vkCreatePipelineCache"); if proc == null() {dummy_vkCreatePipelineCache} else {unsafe {transmute(proc)}}},
			vk_destroy_pipeline_cache: {let proc = get_instance_proc_address(instance, "vkDestroyPipelineCache"); if proc == null() {dummy_vkDestroyPipelineCache} else {unsafe {transmute(proc)}}},
			vk_get_pipeline_cache_data: {let proc = get_instance_proc_address(instance, "vkGetPipelineCacheData"); if proc == null() {dummy_vkGetPipelineCacheData} else {unsafe {transmute(proc)}}},
			vk_merge_pipeline_caches: {let proc = get_instance_proc_address(instance, "vkMergePipelineCaches"); if proc == null() {dummy_vkMergePipelineCaches} else {unsafe {transmute(proc)}}},
			vk_create_graphics_pipelines: {let proc = get_instance_proc_address(instance, "vkCreateGraphicsPipelines"); if proc == null() {dummy_vkCreateGraphicsPipelines} else {unsafe {transmute(proc)}}},
			vk_create_compute_pipelines: {let proc = get_instance_proc_address(instance, "vkCreateComputePipelines"); if proc == null() {dummy_vkCreateComputePipelines} else {unsafe {transmute(proc)}}},
			vk_destroy_pipeline: {let proc = get_instance_proc_address(instance, "vkDestroyPipeline"); if proc == null() {dummy_vkDestroyPipeline} else {unsafe {transmute(proc)}}},
			vk_create_pipeline_layout: {let proc = get_instance_proc_address(instance, "vkCreatePipelineLayout"); if proc == null() {dummy_vkCreatePipelineLayout} else {unsafe {transmute(proc)}}},
			vk_destroy_pipeline_layout: {let proc = get_instance_proc_address(instance, "vkDestroyPipelineLayout"); if proc == null() {dummy_vkDestroyPipelineLayout} else {unsafe {transmute(proc)}}},
			vk_create_sampler: {let proc = get_instance_proc_address(instance, "vkCreateSampler"); if proc == null() {dummy_vkCreateSampler} else {unsafe {transmute(proc)}}},
			vk_destroy_sampler: {let proc = get_instance_proc_address(instance, "vkDestroySampler"); if proc == null() {dummy_vkDestroySampler} else {unsafe {transmute(proc)}}},
			vk_create_descriptor_set_layout: {let proc = get_instance_proc_address(instance, "vkCreateDescriptorSetLayout"); if proc == null() {dummy_vkCreateDescriptorSetLayout} else {unsafe {transmute(proc)}}},
			vk_destroy_descriptor_set_layout: {let proc = get_instance_proc_address(instance, "vkDestroyDescriptorSetLayout"); if proc == null() {dummy_vkDestroyDescriptorSetLayout} else {unsafe {transmute(proc)}}},
			vk_create_descriptor_pool: {let proc = get_instance_proc_address(instance, "vkCreateDescriptorPool"); if proc == null() {dummy_vkCreateDescriptorPool} else {unsafe {transmute(proc)}}},
			vk_destroy_descriptor_pool: {let proc = get_instance_proc_address(instance, "vkDestroyDescriptorPool"); if proc == null() {dummy_vkDestroyDescriptorPool} else {unsafe {transmute(proc)}}},
			vk_reset_descriptor_pool: {let proc = get_instance_proc_address(instance, "vkResetDescriptorPool"); if proc == null() {dummy_vkResetDescriptorPool} else {unsafe {transmute(proc)}}},
			vk_allocate_descriptor_sets: {let proc = get_instance_proc_address(instance, "vkAllocateDescriptorSets"); if proc == null() {dummy_vkAllocateDescriptorSets} else {unsafe {transmute(proc)}}},
			vk_free_descriptor_sets: {let proc = get_instance_proc_address(instance, "vkFreeDescriptorSets"); if proc == null() {dummy_vkFreeDescriptorSets} else {unsafe {transmute(proc)}}},
			vk_update_descriptor_sets: {let proc = get_instance_proc_address(instance, "vkUpdateDescriptorSets"); if proc == null() {dummy_vkUpdateDescriptorSets} else {unsafe {transmute(proc)}}},
			vk_create_framebuffer: {let proc = get_instance_proc_address(instance, "vkCreateFramebuffer"); if proc == null() {dummy_vkCreateFramebuffer} else {unsafe {transmute(proc)}}},
			vk_destroy_framebuffer: {let proc = get_instance_proc_address(instance, "vkDestroyFramebuffer"); if proc == null() {dummy_vkDestroyFramebuffer} else {unsafe {transmute(proc)}}},
			vk_create_render_pass: {let proc = get_instance_proc_address(instance, "vkCreateRenderPass"); if proc == null() {dummy_vkCreateRenderPass} else {unsafe {transmute(proc)}}},
			vk_destroy_render_pass: {let proc = get_instance_proc_address(instance, "vkDestroyRenderPass"); if proc == null() {dummy_vkDestroyRenderPass} else {unsafe {transmute(proc)}}},
			vk_get_render_area_granularity: {let proc = get_instance_proc_address(instance, "vkGetRenderAreaGranularity"); if proc == null() {dummy_vkGetRenderAreaGranularity} else {unsafe {transmute(proc)}}},
			vk_create_command_pool: {let proc = get_instance_proc_address(instance, "vkCreateCommandPool"); if proc == null() {dummy_vkCreateCommandPool} else {unsafe {transmute(proc)}}},
			vk_destroy_command_pool: {let proc = get_instance_proc_address(instance, "vkDestroyCommandPool"); if proc == null() {dummy_vkDestroyCommandPool} else {unsafe {transmute(proc)}}},
			vk_reset_command_pool: {let proc = get_instance_proc_address(instance, "vkResetCommandPool"); if proc == null() {dummy_vkResetCommandPool} else {unsafe {transmute(proc)}}},
			vk_allocate_command_buffers: {let proc = get_instance_proc_address(instance, "vkAllocateCommandBuffers"); if proc == null() {dummy_vkAllocateCommandBuffers} else {unsafe {transmute(proc)}}},
			vk_free_command_buffers: {let proc = get_instance_proc_address(instance, "vkFreeCommandBuffers"); if proc == null() {dummy_vkFreeCommandBuffers} else {unsafe {transmute(proc)}}},
			vk_begin_command_buffer: {let proc = get_instance_proc_address(instance, "vkBeginCommandBuffer"); if proc == null() {dummy_vkBeginCommandBuffer} else {unsafe {transmute(proc)}}},
			vk_end_command_buffer: {let proc = get_instance_proc_address(instance, "vkEndCommandBuffer"); if proc == null() {dummy_vkEndCommandBuffer} else {unsafe {transmute(proc)}}},
			vk_reset_command_buffer: {let proc = get_instance_proc_address(instance, "vkResetCommandBuffer"); if proc == null() {dummy_vkResetCommandBuffer} else {unsafe {transmute(proc)}}},
			vk_cmd_bind_pipeline: {let proc = get_instance_proc_address(instance, "vkCmdBindPipeline"); if proc == null() {dummy_vkCmdBindPipeline} else {unsafe {transmute(proc)}}},
			vk_cmd_set_viewport: {let proc = get_instance_proc_address(instance, "vkCmdSetViewport"); if proc == null() {dummy_vkCmdSetViewport} else {unsafe {transmute(proc)}}},
			vk_cmd_set_scissor: {let proc = get_instance_proc_address(instance, "vkCmdSetScissor"); if proc == null() {dummy_vkCmdSetScissor} else {unsafe {transmute(proc)}}},
			vk_cmd_set_line_width: {let proc = get_instance_proc_address(instance, "vkCmdSetLineWidth"); if proc == null() {dummy_vkCmdSetLineWidth} else {unsafe {transmute(proc)}}},
			vk_cmd_set_depth_bias: {let proc = get_instance_proc_address(instance, "vkCmdSetDepthBias"); if proc == null() {dummy_vkCmdSetDepthBias} else {unsafe {transmute(proc)}}},
			vk_cmd_set_blend_constants: {let proc = get_instance_proc_address(instance, "vkCmdSetBlendConstants"); if proc == null() {dummy_vkCmdSetBlendConstants} else {unsafe {transmute(proc)}}},
			vk_cmd_set_depth_bounds: {let proc = get_instance_proc_address(instance, "vkCmdSetDepthBounds"); if proc == null() {dummy_vkCmdSetDepthBounds} else {unsafe {transmute(proc)}}},
			vk_cmd_set_stencil_compare_mask: {let proc = get_instance_proc_address(instance, "vkCmdSetStencilCompareMask"); if proc == null() {dummy_vkCmdSetStencilCompareMask} else {unsafe {transmute(proc)}}},
			vk_cmd_set_stencil_write_mask: {let proc = get_instance_proc_address(instance, "vkCmdSetStencilWriteMask"); if proc == null() {dummy_vkCmdSetStencilWriteMask} else {unsafe {transmute(proc)}}},
			vk_cmd_set_stencil_reference: {let proc = get_instance_proc_address(instance, "vkCmdSetStencilReference"); if proc == null() {dummy_vkCmdSetStencilReference} else {unsafe {transmute(proc)}}},
			vk_cmd_bind_descriptor_sets: {let proc = get_instance_proc_address(instance, "vkCmdBindDescriptorSets"); if proc == null() {dummy_vkCmdBindDescriptorSets} else {unsafe {transmute(proc)}}},
			vk_cmd_bind_index_buffer: {let proc = get_instance_proc_address(instance, "vkCmdBindIndexBuffer"); if proc == null() {dummy_vkCmdBindIndexBuffer} else {unsafe {transmute(proc)}}},
			vk_cmd_bind_vertex_buffers: {let proc = get_instance_proc_address(instance, "vkCmdBindVertexBuffers"); if proc == null() {dummy_vkCmdBindVertexBuffers} else {unsafe {transmute(proc)}}},
			vk_cmd_draw: {let proc = get_instance_proc_address(instance, "vkCmdDraw"); if proc == null() {dummy_vkCmdDraw} else {unsafe {transmute(proc)}}},
			vk_cmd_draw_indexed: {let proc = get_instance_proc_address(instance, "vkCmdDrawIndexed"); if proc == null() {dummy_vkCmdDrawIndexed} else {unsafe {transmute(proc)}}},
			vk_cmd_draw_indirect: {let proc = get_instance_proc_address(instance, "vkCmdDrawIndirect"); if proc == null() {dummy_vkCmdDrawIndirect} else {unsafe {transmute(proc)}}},
			vk_cmd_draw_indexed_indirect: {let proc = get_instance_proc_address(instance, "vkCmdDrawIndexedIndirect"); if proc == null() {dummy_vkCmdDrawIndexedIndirect} else {unsafe {transmute(proc)}}},
			vk_cmd_dispatch: {let proc = get_instance_proc_address(instance, "vkCmdDispatch"); if proc == null() {dummy_vkCmdDispatch} else {unsafe {transmute(proc)}}},
			vk_cmd_dispatch_indirect: {let proc = get_instance_proc_address(instance, "vkCmdDispatchIndirect"); if proc == null() {dummy_vkCmdDispatchIndirect} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_buffer: {let proc = get_instance_proc_address(instance, "vkCmdCopyBuffer"); if proc == null() {dummy_vkCmdCopyBuffer} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_image: {let proc = get_instance_proc_address(instance, "vkCmdCopyImage"); if proc == null() {dummy_vkCmdCopyImage} else {unsafe {transmute(proc)}}},
			vk_cmd_blit_image: {let proc = get_instance_proc_address(instance, "vkCmdBlitImage"); if proc == null() {dummy_vkCmdBlitImage} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_buffer_to_image: {let proc = get_instance_proc_address(instance, "vkCmdCopyBufferToImage"); if proc == null() {dummy_vkCmdCopyBufferToImage} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_image_to_buffer: {let proc = get_instance_proc_address(instance, "vkCmdCopyImageToBuffer"); if proc == null() {dummy_vkCmdCopyImageToBuffer} else {unsafe {transmute(proc)}}},
			vk_cmd_update_buffer: {let proc = get_instance_proc_address(instance, "vkCmdUpdateBuffer"); if proc == null() {dummy_vkCmdUpdateBuffer} else {unsafe {transmute(proc)}}},
			vk_cmd_fill_buffer: {let proc = get_instance_proc_address(instance, "vkCmdFillBuffer"); if proc == null() {dummy_vkCmdFillBuffer} else {unsafe {transmute(proc)}}},
			vk_cmd_clear_color_image: {let proc = get_instance_proc_address(instance, "vkCmdClearColorImage"); if proc == null() {dummy_vkCmdClearColorImage} else {unsafe {transmute(proc)}}},
			vk_cmd_clear_depth_stencil_image: {let proc = get_instance_proc_address(instance, "vkCmdClearDepthStencilImage"); if proc == null() {dummy_vkCmdClearDepthStencilImage} else {unsafe {transmute(proc)}}},
			vk_cmd_clear_attachments: {let proc = get_instance_proc_address(instance, "vkCmdClearAttachments"); if proc == null() {dummy_vkCmdClearAttachments} else {unsafe {transmute(proc)}}},
			vk_cmd_resolve_image: {let proc = get_instance_proc_address(instance, "vkCmdResolveImage"); if proc == null() {dummy_vkCmdResolveImage} else {unsafe {transmute(proc)}}},
			vk_cmd_set_event: {let proc = get_instance_proc_address(instance, "vkCmdSetEvent"); if proc == null() {dummy_vkCmdSetEvent} else {unsafe {transmute(proc)}}},
			vk_cmd_reset_event: {let proc = get_instance_proc_address(instance, "vkCmdResetEvent"); if proc == null() {dummy_vkCmdResetEvent} else {unsafe {transmute(proc)}}},
			vk_cmd_wait_events: {let proc = get_instance_proc_address(instance, "vkCmdWaitEvents"); if proc == null() {dummy_vkCmdWaitEvents} else {unsafe {transmute(proc)}}},
			vk_cmd_pipeline_barrier: {let proc = get_instance_proc_address(instance, "vkCmdPipelineBarrier"); if proc == null() {dummy_vkCmdPipelineBarrier} else {unsafe {transmute(proc)}}},
			vk_cmd_begin_query: {let proc = get_instance_proc_address(instance, "vkCmdBeginQuery"); if proc == null() {dummy_vkCmdBeginQuery} else {unsafe {transmute(proc)}}},
			vk_cmd_end_query: {let proc = get_instance_proc_address(instance, "vkCmdEndQuery"); if proc == null() {dummy_vkCmdEndQuery} else {unsafe {transmute(proc)}}},
			vk_cmd_reset_query_pool: {let proc = get_instance_proc_address(instance, "vkCmdResetQueryPool"); if proc == null() {dummy_vkCmdResetQueryPool} else {unsafe {transmute(proc)}}},
			vk_cmd_write_timestamp: {let proc = get_instance_proc_address(instance, "vkCmdWriteTimestamp"); if proc == null() {dummy_vkCmdWriteTimestamp} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_query_pool_results: {let proc = get_instance_proc_address(instance, "vkCmdCopyQueryPoolResults"); if proc == null() {dummy_vkCmdCopyQueryPoolResults} else {unsafe {transmute(proc)}}},
			vk_cmd_push_constants: {let proc = get_instance_proc_address(instance, "vkCmdPushConstants"); if proc == null() {dummy_vkCmdPushConstants} else {unsafe {transmute(proc)}}},
			vk_cmd_begin_render_pass: {let proc = get_instance_proc_address(instance, "vkCmdBeginRenderPass"); if proc == null() {dummy_vkCmdBeginRenderPass} else {unsafe {transmute(proc)}}},
			vk_cmd_next_subpass: {let proc = get_instance_proc_address(instance, "vkCmdNextSubpass"); if proc == null() {dummy_vkCmdNextSubpass} else {unsafe {transmute(proc)}}},
			vk_cmd_end_render_pass: {let proc = get_instance_proc_address(instance, "vkCmdEndRenderPass"); if proc == null() {dummy_vkCmdEndRenderPass} else {unsafe {transmute(proc)}}},
			vk_cmd_execute_commands: {let proc = get_instance_proc_address(instance, "vkCmdExecuteCommands"); if proc == null() {dummy_vkCmdExecuteCommands} else {unsafe {transmute(proc)}}},
		}
	}
}
/// constant `VK_API_VERSION_1_1` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_API_VERSION_1_1.html>
pub const VK_API_VERSION_1_1: u32 = 0x401000;
/// constant `VK_MAX_DEVICE_GROUP_SIZE` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_DEVICE_GROUP_SIZE.html>
pub const VK_MAX_DEVICE_GROUP_SIZE: u32 = 32u32;
/// constant `VK_LUID_SIZE` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_LUID_SIZE.html>
pub const VK_LUID_SIZE: u32 = 8u32;
/// constant `VK_QUEUE_FAMILY_EXTERNAL` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QUEUE_FAMILY_EXTERNAL.html>
pub const VK_QUEUE_FAMILY_EXTERNAL: u32 = !1u32;
/// type definition `VkSubgroupFeatureFlags` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubgroupFeatureFlags.html>
pub type VkSubgroupFeatureFlags = VkFlags;
pub fn vk_subgroup_feature_flags_to_string(value: VkSubgroupFeatureFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(14);
	if (value & VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_BASIC_BIT as VkSubgroupFeatureFlags) == VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_BASIC_BIT as VkSubgroupFeatureFlags {
		flags.push("VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_BASIC_BIT");
	}
	if (value & VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_VOTE_BIT as VkSubgroupFeatureFlags) == VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_VOTE_BIT as VkSubgroupFeatureFlags {
		flags.push("VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_VOTE_BIT");
	}
	if (value & VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ARITHMETIC_BIT as VkSubgroupFeatureFlags) == VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ARITHMETIC_BIT as VkSubgroupFeatureFlags {
		flags.push("VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ARITHMETIC_BIT");
	}
	if (value & VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_BALLOT_BIT as VkSubgroupFeatureFlags) == VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_BALLOT_BIT as VkSubgroupFeatureFlags {
		flags.push("VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_BALLOT_BIT");
	}
	if (value & VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_SHUFFLE_BIT as VkSubgroupFeatureFlags) == VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_SHUFFLE_BIT as VkSubgroupFeatureFlags {
		flags.push("VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_SHUFFLE_BIT");
	}
	if (value & VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT as VkSubgroupFeatureFlags) == VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT as VkSubgroupFeatureFlags {
		flags.push("VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT");
	}
	if (value & VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_CLUSTERED_BIT as VkSubgroupFeatureFlags) == VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_CLUSTERED_BIT as VkSubgroupFeatureFlags {
		flags.push("VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_CLUSTERED_BIT");
	}
	if (value & VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_QUAD_BIT as VkSubgroupFeatureFlags) == VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_QUAD_BIT as VkSubgroupFeatureFlags {
		flags.push("VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_QUAD_BIT");
	}
	if (value & VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ROTATE_BIT as VkSubgroupFeatureFlags) == VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ROTATE_BIT as VkSubgroupFeatureFlags {
		flags.push("VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ROTATE_BIT");
	}
	if (value & VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT as VkSubgroupFeatureFlags) == VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT as VkSubgroupFeatureFlags {
		flags.push("VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT");
	}
	if (value & VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV as VkSubgroupFeatureFlags) == VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV as VkSubgroupFeatureFlags {
		flags.push("VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV");
	}
	if (value & VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR as VkSubgroupFeatureFlags) == VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR as VkSubgroupFeatureFlags {
		flags.push("VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR");
	}
	if (value & VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR as VkSubgroupFeatureFlags) == VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR as VkSubgroupFeatureFlags {
		flags.push("VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR");
	}
	if (value & VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM as VkSubgroupFeatureFlags) == VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM as VkSubgroupFeatureFlags {
		flags.push("VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkPeerMemoryFeatureFlags` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPeerMemoryFeatureFlags.html>
pub type VkPeerMemoryFeatureFlags = VkFlags;
pub fn vk_peer_memory_feature_flags_to_string(value: VkPeerMemoryFeatureFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(9);
	if (value & VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT as VkPeerMemoryFeatureFlags) == VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT as VkPeerMemoryFeatureFlags {
		flags.push("VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT");
	}
	if (value & VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_DST_BIT as VkPeerMemoryFeatureFlags) == VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_DST_BIT as VkPeerMemoryFeatureFlags {
		flags.push("VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_DST_BIT");
	}
	if (value & VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT as VkPeerMemoryFeatureFlags) == VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT as VkPeerMemoryFeatureFlags {
		flags.push("VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT");
	}
	if (value & VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT as VkPeerMemoryFeatureFlags) == VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT as VkPeerMemoryFeatureFlags {
		flags.push("VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT");
	}
	if (value & VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR as VkPeerMemoryFeatureFlags) == VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR as VkPeerMemoryFeatureFlags {
		flags.push("VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR");
	}
	if (value & VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR as VkPeerMemoryFeatureFlags) == VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR as VkPeerMemoryFeatureFlags {
		flags.push("VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR");
	}
	if (value & VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR as VkPeerMemoryFeatureFlags) == VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR as VkPeerMemoryFeatureFlags {
		flags.push("VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR");
	}
	if (value & VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR as VkPeerMemoryFeatureFlags) == VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR as VkPeerMemoryFeatureFlags {
		flags.push("VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR");
	}
	if (value & VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM as VkPeerMemoryFeatureFlags) == VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM as VkPeerMemoryFeatureFlags {
		flags.push("VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkMemoryAllocateFlags` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryAllocateFlags.html>
pub type VkMemoryAllocateFlags = VkFlags;
pub fn vk_memory_allocate_flags_to_string(value: VkMemoryAllocateFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(8);
	if (value & VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT as VkMemoryAllocateFlags) == VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT as VkMemoryAllocateFlags {
		flags.push("VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT");
	}
	if (value & VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT as VkMemoryAllocateFlags) == VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT as VkMemoryAllocateFlags {
		flags.push("VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT");
	}
	if (value & VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT as VkMemoryAllocateFlags) == VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT as VkMemoryAllocateFlags {
		flags.push("VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT");
	}
	if (value & VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT as VkMemoryAllocateFlags) == VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT as VkMemoryAllocateFlags {
		flags.push("VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT");
	}
	if (value & VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR as VkMemoryAllocateFlags) == VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR as VkMemoryAllocateFlags {
		flags.push("VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR");
	}
	if (value & VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR as VkMemoryAllocateFlags) == VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR as VkMemoryAllocateFlags {
		flags.push("VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR");
	}
	if (value & VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR as VkMemoryAllocateFlags) == VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR as VkMemoryAllocateFlags {
		flags.push("VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR");
	}
	if (value & VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM as VkMemoryAllocateFlags) == VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM as VkMemoryAllocateFlags {
		flags.push("VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkCommandPoolTrimFlags` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandPoolTrimFlags.html>
pub type VkCommandPoolTrimFlags = VkFlags;
/// type definition `VkDescriptorUpdateTemplateCreateFlags` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorUpdateTemplateCreateFlags.html>
pub type VkDescriptorUpdateTemplateCreateFlags = VkFlags;
/// type definition `VkExternalMemoryHandleTypeFlags` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryHandleTypeFlags.html>
pub type VkExternalMemoryHandleTypeFlags = VkFlags;
pub fn vk_external_memory_handle_type_flags_to_string(value: VkExternalMemoryHandleTypeFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(25);
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR");
	}
	if (value & VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM as VkExternalMemoryHandleTypeFlags) == VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM as VkExternalMemoryHandleTypeFlags {
		flags.push("VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkExternalMemoryFeatureFlags` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryFeatureFlags.html>
pub type VkExternalMemoryFeatureFlags = VkFlags;
pub fn vk_external_memory_feature_flags_to_string(value: VkExternalMemoryFeatureFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(7);
	if (value & VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT as VkExternalMemoryFeatureFlags) == VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT as VkExternalMemoryFeatureFlags {
		flags.push("VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT");
	}
	if (value & VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT as VkExternalMemoryFeatureFlags) == VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT as VkExternalMemoryFeatureFlags {
		flags.push("VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT");
	}
	if (value & VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT as VkExternalMemoryFeatureFlags) == VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT as VkExternalMemoryFeatureFlags {
		flags.push("VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT");
	}
	if (value & VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR as VkExternalMemoryFeatureFlags) == VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR as VkExternalMemoryFeatureFlags {
		flags.push("VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR");
	}
	if (value & VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR as VkExternalMemoryFeatureFlags) == VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR as VkExternalMemoryFeatureFlags {
		flags.push("VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR");
	}
	if (value & VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR as VkExternalMemoryFeatureFlags) == VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR as VkExternalMemoryFeatureFlags {
		flags.push("VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR");
	}
	if (value & VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM as VkExternalMemoryFeatureFlags) == VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM as VkExternalMemoryFeatureFlags {
		flags.push("VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkExternalFenceHandleTypeFlags` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalFenceHandleTypeFlags.html>
pub type VkExternalFenceHandleTypeFlags = VkFlags;
pub fn vk_external_fence_handle_type_flags_to_string(value: VkExternalFenceHandleTypeFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(9);
	if (value & VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT as VkExternalFenceHandleTypeFlags) == VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT as VkExternalFenceHandleTypeFlags {
		flags.push("VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT");
	}
	if (value & VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT as VkExternalFenceHandleTypeFlags) == VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT as VkExternalFenceHandleTypeFlags {
		flags.push("VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT");
	}
	if (value & VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT as VkExternalFenceHandleTypeFlags) == VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT as VkExternalFenceHandleTypeFlags {
		flags.push("VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT");
	}
	if (value & VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT as VkExternalFenceHandleTypeFlags) == VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT as VkExternalFenceHandleTypeFlags {
		flags.push("VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT");
	}
	if (value & VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR as VkExternalFenceHandleTypeFlags) == VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR as VkExternalFenceHandleTypeFlags {
		flags.push("VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR");
	}
	if (value & VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR as VkExternalFenceHandleTypeFlags) == VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR as VkExternalFenceHandleTypeFlags {
		flags.push("VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR");
	}
	if (value & VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR as VkExternalFenceHandleTypeFlags) == VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR as VkExternalFenceHandleTypeFlags {
		flags.push("VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR");
	}
	if (value & VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR as VkExternalFenceHandleTypeFlags) == VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR as VkExternalFenceHandleTypeFlags {
		flags.push("VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR");
	}
	if (value & VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM as VkExternalFenceHandleTypeFlags) == VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM as VkExternalFenceHandleTypeFlags {
		flags.push("VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkExternalFenceFeatureFlags` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalFenceFeatureFlags.html>
pub type VkExternalFenceFeatureFlags = VkFlags;
pub fn vk_external_fence_feature_flags_to_string(value: VkExternalFenceFeatureFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(5);
	if (value & VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT as VkExternalFenceFeatureFlags) == VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT as VkExternalFenceFeatureFlags {
		flags.push("VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT");
	}
	if (value & VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT as VkExternalFenceFeatureFlags) == VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT as VkExternalFenceFeatureFlags {
		flags.push("VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT");
	}
	if (value & VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR as VkExternalFenceFeatureFlags) == VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR as VkExternalFenceFeatureFlags {
		flags.push("VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR");
	}
	if (value & VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR as VkExternalFenceFeatureFlags) == VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR as VkExternalFenceFeatureFlags {
		flags.push("VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR");
	}
	if (value & VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM as VkExternalFenceFeatureFlags) == VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM as VkExternalFenceFeatureFlags {
		flags.push("VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkFenceImportFlags` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFenceImportFlags.html>
pub type VkFenceImportFlags = VkFlags;
pub fn vk_fence_import_flags_to_string(value: VkFenceImportFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(3);
	if (value & VkFenceImportFlagBits::VK_FENCE_IMPORT_TEMPORARY_BIT as VkFenceImportFlags) == VkFenceImportFlagBits::VK_FENCE_IMPORT_TEMPORARY_BIT as VkFenceImportFlags {
		flags.push("VkFenceImportFlagBits::VK_FENCE_IMPORT_TEMPORARY_BIT");
	}
	if (value & VkFenceImportFlagBits::VK_FENCE_IMPORT_TEMPORARY_BIT_KHR as VkFenceImportFlags) == VkFenceImportFlagBits::VK_FENCE_IMPORT_TEMPORARY_BIT_KHR as VkFenceImportFlags {
		flags.push("VkFenceImportFlagBits::VK_FENCE_IMPORT_TEMPORARY_BIT_KHR");
	}
	if (value & VkFenceImportFlagBits::VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM as VkFenceImportFlags) == VkFenceImportFlagBits::VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM as VkFenceImportFlags {
		flags.push("VkFenceImportFlagBits::VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkSemaphoreImportFlags` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreImportFlags.html>
pub type VkSemaphoreImportFlags = VkFlags;
pub fn vk_semaphore_import_flags_to_string(value: VkSemaphoreImportFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(3);
	if (value & VkSemaphoreImportFlagBits::VK_SEMAPHORE_IMPORT_TEMPORARY_BIT as VkSemaphoreImportFlags) == VkSemaphoreImportFlagBits::VK_SEMAPHORE_IMPORT_TEMPORARY_BIT as VkSemaphoreImportFlags {
		flags.push("VkSemaphoreImportFlagBits::VK_SEMAPHORE_IMPORT_TEMPORARY_BIT");
	}
	if (value & VkSemaphoreImportFlagBits::VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR as VkSemaphoreImportFlags) == VkSemaphoreImportFlagBits::VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR as VkSemaphoreImportFlags {
		flags.push("VkSemaphoreImportFlagBits::VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR");
	}
	if (value & VkSemaphoreImportFlagBits::VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM as VkSemaphoreImportFlags) == VkSemaphoreImportFlagBits::VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM as VkSemaphoreImportFlags {
		flags.push("VkSemaphoreImportFlagBits::VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkExternalSemaphoreHandleTypeFlags` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalSemaphoreHandleTypeFlags.html>
pub type VkExternalSemaphoreHandleTypeFlags = VkFlags;
pub fn vk_external_semaphore_handle_type_flags_to_string(value: VkExternalSemaphoreHandleTypeFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(13);
	if (value & VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT as VkExternalSemaphoreHandleTypeFlags) == VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT as VkExternalSemaphoreHandleTypeFlags {
		flags.push("VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT");
	}
	if (value & VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT as VkExternalSemaphoreHandleTypeFlags) == VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT as VkExternalSemaphoreHandleTypeFlags {
		flags.push("VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT");
	}
	if (value & VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT as VkExternalSemaphoreHandleTypeFlags) == VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT as VkExternalSemaphoreHandleTypeFlags {
		flags.push("VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT");
	}
	if (value & VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT as VkExternalSemaphoreHandleTypeFlags) == VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT as VkExternalSemaphoreHandleTypeFlags {
		flags.push("VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT");
	}
	if (value & VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT as VkExternalSemaphoreHandleTypeFlags) == VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT as VkExternalSemaphoreHandleTypeFlags {
		flags.push("VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT");
	}
	if (value & VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA as VkExternalSemaphoreHandleTypeFlags) == VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA as VkExternalSemaphoreHandleTypeFlags {
		flags.push("VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA");
	}
	if (value & VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT as VkExternalSemaphoreHandleTypeFlags) == VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT as VkExternalSemaphoreHandleTypeFlags {
		flags.push("VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT");
	}
	if (value & VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR as VkExternalSemaphoreHandleTypeFlags) == VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR as VkExternalSemaphoreHandleTypeFlags {
		flags.push("VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR");
	}
	if (value & VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR as VkExternalSemaphoreHandleTypeFlags) == VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR as VkExternalSemaphoreHandleTypeFlags {
		flags.push("VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR");
	}
	if (value & VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR as VkExternalSemaphoreHandleTypeFlags) == VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR as VkExternalSemaphoreHandleTypeFlags {
		flags.push("VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR");
	}
	if (value & VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR as VkExternalSemaphoreHandleTypeFlags) == VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR as VkExternalSemaphoreHandleTypeFlags {
		flags.push("VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR");
	}
	if (value & VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR as VkExternalSemaphoreHandleTypeFlags) == VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR as VkExternalSemaphoreHandleTypeFlags {
		flags.push("VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR");
	}
	if (value & VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM as VkExternalSemaphoreHandleTypeFlags) == VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM as VkExternalSemaphoreHandleTypeFlags {
		flags.push("VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkExternalSemaphoreFeatureFlags` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalSemaphoreFeatureFlags.html>
pub type VkExternalSemaphoreFeatureFlags = VkFlags;
pub fn vk_external_semaphore_feature_flags_to_string(value: VkExternalSemaphoreFeatureFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(5);
	if (value & VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT as VkExternalSemaphoreFeatureFlags) == VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT as VkExternalSemaphoreFeatureFlags {
		flags.push("VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT");
	}
	if (value & VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT as VkExternalSemaphoreFeatureFlags) == VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT as VkExternalSemaphoreFeatureFlags {
		flags.push("VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT");
	}
	if (value & VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR as VkExternalSemaphoreFeatureFlags) == VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR as VkExternalSemaphoreFeatureFlags {
		flags.push("VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR");
	}
	if (value & VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR as VkExternalSemaphoreFeatureFlags) == VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR as VkExternalSemaphoreFeatureFlags {
		flags.push("VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR");
	}
	if (value & VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM as VkExternalSemaphoreFeatureFlags) == VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM as VkExternalSemaphoreFeatureFlags {
		flags.push("VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkPhysicalDeviceVariablePointerFeatures` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVariablePointerFeatures.html>
pub type VkPhysicalDeviceVariablePointerFeatures = VkPhysicalDeviceVariablePointersFeatures;
/// type definition `VkPhysicalDeviceShaderDrawParameterFeatures` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderDrawParameterFeatures.html>
pub type VkPhysicalDeviceShaderDrawParameterFeatures = VkPhysicalDeviceShaderDrawParametersFeatures;
/// Non-dispatchable handle `VkSamplerYcbcrConversion` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerYcbcrConversion.html
#[cfg(target_pointer_width = "32")] pub type VkSamplerYcbcrConversion = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkSamplerYcbcrConversion_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkSamplerYcbcrConversion = *const VkSamplerYcbcrConversion_T;
/// Non-dispatchable handle `VkDescriptorUpdateTemplate` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorUpdateTemplate.html
#[cfg(target_pointer_width = "32")] pub type VkDescriptorUpdateTemplate = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkDescriptorUpdateTemplate_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkDescriptorUpdateTemplate = *const VkDescriptorUpdateTemplate_T;
/// enum `VkPointClippingBehavior` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPointClippingBehavior.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPointClippingBehavior {
	VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
	VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
	VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM = 0x7fffffff,
}
impl VkPointClippingBehavior {
	pub const VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR: VkPointClippingBehavior = VkPointClippingBehavior::VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES;
	pub const VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR: VkPointClippingBehavior = VkPointClippingBehavior::VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY;
}
/// enum `VkTessellationDomainOrigin` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTessellationDomainOrigin.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkTessellationDomainOrigin {
	VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
	VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
	VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM = 0x7fffffff,
}
impl VkTessellationDomainOrigin {
	pub const VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR: VkTessellationDomainOrigin = VkTessellationDomainOrigin::VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT;
	pub const VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR: VkTessellationDomainOrigin = VkTessellationDomainOrigin::VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT;
}
/// enum `VkSamplerYcbcrModelConversion` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerYcbcrModelConversion.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSamplerYcbcrModelConversion {
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM = 0x7fffffff,
}
impl VkSamplerYcbcrModelConversion {
	pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR: VkSamplerYcbcrModelConversion = VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY;
	pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR: VkSamplerYcbcrModelConversion = VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY;
	pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR: VkSamplerYcbcrModelConversion = VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709;
	pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR: VkSamplerYcbcrModelConversion = VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601;
	pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR: VkSamplerYcbcrModelConversion = VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020;
}
/// enum `VkSamplerYcbcrRange` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerYcbcrRange.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSamplerYcbcrRange {
	VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
	VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
	VK_SAMPLER_YCBCR_RANGE_MAX_ENUM = 0x7fffffff,
}
impl VkSamplerYcbcrRange {
	pub const VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR: VkSamplerYcbcrRange = VkSamplerYcbcrRange::VK_SAMPLER_YCBCR_RANGE_ITU_FULL;
	pub const VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR: VkSamplerYcbcrRange = VkSamplerYcbcrRange::VK_SAMPLER_YCBCR_RANGE_ITU_NARROW;
}
/// enum `VkChromaLocation` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkChromaLocation.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkChromaLocation {
	VK_CHROMA_LOCATION_COSITED_EVEN = 0,
	VK_CHROMA_LOCATION_MIDPOINT = 1,
	VK_CHROMA_LOCATION_MAX_ENUM = 0x7fffffff,
}
impl VkChromaLocation {
	pub const VK_CHROMA_LOCATION_COSITED_EVEN_KHR: VkChromaLocation = VkChromaLocation::VK_CHROMA_LOCATION_COSITED_EVEN;
	pub const VK_CHROMA_LOCATION_MIDPOINT_KHR: VkChromaLocation = VkChromaLocation::VK_CHROMA_LOCATION_MIDPOINT;
}
/// enum `VkDescriptorUpdateTemplateType` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorUpdateTemplateType.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDescriptorUpdateTemplateType {
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS = 1,
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM = 0x7fffffff,
}
impl VkDescriptorUpdateTemplateType {
	pub const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR: VkDescriptorUpdateTemplateType = VkDescriptorUpdateTemplateType::VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS;
	pub const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR: VkDescriptorUpdateTemplateType = VkDescriptorUpdateTemplateType::VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET;
}
/// enum `VkSubgroupFeatureFlagBits` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubgroupFeatureFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSubgroupFeatureFlagBits {
	VK_SUBGROUP_FEATURE_BASIC_BIT = 0x00000001,
	VK_SUBGROUP_FEATURE_VOTE_BIT = 0x00000002,
	VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 0x00000004,
	VK_SUBGROUP_FEATURE_BALLOT_BIT = 0x00000008,
	VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 0x00000010,
	VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 0x00000020,
	VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 0x00000040,
	VK_SUBGROUP_FEATURE_QUAD_BIT = 0x00000080,
	VK_SUBGROUP_FEATURE_ROTATE_BIT = 0x00000200,
	VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT = 0x00000400,
	VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 0x00000100,
	VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkSubgroupFeatureFlagBits {
	pub const VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR: VkSubgroupFeatureFlagBits = VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ROTATE_BIT;
	pub const VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR: VkSubgroupFeatureFlagBits = VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT;
}
/// enum `VkPeerMemoryFeatureFlagBits` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPeerMemoryFeatureFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPeerMemoryFeatureFlagBits {
	VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 0x00000001,
	VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 0x00000002,
	VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 0x00000004,
	VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 0x00000008,
	VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkPeerMemoryFeatureFlagBits {
	pub const VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR: VkPeerMemoryFeatureFlagBits = VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT;
	pub const VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR: VkPeerMemoryFeatureFlagBits = VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_DST_BIT;
	pub const VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR: VkPeerMemoryFeatureFlagBits = VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT;
	pub const VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR: VkPeerMemoryFeatureFlagBits = VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT;
}
/// enum `VkMemoryAllocateFlagBits` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryAllocateFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkMemoryAllocateFlagBits {
	VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 0x00000001,
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT = 0x00000002,
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x00000004,
	VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT = 0x00000008,
	VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkMemoryAllocateFlagBits {
	pub const VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR: VkMemoryAllocateFlagBits = VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT;
	pub const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR: VkMemoryAllocateFlagBits = VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT;
	pub const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR: VkMemoryAllocateFlagBits = VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT;
}
/// enum `VkExternalMemoryHandleTypeFlagBits` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryHandleTypeFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkExternalMemoryHandleTypeFlagBits {
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 0x00000008,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 0x00000010,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 0x00000020,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x00000040,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x00000200,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 0x00000400,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x00000080,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x00000100,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA = 0x00000800,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV = 0x00001000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX = 0x00004000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT = 0x00010000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT = 0x00020000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT = 0x00040000,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkExternalMemoryHandleTypeFlagBits {
	pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalMemoryHandleTypeFlagBits = VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
	pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalMemoryHandleTypeFlagBits = VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
	pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalMemoryHandleTypeFlagBits = VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
	pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR: VkExternalMemoryHandleTypeFlagBits = VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT;
	pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR: VkExternalMemoryHandleTypeFlagBits = VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT;
	pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR: VkExternalMemoryHandleTypeFlagBits = VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT;
	pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR: VkExternalMemoryHandleTypeFlagBits = VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT;
}
/// enum `VkExternalMemoryFeatureFlagBits` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryFeatureFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkExternalMemoryFeatureFlagBits {
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 0x00000001,
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 0x00000002,
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 0x00000004,
	VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkExternalMemoryFeatureFlagBits {
	pub const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR: VkExternalMemoryFeatureFlagBits = VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT;
	pub const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR: VkExternalMemoryFeatureFlagBits = VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT;
	pub const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR: VkExternalMemoryFeatureFlagBits = VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT;
}
/// enum `VkExternalFenceHandleTypeFlagBits` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalFenceHandleTypeFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkExternalFenceHandleTypeFlagBits {
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000008,
	VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkExternalFenceHandleTypeFlagBits {
	pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalFenceHandleTypeFlagBits = VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT;
	pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalFenceHandleTypeFlagBits = VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
	pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalFenceHandleTypeFlagBits = VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
	pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR: VkExternalFenceHandleTypeFlagBits = VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT;
}
/// enum `VkExternalFenceFeatureFlagBits` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalFenceFeatureFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkExternalFenceFeatureFlagBits {
	VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 0x00000001,
	VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 0x00000002,
	VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkExternalFenceFeatureFlagBits {
	pub const VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR: VkExternalFenceFeatureFlagBits = VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT;
	pub const VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR: VkExternalFenceFeatureFlagBits = VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT;
}
/// enum `VkFenceImportFlagBits` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFenceImportFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFenceImportFlagBits {
	VK_FENCE_IMPORT_TEMPORARY_BIT = 0x00000001,
	VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkFenceImportFlagBits {
	pub const VK_FENCE_IMPORT_TEMPORARY_BIT_KHR: VkFenceImportFlagBits = VkFenceImportFlagBits::VK_FENCE_IMPORT_TEMPORARY_BIT;
}
/// enum `VkSemaphoreImportFlagBits` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreImportFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSemaphoreImportFlagBits {
	VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 0x00000001,
	VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkSemaphoreImportFlagBits {
	pub const VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR: VkSemaphoreImportFlagBits = VkSemaphoreImportFlagBits::VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;
}
/// enum `VkExternalSemaphoreHandleTypeFlagBits` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalSemaphoreHandleTypeFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkExternalSemaphoreHandleTypeFlagBits {
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 0x00000008,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000010,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA = 0x00000080,
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkExternalSemaphoreHandleTypeFlagBits {
	pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT: VkExternalSemaphoreHandleTypeFlagBits = VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
	pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits = VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
	pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits = VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
	pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits = VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
	pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits = VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
	pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits = VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
}
/// enum `VkExternalSemaphoreFeatureFlagBits` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalSemaphoreFeatureFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkExternalSemaphoreFeatureFlagBits {
	VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 0x00000001,
	VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 0x00000002,
	VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkExternalSemaphoreFeatureFlagBits {
	pub const VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR: VkExternalSemaphoreFeatureFlagBits = VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT;
	pub const VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR: VkExternalSemaphoreFeatureFlagBits = VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT;
}
/// struct `VkPhysicalDeviceSubgroupProperties` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSubgroupProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSubgroupProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub subgroupSize: u32,
	pub supportedStages: VkShaderStageFlags,
	pub supportedOperations: VkSubgroupFeatureFlags,
	pub quadOperationsInAllStages: VkBool32,
}
impl Debug for VkPhysicalDeviceSubgroupProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSubgroupProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("subgroupSize", &self.subgroupSize)
		.field("supportedStages", &self.supportedStages)
		.field("supportedOperations", &format_args!("{}", vk_subgroup_feature_flags_to_string(self.supportedOperations)))
		.field("quadOperationsInAllStages", &self.quadOperationsInAllStages)
		.finish()
	}
}
/// struct `VkBindBufferMemoryInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindBufferMemoryInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindBufferMemoryInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub buffer: VkBuffer,
	pub memory: VkDeviceMemory,
	pub memoryOffset: VkDeviceSize,
}
impl Debug for VkBindBufferMemoryInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindBufferMemoryInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("buffer", &self.buffer)
		.field("memory", &self.memory)
		.field("memoryOffset", &self.memoryOffset)
		.finish()
	}
}
/// struct `VkBindImageMemoryInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindImageMemoryInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindImageMemoryInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub image: VkImage,
	pub memory: VkDeviceMemory,
	pub memoryOffset: VkDeviceSize,
}
impl Debug for VkBindImageMemoryInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindImageMemoryInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("image", &self.image)
		.field("memory", &self.memory)
		.field("memoryOffset", &self.memoryOffset)
		.finish()
	}
}
/// struct `VkPhysicalDevice16BitStorageFeatures` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevice16BitStorageFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevice16BitStorageFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub storageBuffer16BitAccess: VkBool32,
	pub uniformAndStorageBuffer16BitAccess: VkBool32,
	pub storagePushConstant16: VkBool32,
	pub storageInputOutput16: VkBool32,
}
impl Debug for VkPhysicalDevice16BitStorageFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevice16BitStorageFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("storageBuffer16BitAccess", &self.storageBuffer16BitAccess)
		.field("uniformAndStorageBuffer16BitAccess", &self.uniformAndStorageBuffer16BitAccess)
		.field("storagePushConstant16", &self.storagePushConstant16)
		.field("storageInputOutput16", &self.storageInputOutput16)
		.finish()
	}
}
/// struct `VkMemoryDedicatedRequirements` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryDedicatedRequirements.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryDedicatedRequirements {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub prefersDedicatedAllocation: VkBool32,
	pub requiresDedicatedAllocation: VkBool32,
}
impl Debug for VkMemoryDedicatedRequirements {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryDedicatedRequirements")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("prefersDedicatedAllocation", &self.prefersDedicatedAllocation)
		.field("requiresDedicatedAllocation", &self.requiresDedicatedAllocation)
		.finish()
	}
}
/// struct `VkMemoryDedicatedAllocateInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryDedicatedAllocateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryDedicatedAllocateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub image: VkImage,
	pub buffer: VkBuffer,
}
impl Debug for VkMemoryDedicatedAllocateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryDedicatedAllocateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("image", &self.image)
		.field("buffer", &self.buffer)
		.finish()
	}
}
/// struct `VkMemoryAllocateFlagsInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryAllocateFlagsInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryAllocateFlagsInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkMemoryAllocateFlags,
	pub deviceMask: u32,
}
impl Debug for VkMemoryAllocateFlagsInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryAllocateFlagsInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_memory_allocate_flags_to_string(self.flags)))
		.field("deviceMask", &self.deviceMask)
		.finish()
	}
}
/// struct `VkDeviceGroupRenderPassBeginInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupRenderPassBeginInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceGroupRenderPassBeginInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub deviceMask: u32,
	pub deviceRenderAreaCount: u32,
	pub pDeviceRenderAreas: *const VkRect2D,
}
impl Debug for VkDeviceGroupRenderPassBeginInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceGroupRenderPassBeginInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceMask", &self.deviceMask)
		.field("deviceRenderAreaCount", &self.deviceRenderAreaCount)
		.field("pDeviceRenderAreas", &self.pDeviceRenderAreas)
		.finish()
	}
}
/// struct `VkDeviceGroupCommandBufferBeginInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupCommandBufferBeginInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceGroupCommandBufferBeginInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub deviceMask: u32,
}
impl Debug for VkDeviceGroupCommandBufferBeginInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceGroupCommandBufferBeginInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceMask", &self.deviceMask)
		.finish()
	}
}
/// struct `VkDeviceGroupSubmitInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupSubmitInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceGroupSubmitInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub waitSemaphoreCount: u32,
	pub pWaitSemaphoreDeviceIndices: *const uint32_t,
	pub commandBufferCount: u32,
	pub pCommandBufferDeviceMasks: *const uint32_t,
	pub signalSemaphoreCount: u32,
	pub pSignalSemaphoreDeviceIndices: *const uint32_t,
}
impl Debug for VkDeviceGroupSubmitInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceGroupSubmitInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("waitSemaphoreCount", &self.waitSemaphoreCount)
		.field("pWaitSemaphoreDeviceIndices", &self.pWaitSemaphoreDeviceIndices)
		.field("commandBufferCount", &self.commandBufferCount)
		.field("pCommandBufferDeviceMasks", &self.pCommandBufferDeviceMasks)
		.field("signalSemaphoreCount", &self.signalSemaphoreCount)
		.field("pSignalSemaphoreDeviceIndices", &self.pSignalSemaphoreDeviceIndices)
		.finish()
	}
}
/// struct `VkDeviceGroupBindSparseInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupBindSparseInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceGroupBindSparseInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub resourceDeviceIndex: u32,
	pub memoryDeviceIndex: u32,
}
impl Debug for VkDeviceGroupBindSparseInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceGroupBindSparseInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("resourceDeviceIndex", &self.resourceDeviceIndex)
		.field("memoryDeviceIndex", &self.memoryDeviceIndex)
		.finish()
	}
}
/// struct `VkBindBufferMemoryDeviceGroupInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindBufferMemoryDeviceGroupInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindBufferMemoryDeviceGroupInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub deviceIndexCount: u32,
	pub pDeviceIndices: *const uint32_t,
}
impl Debug for VkBindBufferMemoryDeviceGroupInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindBufferMemoryDeviceGroupInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceIndexCount", &self.deviceIndexCount)
		.field("pDeviceIndices", &self.pDeviceIndices)
		.finish()
	}
}
/// struct `VkBindImageMemoryDeviceGroupInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindImageMemoryDeviceGroupInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindImageMemoryDeviceGroupInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub deviceIndexCount: u32,
	pub pDeviceIndices: *const uint32_t,
	pub splitInstanceBindRegionCount: u32,
	pub pSplitInstanceBindRegions: *const VkRect2D,
}
impl Debug for VkBindImageMemoryDeviceGroupInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindImageMemoryDeviceGroupInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceIndexCount", &self.deviceIndexCount)
		.field("pDeviceIndices", &self.pDeviceIndices)
		.field("splitInstanceBindRegionCount", &self.splitInstanceBindRegionCount)
		.field("pSplitInstanceBindRegions", &self.pSplitInstanceBindRegions)
		.finish()
	}
}
/// struct `VkPhysicalDeviceGroupProperties` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceGroupProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceGroupProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub physicalDeviceCount: u32,
	pub physicalDevices: [VkPhysicalDevice; VK_MAX_DEVICE_GROUP_SIZE as usize],
	pub subsetAllocation: VkBool32,
}
impl Debug for VkPhysicalDeviceGroupProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceGroupProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("physicalDeviceCount", &self.physicalDeviceCount)
		.field("physicalDevices", &self.physicalDevices)
		.field("subsetAllocation", &self.subsetAllocation)
		.finish()
	}
}
/// struct `VkDeviceGroupDeviceCreateInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupDeviceCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceGroupDeviceCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub physicalDeviceCount: u32,
	pub pPhysicalDevices: *const VkPhysicalDevice,
}
impl Debug for VkDeviceGroupDeviceCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceGroupDeviceCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("physicalDeviceCount", &self.physicalDeviceCount)
		.field("pPhysicalDevices", &self.pPhysicalDevices)
		.finish()
	}
}
/// struct `VkBufferMemoryRequirementsInfo2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferMemoryRequirementsInfo2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBufferMemoryRequirementsInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub buffer: VkBuffer,
}
impl Debug for VkBufferMemoryRequirementsInfo2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBufferMemoryRequirementsInfo2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("buffer", &self.buffer)
		.finish()
	}
}
/// struct `VkImageMemoryRequirementsInfo2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryRequirementsInfo2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageMemoryRequirementsInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub image: VkImage,
}
impl Debug for VkImageMemoryRequirementsInfo2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageMemoryRequirementsInfo2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("image", &self.image)
		.finish()
	}
}
/// struct `VkImageSparseMemoryRequirementsInfo2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageSparseMemoryRequirementsInfo2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageSparseMemoryRequirementsInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub image: VkImage,
}
impl Debug for VkImageSparseMemoryRequirementsInfo2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageSparseMemoryRequirementsInfo2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("image", &self.image)
		.finish()
	}
}
/// struct `VkMemoryRequirements2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryRequirements2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryRequirements2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryRequirements: VkMemoryRequirements,
}
impl Debug for VkMemoryRequirements2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryRequirements2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("memoryRequirements", &self.memoryRequirements)
		.finish()
	}
}
/// struct `VkSparseImageMemoryRequirements2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSparseImageMemoryRequirements2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSparseImageMemoryRequirements2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryRequirements: VkSparseImageMemoryRequirements,
}
impl Debug for VkSparseImageMemoryRequirements2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSparseImageMemoryRequirements2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("memoryRequirements", &self.memoryRequirements)
		.finish()
	}
}
/// struct `VkPhysicalDeviceFeatures2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFeatures2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFeatures2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub features: VkPhysicalDeviceFeatures,
}
impl Debug for VkPhysicalDeviceFeatures2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFeatures2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("features", &self.features)
		.finish()
	}
}
/// struct `VkPhysicalDeviceProperties2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceProperties2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceProperties2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub properties: VkPhysicalDeviceProperties,
}
impl Debug for VkPhysicalDeviceProperties2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceProperties2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("properties", &self.properties)
		.finish()
	}
}
/// struct `VkFormatProperties2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormatProperties2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkFormatProperties2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub formatProperties: VkFormatProperties,
}
impl Debug for VkFormatProperties2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkFormatProperties2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("formatProperties", &self.formatProperties)
		.finish()
	}
}
/// struct `VkImageFormatProperties2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageFormatProperties2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageFormatProperties2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageFormatProperties: VkImageFormatProperties,
}
impl Debug for VkImageFormatProperties2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageFormatProperties2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("imageFormatProperties", &self.imageFormatProperties)
		.finish()
	}
}
/// struct `VkPhysicalDeviceImageFormatInfo2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImageFormatInfo2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceImageFormatInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub format: VkFormat,
	pub type_: VkImageType,
	pub tiling: VkImageTiling,
	pub usage: VkImageUsageFlags,
	pub flags: VkImageCreateFlags,
}
impl Debug for VkPhysicalDeviceImageFormatInfo2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceImageFormatInfo2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("format", &self.format)
		.field("type_", &self.type_)
		.field("tiling", &self.tiling)
		.field("usage", &self.usage)
		.field("flags", &self.flags)
		.finish()
	}
}
/// struct `VkQueueFamilyProperties2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueFamilyProperties2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkQueueFamilyProperties2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub queueFamilyProperties: VkQueueFamilyProperties,
}
impl Debug for VkQueueFamilyProperties2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkQueueFamilyProperties2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("queueFamilyProperties", &self.queueFamilyProperties)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMemoryProperties2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMemoryProperties2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMemoryProperties2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryProperties: VkPhysicalDeviceMemoryProperties,
}
impl Debug for VkPhysicalDeviceMemoryProperties2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMemoryProperties2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("memoryProperties", &self.memoryProperties)
		.finish()
	}
}
/// struct `VkSparseImageFormatProperties2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSparseImageFormatProperties2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSparseImageFormatProperties2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub properties: VkSparseImageFormatProperties,
}
impl Debug for VkSparseImageFormatProperties2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSparseImageFormatProperties2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("properties", &self.properties)
		.finish()
	}
}
/// struct `VkPhysicalDeviceSparseImageFormatInfo2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSparseImageFormatInfo2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSparseImageFormatInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub format: VkFormat,
	pub type_: VkImageType,
	pub samples: VkSampleCountFlagBits,
	pub usage: VkImageUsageFlags,
	pub tiling: VkImageTiling,
}
impl Debug for VkPhysicalDeviceSparseImageFormatInfo2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSparseImageFormatInfo2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("format", &self.format)
		.field("type_", &self.type_)
		.field("samples", &self.samples)
		.field("usage", &self.usage)
		.field("tiling", &self.tiling)
		.finish()
	}
}
/// struct `VkPhysicalDevicePointClippingProperties` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePointClippingProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePointClippingProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pointClippingBehavior: VkPointClippingBehavior,
}
impl Debug for VkPhysicalDevicePointClippingProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePointClippingProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pointClippingBehavior", &self.pointClippingBehavior)
		.finish()
	}
}
/// struct `VkInputAttachmentAspectReference` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkInputAttachmentAspectReference.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkInputAttachmentAspectReference {
	pub subpass: u32,
	pub inputAttachmentIndex: u32,
	pub aspectMask: VkImageAspectFlags,
}
impl Debug for VkInputAttachmentAspectReference {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkInputAttachmentAspectReference")
		.field("subpass", &self.subpass)
		.field("inputAttachmentIndex", &self.inputAttachmentIndex)
		.field("aspectMask", &self.aspectMask)
		.finish()
	}
}
/// struct `VkRenderPassInputAttachmentAspectCreateInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassInputAttachmentAspectCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassInputAttachmentAspectCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub aspectReferenceCount: u32,
	pub pAspectReferences: *const VkInputAttachmentAspectReference,
}
impl Debug for VkRenderPassInputAttachmentAspectCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassInputAttachmentAspectCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("aspectReferenceCount", &self.aspectReferenceCount)
		.field("pAspectReferences", &self.pAspectReferences)
		.finish()
	}
}
/// struct `VkImageViewUsageCreateInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageViewUsageCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageViewUsageCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub usage: VkImageUsageFlags,
}
impl Debug for VkImageViewUsageCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageViewUsageCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("usage", &self.usage)
		.finish()
	}
}
/// struct `VkPipelineTessellationDomainOriginStateCreateInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineTessellationDomainOriginStateCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineTessellationDomainOriginStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub domainOrigin: VkTessellationDomainOrigin,
}
impl Debug for VkPipelineTessellationDomainOriginStateCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineTessellationDomainOriginStateCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("domainOrigin", &self.domainOrigin)
		.finish()
	}
}
/// struct `VkRenderPassMultiviewCreateInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassMultiviewCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassMultiviewCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub subpassCount: u32,
	pub pViewMasks: *const uint32_t,
	pub dependencyCount: u32,
	pub pViewOffsets: *const int32_t,
	pub correlationMaskCount: u32,
	pub pCorrelationMasks: *const uint32_t,
}
impl Debug for VkRenderPassMultiviewCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassMultiviewCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("subpassCount", &self.subpassCount)
		.field("pViewMasks", &self.pViewMasks)
		.field("dependencyCount", &self.dependencyCount)
		.field("pViewOffsets", &self.pViewOffsets)
		.field("correlationMaskCount", &self.correlationMaskCount)
		.field("pCorrelationMasks", &self.pCorrelationMasks)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMultiviewFeatures` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMultiviewFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMultiviewFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub multiview: VkBool32,
	pub multiviewGeometryShader: VkBool32,
	pub multiviewTessellationShader: VkBool32,
}
impl Debug for VkPhysicalDeviceMultiviewFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMultiviewFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("multiview", &self.multiview)
		.field("multiviewGeometryShader", &self.multiviewGeometryShader)
		.field("multiviewTessellationShader", &self.multiviewTessellationShader)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMultiviewProperties` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMultiviewProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMultiviewProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxMultiviewViewCount: u32,
	pub maxMultiviewInstanceIndex: u32,
}
impl Debug for VkPhysicalDeviceMultiviewProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMultiviewProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxMultiviewViewCount", &self.maxMultiviewViewCount)
		.field("maxMultiviewInstanceIndex", &self.maxMultiviewInstanceIndex)
		.finish()
	}
}
/// struct `VkPhysicalDeviceVariablePointersFeatures` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVariablePointersFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVariablePointersFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub variablePointersStorageBuffer: VkBool32,
	pub variablePointers: VkBool32,
}
impl Debug for VkPhysicalDeviceVariablePointersFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVariablePointersFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("variablePointersStorageBuffer", &self.variablePointersStorageBuffer)
		.field("variablePointers", &self.variablePointers)
		.finish()
	}
}
/// struct `VkPhysicalDeviceProtectedMemoryFeatures` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceProtectedMemoryFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceProtectedMemoryFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub protectedMemory: VkBool32,
}
impl Debug for VkPhysicalDeviceProtectedMemoryFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceProtectedMemoryFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("protectedMemory", &self.protectedMemory)
		.finish()
	}
}
/// struct `VkPhysicalDeviceProtectedMemoryProperties` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceProtectedMemoryProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceProtectedMemoryProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub protectedNoFault: VkBool32,
}
impl Debug for VkPhysicalDeviceProtectedMemoryProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceProtectedMemoryProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("protectedNoFault", &self.protectedNoFault)
		.finish()
	}
}
/// struct `VkDeviceQueueInfo2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceQueueInfo2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceQueueInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDeviceQueueCreateFlags,
	pub queueFamilyIndex: u32,
	pub queueIndex: u32,
}
impl Debug for VkDeviceQueueInfo2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceQueueInfo2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("queueFamilyIndex", &self.queueFamilyIndex)
		.field("queueIndex", &self.queueIndex)
		.finish()
	}
}
/// struct `VkProtectedSubmitInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkProtectedSubmitInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkProtectedSubmitInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub protectedSubmit: VkBool32,
}
impl Debug for VkProtectedSubmitInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkProtectedSubmitInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("protectedSubmit", &self.protectedSubmit)
		.finish()
	}
}
/// struct `VkSamplerYcbcrConversionCreateInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerYcbcrConversionCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSamplerYcbcrConversionCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub format: VkFormat,
	pub ycbcrModel: VkSamplerYcbcrModelConversion,
	pub ycbcrRange: VkSamplerYcbcrRange,
	pub components: VkComponentMapping,
	pub xChromaOffset: VkChromaLocation,
	pub yChromaOffset: VkChromaLocation,
	pub chromaFilter: VkFilter,
	pub forceExplicitReconstruction: VkBool32,
}
impl Debug for VkSamplerYcbcrConversionCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSamplerYcbcrConversionCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("format", &self.format)
		.field("ycbcrModel", &self.ycbcrModel)
		.field("ycbcrRange", &self.ycbcrRange)
		.field("components", &self.components)
		.field("xChromaOffset", &self.xChromaOffset)
		.field("yChromaOffset", &self.yChromaOffset)
		.field("chromaFilter", &self.chromaFilter)
		.field("forceExplicitReconstruction", &self.forceExplicitReconstruction)
		.finish()
	}
}
/// struct `VkSamplerYcbcrConversionInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerYcbcrConversionInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSamplerYcbcrConversionInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub conversion: VkSamplerYcbcrConversion,
}
impl Debug for VkSamplerYcbcrConversionInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSamplerYcbcrConversionInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("conversion", &self.conversion)
		.finish()
	}
}
/// struct `VkBindImagePlaneMemoryInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindImagePlaneMemoryInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindImagePlaneMemoryInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub planeAspect: VkImageAspectFlagBits,
}
impl Debug for VkBindImagePlaneMemoryInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindImagePlaneMemoryInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("planeAspect", &self.planeAspect)
		.finish()
	}
}
/// struct `VkImagePlaneMemoryRequirementsInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImagePlaneMemoryRequirementsInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImagePlaneMemoryRequirementsInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub planeAspect: VkImageAspectFlagBits,
}
impl Debug for VkImagePlaneMemoryRequirementsInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImagePlaneMemoryRequirementsInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("planeAspect", &self.planeAspect)
		.finish()
	}
}
/// struct `VkPhysicalDeviceSamplerYcbcrConversionFeatures` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSamplerYcbcrConversionFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSamplerYcbcrConversionFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub samplerYcbcrConversion: VkBool32,
}
impl Debug for VkPhysicalDeviceSamplerYcbcrConversionFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSamplerYcbcrConversionFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("samplerYcbcrConversion", &self.samplerYcbcrConversion)
		.finish()
	}
}
/// struct `VkSamplerYcbcrConversionImageFormatProperties` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerYcbcrConversionImageFormatProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSamplerYcbcrConversionImageFormatProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub combinedImageSamplerDescriptorCount: u32,
}
impl Debug for VkSamplerYcbcrConversionImageFormatProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSamplerYcbcrConversionImageFormatProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("combinedImageSamplerDescriptorCount", &self.combinedImageSamplerDescriptorCount)
		.finish()
	}
}
/// struct `VkDescriptorUpdateTemplateEntry` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorUpdateTemplateEntry.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorUpdateTemplateEntry {
	pub dstBinding: u32,
	pub dstArrayElement: u32,
	pub descriptorCount: u32,
	pub descriptorType: VkDescriptorType,
	pub offset: usize,
	pub stride: usize,
}
impl Debug for VkDescriptorUpdateTemplateEntry {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorUpdateTemplateEntry")
		.field("dstBinding", &self.dstBinding)
		.field("dstArrayElement", &self.dstArrayElement)
		.field("descriptorCount", &self.descriptorCount)
		.field("descriptorType", &self.descriptorType)
		.field("offset", &self.offset)
		.field("stride", &self.stride)
		.finish()
	}
}
/// struct `VkDescriptorUpdateTemplateCreateInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorUpdateTemplateCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorUpdateTemplateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDescriptorUpdateTemplateCreateFlags,
	pub descriptorUpdateEntryCount: u32,
	pub pDescriptorUpdateEntries: *const VkDescriptorUpdateTemplateEntry,
	pub templateType: VkDescriptorUpdateTemplateType,
	pub descriptorSetLayout: VkDescriptorSetLayout,
	pub pipelineBindPoint: VkPipelineBindPoint,
	pub pipelineLayout: VkPipelineLayout,
	pub set: u32,
}
impl Debug for VkDescriptorUpdateTemplateCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorUpdateTemplateCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("descriptorUpdateEntryCount", &self.descriptorUpdateEntryCount)
		.field("pDescriptorUpdateEntries", &self.pDescriptorUpdateEntries)
		.field("templateType", &self.templateType)
		.field("descriptorSetLayout", &self.descriptorSetLayout)
		.field("pipelineBindPoint", &self.pipelineBindPoint)
		.field("pipelineLayout", &self.pipelineLayout)
		.field("set", &self.set)
		.finish()
	}
}
/// struct `VkExternalMemoryProperties` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExternalMemoryProperties {
	pub externalMemoryFeatures: VkExternalMemoryFeatureFlags,
	pub exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlags,
	pub compatibleHandleTypes: VkExternalMemoryHandleTypeFlags,
}
impl Debug for VkExternalMemoryProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExternalMemoryProperties")
		.field("externalMemoryFeatures", &format_args!("{}", vk_external_memory_feature_flags_to_string(self.externalMemoryFeatures)))
		.field("exportFromImportedHandleTypes", &format_args!("{}", vk_external_memory_handle_type_flags_to_string(self.exportFromImportedHandleTypes)))
		.field("compatibleHandleTypes", &format_args!("{}", vk_external_memory_handle_type_flags_to_string(self.compatibleHandleTypes)))
		.finish()
	}
}
/// struct `VkPhysicalDeviceExternalImageFormatInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExternalImageFormatInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceExternalImageFormatInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
impl Debug for VkPhysicalDeviceExternalImageFormatInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceExternalImageFormatInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("handleType", &self.handleType)
		.finish()
	}
}
/// struct `VkExternalImageFormatProperties` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalImageFormatProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExternalImageFormatProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub externalMemoryProperties: VkExternalMemoryProperties,
}
impl Debug for VkExternalImageFormatProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExternalImageFormatProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("externalMemoryProperties", &self.externalMemoryProperties)
		.finish()
	}
}
/// struct `VkPhysicalDeviceExternalBufferInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExternalBufferInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceExternalBufferInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkBufferCreateFlags,
	pub usage: VkBufferUsageFlags,
	pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
impl Debug for VkPhysicalDeviceExternalBufferInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceExternalBufferInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("usage", &self.usage)
		.field("handleType", &self.handleType)
		.finish()
	}
}
/// struct `VkExternalBufferProperties` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalBufferProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExternalBufferProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub externalMemoryProperties: VkExternalMemoryProperties,
}
impl Debug for VkExternalBufferProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExternalBufferProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("externalMemoryProperties", &self.externalMemoryProperties)
		.finish()
	}
}
/// struct `VkPhysicalDeviceIDProperties` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceIDProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceIDProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceUUID: [u8; VK_UUID_SIZE as usize],
	pub driverUUID: [u8; VK_UUID_SIZE as usize],
	pub deviceLUID: [u8; VK_LUID_SIZE as usize],
	pub deviceNodeMask: u32,
	pub deviceLUIDValid: VkBool32,
}
impl Debug for VkPhysicalDeviceIDProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceIDProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceUUID", &self.deviceUUID)
		.field("driverUUID", &self.driverUUID)
		.field("deviceLUID", &self.deviceLUID)
		.field("deviceNodeMask", &self.deviceNodeMask)
		.field("deviceLUIDValid", &self.deviceLUIDValid)
		.finish()
	}
}
/// struct `VkExternalMemoryImageCreateInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryImageCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExternalMemoryImageCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes: VkExternalMemoryHandleTypeFlags,
}
impl Debug for VkExternalMemoryImageCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExternalMemoryImageCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("handleTypes", &format_args!("{}", vk_external_memory_handle_type_flags_to_string(self.handleTypes)))
		.finish()
	}
}
/// struct `VkExternalMemoryBufferCreateInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryBufferCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExternalMemoryBufferCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes: VkExternalMemoryHandleTypeFlags,
}
impl Debug for VkExternalMemoryBufferCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExternalMemoryBufferCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("handleTypes", &format_args!("{}", vk_external_memory_handle_type_flags_to_string(self.handleTypes)))
		.finish()
	}
}
/// struct `VkExportMemoryAllocateInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExportMemoryAllocateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExportMemoryAllocateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes: VkExternalMemoryHandleTypeFlags,
}
impl Debug for VkExportMemoryAllocateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExportMemoryAllocateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("handleTypes", &format_args!("{}", vk_external_memory_handle_type_flags_to_string(self.handleTypes)))
		.finish()
	}
}
/// struct `VkPhysicalDeviceExternalFenceInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExternalFenceInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceExternalFenceInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleType: VkExternalFenceHandleTypeFlagBits,
}
impl Debug for VkPhysicalDeviceExternalFenceInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceExternalFenceInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("handleType", &self.handleType)
		.finish()
	}
}
/// struct `VkExternalFenceProperties` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalFenceProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExternalFenceProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlags,
	pub compatibleHandleTypes: VkExternalFenceHandleTypeFlags,
	pub externalFenceFeatures: VkExternalFenceFeatureFlags,
}
impl Debug for VkExternalFenceProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExternalFenceProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("exportFromImportedHandleTypes", &format_args!("{}", vk_external_fence_handle_type_flags_to_string(self.exportFromImportedHandleTypes)))
		.field("compatibleHandleTypes", &format_args!("{}", vk_external_fence_handle_type_flags_to_string(self.compatibleHandleTypes)))
		.field("externalFenceFeatures", &format_args!("{}", vk_external_fence_feature_flags_to_string(self.externalFenceFeatures)))
		.finish()
	}
}
/// struct `VkExportFenceCreateInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExportFenceCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExportFenceCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes: VkExternalFenceHandleTypeFlags,
}
impl Debug for VkExportFenceCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExportFenceCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("handleTypes", &format_args!("{}", vk_external_fence_handle_type_flags_to_string(self.handleTypes)))
		.finish()
	}
}
/// struct `VkExportSemaphoreCreateInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExportSemaphoreCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExportSemaphoreCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes: VkExternalSemaphoreHandleTypeFlags,
}
impl Debug for VkExportSemaphoreCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExportSemaphoreCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("handleTypes", &format_args!("{}", vk_external_semaphore_handle_type_flags_to_string(self.handleTypes)))
		.finish()
	}
}
/// struct `VkPhysicalDeviceExternalSemaphoreInfo` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExternalSemaphoreInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceExternalSemaphoreInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleType: VkExternalSemaphoreHandleTypeFlagBits,
}
impl Debug for VkPhysicalDeviceExternalSemaphoreInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceExternalSemaphoreInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("handleType", &self.handleType)
		.finish()
	}
}
/// struct `VkExternalSemaphoreProperties` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalSemaphoreProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExternalSemaphoreProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlags,
	pub compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlags,
	pub externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlags,
}
impl Debug for VkExternalSemaphoreProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExternalSemaphoreProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("exportFromImportedHandleTypes", &format_args!("{}", vk_external_semaphore_handle_type_flags_to_string(self.exportFromImportedHandleTypes)))
		.field("compatibleHandleTypes", &format_args!("{}", vk_external_semaphore_handle_type_flags_to_string(self.compatibleHandleTypes)))
		.field("externalSemaphoreFeatures", &format_args!("{}", vk_external_semaphore_feature_flags_to_string(self.externalSemaphoreFeatures)))
		.finish()
	}
}
/// struct `VkPhysicalDeviceMaintenance3Properties` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance3Properties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance3Properties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxPerSetDescriptors: u32,
	pub maxMemoryAllocationSize: VkDeviceSize,
}
impl Debug for VkPhysicalDeviceMaintenance3Properties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMaintenance3Properties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxPerSetDescriptors", &self.maxPerSetDescriptors)
		.field("maxMemoryAllocationSize", &self.maxMemoryAllocationSize)
		.finish()
	}
}
/// struct `VkDescriptorSetLayoutSupport` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutSupport.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorSetLayoutSupport {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub supported: VkBool32,
}
impl Debug for VkDescriptorSetLayoutSupport {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorSetLayoutSupport")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("supported", &self.supported)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShaderDrawParametersFeatures` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderDrawParametersFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderDrawParametersFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderDrawParameters: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderDrawParametersFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderDrawParametersFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderDrawParameters", &self.shaderDrawParameters)
		.finish()
	}
}
/// function prototype `PFN_vkEnumerateInstanceVersion` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateInstanceVersion.html>
type PFN_vkEnumerateInstanceVersion = extern "system" fn(pApiVersion: *mut uint32_t) -> VkResult;
/// function prototype `PFN_vkBindBufferMemory2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindBufferMemory2.html>
type PFN_vkBindBufferMemory2 = extern "system" fn(device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindBufferMemoryInfo) -> VkResult;
/// function prototype `PFN_vkBindImageMemory2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindImageMemory2.html>
type PFN_vkBindImageMemory2 = extern "system" fn(device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindImageMemoryInfo) -> VkResult;
/// function prototype `PFN_vkGetDeviceGroupPeerMemoryFeatures` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceGroupPeerMemoryFeatures.html>
type PFN_vkGetDeviceGroupPeerMemoryFeatures = extern "system" fn(device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags);
/// function prototype `PFN_vkCmdSetDeviceMask` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDeviceMask.html>
type PFN_vkCmdSetDeviceMask = extern "system" fn(commandBuffer: VkCommandBuffer, deviceMask: u32);
/// function prototype `PFN_vkCmdDispatchBase` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchBase.html>
type PFN_vkCmdDispatchBase = extern "system" fn(commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32);
/// function prototype `PFN_vkEnumeratePhysicalDeviceGroups` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceGroups.html>
type PFN_vkEnumeratePhysicalDeviceGroups = extern "system" fn(instance: VkInstance, pPhysicalDeviceGroupCount: *mut uint32_t, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties) -> VkResult;
/// function prototype `PFN_vkGetImageMemoryRequirements2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageMemoryRequirements2.html>
type PFN_vkGetImageMemoryRequirements2 = extern "system" fn(device: VkDevice, pInfo: *const VkImageMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2);
/// function prototype `PFN_vkGetBufferMemoryRequirements2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferMemoryRequirements2.html>
type PFN_vkGetBufferMemoryRequirements2 = extern "system" fn(device: VkDevice, pInfo: *const VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2);
/// function prototype `PFN_vkGetImageSparseMemoryRequirements2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSparseMemoryRequirements2.html>
type PFN_vkGetImageSparseMemoryRequirements2 = extern "system" fn(device: VkDevice, pInfo: *const VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2);
/// function prototype `PFN_vkGetPhysicalDeviceFeatures2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures2.html>
type PFN_vkGetPhysicalDeviceFeatures2 = extern "system" fn(physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2);
/// function prototype `PFN_vkGetPhysicalDeviceProperties2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceProperties2.html>
type PFN_vkGetPhysicalDeviceProperties2 = extern "system" fn(physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties2);
/// function prototype `PFN_vkGetPhysicalDeviceFormatProperties2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFormatProperties2.html>
type PFN_vkGetPhysicalDeviceFormatProperties2 = extern "system" fn(physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties2);
/// function prototype `PFN_vkGetPhysicalDeviceImageFormatProperties2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceImageFormatProperties2.html>
type PFN_vkGetPhysicalDeviceImageFormatProperties2 = extern "system" fn(physicalDevice: VkPhysicalDevice, pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *mut VkImageFormatProperties2) -> VkResult;
/// function prototype `PFN_vkGetPhysicalDeviceQueueFamilyProperties2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties2.html>
type PFN_vkGetPhysicalDeviceQueueFamilyProperties2 = extern "system" fn(physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties2);
/// function prototype `PFN_vkGetPhysicalDeviceMemoryProperties2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMemoryProperties2.html>
type PFN_vkGetPhysicalDeviceMemoryProperties2 = extern "system" fn(physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2);
/// function prototype `PFN_vkGetPhysicalDeviceSparseImageFormatProperties2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2.html>
type PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 = extern "system" fn(physicalDevice: VkPhysicalDevice, pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties2);
/// function prototype `PFN_vkTrimCommandPool` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkTrimCommandPool.html>
type PFN_vkTrimCommandPool = extern "system" fn(device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags);
/// function prototype `PFN_vkGetDeviceQueue2` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceQueue2.html>
type PFN_vkGetDeviceQueue2 = extern "system" fn(device: VkDevice, pQueueInfo: *const VkDeviceQueueInfo2, pQueue: *mut VkQueue);
/// function prototype `PFN_vkCreateSamplerYcbcrConversion` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSamplerYcbcrConversion.html>
type PFN_vkCreateSamplerYcbcrConversion = extern "system" fn(device: VkDevice, pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo, pAllocator: *const VkAllocationCallbacks, pYcbcrConversion: *mut VkSamplerYcbcrConversion) -> VkResult;
/// function prototype `PFN_vkDestroySamplerYcbcrConversion` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySamplerYcbcrConversion.html>
type PFN_vkDestroySamplerYcbcrConversion = extern "system" fn(device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCreateDescriptorUpdateTemplate` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorUpdateTemplate.html>
type PFN_vkCreateDescriptorUpdateTemplate = extern "system" fn(device: VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate) -> VkResult;
/// function prototype `PFN_vkDestroyDescriptorUpdateTemplate` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorUpdateTemplate.html>
type PFN_vkDestroyDescriptorUpdateTemplate = extern "system" fn(device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkUpdateDescriptorSetWithTemplate` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSetWithTemplate.html>
type PFN_vkUpdateDescriptorSetWithTemplate = extern "system" fn(device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: *const c_void);
/// function prototype `PFN_vkGetPhysicalDeviceExternalBufferProperties` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalBufferProperties.html>
type PFN_vkGetPhysicalDeviceExternalBufferProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut VkExternalBufferProperties);
/// function prototype `PFN_vkGetPhysicalDeviceExternalFenceProperties` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalFenceProperties.html>
type PFN_vkGetPhysicalDeviceExternalFenceProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut VkExternalFenceProperties);
/// function prototype `PFN_vkGetPhysicalDeviceExternalSemaphoreProperties` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalSemaphoreProperties.html>
type PFN_vkGetPhysicalDeviceExternalSemaphoreProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties);
/// function prototype `PFN_vkGetDescriptorSetLayoutSupport` from VK_VERSION_1_1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutSupport.html>
type PFN_vkGetDescriptorSetLayoutSupport = extern "system" fn(device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pSupport: *mut VkDescriptorSetLayoutSupport);
/// The dummy function for `vkEnumerateInstanceVersion` from `VK_VERSION_1_1`
extern "system" fn dummy_vkEnumerateInstanceVersion(_: *mut uint32_t) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkEnumerateInstanceVersion"))
}
/// The dummy function for `vkBindBufferMemory2` from `VK_VERSION_1_1`
extern "system" fn dummy_vkBindBufferMemory2(_: VkDevice, _: u32, _: *const VkBindBufferMemoryInfo) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkBindBufferMemory2"))
}
/// The dummy function for `vkBindImageMemory2` from `VK_VERSION_1_1`
extern "system" fn dummy_vkBindImageMemory2(_: VkDevice, _: u32, _: *const VkBindImageMemoryInfo) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkBindImageMemory2"))
}
/// The dummy function for `vkGetDeviceGroupPeerMemoryFeatures` from `VK_VERSION_1_1`
extern "system" fn dummy_vkGetDeviceGroupPeerMemoryFeatures(_: VkDevice, _: u32, _: u32, _: u32, _: *mut VkPeerMemoryFeatureFlags) {
	panic_any(VkError::NullFunctionPointer("vkGetDeviceGroupPeerMemoryFeatures"))
}
/// The dummy function for `vkCmdSetDeviceMask` from `VK_VERSION_1_1`
extern "system" fn dummy_vkCmdSetDeviceMask(_: VkCommandBuffer, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetDeviceMask"))
}
/// The dummy function for `vkCmdDispatchBase` from `VK_VERSION_1_1`
extern "system" fn dummy_vkCmdDispatchBase(_: VkCommandBuffer, _: u32, _: u32, _: u32, _: u32, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdDispatchBase"))
}
/// The dummy function for `vkEnumeratePhysicalDeviceGroups` from `VK_VERSION_1_1`
extern "system" fn dummy_vkEnumeratePhysicalDeviceGroups(_: VkInstance, _: *mut uint32_t, _: *mut VkPhysicalDeviceGroupProperties) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkEnumeratePhysicalDeviceGroups"))
}
/// The dummy function for `vkGetImageMemoryRequirements2` from `VK_VERSION_1_1`
extern "system" fn dummy_vkGetImageMemoryRequirements2(_: VkDevice, _: *const VkImageMemoryRequirementsInfo2, _: *mut VkMemoryRequirements2) {
	panic_any(VkError::NullFunctionPointer("vkGetImageMemoryRequirements2"))
}
/// The dummy function for `vkGetBufferMemoryRequirements2` from `VK_VERSION_1_1`
extern "system" fn dummy_vkGetBufferMemoryRequirements2(_: VkDevice, _: *const VkBufferMemoryRequirementsInfo2, _: *mut VkMemoryRequirements2) {
	panic_any(VkError::NullFunctionPointer("vkGetBufferMemoryRequirements2"))
}
/// The dummy function for `vkGetImageSparseMemoryRequirements2` from `VK_VERSION_1_1`
extern "system" fn dummy_vkGetImageSparseMemoryRequirements2(_: VkDevice, _: *const VkImageSparseMemoryRequirementsInfo2, _: *mut uint32_t, _: *mut VkSparseImageMemoryRequirements2) {
	panic_any(VkError::NullFunctionPointer("vkGetImageSparseMemoryRequirements2"))
}
/// The dummy function for `vkGetPhysicalDeviceFeatures2` from `VK_VERSION_1_1`
extern "system" fn dummy_vkGetPhysicalDeviceFeatures2(_: VkPhysicalDevice, _: *mut VkPhysicalDeviceFeatures2) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceFeatures2"))
}
/// The dummy function for `vkGetPhysicalDeviceProperties2` from `VK_VERSION_1_1`
extern "system" fn dummy_vkGetPhysicalDeviceProperties2(_: VkPhysicalDevice, _: *mut VkPhysicalDeviceProperties2) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceProperties2"))
}
/// The dummy function for `vkGetPhysicalDeviceFormatProperties2` from `VK_VERSION_1_1`
extern "system" fn dummy_vkGetPhysicalDeviceFormatProperties2(_: VkPhysicalDevice, _: VkFormat, _: *mut VkFormatProperties2) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceFormatProperties2"))
}
/// The dummy function for `vkGetPhysicalDeviceImageFormatProperties2` from `VK_VERSION_1_1`
extern "system" fn dummy_vkGetPhysicalDeviceImageFormatProperties2(_: VkPhysicalDevice, _: *const VkPhysicalDeviceImageFormatInfo2, _: *mut VkImageFormatProperties2) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceImageFormatProperties2"))
}
/// The dummy function for `vkGetPhysicalDeviceQueueFamilyProperties2` from `VK_VERSION_1_1`
extern "system" fn dummy_vkGetPhysicalDeviceQueueFamilyProperties2(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkQueueFamilyProperties2) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceQueueFamilyProperties2"))
}
/// The dummy function for `vkGetPhysicalDeviceMemoryProperties2` from `VK_VERSION_1_1`
extern "system" fn dummy_vkGetPhysicalDeviceMemoryProperties2(_: VkPhysicalDevice, _: *mut VkPhysicalDeviceMemoryProperties2) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceMemoryProperties2"))
}
/// The dummy function for `vkGetPhysicalDeviceSparseImageFormatProperties2` from `VK_VERSION_1_1`
extern "system" fn dummy_vkGetPhysicalDeviceSparseImageFormatProperties2(_: VkPhysicalDevice, _: *const VkPhysicalDeviceSparseImageFormatInfo2, _: *mut uint32_t, _: *mut VkSparseImageFormatProperties2) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceSparseImageFormatProperties2"))
}
/// The dummy function for `vkTrimCommandPool` from `VK_VERSION_1_1`
extern "system" fn dummy_vkTrimCommandPool(_: VkDevice, _: VkCommandPool, _: VkCommandPoolTrimFlags) {
	panic_any(VkError::NullFunctionPointer("vkTrimCommandPool"))
}
/// The dummy function for `vkGetDeviceQueue2` from `VK_VERSION_1_1`
extern "system" fn dummy_vkGetDeviceQueue2(_: VkDevice, _: *const VkDeviceQueueInfo2, _: *mut VkQueue) {
	panic_any(VkError::NullFunctionPointer("vkGetDeviceQueue2"))
}
/// The dummy function for `vkCreateSamplerYcbcrConversion` from `VK_VERSION_1_1`
extern "system" fn dummy_vkCreateSamplerYcbcrConversion(_: VkDevice, _: *const VkSamplerYcbcrConversionCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkSamplerYcbcrConversion) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateSamplerYcbcrConversion"))
}
/// The dummy function for `vkDestroySamplerYcbcrConversion` from `VK_VERSION_1_1`
extern "system" fn dummy_vkDestroySamplerYcbcrConversion(_: VkDevice, _: VkSamplerYcbcrConversion, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroySamplerYcbcrConversion"))
}
/// The dummy function for `vkCreateDescriptorUpdateTemplate` from `VK_VERSION_1_1`
extern "system" fn dummy_vkCreateDescriptorUpdateTemplate(_: VkDevice, _: *const VkDescriptorUpdateTemplateCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkDescriptorUpdateTemplate) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateDescriptorUpdateTemplate"))
}
/// The dummy function for `vkDestroyDescriptorUpdateTemplate` from `VK_VERSION_1_1`
extern "system" fn dummy_vkDestroyDescriptorUpdateTemplate(_: VkDevice, _: VkDescriptorUpdateTemplate, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyDescriptorUpdateTemplate"))
}
/// The dummy function for `vkUpdateDescriptorSetWithTemplate` from `VK_VERSION_1_1`
extern "system" fn dummy_vkUpdateDescriptorSetWithTemplate(_: VkDevice, _: VkDescriptorSet, _: VkDescriptorUpdateTemplate, _: *const c_void) {
	panic_any(VkError::NullFunctionPointer("vkUpdateDescriptorSetWithTemplate"))
}
/// The dummy function for `vkGetPhysicalDeviceExternalBufferProperties` from `VK_VERSION_1_1`
extern "system" fn dummy_vkGetPhysicalDeviceExternalBufferProperties(_: VkPhysicalDevice, _: *const VkPhysicalDeviceExternalBufferInfo, _: *mut VkExternalBufferProperties) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceExternalBufferProperties"))
}
/// The dummy function for `vkGetPhysicalDeviceExternalFenceProperties` from `VK_VERSION_1_1`
extern "system" fn dummy_vkGetPhysicalDeviceExternalFenceProperties(_: VkPhysicalDevice, _: *const VkPhysicalDeviceExternalFenceInfo, _: *mut VkExternalFenceProperties) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceExternalFenceProperties"))
}
/// The dummy function for `vkGetPhysicalDeviceExternalSemaphoreProperties` from `VK_VERSION_1_1`
extern "system" fn dummy_vkGetPhysicalDeviceExternalSemaphoreProperties(_: VkPhysicalDevice, _: *const VkPhysicalDeviceExternalSemaphoreInfo, _: *mut VkExternalSemaphoreProperties) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceExternalSemaphoreProperties"))
}
/// The dummy function for `vkGetDescriptorSetLayoutSupport` from `VK_VERSION_1_1`
extern "system" fn dummy_vkGetDescriptorSetLayoutSupport(_: VkDevice, _: *const VkDescriptorSetLayoutCreateInfo, _: *mut VkDescriptorSetLayoutSupport) {
	panic_any(VkError::NullFunctionPointer("vkGetDescriptorSetLayoutSupport"))
}
/// trait for `VK_VERSION_1_1`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_VERSION_1_1.html>
pub trait VK_VERSION_1_1: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateInstanceVersion.html>
	fn vkEnumerateInstanceVersion(&self, pApiVersion: *mut uint32_t) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindBufferMemory2.html>
	fn vkBindBufferMemory2(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindBufferMemoryInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindImageMemory2.html>
	fn vkBindImageMemory2(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindImageMemoryInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceGroupPeerMemoryFeatures.html>
	fn vkGetDeviceGroupPeerMemoryFeatures(&self, device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDeviceMask.html>
	fn vkCmdSetDeviceMask(&self, commandBuffer: VkCommandBuffer, deviceMask: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchBase.html>
	fn vkCmdDispatchBase(&self, commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceGroups.html>
	fn vkEnumeratePhysicalDeviceGroups(&self, instance: VkInstance, pPhysicalDeviceGroupCount: *mut uint32_t, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageMemoryRequirements2.html>
	fn vkGetImageMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkImageMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferMemoryRequirements2.html>
	fn vkGetBufferMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSparseMemoryRequirements2.html>
	fn vkGetImageSparseMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures2.html>
	fn vkGetPhysicalDeviceFeatures2(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceProperties2.html>
	fn vkGetPhysicalDeviceProperties2(&self, physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFormatProperties2.html>
	fn vkGetPhysicalDeviceFormatProperties2(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceImageFormatProperties2.html>
	fn vkGetPhysicalDeviceImageFormatProperties2(&self, physicalDevice: VkPhysicalDevice, pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *mut VkImageFormatProperties2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties2.html>
	fn vkGetPhysicalDeviceQueueFamilyProperties2(&self, physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMemoryProperties2.html>
	fn vkGetPhysicalDeviceMemoryProperties2(&self, physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2.html>
	fn vkGetPhysicalDeviceSparseImageFormatProperties2(&self, physicalDevice: VkPhysicalDevice, pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkTrimCommandPool.html>
	fn vkTrimCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceQueue2.html>
	fn vkGetDeviceQueue2(&self, device: VkDevice, pQueueInfo: *const VkDeviceQueueInfo2, pQueue: *mut VkQueue) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSamplerYcbcrConversion.html>
	fn vkCreateSamplerYcbcrConversion(&self, device: VkDevice, pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo, pAllocator: *const VkAllocationCallbacks, pYcbcrConversion: *mut VkSamplerYcbcrConversion) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySamplerYcbcrConversion.html>
	fn vkDestroySamplerYcbcrConversion(&self, device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorUpdateTemplate.html>
	fn vkCreateDescriptorUpdateTemplate(&self, device: VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorUpdateTemplate.html>
	fn vkDestroyDescriptorUpdateTemplate(&self, device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSetWithTemplate.html>
	fn vkUpdateDescriptorSetWithTemplate(&self, device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: *const c_void) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalBufferProperties.html>
	fn vkGetPhysicalDeviceExternalBufferProperties(&self, physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut VkExternalBufferProperties) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalFenceProperties.html>
	fn vkGetPhysicalDeviceExternalFenceProperties(&self, physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut VkExternalFenceProperties) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalSemaphoreProperties.html>
	fn vkGetPhysicalDeviceExternalSemaphoreProperties(&self, physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutSupport.html>
	fn vkGetDescriptorSetLayoutSupport(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pSupport: *mut VkDescriptorSetLayoutSupport) -> Result<()>;
}
/// struct for `VK_VERSION_1_1`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_VERSION_1_1 {
	vk_enumerate_instance_version: PFN_vkEnumerateInstanceVersion,
	vk_bind_buffer_memory2: PFN_vkBindBufferMemory2,
	vk_bind_image_memory2: PFN_vkBindImageMemory2,
	vk_get_device_group_peer_memory_features: PFN_vkGetDeviceGroupPeerMemoryFeatures,
	vk_cmd_set_device_mask: PFN_vkCmdSetDeviceMask,
	vk_cmd_dispatch_base: PFN_vkCmdDispatchBase,
	vk_enumerate_physical_device_groups: PFN_vkEnumeratePhysicalDeviceGroups,
	vk_get_image_memory_requirements2: PFN_vkGetImageMemoryRequirements2,
	vk_get_buffer_memory_requirements2: PFN_vkGetBufferMemoryRequirements2,
	vk_get_image_sparse_memory_requirements2: PFN_vkGetImageSparseMemoryRequirements2,
	vk_get_physical_device_features2: PFN_vkGetPhysicalDeviceFeatures2,
	vk_get_physical_device_properties2: PFN_vkGetPhysicalDeviceProperties2,
	vk_get_physical_device_format_properties2: PFN_vkGetPhysicalDeviceFormatProperties2,
	vk_get_physical_device_image_format_properties2: PFN_vkGetPhysicalDeviceImageFormatProperties2,
	vk_get_physical_device_queue_family_properties2: PFN_vkGetPhysicalDeviceQueueFamilyProperties2,
	vk_get_physical_device_memory_properties2: PFN_vkGetPhysicalDeviceMemoryProperties2,
	vk_get_physical_device_sparse_image_format_properties2: PFN_vkGetPhysicalDeviceSparseImageFormatProperties2,
	vk_trim_command_pool: PFN_vkTrimCommandPool,
	vk_get_device_queue2: PFN_vkGetDeviceQueue2,
	vk_create_sampler_ycbcr_conversion: PFN_vkCreateSamplerYcbcrConversion,
	vk_destroy_sampler_ycbcr_conversion: PFN_vkDestroySamplerYcbcrConversion,
	vk_create_descriptor_update_template: PFN_vkCreateDescriptorUpdateTemplate,
	vk_destroy_descriptor_update_template: PFN_vkDestroyDescriptorUpdateTemplate,
	vk_update_descriptor_set_with_template: PFN_vkUpdateDescriptorSetWithTemplate,
	vk_get_physical_device_external_buffer_properties: PFN_vkGetPhysicalDeviceExternalBufferProperties,
	vk_get_physical_device_external_fence_properties: PFN_vkGetPhysicalDeviceExternalFenceProperties,
	vk_get_physical_device_external_semaphore_properties: PFN_vkGetPhysicalDeviceExternalSemaphoreProperties,
	vk_get_descriptor_set_layout_support: PFN_vkGetDescriptorSetLayoutSupport,
}
impl VK_VERSION_1_1 for Vulkan_VERSION_1_1 {
	fn vkEnumerateInstanceVersion(&self, pApiVersion: *mut uint32_t) -> Result<()> {
		convert_result("vkEnumerateInstanceVersion", catch_unwind(||((self.vk_enumerate_instance_version)(pApiVersion))))
	}
	fn vkBindBufferMemory2(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindBufferMemoryInfo) -> Result<()> {
		convert_result("vkBindBufferMemory2", catch_unwind(||((self.vk_bind_buffer_memory2)(device, bindInfoCount, pBindInfos))))
	}
	fn vkBindImageMemory2(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindImageMemoryInfo) -> Result<()> {
		convert_result("vkBindImageMemory2", catch_unwind(||((self.vk_bind_image_memory2)(device, bindInfoCount, pBindInfos))))
	}
	fn vkGetDeviceGroupPeerMemoryFeatures(&self, device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_device_group_peer_memory_features)(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures))))
	}
	fn vkCmdSetDeviceMask(&self, commandBuffer: VkCommandBuffer, deviceMask: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_device_mask)(commandBuffer, deviceMask))))
	}
	fn vkCmdDispatchBase(&self, commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_dispatch_base)(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ))))
	}
	fn vkEnumeratePhysicalDeviceGroups(&self, instance: VkInstance, pPhysicalDeviceGroupCount: *mut uint32_t, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties) -> Result<()> {
		convert_result("vkEnumeratePhysicalDeviceGroups", catch_unwind(||((self.vk_enumerate_physical_device_groups)(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties))))
	}
	fn vkGetImageMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkImageMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_image_memory_requirements2)(device, pInfo, pMemoryRequirements))))
	}
	fn vkGetBufferMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_buffer_memory_requirements2)(device, pInfo, pMemoryRequirements))))
	}
	fn vkGetImageSparseMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_image_sparse_memory_requirements2)(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements))))
	}
	fn vkGetPhysicalDeviceFeatures2(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_features2)(physicalDevice, pFeatures))))
	}
	fn vkGetPhysicalDeviceProperties2(&self, physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_properties2)(physicalDevice, pProperties))))
	}
	fn vkGetPhysicalDeviceFormatProperties2(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_format_properties2)(physicalDevice, format, pFormatProperties))))
	}
	fn vkGetPhysicalDeviceImageFormatProperties2(&self, physicalDevice: VkPhysicalDevice, pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *mut VkImageFormatProperties2) -> Result<()> {
		convert_result("vkGetPhysicalDeviceImageFormatProperties2", catch_unwind(||((self.vk_get_physical_device_image_format_properties2)(physicalDevice, pImageFormatInfo, pImageFormatProperties))))
	}
	fn vkGetPhysicalDeviceQueueFamilyProperties2(&self, physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_queue_family_properties2)(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties))))
	}
	fn vkGetPhysicalDeviceMemoryProperties2(&self, physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_memory_properties2)(physicalDevice, pMemoryProperties))))
	}
	fn vkGetPhysicalDeviceSparseImageFormatProperties2(&self, physicalDevice: VkPhysicalDevice, pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_sparse_image_format_properties2)(physicalDevice, pFormatInfo, pPropertyCount, pProperties))))
	}
	fn vkTrimCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_trim_command_pool)(device, commandPool, flags))))
	}
	fn vkGetDeviceQueue2(&self, device: VkDevice, pQueueInfo: *const VkDeviceQueueInfo2, pQueue: *mut VkQueue) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_device_queue2)(device, pQueueInfo, pQueue))))
	}
	fn vkCreateSamplerYcbcrConversion(&self, device: VkDevice, pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo, pAllocator: *const VkAllocationCallbacks, pYcbcrConversion: *mut VkSamplerYcbcrConversion) -> Result<()> {
		convert_result("vkCreateSamplerYcbcrConversion", catch_unwind(||((self.vk_create_sampler_ycbcr_conversion)(device, pCreateInfo, pAllocator, pYcbcrConversion))))
	}
	fn vkDestroySamplerYcbcrConversion(&self, device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_sampler_ycbcr_conversion)(device, ycbcrConversion, pAllocator))))
	}
	fn vkCreateDescriptorUpdateTemplate(&self, device: VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate) -> Result<()> {
		convert_result("vkCreateDescriptorUpdateTemplate", catch_unwind(||((self.vk_create_descriptor_update_template)(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate))))
	}
	fn vkDestroyDescriptorUpdateTemplate(&self, device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_descriptor_update_template)(device, descriptorUpdateTemplate, pAllocator))))
	}
	fn vkUpdateDescriptorSetWithTemplate(&self, device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: *const c_void) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_update_descriptor_set_with_template)(device, descriptorSet, descriptorUpdateTemplate, pData))))
	}
	fn vkGetPhysicalDeviceExternalBufferProperties(&self, physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut VkExternalBufferProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_external_buffer_properties)(physicalDevice, pExternalBufferInfo, pExternalBufferProperties))))
	}
	fn vkGetPhysicalDeviceExternalFenceProperties(&self, physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut VkExternalFenceProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_external_fence_properties)(physicalDevice, pExternalFenceInfo, pExternalFenceProperties))))
	}
	fn vkGetPhysicalDeviceExternalSemaphoreProperties(&self, physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_external_semaphore_properties)(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties))))
	}
	fn vkGetDescriptorSetLayoutSupport(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pSupport: *mut VkDescriptorSetLayoutSupport) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_descriptor_set_layout_support)(device, pCreateInfo, pSupport))))
	}
}
impl Default for Vulkan_VERSION_1_1 {
	fn default() -> Self {
		Self {
			vk_enumerate_instance_version: dummy_vkEnumerateInstanceVersion,
			vk_bind_buffer_memory2: dummy_vkBindBufferMemory2,
			vk_bind_image_memory2: dummy_vkBindImageMemory2,
			vk_get_device_group_peer_memory_features: dummy_vkGetDeviceGroupPeerMemoryFeatures,
			vk_cmd_set_device_mask: dummy_vkCmdSetDeviceMask,
			vk_cmd_dispatch_base: dummy_vkCmdDispatchBase,
			vk_enumerate_physical_device_groups: dummy_vkEnumeratePhysicalDeviceGroups,
			vk_get_image_memory_requirements2: dummy_vkGetImageMemoryRequirements2,
			vk_get_buffer_memory_requirements2: dummy_vkGetBufferMemoryRequirements2,
			vk_get_image_sparse_memory_requirements2: dummy_vkGetImageSparseMemoryRequirements2,
			vk_get_physical_device_features2: dummy_vkGetPhysicalDeviceFeatures2,
			vk_get_physical_device_properties2: dummy_vkGetPhysicalDeviceProperties2,
			vk_get_physical_device_format_properties2: dummy_vkGetPhysicalDeviceFormatProperties2,
			vk_get_physical_device_image_format_properties2: dummy_vkGetPhysicalDeviceImageFormatProperties2,
			vk_get_physical_device_queue_family_properties2: dummy_vkGetPhysicalDeviceQueueFamilyProperties2,
			vk_get_physical_device_memory_properties2: dummy_vkGetPhysicalDeviceMemoryProperties2,
			vk_get_physical_device_sparse_image_format_properties2: dummy_vkGetPhysicalDeviceSparseImageFormatProperties2,
			vk_trim_command_pool: dummy_vkTrimCommandPool,
			vk_get_device_queue2: dummy_vkGetDeviceQueue2,
			vk_create_sampler_ycbcr_conversion: dummy_vkCreateSamplerYcbcrConversion,
			vk_destroy_sampler_ycbcr_conversion: dummy_vkDestroySamplerYcbcrConversion,
			vk_create_descriptor_update_template: dummy_vkCreateDescriptorUpdateTemplate,
			vk_destroy_descriptor_update_template: dummy_vkDestroyDescriptorUpdateTemplate,
			vk_update_descriptor_set_with_template: dummy_vkUpdateDescriptorSetWithTemplate,
			vk_get_physical_device_external_buffer_properties: dummy_vkGetPhysicalDeviceExternalBufferProperties,
			vk_get_physical_device_external_fence_properties: dummy_vkGetPhysicalDeviceExternalFenceProperties,
			vk_get_physical_device_external_semaphore_properties: dummy_vkGetPhysicalDeviceExternalSemaphoreProperties,
			vk_get_descriptor_set_layout_support: dummy_vkGetDescriptorSetLayoutSupport,
		}
	}
}
impl Vulkan_VERSION_1_1 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_enumerate_instance_version: {let proc = get_instance_proc_address(instance, "vkEnumerateInstanceVersion"); if proc == null() {dummy_vkEnumerateInstanceVersion} else {unsafe {transmute(proc)}}},
			vk_bind_buffer_memory2: {let proc = get_instance_proc_address(instance, "vkBindBufferMemory2"); if proc == null() {dummy_vkBindBufferMemory2} else {unsafe {transmute(proc)}}},
			vk_bind_image_memory2: {let proc = get_instance_proc_address(instance, "vkBindImageMemory2"); if proc == null() {dummy_vkBindImageMemory2} else {unsafe {transmute(proc)}}},
			vk_get_device_group_peer_memory_features: {let proc = get_instance_proc_address(instance, "vkGetDeviceGroupPeerMemoryFeatures"); if proc == null() {dummy_vkGetDeviceGroupPeerMemoryFeatures} else {unsafe {transmute(proc)}}},
			vk_cmd_set_device_mask: {let proc = get_instance_proc_address(instance, "vkCmdSetDeviceMask"); if proc == null() {dummy_vkCmdSetDeviceMask} else {unsafe {transmute(proc)}}},
			vk_cmd_dispatch_base: {let proc = get_instance_proc_address(instance, "vkCmdDispatchBase"); if proc == null() {dummy_vkCmdDispatchBase} else {unsafe {transmute(proc)}}},
			vk_enumerate_physical_device_groups: {let proc = get_instance_proc_address(instance, "vkEnumeratePhysicalDeviceGroups"); if proc == null() {dummy_vkEnumeratePhysicalDeviceGroups} else {unsafe {transmute(proc)}}},
			vk_get_image_memory_requirements2: {let proc = get_instance_proc_address(instance, "vkGetImageMemoryRequirements2"); if proc == null() {dummy_vkGetImageMemoryRequirements2} else {unsafe {transmute(proc)}}},
			vk_get_buffer_memory_requirements2: {let proc = get_instance_proc_address(instance, "vkGetBufferMemoryRequirements2"); if proc == null() {dummy_vkGetBufferMemoryRequirements2} else {unsafe {transmute(proc)}}},
			vk_get_image_sparse_memory_requirements2: {let proc = get_instance_proc_address(instance, "vkGetImageSparseMemoryRequirements2"); if proc == null() {dummy_vkGetImageSparseMemoryRequirements2} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_features2: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceFeatures2"); if proc == null() {dummy_vkGetPhysicalDeviceFeatures2} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_properties2: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceProperties2"); if proc == null() {dummy_vkGetPhysicalDeviceProperties2} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_format_properties2: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceFormatProperties2"); if proc == null() {dummy_vkGetPhysicalDeviceFormatProperties2} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_image_format_properties2: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceImageFormatProperties2"); if proc == null() {dummy_vkGetPhysicalDeviceImageFormatProperties2} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_queue_family_properties2: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceQueueFamilyProperties2"); if proc == null() {dummy_vkGetPhysicalDeviceQueueFamilyProperties2} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_memory_properties2: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceMemoryProperties2"); if proc == null() {dummy_vkGetPhysicalDeviceMemoryProperties2} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_sparse_image_format_properties2: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceSparseImageFormatProperties2"); if proc == null() {dummy_vkGetPhysicalDeviceSparseImageFormatProperties2} else {unsafe {transmute(proc)}}},
			vk_trim_command_pool: {let proc = get_instance_proc_address(instance, "vkTrimCommandPool"); if proc == null() {dummy_vkTrimCommandPool} else {unsafe {transmute(proc)}}},
			vk_get_device_queue2: {let proc = get_instance_proc_address(instance, "vkGetDeviceQueue2"); if proc == null() {dummy_vkGetDeviceQueue2} else {unsafe {transmute(proc)}}},
			vk_create_sampler_ycbcr_conversion: {let proc = get_instance_proc_address(instance, "vkCreateSamplerYcbcrConversion"); if proc == null() {dummy_vkCreateSamplerYcbcrConversion} else {unsafe {transmute(proc)}}},
			vk_destroy_sampler_ycbcr_conversion: {let proc = get_instance_proc_address(instance, "vkDestroySamplerYcbcrConversion"); if proc == null() {dummy_vkDestroySamplerYcbcrConversion} else {unsafe {transmute(proc)}}},
			vk_create_descriptor_update_template: {let proc = get_instance_proc_address(instance, "vkCreateDescriptorUpdateTemplate"); if proc == null() {dummy_vkCreateDescriptorUpdateTemplate} else {unsafe {transmute(proc)}}},
			vk_destroy_descriptor_update_template: {let proc = get_instance_proc_address(instance, "vkDestroyDescriptorUpdateTemplate"); if proc == null() {dummy_vkDestroyDescriptorUpdateTemplate} else {unsafe {transmute(proc)}}},
			vk_update_descriptor_set_with_template: {let proc = get_instance_proc_address(instance, "vkUpdateDescriptorSetWithTemplate"); if proc == null() {dummy_vkUpdateDescriptorSetWithTemplate} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_external_buffer_properties: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceExternalBufferProperties"); if proc == null() {dummy_vkGetPhysicalDeviceExternalBufferProperties} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_external_fence_properties: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceExternalFenceProperties"); if proc == null() {dummy_vkGetPhysicalDeviceExternalFenceProperties} else {unsafe {transmute(proc)}}},
			vk_get_physical_device_external_semaphore_properties: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceExternalSemaphoreProperties"); if proc == null() {dummy_vkGetPhysicalDeviceExternalSemaphoreProperties} else {unsafe {transmute(proc)}}},
			vk_get_descriptor_set_layout_support: {let proc = get_instance_proc_address(instance, "vkGetDescriptorSetLayoutSupport"); if proc == null() {dummy_vkGetDescriptorSetLayoutSupport} else {unsafe {transmute(proc)}}},
		}
	}
}
/// constant `VK_API_VERSION_1_2` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_API_VERSION_1_2.html>
pub const VK_API_VERSION_1_2: u32 = 0x402000;
/// constant `VK_MAX_DRIVER_NAME_SIZE` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_DRIVER_NAME_SIZE.html>
pub const VK_MAX_DRIVER_NAME_SIZE: u32 = 256u32;
/// constant `VK_MAX_DRIVER_INFO_SIZE` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_DRIVER_INFO_SIZE.html>
pub const VK_MAX_DRIVER_INFO_SIZE: u32 = 256u32;
/// type definition `VkResolveModeFlags` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkResolveModeFlags.html>
pub type VkResolveModeFlags = VkFlags;
pub fn vk_resolve_mode_flags_to_string(value: VkResolveModeFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(13);
	if (value & VkResolveModeFlagBits::VK_RESOLVE_MODE_NONE as VkResolveModeFlags) == VkResolveModeFlagBits::VK_RESOLVE_MODE_NONE as VkResolveModeFlags {
		flags.push("VkResolveModeFlagBits::VK_RESOLVE_MODE_NONE");
	}
	if (value & VkResolveModeFlagBits::VK_RESOLVE_MODE_SAMPLE_ZERO_BIT as VkResolveModeFlags) == VkResolveModeFlagBits::VK_RESOLVE_MODE_SAMPLE_ZERO_BIT as VkResolveModeFlags {
		flags.push("VkResolveModeFlagBits::VK_RESOLVE_MODE_SAMPLE_ZERO_BIT");
	}
	if (value & VkResolveModeFlagBits::VK_RESOLVE_MODE_AVERAGE_BIT as VkResolveModeFlags) == VkResolveModeFlagBits::VK_RESOLVE_MODE_AVERAGE_BIT as VkResolveModeFlags {
		flags.push("VkResolveModeFlagBits::VK_RESOLVE_MODE_AVERAGE_BIT");
	}
	if (value & VkResolveModeFlagBits::VK_RESOLVE_MODE_MIN_BIT as VkResolveModeFlags) == VkResolveModeFlagBits::VK_RESOLVE_MODE_MIN_BIT as VkResolveModeFlags {
		flags.push("VkResolveModeFlagBits::VK_RESOLVE_MODE_MIN_BIT");
	}
	if (value & VkResolveModeFlagBits::VK_RESOLVE_MODE_MAX_BIT as VkResolveModeFlags) == VkResolveModeFlagBits::VK_RESOLVE_MODE_MAX_BIT as VkResolveModeFlags {
		flags.push("VkResolveModeFlagBits::VK_RESOLVE_MODE_MAX_BIT");
	}
	if (value & VkResolveModeFlagBits::VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID as VkResolveModeFlags) == VkResolveModeFlagBits::VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID as VkResolveModeFlags {
		flags.push("VkResolveModeFlagBits::VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID");
	}
	if (value & VkResolveModeFlagBits::VK_RESOLVE_MODE_NONE_KHR as VkResolveModeFlags) == VkResolveModeFlagBits::VK_RESOLVE_MODE_NONE_KHR as VkResolveModeFlags {
		flags.push("VkResolveModeFlagBits::VK_RESOLVE_MODE_NONE_KHR");
	}
	if (value & VkResolveModeFlagBits::VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR as VkResolveModeFlags) == VkResolveModeFlagBits::VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR as VkResolveModeFlags {
		flags.push("VkResolveModeFlagBits::VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR");
	}
	if (value & VkResolveModeFlagBits::VK_RESOLVE_MODE_AVERAGE_BIT_KHR as VkResolveModeFlags) == VkResolveModeFlagBits::VK_RESOLVE_MODE_AVERAGE_BIT_KHR as VkResolveModeFlags {
		flags.push("VkResolveModeFlagBits::VK_RESOLVE_MODE_AVERAGE_BIT_KHR");
	}
	if (value & VkResolveModeFlagBits::VK_RESOLVE_MODE_MIN_BIT_KHR as VkResolveModeFlags) == VkResolveModeFlagBits::VK_RESOLVE_MODE_MIN_BIT_KHR as VkResolveModeFlags {
		flags.push("VkResolveModeFlagBits::VK_RESOLVE_MODE_MIN_BIT_KHR");
	}
	if (value & VkResolveModeFlagBits::VK_RESOLVE_MODE_MAX_BIT_KHR as VkResolveModeFlags) == VkResolveModeFlagBits::VK_RESOLVE_MODE_MAX_BIT_KHR as VkResolveModeFlags {
		flags.push("VkResolveModeFlagBits::VK_RESOLVE_MODE_MAX_BIT_KHR");
	}
	if (value & VkResolveModeFlagBits::VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID as VkResolveModeFlags) == VkResolveModeFlagBits::VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID as VkResolveModeFlags {
		flags.push("VkResolveModeFlagBits::VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID");
	}
	if (value & VkResolveModeFlagBits::VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM as VkResolveModeFlags) == VkResolveModeFlagBits::VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM as VkResolveModeFlags {
		flags.push("VkResolveModeFlagBits::VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkDescriptorBindingFlags` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorBindingFlags.html>
pub type VkDescriptorBindingFlags = VkFlags;
pub fn vk_descriptor_binding_flags_to_string(value: VkDescriptorBindingFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(9);
	if (value & VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT as VkDescriptorBindingFlags) == VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT as VkDescriptorBindingFlags {
		flags.push("VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT");
	}
	if (value & VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT as VkDescriptorBindingFlags) == VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT as VkDescriptorBindingFlags {
		flags.push("VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT");
	}
	if (value & VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT as VkDescriptorBindingFlags) == VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT as VkDescriptorBindingFlags {
		flags.push("VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT");
	}
	if (value & VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT as VkDescriptorBindingFlags) == VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT as VkDescriptorBindingFlags {
		flags.push("VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT");
	}
	if (value & VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT as VkDescriptorBindingFlags) == VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT as VkDescriptorBindingFlags {
		flags.push("VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT");
	}
	if (value & VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT as VkDescriptorBindingFlags) == VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT as VkDescriptorBindingFlags {
		flags.push("VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT");
	}
	if (value & VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT as VkDescriptorBindingFlags) == VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT as VkDescriptorBindingFlags {
		flags.push("VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT");
	}
	if (value & VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT as VkDescriptorBindingFlags) == VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT as VkDescriptorBindingFlags {
		flags.push("VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT");
	}
	if (value & VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM as VkDescriptorBindingFlags) == VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM as VkDescriptorBindingFlags {
		flags.push("VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkSemaphoreWaitFlags` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreWaitFlags.html>
pub type VkSemaphoreWaitFlags = VkFlags;
pub fn vk_semaphore_wait_flags_to_string(value: VkSemaphoreWaitFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(3);
	if (value & VkSemaphoreWaitFlagBits::VK_SEMAPHORE_WAIT_ANY_BIT as VkSemaphoreWaitFlags) == VkSemaphoreWaitFlagBits::VK_SEMAPHORE_WAIT_ANY_BIT as VkSemaphoreWaitFlags {
		flags.push("VkSemaphoreWaitFlagBits::VK_SEMAPHORE_WAIT_ANY_BIT");
	}
	if (value & VkSemaphoreWaitFlagBits::VK_SEMAPHORE_WAIT_ANY_BIT_KHR as VkSemaphoreWaitFlags) == VkSemaphoreWaitFlagBits::VK_SEMAPHORE_WAIT_ANY_BIT_KHR as VkSemaphoreWaitFlags {
		flags.push("VkSemaphoreWaitFlagBits::VK_SEMAPHORE_WAIT_ANY_BIT_KHR");
	}
	if (value & VkSemaphoreWaitFlagBits::VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM as VkSemaphoreWaitFlags) == VkSemaphoreWaitFlagBits::VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM as VkSemaphoreWaitFlags {
		flags.push("VkSemaphoreWaitFlagBits::VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// enum `VkDriverId` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDriverId.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDriverId {
	VK_DRIVER_ID_AMD_PROPRIETARY = 1,
	VK_DRIVER_ID_AMD_OPEN_SOURCE = 2,
	VK_DRIVER_ID_MESA_RADV = 3,
	VK_DRIVER_ID_NVIDIA_PROPRIETARY = 4,
	VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5,
	VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6,
	VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 7,
	VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 8,
	VK_DRIVER_ID_ARM_PROPRIETARY = 9,
	VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 10,
	VK_DRIVER_ID_GGP_PROPRIETARY = 11,
	VK_DRIVER_ID_BROADCOM_PROPRIETARY = 12,
	VK_DRIVER_ID_MESA_LLVMPIPE = 13,
	VK_DRIVER_ID_MOLTENVK = 14,
	VK_DRIVER_ID_COREAVI_PROPRIETARY = 15,
	VK_DRIVER_ID_JUICE_PROPRIETARY = 16,
	VK_DRIVER_ID_VERISILICON_PROPRIETARY = 17,
	VK_DRIVER_ID_MESA_TURNIP = 18,
	VK_DRIVER_ID_MESA_V3DV = 19,
	VK_DRIVER_ID_MESA_PANVK = 20,
	VK_DRIVER_ID_SAMSUNG_PROPRIETARY = 21,
	VK_DRIVER_ID_MESA_VENUS = 22,
	VK_DRIVER_ID_MESA_DOZEN = 23,
	VK_DRIVER_ID_MESA_NVK = 24,
	VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA = 25,
	VK_DRIVER_ID_MESA_HONEYKRISP = 26,
	VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN = 27,
	VK_DRIVER_ID_MAX_ENUM = 0x7fffffff,
}
impl VkDriverId {
	pub const VK_DRIVER_ID_AMD_PROPRIETARY_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_AMD_PROPRIETARY;
	pub const VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_AMD_OPEN_SOURCE;
	pub const VK_DRIVER_ID_MESA_RADV_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_MESA_RADV;
	pub const VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_NVIDIA_PROPRIETARY;
	pub const VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS;
	pub const VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA;
	pub const VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_IMAGINATION_PROPRIETARY;
	pub const VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_QUALCOMM_PROPRIETARY;
	pub const VK_DRIVER_ID_ARM_PROPRIETARY_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_ARM_PROPRIETARY;
	pub const VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_GOOGLE_SWIFTSHADER;
	pub const VK_DRIVER_ID_GGP_PROPRIETARY_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_GGP_PROPRIETARY;
	pub const VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR: VkDriverId = VkDriverId::VK_DRIVER_ID_BROADCOM_PROPRIETARY;
}
/// enum `VkShaderFloatControlsIndependence` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderFloatControlsIndependence.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkShaderFloatControlsIndependence {
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2,
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM = 0x7fffffff,
}
impl VkShaderFloatControlsIndependence {
	pub const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR: VkShaderFloatControlsIndependence = VkShaderFloatControlsIndependence::VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY;
	pub const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR: VkShaderFloatControlsIndependence = VkShaderFloatControlsIndependence::VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL;
	pub const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR: VkShaderFloatControlsIndependence = VkShaderFloatControlsIndependence::VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE;
}
/// enum `VkSamplerReductionMode` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerReductionMode.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSamplerReductionMode {
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0,
	VK_SAMPLER_REDUCTION_MODE_MIN = 1,
	VK_SAMPLER_REDUCTION_MODE_MAX = 2,
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM = 1000521000,
	VK_SAMPLER_REDUCTION_MODE_MAX_ENUM = 0x7fffffff,
}
impl VkSamplerReductionMode {
	pub const VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT: VkSamplerReductionMode = VkSamplerReductionMode::VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE;
	pub const VK_SAMPLER_REDUCTION_MODE_MIN_EXT: VkSamplerReductionMode = VkSamplerReductionMode::VK_SAMPLER_REDUCTION_MODE_MIN;
	pub const VK_SAMPLER_REDUCTION_MODE_MAX_EXT: VkSamplerReductionMode = VkSamplerReductionMode::VK_SAMPLER_REDUCTION_MODE_MAX;
}
/// enum `VkSemaphoreType` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreType.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSemaphoreType {
	VK_SEMAPHORE_TYPE_BINARY = 0,
	VK_SEMAPHORE_TYPE_TIMELINE = 1,
	VK_SEMAPHORE_TYPE_MAX_ENUM = 0x7fffffff,
}
impl VkSemaphoreType {
	pub const VK_SEMAPHORE_TYPE_BINARY_KHR: VkSemaphoreType = VkSemaphoreType::VK_SEMAPHORE_TYPE_BINARY;
	pub const VK_SEMAPHORE_TYPE_TIMELINE_KHR: VkSemaphoreType = VkSemaphoreType::VK_SEMAPHORE_TYPE_TIMELINE;
}
/// enum `VkResolveModeFlagBits` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkResolveModeFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkResolveModeFlagBits {
	VK_RESOLVE_MODE_NONE = 0,
	VK_RESOLVE_MODE_SAMPLE_ZERO_BIT = 0x00000001,
	VK_RESOLVE_MODE_AVERAGE_BIT = 0x00000002,
	VK_RESOLVE_MODE_MIN_BIT = 0x00000004,
	VK_RESOLVE_MODE_MAX_BIT = 0x00000008,
	VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID = 0x00000010,
	VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkResolveModeFlagBits {
	pub const VK_RESOLVE_MODE_NONE_KHR: VkResolveModeFlagBits = VkResolveModeFlagBits::VK_RESOLVE_MODE_NONE;
	pub const VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR: VkResolveModeFlagBits = VkResolveModeFlagBits::VK_RESOLVE_MODE_SAMPLE_ZERO_BIT;
	pub const VK_RESOLVE_MODE_AVERAGE_BIT_KHR: VkResolveModeFlagBits = VkResolveModeFlagBits::VK_RESOLVE_MODE_AVERAGE_BIT;
	pub const VK_RESOLVE_MODE_MIN_BIT_KHR: VkResolveModeFlagBits = VkResolveModeFlagBits::VK_RESOLVE_MODE_MIN_BIT;
	pub const VK_RESOLVE_MODE_MAX_BIT_KHR: VkResolveModeFlagBits = VkResolveModeFlagBits::VK_RESOLVE_MODE_MAX_BIT;
	pub const VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID: VkResolveModeFlagBits = VkResolveModeFlagBits::VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID;
}
/// enum `VkDescriptorBindingFlagBits` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorBindingFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDescriptorBindingFlagBits {
	VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = 0x00000001,
	VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = 0x00000002,
	VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = 0x00000004,
	VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = 0x00000008,
	VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkDescriptorBindingFlagBits {
	pub const VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT: VkDescriptorBindingFlagBits = VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT;
	pub const VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT: VkDescriptorBindingFlagBits = VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT;
	pub const VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT: VkDescriptorBindingFlagBits = VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT;
	pub const VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT: VkDescriptorBindingFlagBits = VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT;
}
/// enum `VkSemaphoreWaitFlagBits` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreWaitFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSemaphoreWaitFlagBits {
	VK_SEMAPHORE_WAIT_ANY_BIT = 0x00000001,
	VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkSemaphoreWaitFlagBits {
	pub const VK_SEMAPHORE_WAIT_ANY_BIT_KHR: VkSemaphoreWaitFlagBits = VkSemaphoreWaitFlagBits::VK_SEMAPHORE_WAIT_ANY_BIT;
}
/// struct `VkPhysicalDeviceVulkan11Features` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVulkan11Features.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVulkan11Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub storageBuffer16BitAccess: VkBool32,
	pub uniformAndStorageBuffer16BitAccess: VkBool32,
	pub storagePushConstant16: VkBool32,
	pub storageInputOutput16: VkBool32,
	pub multiview: VkBool32,
	pub multiviewGeometryShader: VkBool32,
	pub multiviewTessellationShader: VkBool32,
	pub variablePointersStorageBuffer: VkBool32,
	pub variablePointers: VkBool32,
	pub protectedMemory: VkBool32,
	pub samplerYcbcrConversion: VkBool32,
	pub shaderDrawParameters: VkBool32,
}
impl Debug for VkPhysicalDeviceVulkan11Features {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVulkan11Features")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("storageBuffer16BitAccess", &self.storageBuffer16BitAccess)
		.field("uniformAndStorageBuffer16BitAccess", &self.uniformAndStorageBuffer16BitAccess)
		.field("storagePushConstant16", &self.storagePushConstant16)
		.field("storageInputOutput16", &self.storageInputOutput16)
		.field("multiview", &self.multiview)
		.field("multiviewGeometryShader", &self.multiviewGeometryShader)
		.field("multiviewTessellationShader", &self.multiviewTessellationShader)
		.field("variablePointersStorageBuffer", &self.variablePointersStorageBuffer)
		.field("variablePointers", &self.variablePointers)
		.field("protectedMemory", &self.protectedMemory)
		.field("samplerYcbcrConversion", &self.samplerYcbcrConversion)
		.field("shaderDrawParameters", &self.shaderDrawParameters)
		.finish()
	}
}
/// struct `VkPhysicalDeviceVulkan11Properties` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVulkan11Properties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVulkan11Properties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceUUID: [u8; VK_UUID_SIZE as usize],
	pub driverUUID: [u8; VK_UUID_SIZE as usize],
	pub deviceLUID: [u8; VK_LUID_SIZE as usize],
	pub deviceNodeMask: u32,
	pub deviceLUIDValid: VkBool32,
	pub subgroupSize: u32,
	pub subgroupSupportedStages: VkShaderStageFlags,
	pub subgroupSupportedOperations: VkSubgroupFeatureFlags,
	pub subgroupQuadOperationsInAllStages: VkBool32,
	pub pointClippingBehavior: VkPointClippingBehavior,
	pub maxMultiviewViewCount: u32,
	pub maxMultiviewInstanceIndex: u32,
	pub protectedNoFault: VkBool32,
	pub maxPerSetDescriptors: u32,
	pub maxMemoryAllocationSize: VkDeviceSize,
}
impl Debug for VkPhysicalDeviceVulkan11Properties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVulkan11Properties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceUUID", &self.deviceUUID)
		.field("driverUUID", &self.driverUUID)
		.field("deviceLUID", &self.deviceLUID)
		.field("deviceNodeMask", &self.deviceNodeMask)
		.field("deviceLUIDValid", &self.deviceLUIDValid)
		.field("subgroupSize", &self.subgroupSize)
		.field("subgroupSupportedStages", &self.subgroupSupportedStages)
		.field("subgroupSupportedOperations", &self.subgroupSupportedOperations)
		.field("subgroupQuadOperationsInAllStages", &self.subgroupQuadOperationsInAllStages)
		.field("pointClippingBehavior", &self.pointClippingBehavior)
		.field("maxMultiviewViewCount", &self.maxMultiviewViewCount)
		.field("maxMultiviewInstanceIndex", &self.maxMultiviewInstanceIndex)
		.field("protectedNoFault", &self.protectedNoFault)
		.field("maxPerSetDescriptors", &self.maxPerSetDescriptors)
		.field("maxMemoryAllocationSize", &self.maxMemoryAllocationSize)
		.finish()
	}
}
/// struct `VkPhysicalDeviceVulkan12Features` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVulkan12Features.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVulkan12Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub samplerMirrorClampToEdge: VkBool32,
	pub drawIndirectCount: VkBool32,
	pub storageBuffer8BitAccess: VkBool32,
	pub uniformAndStorageBuffer8BitAccess: VkBool32,
	pub storagePushConstant8: VkBool32,
	pub shaderBufferInt64Atomics: VkBool32,
	pub shaderSharedInt64Atomics: VkBool32,
	pub shaderFloat16: VkBool32,
	pub shaderInt8: VkBool32,
	pub descriptorIndexing: VkBool32,
	pub shaderInputAttachmentArrayDynamicIndexing: VkBool32,
	pub shaderUniformTexelBufferArrayDynamicIndexing: VkBool32,
	pub shaderStorageTexelBufferArrayDynamicIndexing: VkBool32,
	pub shaderUniformBufferArrayNonUniformIndexing: VkBool32,
	pub shaderSampledImageArrayNonUniformIndexing: VkBool32,
	pub shaderStorageBufferArrayNonUniformIndexing: VkBool32,
	pub shaderStorageImageArrayNonUniformIndexing: VkBool32,
	pub shaderInputAttachmentArrayNonUniformIndexing: VkBool32,
	pub shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32,
	pub shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32,
	pub descriptorBindingUniformBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingSampledImageUpdateAfterBind: VkBool32,
	pub descriptorBindingStorageImageUpdateAfterBind: VkBool32,
	pub descriptorBindingStorageBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingUpdateUnusedWhilePending: VkBool32,
	pub descriptorBindingPartiallyBound: VkBool32,
	pub descriptorBindingVariableDescriptorCount: VkBool32,
	pub runtimeDescriptorArray: VkBool32,
	pub samplerFilterMinmax: VkBool32,
	pub scalarBlockLayout: VkBool32,
	pub imagelessFramebuffer: VkBool32,
	pub uniformBufferStandardLayout: VkBool32,
	pub shaderSubgroupExtendedTypes: VkBool32,
	pub separateDepthStencilLayouts: VkBool32,
	pub hostQueryReset: VkBool32,
	pub timelineSemaphore: VkBool32,
	pub bufferDeviceAddress: VkBool32,
	pub bufferDeviceAddressCaptureReplay: VkBool32,
	pub bufferDeviceAddressMultiDevice: VkBool32,
	pub vulkanMemoryModel: VkBool32,
	pub vulkanMemoryModelDeviceScope: VkBool32,
	pub vulkanMemoryModelAvailabilityVisibilityChains: VkBool32,
	pub shaderOutputViewportIndex: VkBool32,
	pub shaderOutputLayer: VkBool32,
	pub subgroupBroadcastDynamicId: VkBool32,
}
impl Debug for VkPhysicalDeviceVulkan12Features {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVulkan12Features")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("samplerMirrorClampToEdge", &self.samplerMirrorClampToEdge)
		.field("drawIndirectCount", &self.drawIndirectCount)
		.field("storageBuffer8BitAccess", &self.storageBuffer8BitAccess)
		.field("uniformAndStorageBuffer8BitAccess", &self.uniformAndStorageBuffer8BitAccess)
		.field("storagePushConstant8", &self.storagePushConstant8)
		.field("shaderBufferInt64Atomics", &self.shaderBufferInt64Atomics)
		.field("shaderSharedInt64Atomics", &self.shaderSharedInt64Atomics)
		.field("shaderFloat16", &self.shaderFloat16)
		.field("shaderInt8", &self.shaderInt8)
		.field("descriptorIndexing", &self.descriptorIndexing)
		.field("shaderInputAttachmentArrayDynamicIndexing", &self.shaderInputAttachmentArrayDynamicIndexing)
		.field("shaderUniformTexelBufferArrayDynamicIndexing", &self.shaderUniformTexelBufferArrayDynamicIndexing)
		.field("shaderStorageTexelBufferArrayDynamicIndexing", &self.shaderStorageTexelBufferArrayDynamicIndexing)
		.field("shaderUniformBufferArrayNonUniformIndexing", &self.shaderUniformBufferArrayNonUniformIndexing)
		.field("shaderSampledImageArrayNonUniformIndexing", &self.shaderSampledImageArrayNonUniformIndexing)
		.field("shaderStorageBufferArrayNonUniformIndexing", &self.shaderStorageBufferArrayNonUniformIndexing)
		.field("shaderStorageImageArrayNonUniformIndexing", &self.shaderStorageImageArrayNonUniformIndexing)
		.field("shaderInputAttachmentArrayNonUniformIndexing", &self.shaderInputAttachmentArrayNonUniformIndexing)
		.field("shaderUniformTexelBufferArrayNonUniformIndexing", &self.shaderUniformTexelBufferArrayNonUniformIndexing)
		.field("shaderStorageTexelBufferArrayNonUniformIndexing", &self.shaderStorageTexelBufferArrayNonUniformIndexing)
		.field("descriptorBindingUniformBufferUpdateAfterBind", &self.descriptorBindingUniformBufferUpdateAfterBind)
		.field("descriptorBindingSampledImageUpdateAfterBind", &self.descriptorBindingSampledImageUpdateAfterBind)
		.field("descriptorBindingStorageImageUpdateAfterBind", &self.descriptorBindingStorageImageUpdateAfterBind)
		.field("descriptorBindingStorageBufferUpdateAfterBind", &self.descriptorBindingStorageBufferUpdateAfterBind)
		.field("descriptorBindingUniformTexelBufferUpdateAfterBind", &self.descriptorBindingUniformTexelBufferUpdateAfterBind)
		.field("descriptorBindingStorageTexelBufferUpdateAfterBind", &self.descriptorBindingStorageTexelBufferUpdateAfterBind)
		.field("descriptorBindingUpdateUnusedWhilePending", &self.descriptorBindingUpdateUnusedWhilePending)
		.field("descriptorBindingPartiallyBound", &self.descriptorBindingPartiallyBound)
		.field("descriptorBindingVariableDescriptorCount", &self.descriptorBindingVariableDescriptorCount)
		.field("runtimeDescriptorArray", &self.runtimeDescriptorArray)
		.field("samplerFilterMinmax", &self.samplerFilterMinmax)
		.field("scalarBlockLayout", &self.scalarBlockLayout)
		.field("imagelessFramebuffer", &self.imagelessFramebuffer)
		.field("uniformBufferStandardLayout", &self.uniformBufferStandardLayout)
		.field("shaderSubgroupExtendedTypes", &self.shaderSubgroupExtendedTypes)
		.field("separateDepthStencilLayouts", &self.separateDepthStencilLayouts)
		.field("hostQueryReset", &self.hostQueryReset)
		.field("timelineSemaphore", &self.timelineSemaphore)
		.field("bufferDeviceAddress", &self.bufferDeviceAddress)
		.field("bufferDeviceAddressCaptureReplay", &self.bufferDeviceAddressCaptureReplay)
		.field("bufferDeviceAddressMultiDevice", &self.bufferDeviceAddressMultiDevice)
		.field("vulkanMemoryModel", &self.vulkanMemoryModel)
		.field("vulkanMemoryModelDeviceScope", &self.vulkanMemoryModelDeviceScope)
		.field("vulkanMemoryModelAvailabilityVisibilityChains", &self.vulkanMemoryModelAvailabilityVisibilityChains)
		.field("shaderOutputViewportIndex", &self.shaderOutputViewportIndex)
		.field("shaderOutputLayer", &self.shaderOutputLayer)
		.field("subgroupBroadcastDynamicId", &self.subgroupBroadcastDynamicId)
		.finish()
	}
}
/// struct `VkConformanceVersion` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkConformanceVersion.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkConformanceVersion {
	pub major: u8,
	pub minor: u8,
	pub subminor: u8,
	pub patch: u8,
}
impl Debug for VkConformanceVersion {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkConformanceVersion")
		.field("major", &self.major)
		.field("minor", &self.minor)
		.field("subminor", &self.subminor)
		.field("patch", &self.patch)
		.finish()
	}
}
/// struct `VkPhysicalDeviceVulkan12Properties` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVulkan12Properties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVulkan12Properties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub driverID: VkDriverId,
	pub driverName: [i8; VK_MAX_DRIVER_NAME_SIZE as usize],
	pub driverInfo: [i8; VK_MAX_DRIVER_INFO_SIZE as usize],
	pub conformanceVersion: VkConformanceVersion,
	pub denormBehaviorIndependence: VkShaderFloatControlsIndependence,
	pub roundingModeIndependence: VkShaderFloatControlsIndependence,
	pub shaderSignedZeroInfNanPreserveFloat16: VkBool32,
	pub shaderSignedZeroInfNanPreserveFloat32: VkBool32,
	pub shaderSignedZeroInfNanPreserveFloat64: VkBool32,
	pub shaderDenormPreserveFloat16: VkBool32,
	pub shaderDenormPreserveFloat32: VkBool32,
	pub shaderDenormPreserveFloat64: VkBool32,
	pub shaderDenormFlushToZeroFloat16: VkBool32,
	pub shaderDenormFlushToZeroFloat32: VkBool32,
	pub shaderDenormFlushToZeroFloat64: VkBool32,
	pub shaderRoundingModeRTEFloat16: VkBool32,
	pub shaderRoundingModeRTEFloat32: VkBool32,
	pub shaderRoundingModeRTEFloat64: VkBool32,
	pub shaderRoundingModeRTZFloat16: VkBool32,
	pub shaderRoundingModeRTZFloat32: VkBool32,
	pub shaderRoundingModeRTZFloat64: VkBool32,
	pub maxUpdateAfterBindDescriptorsInAllPools: u32,
	pub shaderUniformBufferArrayNonUniformIndexingNative: VkBool32,
	pub shaderSampledImageArrayNonUniformIndexingNative: VkBool32,
	pub shaderStorageBufferArrayNonUniformIndexingNative: VkBool32,
	pub shaderStorageImageArrayNonUniformIndexingNative: VkBool32,
	pub shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32,
	pub robustBufferAccessUpdateAfterBind: VkBool32,
	pub quadDivergentImplicitLod: VkBool32,
	pub maxPerStageDescriptorUpdateAfterBindSamplers: u32,
	pub maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32,
	pub maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32,
	pub maxPerStageDescriptorUpdateAfterBindSampledImages: u32,
	pub maxPerStageDescriptorUpdateAfterBindStorageImages: u32,
	pub maxPerStageDescriptorUpdateAfterBindInputAttachments: u32,
	pub maxPerStageUpdateAfterBindResources: u32,
	pub maxDescriptorSetUpdateAfterBindSamplers: u32,
	pub maxDescriptorSetUpdateAfterBindUniformBuffers: u32,
	pub maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindStorageBuffers: u32,
	pub maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindSampledImages: u32,
	pub maxDescriptorSetUpdateAfterBindStorageImages: u32,
	pub maxDescriptorSetUpdateAfterBindInputAttachments: u32,
	pub supportedDepthResolveModes: VkResolveModeFlags,
	pub supportedStencilResolveModes: VkResolveModeFlags,
	pub independentResolveNone: VkBool32,
	pub independentResolve: VkBool32,
	pub filterMinmaxSingleComponentFormats: VkBool32,
	pub filterMinmaxImageComponentMapping: VkBool32,
	pub maxTimelineSemaphoreValueDifference: u64,
	pub framebufferIntegerColorSampleCounts: VkSampleCountFlags,
}
impl Debug for VkPhysicalDeviceVulkan12Properties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVulkan12Properties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("driverID", &self.driverID)
		.field("driverName", &format_args!("{}", maybe_string(&self.driverName)))
		.field("driverInfo", &format_args!("{}", maybe_string(&self.driverInfo)))
		.field("conformanceVersion", &self.conformanceVersion)
		.field("denormBehaviorIndependence", &self.denormBehaviorIndependence)
		.field("roundingModeIndependence", &self.roundingModeIndependence)
		.field("shaderSignedZeroInfNanPreserveFloat16", &self.shaderSignedZeroInfNanPreserveFloat16)
		.field("shaderSignedZeroInfNanPreserveFloat32", &self.shaderSignedZeroInfNanPreserveFloat32)
		.field("shaderSignedZeroInfNanPreserveFloat64", &self.shaderSignedZeroInfNanPreserveFloat64)
		.field("shaderDenormPreserveFloat16", &self.shaderDenormPreserveFloat16)
		.field("shaderDenormPreserveFloat32", &self.shaderDenormPreserveFloat32)
		.field("shaderDenormPreserveFloat64", &self.shaderDenormPreserveFloat64)
		.field("shaderDenormFlushToZeroFloat16", &self.shaderDenormFlushToZeroFloat16)
		.field("shaderDenormFlushToZeroFloat32", &self.shaderDenormFlushToZeroFloat32)
		.field("shaderDenormFlushToZeroFloat64", &self.shaderDenormFlushToZeroFloat64)
		.field("shaderRoundingModeRTEFloat16", &self.shaderRoundingModeRTEFloat16)
		.field("shaderRoundingModeRTEFloat32", &self.shaderRoundingModeRTEFloat32)
		.field("shaderRoundingModeRTEFloat64", &self.shaderRoundingModeRTEFloat64)
		.field("shaderRoundingModeRTZFloat16", &self.shaderRoundingModeRTZFloat16)
		.field("shaderRoundingModeRTZFloat32", &self.shaderRoundingModeRTZFloat32)
		.field("shaderRoundingModeRTZFloat64", &self.shaderRoundingModeRTZFloat64)
		.field("maxUpdateAfterBindDescriptorsInAllPools", &self.maxUpdateAfterBindDescriptorsInAllPools)
		.field("shaderUniformBufferArrayNonUniformIndexingNative", &self.shaderUniformBufferArrayNonUniformIndexingNative)
		.field("shaderSampledImageArrayNonUniformIndexingNative", &self.shaderSampledImageArrayNonUniformIndexingNative)
		.field("shaderStorageBufferArrayNonUniformIndexingNative", &self.shaderStorageBufferArrayNonUniformIndexingNative)
		.field("shaderStorageImageArrayNonUniformIndexingNative", &self.shaderStorageImageArrayNonUniformIndexingNative)
		.field("shaderInputAttachmentArrayNonUniformIndexingNative", &self.shaderInputAttachmentArrayNonUniformIndexingNative)
		.field("robustBufferAccessUpdateAfterBind", &self.robustBufferAccessUpdateAfterBind)
		.field("quadDivergentImplicitLod", &self.quadDivergentImplicitLod)
		.field("maxPerStageDescriptorUpdateAfterBindSamplers", &self.maxPerStageDescriptorUpdateAfterBindSamplers)
		.field("maxPerStageDescriptorUpdateAfterBindUniformBuffers", &self.maxPerStageDescriptorUpdateAfterBindUniformBuffers)
		.field("maxPerStageDescriptorUpdateAfterBindStorageBuffers", &self.maxPerStageDescriptorUpdateAfterBindStorageBuffers)
		.field("maxPerStageDescriptorUpdateAfterBindSampledImages", &self.maxPerStageDescriptorUpdateAfterBindSampledImages)
		.field("maxPerStageDescriptorUpdateAfterBindStorageImages", &self.maxPerStageDescriptorUpdateAfterBindStorageImages)
		.field("maxPerStageDescriptorUpdateAfterBindInputAttachments", &self.maxPerStageDescriptorUpdateAfterBindInputAttachments)
		.field("maxPerStageUpdateAfterBindResources", &self.maxPerStageUpdateAfterBindResources)
		.field("maxDescriptorSetUpdateAfterBindSamplers", &self.maxDescriptorSetUpdateAfterBindSamplers)
		.field("maxDescriptorSetUpdateAfterBindUniformBuffers", &self.maxDescriptorSetUpdateAfterBindUniformBuffers)
		.field("maxDescriptorSetUpdateAfterBindUniformBuffersDynamic", &self.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
		.field("maxDescriptorSetUpdateAfterBindStorageBuffers", &self.maxDescriptorSetUpdateAfterBindStorageBuffers)
		.field("maxDescriptorSetUpdateAfterBindStorageBuffersDynamic", &self.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
		.field("maxDescriptorSetUpdateAfterBindSampledImages", &self.maxDescriptorSetUpdateAfterBindSampledImages)
		.field("maxDescriptorSetUpdateAfterBindStorageImages", &self.maxDescriptorSetUpdateAfterBindStorageImages)
		.field("maxDescriptorSetUpdateAfterBindInputAttachments", &self.maxDescriptorSetUpdateAfterBindInputAttachments)
		.field("supportedDepthResolveModes", &format_args!("{}", vk_resolve_mode_flags_to_string(self.supportedDepthResolveModes)))
		.field("supportedStencilResolveModes", &format_args!("{}", vk_resolve_mode_flags_to_string(self.supportedStencilResolveModes)))
		.field("independentResolveNone", &self.independentResolveNone)
		.field("independentResolve", &self.independentResolve)
		.field("filterMinmaxSingleComponentFormats", &self.filterMinmaxSingleComponentFormats)
		.field("filterMinmaxImageComponentMapping", &self.filterMinmaxImageComponentMapping)
		.field("maxTimelineSemaphoreValueDifference", &self.maxTimelineSemaphoreValueDifference)
		.field("framebufferIntegerColorSampleCounts", &self.framebufferIntegerColorSampleCounts)
		.finish()
	}
}
/// struct `VkImageFormatListCreateInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageFormatListCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageFormatListCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub viewFormatCount: u32,
	pub pViewFormats: *const VkFormat,
}
impl Debug for VkImageFormatListCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageFormatListCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("viewFormatCount", &self.viewFormatCount)
		.field("pViewFormats", &self.pViewFormats)
		.finish()
	}
}
/// struct `VkAttachmentDescription2` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentDescription2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAttachmentDescription2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkAttachmentDescriptionFlags,
	pub format: VkFormat,
	pub samples: VkSampleCountFlagBits,
	pub loadOp: VkAttachmentLoadOp,
	pub storeOp: VkAttachmentStoreOp,
	pub stencilLoadOp: VkAttachmentLoadOp,
	pub stencilStoreOp: VkAttachmentStoreOp,
	pub initialLayout: VkImageLayout,
	pub finalLayout: VkImageLayout,
}
impl Debug for VkAttachmentDescription2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAttachmentDescription2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("format", &self.format)
		.field("samples", &self.samples)
		.field("loadOp", &self.loadOp)
		.field("storeOp", &self.storeOp)
		.field("stencilLoadOp", &self.stencilLoadOp)
		.field("stencilStoreOp", &self.stencilStoreOp)
		.field("initialLayout", &self.initialLayout)
		.field("finalLayout", &self.finalLayout)
		.finish()
	}
}
/// struct `VkAttachmentReference2` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentReference2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAttachmentReference2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub attachment: u32,
	pub layout: VkImageLayout,
	pub aspectMask: VkImageAspectFlags,
}
impl Debug for VkAttachmentReference2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAttachmentReference2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("attachment", &self.attachment)
		.field("layout", &self.layout)
		.field("aspectMask", &self.aspectMask)
		.finish()
	}
}
/// struct `VkSubpassDescription2` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassDescription2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSubpassDescription2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkSubpassDescriptionFlags,
	pub pipelineBindPoint: VkPipelineBindPoint,
	pub viewMask: u32,
	pub inputAttachmentCount: u32,
	pub pInputAttachments: *const VkAttachmentReference2,
	pub colorAttachmentCount: u32,
	pub pColorAttachments: *const VkAttachmentReference2,
	pub pResolveAttachments: *const VkAttachmentReference2,
	pub pDepthStencilAttachment: *const VkAttachmentReference2,
	pub preserveAttachmentCount: u32,
	pub pPreserveAttachments: *const uint32_t,
}
impl Debug for VkSubpassDescription2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSubpassDescription2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("pipelineBindPoint", &self.pipelineBindPoint)
		.field("viewMask", &self.viewMask)
		.field("inputAttachmentCount", &self.inputAttachmentCount)
		.field("pInputAttachments", &self.pInputAttachments)
		.field("colorAttachmentCount", &self.colorAttachmentCount)
		.field("pColorAttachments", &self.pColorAttachments)
		.field("pResolveAttachments", &self.pResolveAttachments)
		.field("pDepthStencilAttachment", &self.pDepthStencilAttachment)
		.field("preserveAttachmentCount", &self.preserveAttachmentCount)
		.field("pPreserveAttachments", &self.pPreserveAttachments)
		.finish()
	}
}
/// struct `VkSubpassDependency2` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassDependency2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSubpassDependency2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcSubpass: u32,
	pub dstSubpass: u32,
	pub srcStageMask: VkPipelineStageFlags,
	pub dstStageMask: VkPipelineStageFlags,
	pub srcAccessMask: VkAccessFlags,
	pub dstAccessMask: VkAccessFlags,
	pub dependencyFlags: VkDependencyFlags,
	pub viewOffset: i32,
}
impl Debug for VkSubpassDependency2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSubpassDependency2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcSubpass", &self.srcSubpass)
		.field("dstSubpass", &self.dstSubpass)
		.field("srcStageMask", &self.srcStageMask)
		.field("dstStageMask", &self.dstStageMask)
		.field("srcAccessMask", &self.srcAccessMask)
		.field("dstAccessMask", &self.dstAccessMask)
		.field("dependencyFlags", &self.dependencyFlags)
		.field("viewOffset", &self.viewOffset)
		.finish()
	}
}
/// struct `VkRenderPassCreateInfo2` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassCreateInfo2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassCreateInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkRenderPassCreateFlags,
	pub attachmentCount: u32,
	pub pAttachments: *const VkAttachmentDescription2,
	pub subpassCount: u32,
	pub pSubpasses: *const VkSubpassDescription2,
	pub dependencyCount: u32,
	pub pDependencies: *const VkSubpassDependency2,
	pub correlatedViewMaskCount: u32,
	pub pCorrelatedViewMasks: *const uint32_t,
}
impl Debug for VkRenderPassCreateInfo2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassCreateInfo2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("attachmentCount", &self.attachmentCount)
		.field("pAttachments", &self.pAttachments)
		.field("subpassCount", &self.subpassCount)
		.field("pSubpasses", &self.pSubpasses)
		.field("dependencyCount", &self.dependencyCount)
		.field("pDependencies", &self.pDependencies)
		.field("correlatedViewMaskCount", &self.correlatedViewMaskCount)
		.field("pCorrelatedViewMasks", &self.pCorrelatedViewMasks)
		.finish()
	}
}
/// struct `VkSubpassBeginInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassBeginInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSubpassBeginInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub contents: VkSubpassContents,
}
impl Debug for VkSubpassBeginInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSubpassBeginInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("contents", &self.contents)
		.finish()
	}
}
/// struct `VkSubpassEndInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassEndInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSubpassEndInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
}
impl Debug for VkSubpassEndInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSubpassEndInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.finish()
	}
}
/// struct `VkPhysicalDevice8BitStorageFeatures` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevice8BitStorageFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevice8BitStorageFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub storageBuffer8BitAccess: VkBool32,
	pub uniformAndStorageBuffer8BitAccess: VkBool32,
	pub storagePushConstant8: VkBool32,
}
impl Debug for VkPhysicalDevice8BitStorageFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevice8BitStorageFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("storageBuffer8BitAccess", &self.storageBuffer8BitAccess)
		.field("uniformAndStorageBuffer8BitAccess", &self.uniformAndStorageBuffer8BitAccess)
		.field("storagePushConstant8", &self.storagePushConstant8)
		.finish()
	}
}
/// struct `VkPhysicalDeviceDriverProperties` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDriverProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDriverProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub driverID: VkDriverId,
	pub driverName: [i8; VK_MAX_DRIVER_NAME_SIZE as usize],
	pub driverInfo: [i8; VK_MAX_DRIVER_INFO_SIZE as usize],
	pub conformanceVersion: VkConformanceVersion,
}
impl Debug for VkPhysicalDeviceDriverProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDriverProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("driverID", &self.driverID)
		.field("driverName", &format_args!("{}", maybe_string(&self.driverName)))
		.field("driverInfo", &format_args!("{}", maybe_string(&self.driverInfo)))
		.field("conformanceVersion", &self.conformanceVersion)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShaderAtomicInt64Features` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderAtomicInt64Features.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderAtomicInt64Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderBufferInt64Atomics: VkBool32,
	pub shaderSharedInt64Atomics: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderAtomicInt64Features {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderAtomicInt64Features")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderBufferInt64Atomics", &self.shaderBufferInt64Atomics)
		.field("shaderSharedInt64Atomics", &self.shaderSharedInt64Atomics)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShaderFloat16Int8Features` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderFloat16Int8Features.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderFloat16Int8Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderFloat16: VkBool32,
	pub shaderInt8: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderFloat16Int8Features {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderFloat16Int8Features")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderFloat16", &self.shaderFloat16)
		.field("shaderInt8", &self.shaderInt8)
		.finish()
	}
}
/// struct `VkPhysicalDeviceFloatControlsProperties` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFloatControlsProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFloatControlsProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub denormBehaviorIndependence: VkShaderFloatControlsIndependence,
	pub roundingModeIndependence: VkShaderFloatControlsIndependence,
	pub shaderSignedZeroInfNanPreserveFloat16: VkBool32,
	pub shaderSignedZeroInfNanPreserveFloat32: VkBool32,
	pub shaderSignedZeroInfNanPreserveFloat64: VkBool32,
	pub shaderDenormPreserveFloat16: VkBool32,
	pub shaderDenormPreserveFloat32: VkBool32,
	pub shaderDenormPreserveFloat64: VkBool32,
	pub shaderDenormFlushToZeroFloat16: VkBool32,
	pub shaderDenormFlushToZeroFloat32: VkBool32,
	pub shaderDenormFlushToZeroFloat64: VkBool32,
	pub shaderRoundingModeRTEFloat16: VkBool32,
	pub shaderRoundingModeRTEFloat32: VkBool32,
	pub shaderRoundingModeRTEFloat64: VkBool32,
	pub shaderRoundingModeRTZFloat16: VkBool32,
	pub shaderRoundingModeRTZFloat32: VkBool32,
	pub shaderRoundingModeRTZFloat64: VkBool32,
}
impl Debug for VkPhysicalDeviceFloatControlsProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFloatControlsProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("denormBehaviorIndependence", &self.denormBehaviorIndependence)
		.field("roundingModeIndependence", &self.roundingModeIndependence)
		.field("shaderSignedZeroInfNanPreserveFloat16", &self.shaderSignedZeroInfNanPreserveFloat16)
		.field("shaderSignedZeroInfNanPreserveFloat32", &self.shaderSignedZeroInfNanPreserveFloat32)
		.field("shaderSignedZeroInfNanPreserveFloat64", &self.shaderSignedZeroInfNanPreserveFloat64)
		.field("shaderDenormPreserveFloat16", &self.shaderDenormPreserveFloat16)
		.field("shaderDenormPreserveFloat32", &self.shaderDenormPreserveFloat32)
		.field("shaderDenormPreserveFloat64", &self.shaderDenormPreserveFloat64)
		.field("shaderDenormFlushToZeroFloat16", &self.shaderDenormFlushToZeroFloat16)
		.field("shaderDenormFlushToZeroFloat32", &self.shaderDenormFlushToZeroFloat32)
		.field("shaderDenormFlushToZeroFloat64", &self.shaderDenormFlushToZeroFloat64)
		.field("shaderRoundingModeRTEFloat16", &self.shaderRoundingModeRTEFloat16)
		.field("shaderRoundingModeRTEFloat32", &self.shaderRoundingModeRTEFloat32)
		.field("shaderRoundingModeRTEFloat64", &self.shaderRoundingModeRTEFloat64)
		.field("shaderRoundingModeRTZFloat16", &self.shaderRoundingModeRTZFloat16)
		.field("shaderRoundingModeRTZFloat32", &self.shaderRoundingModeRTZFloat32)
		.field("shaderRoundingModeRTZFloat64", &self.shaderRoundingModeRTZFloat64)
		.finish()
	}
}
/// struct `VkDescriptorSetLayoutBindingFlagsCreateInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutBindingFlagsCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorSetLayoutBindingFlagsCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub bindingCount: u32,
	pub pBindingFlags: *const VkDescriptorBindingFlags,
}
impl Debug for VkDescriptorSetLayoutBindingFlagsCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorSetLayoutBindingFlagsCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("bindingCount", &self.bindingCount)
		.field("pBindingFlags", &self.pBindingFlags)
		.finish()
	}
}
/// struct `VkPhysicalDeviceDescriptorIndexingFeatures` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDescriptorIndexingFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorIndexingFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderInputAttachmentArrayDynamicIndexing: VkBool32,
	pub shaderUniformTexelBufferArrayDynamicIndexing: VkBool32,
	pub shaderStorageTexelBufferArrayDynamicIndexing: VkBool32,
	pub shaderUniformBufferArrayNonUniformIndexing: VkBool32,
	pub shaderSampledImageArrayNonUniformIndexing: VkBool32,
	pub shaderStorageBufferArrayNonUniformIndexing: VkBool32,
	pub shaderStorageImageArrayNonUniformIndexing: VkBool32,
	pub shaderInputAttachmentArrayNonUniformIndexing: VkBool32,
	pub shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32,
	pub shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32,
	pub descriptorBindingUniformBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingSampledImageUpdateAfterBind: VkBool32,
	pub descriptorBindingStorageImageUpdateAfterBind: VkBool32,
	pub descriptorBindingStorageBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32,
	pub descriptorBindingUpdateUnusedWhilePending: VkBool32,
	pub descriptorBindingPartiallyBound: VkBool32,
	pub descriptorBindingVariableDescriptorCount: VkBool32,
	pub runtimeDescriptorArray: VkBool32,
}
impl Debug for VkPhysicalDeviceDescriptorIndexingFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDescriptorIndexingFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderInputAttachmentArrayDynamicIndexing", &self.shaderInputAttachmentArrayDynamicIndexing)
		.field("shaderUniformTexelBufferArrayDynamicIndexing", &self.shaderUniformTexelBufferArrayDynamicIndexing)
		.field("shaderStorageTexelBufferArrayDynamicIndexing", &self.shaderStorageTexelBufferArrayDynamicIndexing)
		.field("shaderUniformBufferArrayNonUniformIndexing", &self.shaderUniformBufferArrayNonUniformIndexing)
		.field("shaderSampledImageArrayNonUniformIndexing", &self.shaderSampledImageArrayNonUniformIndexing)
		.field("shaderStorageBufferArrayNonUniformIndexing", &self.shaderStorageBufferArrayNonUniformIndexing)
		.field("shaderStorageImageArrayNonUniformIndexing", &self.shaderStorageImageArrayNonUniformIndexing)
		.field("shaderInputAttachmentArrayNonUniformIndexing", &self.shaderInputAttachmentArrayNonUniformIndexing)
		.field("shaderUniformTexelBufferArrayNonUniformIndexing", &self.shaderUniformTexelBufferArrayNonUniformIndexing)
		.field("shaderStorageTexelBufferArrayNonUniformIndexing", &self.shaderStorageTexelBufferArrayNonUniformIndexing)
		.field("descriptorBindingUniformBufferUpdateAfterBind", &self.descriptorBindingUniformBufferUpdateAfterBind)
		.field("descriptorBindingSampledImageUpdateAfterBind", &self.descriptorBindingSampledImageUpdateAfterBind)
		.field("descriptorBindingStorageImageUpdateAfterBind", &self.descriptorBindingStorageImageUpdateAfterBind)
		.field("descriptorBindingStorageBufferUpdateAfterBind", &self.descriptorBindingStorageBufferUpdateAfterBind)
		.field("descriptorBindingUniformTexelBufferUpdateAfterBind", &self.descriptorBindingUniformTexelBufferUpdateAfterBind)
		.field("descriptorBindingStorageTexelBufferUpdateAfterBind", &self.descriptorBindingStorageTexelBufferUpdateAfterBind)
		.field("descriptorBindingUpdateUnusedWhilePending", &self.descriptorBindingUpdateUnusedWhilePending)
		.field("descriptorBindingPartiallyBound", &self.descriptorBindingPartiallyBound)
		.field("descriptorBindingVariableDescriptorCount", &self.descriptorBindingVariableDescriptorCount)
		.field("runtimeDescriptorArray", &self.runtimeDescriptorArray)
		.finish()
	}
}
/// struct `VkPhysicalDeviceDescriptorIndexingProperties` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDescriptorIndexingProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorIndexingProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxUpdateAfterBindDescriptorsInAllPools: u32,
	pub shaderUniformBufferArrayNonUniformIndexingNative: VkBool32,
	pub shaderSampledImageArrayNonUniformIndexingNative: VkBool32,
	pub shaderStorageBufferArrayNonUniformIndexingNative: VkBool32,
	pub shaderStorageImageArrayNonUniformIndexingNative: VkBool32,
	pub shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32,
	pub robustBufferAccessUpdateAfterBind: VkBool32,
	pub quadDivergentImplicitLod: VkBool32,
	pub maxPerStageDescriptorUpdateAfterBindSamplers: u32,
	pub maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32,
	pub maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32,
	pub maxPerStageDescriptorUpdateAfterBindSampledImages: u32,
	pub maxPerStageDescriptorUpdateAfterBindStorageImages: u32,
	pub maxPerStageDescriptorUpdateAfterBindInputAttachments: u32,
	pub maxPerStageUpdateAfterBindResources: u32,
	pub maxDescriptorSetUpdateAfterBindSamplers: u32,
	pub maxDescriptorSetUpdateAfterBindUniformBuffers: u32,
	pub maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindStorageBuffers: u32,
	pub maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindSampledImages: u32,
	pub maxDescriptorSetUpdateAfterBindStorageImages: u32,
	pub maxDescriptorSetUpdateAfterBindInputAttachments: u32,
}
impl Debug for VkPhysicalDeviceDescriptorIndexingProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDescriptorIndexingProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxUpdateAfterBindDescriptorsInAllPools", &self.maxUpdateAfterBindDescriptorsInAllPools)
		.field("shaderUniformBufferArrayNonUniformIndexingNative", &self.shaderUniformBufferArrayNonUniformIndexingNative)
		.field("shaderSampledImageArrayNonUniformIndexingNative", &self.shaderSampledImageArrayNonUniformIndexingNative)
		.field("shaderStorageBufferArrayNonUniformIndexingNative", &self.shaderStorageBufferArrayNonUniformIndexingNative)
		.field("shaderStorageImageArrayNonUniformIndexingNative", &self.shaderStorageImageArrayNonUniformIndexingNative)
		.field("shaderInputAttachmentArrayNonUniformIndexingNative", &self.shaderInputAttachmentArrayNonUniformIndexingNative)
		.field("robustBufferAccessUpdateAfterBind", &self.robustBufferAccessUpdateAfterBind)
		.field("quadDivergentImplicitLod", &self.quadDivergentImplicitLod)
		.field("maxPerStageDescriptorUpdateAfterBindSamplers", &self.maxPerStageDescriptorUpdateAfterBindSamplers)
		.field("maxPerStageDescriptorUpdateAfterBindUniformBuffers", &self.maxPerStageDescriptorUpdateAfterBindUniformBuffers)
		.field("maxPerStageDescriptorUpdateAfterBindStorageBuffers", &self.maxPerStageDescriptorUpdateAfterBindStorageBuffers)
		.field("maxPerStageDescriptorUpdateAfterBindSampledImages", &self.maxPerStageDescriptorUpdateAfterBindSampledImages)
		.field("maxPerStageDescriptorUpdateAfterBindStorageImages", &self.maxPerStageDescriptorUpdateAfterBindStorageImages)
		.field("maxPerStageDescriptorUpdateAfterBindInputAttachments", &self.maxPerStageDescriptorUpdateAfterBindInputAttachments)
		.field("maxPerStageUpdateAfterBindResources", &self.maxPerStageUpdateAfterBindResources)
		.field("maxDescriptorSetUpdateAfterBindSamplers", &self.maxDescriptorSetUpdateAfterBindSamplers)
		.field("maxDescriptorSetUpdateAfterBindUniformBuffers", &self.maxDescriptorSetUpdateAfterBindUniformBuffers)
		.field("maxDescriptorSetUpdateAfterBindUniformBuffersDynamic", &self.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
		.field("maxDescriptorSetUpdateAfterBindStorageBuffers", &self.maxDescriptorSetUpdateAfterBindStorageBuffers)
		.field("maxDescriptorSetUpdateAfterBindStorageBuffersDynamic", &self.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
		.field("maxDescriptorSetUpdateAfterBindSampledImages", &self.maxDescriptorSetUpdateAfterBindSampledImages)
		.field("maxDescriptorSetUpdateAfterBindStorageImages", &self.maxDescriptorSetUpdateAfterBindStorageImages)
		.field("maxDescriptorSetUpdateAfterBindInputAttachments", &self.maxDescriptorSetUpdateAfterBindInputAttachments)
		.finish()
	}
}
/// struct `VkDescriptorSetVariableDescriptorCountAllocateInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetVariableDescriptorCountAllocateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorSetVariableDescriptorCountAllocateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub descriptorSetCount: u32,
	pub pDescriptorCounts: *const uint32_t,
}
impl Debug for VkDescriptorSetVariableDescriptorCountAllocateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorSetVariableDescriptorCountAllocateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("descriptorSetCount", &self.descriptorSetCount)
		.field("pDescriptorCounts", &self.pDescriptorCounts)
		.finish()
	}
}
/// struct `VkDescriptorSetVariableDescriptorCountLayoutSupport` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetVariableDescriptorCountLayoutSupport.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorSetVariableDescriptorCountLayoutSupport {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxVariableDescriptorCount: u32,
}
impl Debug for VkDescriptorSetVariableDescriptorCountLayoutSupport {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorSetVariableDescriptorCountLayoutSupport")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxVariableDescriptorCount", &self.maxVariableDescriptorCount)
		.finish()
	}
}
/// struct `VkSubpassDescriptionDepthStencilResolve` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassDescriptionDepthStencilResolve.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSubpassDescriptionDepthStencilResolve {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub depthResolveMode: VkResolveModeFlagBits,
	pub stencilResolveMode: VkResolveModeFlagBits,
	pub pDepthStencilResolveAttachment: *const VkAttachmentReference2,
}
impl Debug for VkSubpassDescriptionDepthStencilResolve {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSubpassDescriptionDepthStencilResolve")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("depthResolveMode", &self.depthResolveMode)
		.field("stencilResolveMode", &self.stencilResolveMode)
		.field("pDepthStencilResolveAttachment", &self.pDepthStencilResolveAttachment)
		.finish()
	}
}
/// struct `VkPhysicalDeviceDepthStencilResolveProperties` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDepthStencilResolveProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDepthStencilResolveProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub supportedDepthResolveModes: VkResolveModeFlags,
	pub supportedStencilResolveModes: VkResolveModeFlags,
	pub independentResolveNone: VkBool32,
	pub independentResolve: VkBool32,
}
impl Debug for VkPhysicalDeviceDepthStencilResolveProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDepthStencilResolveProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("supportedDepthResolveModes", &format_args!("{}", vk_resolve_mode_flags_to_string(self.supportedDepthResolveModes)))
		.field("supportedStencilResolveModes", &format_args!("{}", vk_resolve_mode_flags_to_string(self.supportedStencilResolveModes)))
		.field("independentResolveNone", &self.independentResolveNone)
		.field("independentResolve", &self.independentResolve)
		.finish()
	}
}
/// struct `VkPhysicalDeviceScalarBlockLayoutFeatures` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceScalarBlockLayoutFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceScalarBlockLayoutFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub scalarBlockLayout: VkBool32,
}
impl Debug for VkPhysicalDeviceScalarBlockLayoutFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceScalarBlockLayoutFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("scalarBlockLayout", &self.scalarBlockLayout)
		.finish()
	}
}
/// struct `VkImageStencilUsageCreateInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageStencilUsageCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageStencilUsageCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stencilUsage: VkImageUsageFlags,
}
impl Debug for VkImageStencilUsageCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageStencilUsageCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stencilUsage", &self.stencilUsage)
		.finish()
	}
}
/// struct `VkSamplerReductionModeCreateInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerReductionModeCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSamplerReductionModeCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub reductionMode: VkSamplerReductionMode,
}
impl Debug for VkSamplerReductionModeCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSamplerReductionModeCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("reductionMode", &self.reductionMode)
		.finish()
	}
}
/// struct `VkPhysicalDeviceSamplerFilterMinmaxProperties` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSamplerFilterMinmaxProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSamplerFilterMinmaxProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub filterMinmaxSingleComponentFormats: VkBool32,
	pub filterMinmaxImageComponentMapping: VkBool32,
}
impl Debug for VkPhysicalDeviceSamplerFilterMinmaxProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSamplerFilterMinmaxProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("filterMinmaxSingleComponentFormats", &self.filterMinmaxSingleComponentFormats)
		.field("filterMinmaxImageComponentMapping", &self.filterMinmaxImageComponentMapping)
		.finish()
	}
}
/// struct `VkPhysicalDeviceVulkanMemoryModelFeatures` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVulkanMemoryModelFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVulkanMemoryModelFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub vulkanMemoryModel: VkBool32,
	pub vulkanMemoryModelDeviceScope: VkBool32,
	pub vulkanMemoryModelAvailabilityVisibilityChains: VkBool32,
}
impl Debug for VkPhysicalDeviceVulkanMemoryModelFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVulkanMemoryModelFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("vulkanMemoryModel", &self.vulkanMemoryModel)
		.field("vulkanMemoryModelDeviceScope", &self.vulkanMemoryModelDeviceScope)
		.field("vulkanMemoryModelAvailabilityVisibilityChains", &self.vulkanMemoryModelAvailabilityVisibilityChains)
		.finish()
	}
}
/// struct `VkPhysicalDeviceImagelessFramebufferFeatures` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImagelessFramebufferFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceImagelessFramebufferFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imagelessFramebuffer: VkBool32,
}
impl Debug for VkPhysicalDeviceImagelessFramebufferFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceImagelessFramebufferFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("imagelessFramebuffer", &self.imagelessFramebuffer)
		.finish()
	}
}
/// struct `VkFramebufferAttachmentImageInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFramebufferAttachmentImageInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkFramebufferAttachmentImageInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkImageCreateFlags,
	pub usage: VkImageUsageFlags,
	pub width: u32,
	pub height: u32,
	pub layerCount: u32,
	pub viewFormatCount: u32,
	pub pViewFormats: *const VkFormat,
}
impl Debug for VkFramebufferAttachmentImageInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkFramebufferAttachmentImageInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("usage", &self.usage)
		.field("width", &self.width)
		.field("height", &self.height)
		.field("layerCount", &self.layerCount)
		.field("viewFormatCount", &self.viewFormatCount)
		.field("pViewFormats", &self.pViewFormats)
		.finish()
	}
}
/// struct `VkFramebufferAttachmentsCreateInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFramebufferAttachmentsCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkFramebufferAttachmentsCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub attachmentImageInfoCount: u32,
	pub pAttachmentImageInfos: *const VkFramebufferAttachmentImageInfo,
}
impl Debug for VkFramebufferAttachmentsCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkFramebufferAttachmentsCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("attachmentImageInfoCount", &self.attachmentImageInfoCount)
		.field("pAttachmentImageInfos", &self.pAttachmentImageInfos)
		.finish()
	}
}
/// struct `VkRenderPassAttachmentBeginInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassAttachmentBeginInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassAttachmentBeginInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub attachmentCount: u32,
	pub pAttachments: *const VkImageView,
}
impl Debug for VkRenderPassAttachmentBeginInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassAttachmentBeginInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("attachmentCount", &self.attachmentCount)
		.field("pAttachments", &self.pAttachments)
		.finish()
	}
}
/// struct `VkPhysicalDeviceUniformBufferStandardLayoutFeatures` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceUniformBufferStandardLayoutFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceUniformBufferStandardLayoutFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub uniformBufferStandardLayout: VkBool32,
}
impl Debug for VkPhysicalDeviceUniformBufferStandardLayoutFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceUniformBufferStandardLayoutFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("uniformBufferStandardLayout", &self.uniformBufferStandardLayout)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderSubgroupExtendedTypes: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderSubgroupExtendedTypes", &self.shaderSubgroupExtendedTypes)
		.finish()
	}
}
/// struct `VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub separateDepthStencilLayouts: VkBool32,
}
impl Debug for VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("separateDepthStencilLayouts", &self.separateDepthStencilLayouts)
		.finish()
	}
}
/// struct `VkAttachmentReferenceStencilLayout` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentReferenceStencilLayout.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAttachmentReferenceStencilLayout {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub stencilLayout: VkImageLayout,
}
impl Debug for VkAttachmentReferenceStencilLayout {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAttachmentReferenceStencilLayout")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stencilLayout", &self.stencilLayout)
		.finish()
	}
}
/// struct `VkAttachmentDescriptionStencilLayout` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentDescriptionStencilLayout.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAttachmentDescriptionStencilLayout {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub stencilInitialLayout: VkImageLayout,
	pub stencilFinalLayout: VkImageLayout,
}
impl Debug for VkAttachmentDescriptionStencilLayout {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAttachmentDescriptionStencilLayout")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stencilInitialLayout", &self.stencilInitialLayout)
		.field("stencilFinalLayout", &self.stencilFinalLayout)
		.finish()
	}
}
/// struct `VkPhysicalDeviceHostQueryResetFeatures` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceHostQueryResetFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceHostQueryResetFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub hostQueryReset: VkBool32,
}
impl Debug for VkPhysicalDeviceHostQueryResetFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceHostQueryResetFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("hostQueryReset", &self.hostQueryReset)
		.finish()
	}
}
/// struct `VkPhysicalDeviceTimelineSemaphoreFeatures` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTimelineSemaphoreFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceTimelineSemaphoreFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub timelineSemaphore: VkBool32,
}
impl Debug for VkPhysicalDeviceTimelineSemaphoreFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceTimelineSemaphoreFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("timelineSemaphore", &self.timelineSemaphore)
		.finish()
	}
}
/// struct `VkPhysicalDeviceTimelineSemaphoreProperties` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTimelineSemaphoreProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceTimelineSemaphoreProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxTimelineSemaphoreValueDifference: u64,
}
impl Debug for VkPhysicalDeviceTimelineSemaphoreProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceTimelineSemaphoreProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxTimelineSemaphoreValueDifference", &self.maxTimelineSemaphoreValueDifference)
		.finish()
	}
}
/// struct `VkSemaphoreTypeCreateInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreTypeCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSemaphoreTypeCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub semaphoreType: VkSemaphoreType,
	pub initialValue: u64,
}
impl Debug for VkSemaphoreTypeCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSemaphoreTypeCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("semaphoreType", &self.semaphoreType)
		.field("initialValue", &self.initialValue)
		.finish()
	}
}
/// struct `VkTimelineSemaphoreSubmitInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTimelineSemaphoreSubmitInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTimelineSemaphoreSubmitInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub waitSemaphoreValueCount: u32,
	pub pWaitSemaphoreValues: *const uint64_t,
	pub signalSemaphoreValueCount: u32,
	pub pSignalSemaphoreValues: *const uint64_t,
}
impl Debug for VkTimelineSemaphoreSubmitInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTimelineSemaphoreSubmitInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("waitSemaphoreValueCount", &self.waitSemaphoreValueCount)
		.field("pWaitSemaphoreValues", &self.pWaitSemaphoreValues)
		.field("signalSemaphoreValueCount", &self.signalSemaphoreValueCount)
		.field("pSignalSemaphoreValues", &self.pSignalSemaphoreValues)
		.finish()
	}
}
/// struct `VkSemaphoreWaitInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreWaitInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSemaphoreWaitInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkSemaphoreWaitFlags,
	pub semaphoreCount: u32,
	pub pSemaphores: *const VkSemaphore,
	pub pValues: *const uint64_t,
}
impl Debug for VkSemaphoreWaitInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSemaphoreWaitInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_semaphore_wait_flags_to_string(self.flags)))
		.field("semaphoreCount", &self.semaphoreCount)
		.field("pSemaphores", &self.pSemaphores)
		.field("pValues", &self.pValues)
		.finish()
	}
}
/// struct `VkSemaphoreSignalInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreSignalInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSemaphoreSignalInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub semaphore: VkSemaphore,
	pub value: u64,
}
impl Debug for VkSemaphoreSignalInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSemaphoreSignalInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("semaphore", &self.semaphore)
		.field("value", &self.value)
		.finish()
	}
}
/// struct `VkPhysicalDeviceBufferDeviceAddressFeatures` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceBufferDeviceAddressFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceBufferDeviceAddressFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub bufferDeviceAddress: VkBool32,
	pub bufferDeviceAddressCaptureReplay: VkBool32,
	pub bufferDeviceAddressMultiDevice: VkBool32,
}
impl Debug for VkPhysicalDeviceBufferDeviceAddressFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceBufferDeviceAddressFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("bufferDeviceAddress", &self.bufferDeviceAddress)
		.field("bufferDeviceAddressCaptureReplay", &self.bufferDeviceAddressCaptureReplay)
		.field("bufferDeviceAddressMultiDevice", &self.bufferDeviceAddressMultiDevice)
		.finish()
	}
}
/// struct `VkBufferDeviceAddressInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferDeviceAddressInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBufferDeviceAddressInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub buffer: VkBuffer,
}
impl Debug for VkBufferDeviceAddressInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBufferDeviceAddressInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("buffer", &self.buffer)
		.finish()
	}
}
/// struct `VkBufferOpaqueCaptureAddressCreateInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferOpaqueCaptureAddressCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBufferOpaqueCaptureAddressCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub opaqueCaptureAddress: u64,
}
impl Debug for VkBufferOpaqueCaptureAddressCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBufferOpaqueCaptureAddressCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("opaqueCaptureAddress", &self.opaqueCaptureAddress)
		.finish()
	}
}
/// struct `VkMemoryOpaqueCaptureAddressAllocateInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryOpaqueCaptureAddressAllocateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryOpaqueCaptureAddressAllocateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub opaqueCaptureAddress: u64,
}
impl Debug for VkMemoryOpaqueCaptureAddressAllocateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryOpaqueCaptureAddressAllocateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("opaqueCaptureAddress", &self.opaqueCaptureAddress)
		.finish()
	}
}
/// struct `VkDeviceMemoryOpaqueCaptureAddressInfo` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceMemoryOpaqueCaptureAddressInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceMemoryOpaqueCaptureAddressInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub memory: VkDeviceMemory,
}
impl Debug for VkDeviceMemoryOpaqueCaptureAddressInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceMemoryOpaqueCaptureAddressInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("memory", &self.memory)
		.finish()
	}
}
/// function prototype `PFN_vkCmdDrawIndirectCount` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndirectCount.html>
type PFN_vkCmdDrawIndirectCount = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
/// function prototype `PFN_vkCmdDrawIndexedIndirectCount` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexedIndirectCount.html>
type PFN_vkCmdDrawIndexedIndirectCount = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
/// function prototype `PFN_vkCreateRenderPass2` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRenderPass2.html>
type PFN_vkCreateRenderPass2 = extern "system" fn(device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo2, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult;
/// function prototype `PFN_vkCmdBeginRenderPass2` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderPass2.html>
type PFN_vkCmdBeginRenderPass2 = extern "system" fn(commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, pSubpassBeginInfo: *const VkSubpassBeginInfo);
/// function prototype `PFN_vkCmdNextSubpass2` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdNextSubpass2.html>
type PFN_vkCmdNextSubpass2 = extern "system" fn(commandBuffer: VkCommandBuffer, pSubpassBeginInfo: *const VkSubpassBeginInfo, pSubpassEndInfo: *const VkSubpassEndInfo);
/// function prototype `PFN_vkCmdEndRenderPass2` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRenderPass2.html>
type PFN_vkCmdEndRenderPass2 = extern "system" fn(commandBuffer: VkCommandBuffer, pSubpassEndInfo: *const VkSubpassEndInfo);
/// function prototype `PFN_vkResetQueryPool` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetQueryPool.html>
type PFN_vkResetQueryPool = extern "system" fn(device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32);
/// function prototype `PFN_vkGetSemaphoreCounterValue` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSemaphoreCounterValue.html>
type PFN_vkGetSemaphoreCounterValue = extern "system" fn(device: VkDevice, semaphore: VkSemaphore, pValue: *mut uint64_t) -> VkResult;
/// function prototype `PFN_vkWaitSemaphores` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitSemaphores.html>
type PFN_vkWaitSemaphores = extern "system" fn(device: VkDevice, pWaitInfo: *const VkSemaphoreWaitInfo, timeout: u64) -> VkResult;
/// function prototype `PFN_vkSignalSemaphore` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSignalSemaphore.html>
type PFN_vkSignalSemaphore = extern "system" fn(device: VkDevice, pSignalInfo: *const VkSemaphoreSignalInfo) -> VkResult;
/// function prototype `PFN_vkGetBufferDeviceAddress` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferDeviceAddress.html>
type PFN_vkGetBufferDeviceAddress = extern "system" fn(device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress;
/// function prototype `PFN_vkGetBufferOpaqueCaptureAddress` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferOpaqueCaptureAddress.html>
type PFN_vkGetBufferOpaqueCaptureAddress = extern "system" fn(device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> u64;
/// function prototype `PFN_vkGetDeviceMemoryOpaqueCaptureAddress` from VK_VERSION_1_2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceMemoryOpaqueCaptureAddress.html>
type PFN_vkGetDeviceMemoryOpaqueCaptureAddress = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo) -> u64;
/// The dummy function for `vkCmdDrawIndirectCount` from `VK_VERSION_1_2`
extern "system" fn dummy_vkCmdDrawIndirectCount(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkBuffer, _: VkDeviceSize, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdDrawIndirectCount"))
}
/// The dummy function for `vkCmdDrawIndexedIndirectCount` from `VK_VERSION_1_2`
extern "system" fn dummy_vkCmdDrawIndexedIndirectCount(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkBuffer, _: VkDeviceSize, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdDrawIndexedIndirectCount"))
}
/// The dummy function for `vkCreateRenderPass2` from `VK_VERSION_1_2`
extern "system" fn dummy_vkCreateRenderPass2(_: VkDevice, _: *const VkRenderPassCreateInfo2, _: *const VkAllocationCallbacks, _: *mut VkRenderPass) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateRenderPass2"))
}
/// The dummy function for `vkCmdBeginRenderPass2` from `VK_VERSION_1_2`
extern "system" fn dummy_vkCmdBeginRenderPass2(_: VkCommandBuffer, _: *const VkRenderPassBeginInfo, _: *const VkSubpassBeginInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdBeginRenderPass2"))
}
/// The dummy function for `vkCmdNextSubpass2` from `VK_VERSION_1_2`
extern "system" fn dummy_vkCmdNextSubpass2(_: VkCommandBuffer, _: *const VkSubpassBeginInfo, _: *const VkSubpassEndInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdNextSubpass2"))
}
/// The dummy function for `vkCmdEndRenderPass2` from `VK_VERSION_1_2`
extern "system" fn dummy_vkCmdEndRenderPass2(_: VkCommandBuffer, _: *const VkSubpassEndInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdEndRenderPass2"))
}
/// The dummy function for `vkResetQueryPool` from `VK_VERSION_1_2`
extern "system" fn dummy_vkResetQueryPool(_: VkDevice, _: VkQueryPool, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkResetQueryPool"))
}
/// The dummy function for `vkGetSemaphoreCounterValue` from `VK_VERSION_1_2`
extern "system" fn dummy_vkGetSemaphoreCounterValue(_: VkDevice, _: VkSemaphore, _: *mut uint64_t) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetSemaphoreCounterValue"))
}
/// The dummy function for `vkWaitSemaphores` from `VK_VERSION_1_2`
extern "system" fn dummy_vkWaitSemaphores(_: VkDevice, _: *const VkSemaphoreWaitInfo, _: u64) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkWaitSemaphores"))
}
/// The dummy function for `vkSignalSemaphore` from `VK_VERSION_1_2`
extern "system" fn dummy_vkSignalSemaphore(_: VkDevice, _: *const VkSemaphoreSignalInfo) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkSignalSemaphore"))
}
/// The dummy function for `vkGetBufferDeviceAddress` from `VK_VERSION_1_2`
extern "system" fn dummy_vkGetBufferDeviceAddress(_: VkDevice, _: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress {
	panic_any(VkError::NullFunctionPointer("vkGetBufferDeviceAddress"))
}
/// The dummy function for `vkGetBufferOpaqueCaptureAddress` from `VK_VERSION_1_2`
extern "system" fn dummy_vkGetBufferOpaqueCaptureAddress(_: VkDevice, _: *const VkBufferDeviceAddressInfo) -> u64 {
	panic_any(VkError::NullFunctionPointer("vkGetBufferOpaqueCaptureAddress"))
}
/// The dummy function for `vkGetDeviceMemoryOpaqueCaptureAddress` from `VK_VERSION_1_2`
extern "system" fn dummy_vkGetDeviceMemoryOpaqueCaptureAddress(_: VkDevice, _: *const VkDeviceMemoryOpaqueCaptureAddressInfo) -> u64 {
	panic_any(VkError::NullFunctionPointer("vkGetDeviceMemoryOpaqueCaptureAddress"))
}
/// trait for `VK_VERSION_1_2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_VERSION_1_2.html>
pub trait VK_VERSION_1_2: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndirectCount.html>
	fn vkCmdDrawIndirectCount(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexedIndirectCount.html>
	fn vkCmdDrawIndexedIndirectCount(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRenderPass2.html>
	fn vkCreateRenderPass2(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo2, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderPass2.html>
	fn vkCmdBeginRenderPass2(&self, commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, pSubpassBeginInfo: *const VkSubpassBeginInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdNextSubpass2.html>
	fn vkCmdNextSubpass2(&self, commandBuffer: VkCommandBuffer, pSubpassBeginInfo: *const VkSubpassBeginInfo, pSubpassEndInfo: *const VkSubpassEndInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRenderPass2.html>
	fn vkCmdEndRenderPass2(&self, commandBuffer: VkCommandBuffer, pSubpassEndInfo: *const VkSubpassEndInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetQueryPool.html>
	fn vkResetQueryPool(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSemaphoreCounterValue.html>
	fn vkGetSemaphoreCounterValue(&self, device: VkDevice, semaphore: VkSemaphore, pValue: *mut uint64_t) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitSemaphores.html>
	fn vkWaitSemaphores(&self, device: VkDevice, pWaitInfo: *const VkSemaphoreWaitInfo, timeout: u64) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSignalSemaphore.html>
	fn vkSignalSemaphore(&self, device: VkDevice, pSignalInfo: *const VkSemaphoreSignalInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferDeviceAddress.html>
	fn vkGetBufferDeviceAddress(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> Result<VkDeviceAddress>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferOpaqueCaptureAddress.html>
	fn vkGetBufferOpaqueCaptureAddress(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> Result<u64>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceMemoryOpaqueCaptureAddress.html>
	fn vkGetDeviceMemoryOpaqueCaptureAddress(&self, device: VkDevice, pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo) -> Result<u64>;
}
/// struct for `VK_VERSION_1_2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_VERSION_1_2 {
	vk_cmd_draw_indirect_count: PFN_vkCmdDrawIndirectCount,
	vk_cmd_draw_indexed_indirect_count: PFN_vkCmdDrawIndexedIndirectCount,
	vk_create_render_pass2: PFN_vkCreateRenderPass2,
	vk_cmd_begin_render_pass2: PFN_vkCmdBeginRenderPass2,
	vk_cmd_next_subpass2: PFN_vkCmdNextSubpass2,
	vk_cmd_end_render_pass2: PFN_vkCmdEndRenderPass2,
	vk_reset_query_pool: PFN_vkResetQueryPool,
	vk_get_semaphore_counter_value: PFN_vkGetSemaphoreCounterValue,
	vk_wait_semaphores: PFN_vkWaitSemaphores,
	vk_signal_semaphore: PFN_vkSignalSemaphore,
	vk_get_buffer_device_address: PFN_vkGetBufferDeviceAddress,
	vk_get_buffer_opaque_capture_address: PFN_vkGetBufferOpaqueCaptureAddress,
	vk_get_device_memory_opaque_capture_address: PFN_vkGetDeviceMemoryOpaqueCaptureAddress,
}
impl VK_VERSION_1_2 for Vulkan_VERSION_1_2 {
	fn vkCmdDrawIndirectCount(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_draw_indirect_count)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride))))
	}
	fn vkCmdDrawIndexedIndirectCount(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_draw_indexed_indirect_count)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride))))
	}
	fn vkCreateRenderPass2(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo2, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> Result<()> {
		convert_result("vkCreateRenderPass2", catch_unwind(||((self.vk_create_render_pass2)(device, pCreateInfo, pAllocator, pRenderPass))))
	}
	fn vkCmdBeginRenderPass2(&self, commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, pSubpassBeginInfo: *const VkSubpassBeginInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_begin_render_pass2)(commandBuffer, pRenderPassBegin, pSubpassBeginInfo))))
	}
	fn vkCmdNextSubpass2(&self, commandBuffer: VkCommandBuffer, pSubpassBeginInfo: *const VkSubpassBeginInfo, pSubpassEndInfo: *const VkSubpassEndInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_next_subpass2)(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo))))
	}
	fn vkCmdEndRenderPass2(&self, commandBuffer: VkCommandBuffer, pSubpassEndInfo: *const VkSubpassEndInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_end_render_pass2)(commandBuffer, pSubpassEndInfo))))
	}
	fn vkResetQueryPool(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_reset_query_pool)(device, queryPool, firstQuery, queryCount))))
	}
	fn vkGetSemaphoreCounterValue(&self, device: VkDevice, semaphore: VkSemaphore, pValue: *mut uint64_t) -> Result<()> {
		convert_result("vkGetSemaphoreCounterValue", catch_unwind(||((self.vk_get_semaphore_counter_value)(device, semaphore, pValue))))
	}
	fn vkWaitSemaphores(&self, device: VkDevice, pWaitInfo: *const VkSemaphoreWaitInfo, timeout: u64) -> Result<()> {
		convert_result("vkWaitSemaphores", catch_unwind(||((self.vk_wait_semaphores)(device, pWaitInfo, timeout))))
	}
	fn vkSignalSemaphore(&self, device: VkDevice, pSignalInfo: *const VkSemaphoreSignalInfo) -> Result<()> {
		convert_result("vkSignalSemaphore", catch_unwind(||((self.vk_signal_semaphore)(device, pSignalInfo))))
	}
	fn vkGetBufferDeviceAddress(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> Result<VkDeviceAddress> {
		process_catch(catch_unwind(||((self.vk_get_buffer_device_address)(device, pInfo))))
	}
	fn vkGetBufferOpaqueCaptureAddress(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> Result<u64> {
		process_catch(catch_unwind(||((self.vk_get_buffer_opaque_capture_address)(device, pInfo))))
	}
	fn vkGetDeviceMemoryOpaqueCaptureAddress(&self, device: VkDevice, pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo) -> Result<u64> {
		process_catch(catch_unwind(||((self.vk_get_device_memory_opaque_capture_address)(device, pInfo))))
	}
}
impl Default for Vulkan_VERSION_1_2 {
	fn default() -> Self {
		Self {
			vk_cmd_draw_indirect_count: dummy_vkCmdDrawIndirectCount,
			vk_cmd_draw_indexed_indirect_count: dummy_vkCmdDrawIndexedIndirectCount,
			vk_create_render_pass2: dummy_vkCreateRenderPass2,
			vk_cmd_begin_render_pass2: dummy_vkCmdBeginRenderPass2,
			vk_cmd_next_subpass2: dummy_vkCmdNextSubpass2,
			vk_cmd_end_render_pass2: dummy_vkCmdEndRenderPass2,
			vk_reset_query_pool: dummy_vkResetQueryPool,
			vk_get_semaphore_counter_value: dummy_vkGetSemaphoreCounterValue,
			vk_wait_semaphores: dummy_vkWaitSemaphores,
			vk_signal_semaphore: dummy_vkSignalSemaphore,
			vk_get_buffer_device_address: dummy_vkGetBufferDeviceAddress,
			vk_get_buffer_opaque_capture_address: dummy_vkGetBufferOpaqueCaptureAddress,
			vk_get_device_memory_opaque_capture_address: dummy_vkGetDeviceMemoryOpaqueCaptureAddress,
		}
	}
}
impl Vulkan_VERSION_1_2 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_draw_indirect_count: {let proc = get_instance_proc_address(instance, "vkCmdDrawIndirectCount"); if proc == null() {dummy_vkCmdDrawIndirectCount} else {unsafe {transmute(proc)}}},
			vk_cmd_draw_indexed_indirect_count: {let proc = get_instance_proc_address(instance, "vkCmdDrawIndexedIndirectCount"); if proc == null() {dummy_vkCmdDrawIndexedIndirectCount} else {unsafe {transmute(proc)}}},
			vk_create_render_pass2: {let proc = get_instance_proc_address(instance, "vkCreateRenderPass2"); if proc == null() {dummy_vkCreateRenderPass2} else {unsafe {transmute(proc)}}},
			vk_cmd_begin_render_pass2: {let proc = get_instance_proc_address(instance, "vkCmdBeginRenderPass2"); if proc == null() {dummy_vkCmdBeginRenderPass2} else {unsafe {transmute(proc)}}},
			vk_cmd_next_subpass2: {let proc = get_instance_proc_address(instance, "vkCmdNextSubpass2"); if proc == null() {dummy_vkCmdNextSubpass2} else {unsafe {transmute(proc)}}},
			vk_cmd_end_render_pass2: {let proc = get_instance_proc_address(instance, "vkCmdEndRenderPass2"); if proc == null() {dummy_vkCmdEndRenderPass2} else {unsafe {transmute(proc)}}},
			vk_reset_query_pool: {let proc = get_instance_proc_address(instance, "vkResetQueryPool"); if proc == null() {dummy_vkResetQueryPool} else {unsafe {transmute(proc)}}},
			vk_get_semaphore_counter_value: {let proc = get_instance_proc_address(instance, "vkGetSemaphoreCounterValue"); if proc == null() {dummy_vkGetSemaphoreCounterValue} else {unsafe {transmute(proc)}}},
			vk_wait_semaphores: {let proc = get_instance_proc_address(instance, "vkWaitSemaphores"); if proc == null() {dummy_vkWaitSemaphores} else {unsafe {transmute(proc)}}},
			vk_signal_semaphore: {let proc = get_instance_proc_address(instance, "vkSignalSemaphore"); if proc == null() {dummy_vkSignalSemaphore} else {unsafe {transmute(proc)}}},
			vk_get_buffer_device_address: {let proc = get_instance_proc_address(instance, "vkGetBufferDeviceAddress"); if proc == null() {dummy_vkGetBufferDeviceAddress} else {unsafe {transmute(proc)}}},
			vk_get_buffer_opaque_capture_address: {let proc = get_instance_proc_address(instance, "vkGetBufferOpaqueCaptureAddress"); if proc == null() {dummy_vkGetBufferOpaqueCaptureAddress} else {unsafe {transmute(proc)}}},
			vk_get_device_memory_opaque_capture_address: {let proc = get_instance_proc_address(instance, "vkGetDeviceMemoryOpaqueCaptureAddress"); if proc == null() {dummy_vkGetDeviceMemoryOpaqueCaptureAddress} else {unsafe {transmute(proc)}}},
		}
	}
}
/// constant `VK_API_VERSION_1_3` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_API_VERSION_1_3.html>
pub const VK_API_VERSION_1_3: u32 = 0x403000;
/// type definition `VkFlags64` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFlags64.html>
pub type VkFlags64 = u64;
/// type definition `VkPipelineCreationFeedbackFlags` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreationFeedbackFlags.html>
pub type VkPipelineCreationFeedbackFlags = VkFlags;
pub fn vk_pipeline_creation_feedback_flags_to_string(value: VkPipelineCreationFeedbackFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(7);
	if (value & VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT as VkPipelineCreationFeedbackFlags) == VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT as VkPipelineCreationFeedbackFlags {
		flags.push("VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT");
	}
	if (value & VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT as VkPipelineCreationFeedbackFlags) == VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT as VkPipelineCreationFeedbackFlags {
		flags.push("VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT");
	}
	if (value & VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT as VkPipelineCreationFeedbackFlags) == VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT as VkPipelineCreationFeedbackFlags {
		flags.push("VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT");
	}
	if (value & VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT as VkPipelineCreationFeedbackFlags) == VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT as VkPipelineCreationFeedbackFlags {
		flags.push("VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT");
	}
	if (value & VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT as VkPipelineCreationFeedbackFlags) == VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT as VkPipelineCreationFeedbackFlags {
		flags.push("VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT");
	}
	if (value & VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT as VkPipelineCreationFeedbackFlags) == VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT as VkPipelineCreationFeedbackFlags {
		flags.push("VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT");
	}
	if (value & VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM as VkPipelineCreationFeedbackFlags) == VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM as VkPipelineCreationFeedbackFlags {
		flags.push("VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkToolPurposeFlags` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkToolPurposeFlags.html>
pub type VkToolPurposeFlags = VkFlags;
pub fn vk_tool_purpose_flags_to_string(value: VkToolPurposeFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(13);
	if (value & VkToolPurposeFlagBits::VK_TOOL_PURPOSE_VALIDATION_BIT as VkToolPurposeFlags) == VkToolPurposeFlagBits::VK_TOOL_PURPOSE_VALIDATION_BIT as VkToolPurposeFlags {
		flags.push("VkToolPurposeFlagBits::VK_TOOL_PURPOSE_VALIDATION_BIT");
	}
	if (value & VkToolPurposeFlagBits::VK_TOOL_PURPOSE_PROFILING_BIT as VkToolPurposeFlags) == VkToolPurposeFlagBits::VK_TOOL_PURPOSE_PROFILING_BIT as VkToolPurposeFlags {
		flags.push("VkToolPurposeFlagBits::VK_TOOL_PURPOSE_PROFILING_BIT");
	}
	if (value & VkToolPurposeFlagBits::VK_TOOL_PURPOSE_TRACING_BIT as VkToolPurposeFlags) == VkToolPurposeFlagBits::VK_TOOL_PURPOSE_TRACING_BIT as VkToolPurposeFlags {
		flags.push("VkToolPurposeFlagBits::VK_TOOL_PURPOSE_TRACING_BIT");
	}
	if (value & VkToolPurposeFlagBits::VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT as VkToolPurposeFlags) == VkToolPurposeFlagBits::VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT as VkToolPurposeFlags {
		flags.push("VkToolPurposeFlagBits::VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT");
	}
	if (value & VkToolPurposeFlagBits::VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT as VkToolPurposeFlags) == VkToolPurposeFlagBits::VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT as VkToolPurposeFlags {
		flags.push("VkToolPurposeFlagBits::VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT");
	}
	if (value & VkToolPurposeFlagBits::VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT as VkToolPurposeFlags) == VkToolPurposeFlagBits::VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT as VkToolPurposeFlags {
		flags.push("VkToolPurposeFlagBits::VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT");
	}
	if (value & VkToolPurposeFlagBits::VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT as VkToolPurposeFlags) == VkToolPurposeFlagBits::VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT as VkToolPurposeFlags {
		flags.push("VkToolPurposeFlagBits::VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT");
	}
	if (value & VkToolPurposeFlagBits::VK_TOOL_PURPOSE_VALIDATION_BIT_EXT as VkToolPurposeFlags) == VkToolPurposeFlagBits::VK_TOOL_PURPOSE_VALIDATION_BIT_EXT as VkToolPurposeFlags {
		flags.push("VkToolPurposeFlagBits::VK_TOOL_PURPOSE_VALIDATION_BIT_EXT");
	}
	if (value & VkToolPurposeFlagBits::VK_TOOL_PURPOSE_PROFILING_BIT_EXT as VkToolPurposeFlags) == VkToolPurposeFlagBits::VK_TOOL_PURPOSE_PROFILING_BIT_EXT as VkToolPurposeFlags {
		flags.push("VkToolPurposeFlagBits::VK_TOOL_PURPOSE_PROFILING_BIT_EXT");
	}
	if (value & VkToolPurposeFlagBits::VK_TOOL_PURPOSE_TRACING_BIT_EXT as VkToolPurposeFlags) == VkToolPurposeFlagBits::VK_TOOL_PURPOSE_TRACING_BIT_EXT as VkToolPurposeFlags {
		flags.push("VkToolPurposeFlagBits::VK_TOOL_PURPOSE_TRACING_BIT_EXT");
	}
	if (value & VkToolPurposeFlagBits::VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT as VkToolPurposeFlags) == VkToolPurposeFlagBits::VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT as VkToolPurposeFlags {
		flags.push("VkToolPurposeFlagBits::VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT");
	}
	if (value & VkToolPurposeFlagBits::VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT as VkToolPurposeFlags) == VkToolPurposeFlagBits::VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT as VkToolPurposeFlags {
		flags.push("VkToolPurposeFlagBits::VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT");
	}
	if (value & VkToolPurposeFlagBits::VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM as VkToolPurposeFlags) == VkToolPurposeFlagBits::VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM as VkToolPurposeFlags {
		flags.push("VkToolPurposeFlagBits::VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkPrivateDataSlotCreateFlags` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPrivateDataSlotCreateFlags.html>
pub type VkPrivateDataSlotCreateFlags = VkFlags;
/// type definition `VkPipelineStageFlags2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineStageFlags2.html>
pub type VkPipelineStageFlags2 = VkFlags64;
/// type definition `VkPipelineStageFlagBits2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineStageFlagBits2.html>
pub type VkPipelineStageFlagBits2 = VkFlags64;
/// type definition `VkAccessFlags2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccessFlags2.html>
pub type VkAccessFlags2 = VkFlags64;
/// type definition `VkAccessFlagBits2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccessFlagBits2.html>
pub type VkAccessFlagBits2 = VkFlags64;
/// type definition `VkSubmitFlags` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubmitFlags.html>
pub type VkSubmitFlags = VkFlags;
pub fn vk_submit_flags_to_string(value: VkSubmitFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(3);
	if (value & VkSubmitFlagBits::VK_SUBMIT_PROTECTED_BIT as VkSubmitFlags) == VkSubmitFlagBits::VK_SUBMIT_PROTECTED_BIT as VkSubmitFlags {
		flags.push("VkSubmitFlagBits::VK_SUBMIT_PROTECTED_BIT");
	}
	if (value & VkSubmitFlagBits::VK_SUBMIT_PROTECTED_BIT_KHR as VkSubmitFlags) == VkSubmitFlagBits::VK_SUBMIT_PROTECTED_BIT_KHR as VkSubmitFlags {
		flags.push("VkSubmitFlagBits::VK_SUBMIT_PROTECTED_BIT_KHR");
	}
	if (value & VkSubmitFlagBits::VK_SUBMIT_FLAG_BITS_MAX_ENUM as VkSubmitFlags) == VkSubmitFlagBits::VK_SUBMIT_FLAG_BITS_MAX_ENUM as VkSubmitFlags {
		flags.push("VkSubmitFlagBits::VK_SUBMIT_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkRenderingFlags` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingFlags.html>
pub type VkRenderingFlags = VkFlags;
pub fn vk_rendering_flags_to_string(value: VkRenderingFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(11);
	if (value & VkRenderingFlagBits::VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT as VkRenderingFlags) == VkRenderingFlagBits::VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT as VkRenderingFlags {
		flags.push("VkRenderingFlagBits::VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT");
	}
	if (value & VkRenderingFlagBits::VK_RENDERING_SUSPENDING_BIT as VkRenderingFlags) == VkRenderingFlagBits::VK_RENDERING_SUSPENDING_BIT as VkRenderingFlags {
		flags.push("VkRenderingFlagBits::VK_RENDERING_SUSPENDING_BIT");
	}
	if (value & VkRenderingFlagBits::VK_RENDERING_RESUMING_BIT as VkRenderingFlags) == VkRenderingFlagBits::VK_RENDERING_RESUMING_BIT as VkRenderingFlags {
		flags.push("VkRenderingFlagBits::VK_RENDERING_RESUMING_BIT");
	}
	if (value & VkRenderingFlagBits::VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT as VkRenderingFlags) == VkRenderingFlagBits::VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT as VkRenderingFlags {
		flags.push("VkRenderingFlagBits::VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT");
	}
	if (value & VkRenderingFlagBits::VK_RENDERING_CONTENTS_INLINE_BIT_KHR as VkRenderingFlags) == VkRenderingFlagBits::VK_RENDERING_CONTENTS_INLINE_BIT_KHR as VkRenderingFlags {
		flags.push("VkRenderingFlagBits::VK_RENDERING_CONTENTS_INLINE_BIT_KHR");
	}
	if (value & VkRenderingFlagBits::VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE as VkRenderingFlags) == VkRenderingFlagBits::VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE as VkRenderingFlags {
		flags.push("VkRenderingFlagBits::VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE");
	}
	if (value & VkRenderingFlagBits::VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR as VkRenderingFlags) == VkRenderingFlagBits::VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR as VkRenderingFlags {
		flags.push("VkRenderingFlagBits::VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR");
	}
	if (value & VkRenderingFlagBits::VK_RENDERING_SUSPENDING_BIT_KHR as VkRenderingFlags) == VkRenderingFlagBits::VK_RENDERING_SUSPENDING_BIT_KHR as VkRenderingFlags {
		flags.push("VkRenderingFlagBits::VK_RENDERING_SUSPENDING_BIT_KHR");
	}
	if (value & VkRenderingFlagBits::VK_RENDERING_RESUMING_BIT_KHR as VkRenderingFlags) == VkRenderingFlagBits::VK_RENDERING_RESUMING_BIT_KHR as VkRenderingFlags {
		flags.push("VkRenderingFlagBits::VK_RENDERING_RESUMING_BIT_KHR");
	}
	if (value & VkRenderingFlagBits::VK_RENDERING_CONTENTS_INLINE_BIT_EXT as VkRenderingFlags) == VkRenderingFlagBits::VK_RENDERING_CONTENTS_INLINE_BIT_EXT as VkRenderingFlags {
		flags.push("VkRenderingFlagBits::VK_RENDERING_CONTENTS_INLINE_BIT_EXT");
	}
	if (value & VkRenderingFlagBits::VK_RENDERING_FLAG_BITS_MAX_ENUM as VkRenderingFlags) == VkRenderingFlagBits::VK_RENDERING_FLAG_BITS_MAX_ENUM as VkRenderingFlags {
		flags.push("VkRenderingFlagBits::VK_RENDERING_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkFormatFeatureFlags2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormatFeatureFlags2.html>
pub type VkFormatFeatureFlags2 = VkFlags64;
/// type definition `VkFormatFeatureFlagBits2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormatFeatureFlagBits2.html>
pub type VkFormatFeatureFlagBits2 = VkFlags64;
/// Non-dispatchable handle `VkPrivateDataSlot` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPrivateDataSlot.html
#[cfg(target_pointer_width = "32")] pub type VkPrivateDataSlot = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkPrivateDataSlot_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkPrivateDataSlot = *const VkPrivateDataSlot_T;
/// enum `VkPipelineCreationFeedbackFlagBits` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreationFeedbackFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineCreationFeedbackFlagBits {
	VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT = 0x00000001,
	VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT = 0x00000002,
	VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT = 0x00000004,
	VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineCreationFeedbackFlagBits {
	pub const VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT: VkPipelineCreationFeedbackFlagBits = VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT;
	pub const VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT: VkPipelineCreationFeedbackFlagBits = VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT;
	pub const VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT: VkPipelineCreationFeedbackFlagBits = VkPipelineCreationFeedbackFlagBits::VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT;
}
/// enum `VkToolPurposeFlagBits` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkToolPurposeFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkToolPurposeFlagBits {
	VK_TOOL_PURPOSE_VALIDATION_BIT = 0x00000001,
	VK_TOOL_PURPOSE_PROFILING_BIT = 0x00000002,
	VK_TOOL_PURPOSE_TRACING_BIT = 0x00000004,
	VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT = 0x00000008,
	VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT = 0x00000010,
	VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = 0x00000020,
	VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = 0x00000040,
	VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkToolPurposeFlagBits {
	pub const VK_TOOL_PURPOSE_VALIDATION_BIT_EXT: VkToolPurposeFlagBits = VkToolPurposeFlagBits::VK_TOOL_PURPOSE_VALIDATION_BIT;
	pub const VK_TOOL_PURPOSE_PROFILING_BIT_EXT: VkToolPurposeFlagBits = VkToolPurposeFlagBits::VK_TOOL_PURPOSE_PROFILING_BIT;
	pub const VK_TOOL_PURPOSE_TRACING_BIT_EXT: VkToolPurposeFlagBits = VkToolPurposeFlagBits::VK_TOOL_PURPOSE_TRACING_BIT;
	pub const VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT: VkToolPurposeFlagBits = VkToolPurposeFlagBits::VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT;
	pub const VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT: VkToolPurposeFlagBits = VkToolPurposeFlagBits::VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT;
}
/// enum `VkSubmitFlagBits` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubmitFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSubmitFlagBits {
	VK_SUBMIT_PROTECTED_BIT = 0x00000001,
	VK_SUBMIT_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkSubmitFlagBits {
	pub const VK_SUBMIT_PROTECTED_BIT_KHR: VkSubmitFlagBits = VkSubmitFlagBits::VK_SUBMIT_PROTECTED_BIT;
}
/// enum `VkRenderingFlagBits` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkRenderingFlagBits {
	VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT = 0x00000001,
	VK_RENDERING_SUSPENDING_BIT = 0x00000002,
	VK_RENDERING_RESUMING_BIT = 0x00000004,
	VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x00000008,
	VK_RENDERING_CONTENTS_INLINE_BIT_KHR = 0x00000010,
	VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE = 0x00000020,
	VK_RENDERING_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkRenderingFlagBits {
	pub const VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR: VkRenderingFlagBits = VkRenderingFlagBits::VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT;
	pub const VK_RENDERING_SUSPENDING_BIT_KHR: VkRenderingFlagBits = VkRenderingFlagBits::VK_RENDERING_SUSPENDING_BIT;
	pub const VK_RENDERING_RESUMING_BIT_KHR: VkRenderingFlagBits = VkRenderingFlagBits::VK_RENDERING_RESUMING_BIT;
	pub const VK_RENDERING_CONTENTS_INLINE_BIT_EXT: VkRenderingFlagBits = VkRenderingFlagBits::VK_RENDERING_CONTENTS_INLINE_BIT_KHR;
}
/// struct `VkPhysicalDeviceVulkan13Features` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVulkan13Features.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVulkan13Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub robustImageAccess: VkBool32,
	pub inlineUniformBlock: VkBool32,
	pub descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32,
	pub pipelineCreationCacheControl: VkBool32,
	pub privateData: VkBool32,
	pub shaderDemoteToHelperInvocation: VkBool32,
	pub shaderTerminateInvocation: VkBool32,
	pub subgroupSizeControl: VkBool32,
	pub computeFullSubgroups: VkBool32,
	pub synchronization2: VkBool32,
	pub textureCompressionASTC_HDR: VkBool32,
	pub shaderZeroInitializeWorkgroupMemory: VkBool32,
	pub dynamicRendering: VkBool32,
	pub shaderIntegerDotProduct: VkBool32,
	pub maintenance4: VkBool32,
}
impl Debug for VkPhysicalDeviceVulkan13Features {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVulkan13Features")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("robustImageAccess", &self.robustImageAccess)
		.field("inlineUniformBlock", &self.inlineUniformBlock)
		.field("descriptorBindingInlineUniformBlockUpdateAfterBind", &self.descriptorBindingInlineUniformBlockUpdateAfterBind)
		.field("pipelineCreationCacheControl", &self.pipelineCreationCacheControl)
		.field("privateData", &self.privateData)
		.field("shaderDemoteToHelperInvocation", &self.shaderDemoteToHelperInvocation)
		.field("shaderTerminateInvocation", &self.shaderTerminateInvocation)
		.field("subgroupSizeControl", &self.subgroupSizeControl)
		.field("computeFullSubgroups", &self.computeFullSubgroups)
		.field("synchronization2", &self.synchronization2)
		.field("textureCompressionASTC_HDR", &self.textureCompressionASTC_HDR)
		.field("shaderZeroInitializeWorkgroupMemory", &self.shaderZeroInitializeWorkgroupMemory)
		.field("dynamicRendering", &self.dynamicRendering)
		.field("shaderIntegerDotProduct", &self.shaderIntegerDotProduct)
		.field("maintenance4", &self.maintenance4)
		.finish()
	}
}
/// struct `VkPhysicalDeviceVulkan13Properties` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVulkan13Properties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVulkan13Properties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minSubgroupSize: u32,
	pub maxSubgroupSize: u32,
	pub maxComputeWorkgroupSubgroups: u32,
	pub requiredSubgroupSizeStages: VkShaderStageFlags,
	pub maxInlineUniformBlockSize: u32,
	pub maxPerStageDescriptorInlineUniformBlocks: u32,
	pub maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32,
	pub maxDescriptorSetInlineUniformBlocks: u32,
	pub maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32,
	pub maxInlineUniformTotalSize: u32,
	pub integerDotProduct8BitUnsignedAccelerated: VkBool32,
	pub integerDotProduct8BitSignedAccelerated: VkBool32,
	pub integerDotProduct8BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProduct4x8BitPackedUnsignedAccelerated: VkBool32,
	pub integerDotProduct4x8BitPackedSignedAccelerated: VkBool32,
	pub integerDotProduct4x8BitPackedMixedSignednessAccelerated: VkBool32,
	pub integerDotProduct16BitUnsignedAccelerated: VkBool32,
	pub integerDotProduct16BitSignedAccelerated: VkBool32,
	pub integerDotProduct16BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProduct32BitUnsignedAccelerated: VkBool32,
	pub integerDotProduct32BitSignedAccelerated: VkBool32,
	pub integerDotProduct32BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProduct64BitUnsignedAccelerated: VkBool32,
	pub integerDotProduct64BitSignedAccelerated: VkBool32,
	pub integerDotProduct64BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating8BitSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating16BitSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating32BitSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating64BitSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: VkBool32,
	pub storageTexelBufferOffsetAlignmentBytes: VkDeviceSize,
	pub storageTexelBufferOffsetSingleTexelAlignment: VkBool32,
	pub uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize,
	pub uniformTexelBufferOffsetSingleTexelAlignment: VkBool32,
	pub maxBufferSize: VkDeviceSize,
}
impl Debug for VkPhysicalDeviceVulkan13Properties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVulkan13Properties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("minSubgroupSize", &self.minSubgroupSize)
		.field("maxSubgroupSize", &self.maxSubgroupSize)
		.field("maxComputeWorkgroupSubgroups", &self.maxComputeWorkgroupSubgroups)
		.field("requiredSubgroupSizeStages", &self.requiredSubgroupSizeStages)
		.field("maxInlineUniformBlockSize", &self.maxInlineUniformBlockSize)
		.field("maxPerStageDescriptorInlineUniformBlocks", &self.maxPerStageDescriptorInlineUniformBlocks)
		.field("maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks", &self.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks)
		.field("maxDescriptorSetInlineUniformBlocks", &self.maxDescriptorSetInlineUniformBlocks)
		.field("maxDescriptorSetUpdateAfterBindInlineUniformBlocks", &self.maxDescriptorSetUpdateAfterBindInlineUniformBlocks)
		.field("maxInlineUniformTotalSize", &self.maxInlineUniformTotalSize)
		.field("integerDotProduct8BitUnsignedAccelerated", &self.integerDotProduct8BitUnsignedAccelerated)
		.field("integerDotProduct8BitSignedAccelerated", &self.integerDotProduct8BitSignedAccelerated)
		.field("integerDotProduct8BitMixedSignednessAccelerated", &self.integerDotProduct8BitMixedSignednessAccelerated)
		.field("integerDotProduct4x8BitPackedUnsignedAccelerated", &self.integerDotProduct4x8BitPackedUnsignedAccelerated)
		.field("integerDotProduct4x8BitPackedSignedAccelerated", &self.integerDotProduct4x8BitPackedSignedAccelerated)
		.field("integerDotProduct4x8BitPackedMixedSignednessAccelerated", &self.integerDotProduct4x8BitPackedMixedSignednessAccelerated)
		.field("integerDotProduct16BitUnsignedAccelerated", &self.integerDotProduct16BitUnsignedAccelerated)
		.field("integerDotProduct16BitSignedAccelerated", &self.integerDotProduct16BitSignedAccelerated)
		.field("integerDotProduct16BitMixedSignednessAccelerated", &self.integerDotProduct16BitMixedSignednessAccelerated)
		.field("integerDotProduct32BitUnsignedAccelerated", &self.integerDotProduct32BitUnsignedAccelerated)
		.field("integerDotProduct32BitSignedAccelerated", &self.integerDotProduct32BitSignedAccelerated)
		.field("integerDotProduct32BitMixedSignednessAccelerated", &self.integerDotProduct32BitMixedSignednessAccelerated)
		.field("integerDotProduct64BitUnsignedAccelerated", &self.integerDotProduct64BitUnsignedAccelerated)
		.field("integerDotProduct64BitSignedAccelerated", &self.integerDotProduct64BitSignedAccelerated)
		.field("integerDotProduct64BitMixedSignednessAccelerated", &self.integerDotProduct64BitMixedSignednessAccelerated)
		.field("integerDotProductAccumulatingSaturating8BitUnsignedAccelerated", &self.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated)
		.field("integerDotProductAccumulatingSaturating8BitSignedAccelerated", &self.integerDotProductAccumulatingSaturating8BitSignedAccelerated)
		.field("integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated", &self.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated)
		.field("integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated", &self.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated)
		.field("integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated", &self.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated)
		.field("integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated", &self.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated)
		.field("integerDotProductAccumulatingSaturating16BitUnsignedAccelerated", &self.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated)
		.field("integerDotProductAccumulatingSaturating16BitSignedAccelerated", &self.integerDotProductAccumulatingSaturating16BitSignedAccelerated)
		.field("integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated", &self.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated)
		.field("integerDotProductAccumulatingSaturating32BitUnsignedAccelerated", &self.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated)
		.field("integerDotProductAccumulatingSaturating32BitSignedAccelerated", &self.integerDotProductAccumulatingSaturating32BitSignedAccelerated)
		.field("integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated", &self.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated)
		.field("integerDotProductAccumulatingSaturating64BitUnsignedAccelerated", &self.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated)
		.field("integerDotProductAccumulatingSaturating64BitSignedAccelerated", &self.integerDotProductAccumulatingSaturating64BitSignedAccelerated)
		.field("integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated", &self.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated)
		.field("storageTexelBufferOffsetAlignmentBytes", &self.storageTexelBufferOffsetAlignmentBytes)
		.field("storageTexelBufferOffsetSingleTexelAlignment", &self.storageTexelBufferOffsetSingleTexelAlignment)
		.field("uniformTexelBufferOffsetAlignmentBytes", &self.uniformTexelBufferOffsetAlignmentBytes)
		.field("uniformTexelBufferOffsetSingleTexelAlignment", &self.uniformTexelBufferOffsetSingleTexelAlignment)
		.field("maxBufferSize", &self.maxBufferSize)
		.finish()
	}
}
/// struct `VkPipelineCreationFeedback` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreationFeedback.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineCreationFeedback {
	pub flags: VkPipelineCreationFeedbackFlags,
	pub duration: u64,
}
impl Debug for VkPipelineCreationFeedback {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineCreationFeedback")
		.field("flags", &format_args!("{}", vk_pipeline_creation_feedback_flags_to_string(self.flags)))
		.field("duration", &self.duration)
		.finish()
	}
}
/// struct `VkPipelineCreationFeedbackCreateInfo` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreationFeedbackCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineCreationFeedbackCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pPipelineCreationFeedback: *mut VkPipelineCreationFeedback,
	pub pipelineStageCreationFeedbackCount: u32,
	pub pPipelineStageCreationFeedbacks: *mut VkPipelineCreationFeedback,
}
impl Debug for VkPipelineCreationFeedbackCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineCreationFeedbackCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pPipelineCreationFeedback", &self.pPipelineCreationFeedback)
		.field("pipelineStageCreationFeedbackCount", &self.pipelineStageCreationFeedbackCount)
		.field("pPipelineStageCreationFeedbacks", &self.pPipelineStageCreationFeedbacks)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShaderTerminateInvocationFeatures` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderTerminateInvocationFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderTerminateInvocationFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderTerminateInvocation: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderTerminateInvocationFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderTerminateInvocationFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderTerminateInvocation", &self.shaderTerminateInvocation)
		.finish()
	}
}
/// struct `VkPhysicalDeviceToolProperties` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceToolProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceToolProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub name: [i8; VK_MAX_EXTENSION_NAME_SIZE as usize],
	pub version: [i8; VK_MAX_EXTENSION_NAME_SIZE as usize],
	pub purposes: VkToolPurposeFlags,
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub layer: [i8; VK_MAX_EXTENSION_NAME_SIZE as usize],
}
impl Debug for VkPhysicalDeviceToolProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceToolProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("name", &format_args!("{}", maybe_string(&self.name)))
		.field("version", &format_args!("{}", maybe_string(&self.version)))
		.field("purposes", &format_args!("{}", vk_tool_purpose_flags_to_string(self.purposes)))
		.field("description", &format_args!("{}", maybe_string(&self.description)))
		.field("layer", &format_args!("{}", maybe_string(&self.layer)))
		.finish()
	}
}
/// struct `VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderDemoteToHelperInvocation: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderDemoteToHelperInvocation", &self.shaderDemoteToHelperInvocation)
		.finish()
	}
}
/// struct `VkPhysicalDevicePrivateDataFeatures` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePrivateDataFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePrivateDataFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub privateData: VkBool32,
}
impl Debug for VkPhysicalDevicePrivateDataFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePrivateDataFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("privateData", &self.privateData)
		.finish()
	}
}
/// struct `VkDevicePrivateDataCreateInfo` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDevicePrivateDataCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDevicePrivateDataCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub privateDataSlotRequestCount: u32,
}
impl Debug for VkDevicePrivateDataCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDevicePrivateDataCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("privateDataSlotRequestCount", &self.privateDataSlotRequestCount)
		.finish()
	}
}
/// struct `VkPrivateDataSlotCreateInfo` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPrivateDataSlotCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPrivateDataSlotCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPrivateDataSlotCreateFlags,
}
impl Debug for VkPrivateDataSlotCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPrivateDataSlotCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.finish()
	}
}
/// struct `VkPhysicalDevicePipelineCreationCacheControlFeatures` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePipelineCreationCacheControlFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePipelineCreationCacheControlFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineCreationCacheControl: VkBool32,
}
impl Debug for VkPhysicalDevicePipelineCreationCacheControlFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePipelineCreationCacheControlFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelineCreationCacheControl", &self.pipelineCreationCacheControl)
		.finish()
	}
}
/// struct `VkMemoryBarrier2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryBarrier2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryBarrier2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcStageMask: VkPipelineStageFlags2,
	pub srcAccessMask: VkAccessFlags2,
	pub dstStageMask: VkPipelineStageFlags2,
	pub dstAccessMask: VkAccessFlags2,
}
impl Debug for VkMemoryBarrier2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryBarrier2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcStageMask", &self.srcStageMask)
		.field("srcAccessMask", &self.srcAccessMask)
		.field("dstStageMask", &self.dstStageMask)
		.field("dstAccessMask", &self.dstAccessMask)
		.finish()
	}
}
/// struct `VkBufferMemoryBarrier2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferMemoryBarrier2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBufferMemoryBarrier2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcStageMask: VkPipelineStageFlags2,
	pub srcAccessMask: VkAccessFlags2,
	pub dstStageMask: VkPipelineStageFlags2,
	pub dstAccessMask: VkAccessFlags2,
	pub srcQueueFamilyIndex: u32,
	pub dstQueueFamilyIndex: u32,
	pub buffer: VkBuffer,
	pub offset: VkDeviceSize,
	pub size: VkDeviceSize,
}
impl Debug for VkBufferMemoryBarrier2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBufferMemoryBarrier2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcStageMask", &self.srcStageMask)
		.field("srcAccessMask", &self.srcAccessMask)
		.field("dstStageMask", &self.dstStageMask)
		.field("dstAccessMask", &self.dstAccessMask)
		.field("srcQueueFamilyIndex", &self.srcQueueFamilyIndex)
		.field("dstQueueFamilyIndex", &self.dstQueueFamilyIndex)
		.field("buffer", &self.buffer)
		.field("offset", &self.offset)
		.field("size", &self.size)
		.finish()
	}
}
/// struct `VkImageMemoryBarrier2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageMemoryBarrier2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcStageMask: VkPipelineStageFlags2,
	pub srcAccessMask: VkAccessFlags2,
	pub dstStageMask: VkPipelineStageFlags2,
	pub dstAccessMask: VkAccessFlags2,
	pub oldLayout: VkImageLayout,
	pub newLayout: VkImageLayout,
	pub srcQueueFamilyIndex: u32,
	pub dstQueueFamilyIndex: u32,
	pub image: VkImage,
	pub subresourceRange: VkImageSubresourceRange,
}
impl Debug for VkImageMemoryBarrier2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageMemoryBarrier2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcStageMask", &self.srcStageMask)
		.field("srcAccessMask", &self.srcAccessMask)
		.field("dstStageMask", &self.dstStageMask)
		.field("dstAccessMask", &self.dstAccessMask)
		.field("oldLayout", &self.oldLayout)
		.field("newLayout", &self.newLayout)
		.field("srcQueueFamilyIndex", &self.srcQueueFamilyIndex)
		.field("dstQueueFamilyIndex", &self.dstQueueFamilyIndex)
		.field("image", &self.image)
		.field("subresourceRange", &self.subresourceRange)
		.finish()
	}
}
/// struct `VkDependencyInfo` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDependencyInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDependencyInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dependencyFlags: VkDependencyFlags,
	pub memoryBarrierCount: u32,
	pub pMemoryBarriers: *const VkMemoryBarrier2,
	pub bufferMemoryBarrierCount: u32,
	pub pBufferMemoryBarriers: *const VkBufferMemoryBarrier2,
	pub imageMemoryBarrierCount: u32,
	pub pImageMemoryBarriers: *const VkImageMemoryBarrier2,
}
impl Debug for VkDependencyInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDependencyInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dependencyFlags", &self.dependencyFlags)
		.field("memoryBarrierCount", &self.memoryBarrierCount)
		.field("pMemoryBarriers", &self.pMemoryBarriers)
		.field("bufferMemoryBarrierCount", &self.bufferMemoryBarrierCount)
		.field("pBufferMemoryBarriers", &self.pBufferMemoryBarriers)
		.field("imageMemoryBarrierCount", &self.imageMemoryBarrierCount)
		.field("pImageMemoryBarriers", &self.pImageMemoryBarriers)
		.finish()
	}
}
/// struct `VkSemaphoreSubmitInfo` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreSubmitInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSemaphoreSubmitInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub semaphore: VkSemaphore,
	pub value: u64,
	pub stageMask: VkPipelineStageFlags2,
	pub deviceIndex: u32,
}
impl Debug for VkSemaphoreSubmitInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSemaphoreSubmitInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("semaphore", &self.semaphore)
		.field("value", &self.value)
		.field("stageMask", &self.stageMask)
		.field("deviceIndex", &self.deviceIndex)
		.finish()
	}
}
/// struct `VkCommandBufferSubmitInfo` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferSubmitInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCommandBufferSubmitInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub commandBuffer: VkCommandBuffer,
	pub deviceMask: u32,
}
impl Debug for VkCommandBufferSubmitInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCommandBufferSubmitInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("commandBuffer", &self.commandBuffer)
		.field("deviceMask", &self.deviceMask)
		.finish()
	}
}
/// struct `VkSubmitInfo2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubmitInfo2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSubmitInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkSubmitFlags,
	pub waitSemaphoreInfoCount: u32,
	pub pWaitSemaphoreInfos: *const VkSemaphoreSubmitInfo,
	pub commandBufferInfoCount: u32,
	pub pCommandBufferInfos: *const VkCommandBufferSubmitInfo,
	pub signalSemaphoreInfoCount: u32,
	pub pSignalSemaphoreInfos: *const VkSemaphoreSubmitInfo,
}
impl Debug for VkSubmitInfo2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSubmitInfo2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_submit_flags_to_string(self.flags)))
		.field("waitSemaphoreInfoCount", &self.waitSemaphoreInfoCount)
		.field("pWaitSemaphoreInfos", &self.pWaitSemaphoreInfos)
		.field("commandBufferInfoCount", &self.commandBufferInfoCount)
		.field("pCommandBufferInfos", &self.pCommandBufferInfos)
		.field("signalSemaphoreInfoCount", &self.signalSemaphoreInfoCount)
		.field("pSignalSemaphoreInfos", &self.pSignalSemaphoreInfos)
		.finish()
	}
}
/// struct `VkPhysicalDeviceSynchronization2Features` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSynchronization2Features.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSynchronization2Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub synchronization2: VkBool32,
}
impl Debug for VkPhysicalDeviceSynchronization2Features {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSynchronization2Features")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("synchronization2", &self.synchronization2)
		.finish()
	}
}
/// struct `VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderZeroInitializeWorkgroupMemory: VkBool32,
}
impl Debug for VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderZeroInitializeWorkgroupMemory", &self.shaderZeroInitializeWorkgroupMemory)
		.finish()
	}
}
/// struct `VkPhysicalDeviceImageRobustnessFeatures` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImageRobustnessFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceImageRobustnessFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub robustImageAccess: VkBool32,
}
impl Debug for VkPhysicalDeviceImageRobustnessFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceImageRobustnessFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("robustImageAccess", &self.robustImageAccess)
		.finish()
	}
}
/// struct `VkBufferCopy2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferCopy2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBufferCopy2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcOffset: VkDeviceSize,
	pub dstOffset: VkDeviceSize,
	pub size: VkDeviceSize,
}
impl Debug for VkBufferCopy2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBufferCopy2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcOffset", &self.srcOffset)
		.field("dstOffset", &self.dstOffset)
		.field("size", &self.size)
		.finish()
	}
}
/// struct `VkCopyBufferInfo2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyBufferInfo2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyBufferInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcBuffer: VkBuffer,
	pub dstBuffer: VkBuffer,
	pub regionCount: u32,
	pub pRegions: *const VkBufferCopy2,
}
impl Debug for VkCopyBufferInfo2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyBufferInfo2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcBuffer", &self.srcBuffer)
		.field("dstBuffer", &self.dstBuffer)
		.field("regionCount", &self.regionCount)
		.field("pRegions", &self.pRegions)
		.finish()
	}
}
/// struct `VkImageCopy2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCopy2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageCopy2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcSubresource: VkImageSubresourceLayers,
	pub srcOffset: VkOffset3D,
	pub dstSubresource: VkImageSubresourceLayers,
	pub dstOffset: VkOffset3D,
	pub extent: VkExtent3D,
}
impl Debug for VkImageCopy2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageCopy2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcSubresource", &self.srcSubresource)
		.field("srcOffset", &self.srcOffset)
		.field("dstSubresource", &self.dstSubresource)
		.field("dstOffset", &self.dstOffset)
		.field("extent", &self.extent)
		.finish()
	}
}
/// struct `VkCopyImageInfo2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyImageInfo2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyImageInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcImage: VkImage,
	pub srcImageLayout: VkImageLayout,
	pub dstImage: VkImage,
	pub dstImageLayout: VkImageLayout,
	pub regionCount: u32,
	pub pRegions: *const VkImageCopy2,
}
impl Debug for VkCopyImageInfo2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyImageInfo2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcImage", &self.srcImage)
		.field("srcImageLayout", &self.srcImageLayout)
		.field("dstImage", &self.dstImage)
		.field("dstImageLayout", &self.dstImageLayout)
		.field("regionCount", &self.regionCount)
		.field("pRegions", &self.pRegions)
		.finish()
	}
}
/// struct `VkBufferImageCopy2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferImageCopy2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBufferImageCopy2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub bufferOffset: VkDeviceSize,
	pub bufferRowLength: u32,
	pub bufferImageHeight: u32,
	pub imageSubresource: VkImageSubresourceLayers,
	pub imageOffset: VkOffset3D,
	pub imageExtent: VkExtent3D,
}
impl Debug for VkBufferImageCopy2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBufferImageCopy2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("bufferOffset", &self.bufferOffset)
		.field("bufferRowLength", &self.bufferRowLength)
		.field("bufferImageHeight", &self.bufferImageHeight)
		.field("imageSubresource", &self.imageSubresource)
		.field("imageOffset", &self.imageOffset)
		.field("imageExtent", &self.imageExtent)
		.finish()
	}
}
/// struct `VkCopyBufferToImageInfo2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyBufferToImageInfo2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyBufferToImageInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcBuffer: VkBuffer,
	pub dstImage: VkImage,
	pub dstImageLayout: VkImageLayout,
	pub regionCount: u32,
	pub pRegions: *const VkBufferImageCopy2,
}
impl Debug for VkCopyBufferToImageInfo2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyBufferToImageInfo2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcBuffer", &self.srcBuffer)
		.field("dstImage", &self.dstImage)
		.field("dstImageLayout", &self.dstImageLayout)
		.field("regionCount", &self.regionCount)
		.field("pRegions", &self.pRegions)
		.finish()
	}
}
/// struct `VkCopyImageToBufferInfo2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyImageToBufferInfo2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyImageToBufferInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcImage: VkImage,
	pub srcImageLayout: VkImageLayout,
	pub dstBuffer: VkBuffer,
	pub regionCount: u32,
	pub pRegions: *const VkBufferImageCopy2,
}
impl Debug for VkCopyImageToBufferInfo2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyImageToBufferInfo2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcImage", &self.srcImage)
		.field("srcImageLayout", &self.srcImageLayout)
		.field("dstBuffer", &self.dstBuffer)
		.field("regionCount", &self.regionCount)
		.field("pRegions", &self.pRegions)
		.finish()
	}
}
/// struct `VkImageBlit2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageBlit2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageBlit2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcSubresource: VkImageSubresourceLayers,
	pub srcOffsets: [VkOffset3D; 2 as usize],
	pub dstSubresource: VkImageSubresourceLayers,
	pub dstOffsets: [VkOffset3D; 2 as usize],
}
impl Debug for VkImageBlit2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageBlit2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcSubresource", &self.srcSubresource)
		.field("srcOffsets", &self.srcOffsets)
		.field("dstSubresource", &self.dstSubresource)
		.field("dstOffsets", &self.dstOffsets)
		.finish()
	}
}
/// struct `VkBlitImageInfo2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBlitImageInfo2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBlitImageInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcImage: VkImage,
	pub srcImageLayout: VkImageLayout,
	pub dstImage: VkImage,
	pub dstImageLayout: VkImageLayout,
	pub regionCount: u32,
	pub pRegions: *const VkImageBlit2,
	pub filter: VkFilter,
}
impl Debug for VkBlitImageInfo2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBlitImageInfo2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcImage", &self.srcImage)
		.field("srcImageLayout", &self.srcImageLayout)
		.field("dstImage", &self.dstImage)
		.field("dstImageLayout", &self.dstImageLayout)
		.field("regionCount", &self.regionCount)
		.field("pRegions", &self.pRegions)
		.field("filter", &self.filter)
		.finish()
	}
}
/// struct `VkImageResolve2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageResolve2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageResolve2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcSubresource: VkImageSubresourceLayers,
	pub srcOffset: VkOffset3D,
	pub dstSubresource: VkImageSubresourceLayers,
	pub dstOffset: VkOffset3D,
	pub extent: VkExtent3D,
}
impl Debug for VkImageResolve2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageResolve2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcSubresource", &self.srcSubresource)
		.field("srcOffset", &self.srcOffset)
		.field("dstSubresource", &self.dstSubresource)
		.field("dstOffset", &self.dstOffset)
		.field("extent", &self.extent)
		.finish()
	}
}
/// struct `VkResolveImageInfo2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkResolveImageInfo2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkResolveImageInfo2 {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcImage: VkImage,
	pub srcImageLayout: VkImageLayout,
	pub dstImage: VkImage,
	pub dstImageLayout: VkImageLayout,
	pub regionCount: u32,
	pub pRegions: *const VkImageResolve2,
}
impl Debug for VkResolveImageInfo2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkResolveImageInfo2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcImage", &self.srcImage)
		.field("srcImageLayout", &self.srcImageLayout)
		.field("dstImage", &self.dstImage)
		.field("dstImageLayout", &self.dstImageLayout)
		.field("regionCount", &self.regionCount)
		.field("pRegions", &self.pRegions)
		.finish()
	}
}
/// struct `VkPhysicalDeviceSubgroupSizeControlFeatures` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSubgroupSizeControlFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSubgroupSizeControlFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub subgroupSizeControl: VkBool32,
	pub computeFullSubgroups: VkBool32,
}
impl Debug for VkPhysicalDeviceSubgroupSizeControlFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSubgroupSizeControlFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("subgroupSizeControl", &self.subgroupSizeControl)
		.field("computeFullSubgroups", &self.computeFullSubgroups)
		.finish()
	}
}
/// struct `VkPhysicalDeviceSubgroupSizeControlProperties` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSubgroupSizeControlProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSubgroupSizeControlProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minSubgroupSize: u32,
	pub maxSubgroupSize: u32,
	pub maxComputeWorkgroupSubgroups: u32,
	pub requiredSubgroupSizeStages: VkShaderStageFlags,
}
impl Debug for VkPhysicalDeviceSubgroupSizeControlProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSubgroupSizeControlProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("minSubgroupSize", &self.minSubgroupSize)
		.field("maxSubgroupSize", &self.maxSubgroupSize)
		.field("maxComputeWorkgroupSubgroups", &self.maxComputeWorkgroupSubgroups)
		.field("requiredSubgroupSizeStages", &self.requiredSubgroupSizeStages)
		.finish()
	}
}
/// struct `VkPipelineShaderStageRequiredSubgroupSizeCreateInfo` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub requiredSubgroupSize: u32,
}
impl Debug for VkPipelineShaderStageRequiredSubgroupSizeCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineShaderStageRequiredSubgroupSizeCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("requiredSubgroupSize", &self.requiredSubgroupSize)
		.finish()
	}
}
/// struct `VkPhysicalDeviceInlineUniformBlockFeatures` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceInlineUniformBlockFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceInlineUniformBlockFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub inlineUniformBlock: VkBool32,
	pub descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32,
}
impl Debug for VkPhysicalDeviceInlineUniformBlockFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceInlineUniformBlockFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("inlineUniformBlock", &self.inlineUniformBlock)
		.field("descriptorBindingInlineUniformBlockUpdateAfterBind", &self.descriptorBindingInlineUniformBlockUpdateAfterBind)
		.finish()
	}
}
/// struct `VkPhysicalDeviceInlineUniformBlockProperties` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceInlineUniformBlockProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceInlineUniformBlockProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxInlineUniformBlockSize: u32,
	pub maxPerStageDescriptorInlineUniformBlocks: u32,
	pub maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32,
	pub maxDescriptorSetInlineUniformBlocks: u32,
	pub maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32,
}
impl Debug for VkPhysicalDeviceInlineUniformBlockProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceInlineUniformBlockProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxInlineUniformBlockSize", &self.maxInlineUniformBlockSize)
		.field("maxPerStageDescriptorInlineUniformBlocks", &self.maxPerStageDescriptorInlineUniformBlocks)
		.field("maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks", &self.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks)
		.field("maxDescriptorSetInlineUniformBlocks", &self.maxDescriptorSetInlineUniformBlocks)
		.field("maxDescriptorSetUpdateAfterBindInlineUniformBlocks", &self.maxDescriptorSetUpdateAfterBindInlineUniformBlocks)
		.finish()
	}
}
/// struct `VkWriteDescriptorSetInlineUniformBlock` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetInlineUniformBlock.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkWriteDescriptorSetInlineUniformBlock {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dataSize: u32,
	pub pData: *const c_void,
}
impl Debug for VkWriteDescriptorSetInlineUniformBlock {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkWriteDescriptorSetInlineUniformBlock")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dataSize", &self.dataSize)
		.field("pData", &self.pData)
		.finish()
	}
}
/// struct `VkDescriptorPoolInlineUniformBlockCreateInfo` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolInlineUniformBlockCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorPoolInlineUniformBlockCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maxInlineUniformBlockBindings: u32,
}
impl Debug for VkDescriptorPoolInlineUniformBlockCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorPoolInlineUniformBlockCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxInlineUniformBlockBindings", &self.maxInlineUniformBlockBindings)
		.finish()
	}
}
/// struct `VkPhysicalDeviceTextureCompressionASTCHDRFeatures` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTextureCompressionASTCHDRFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceTextureCompressionASTCHDRFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub textureCompressionASTC_HDR: VkBool32,
}
impl Debug for VkPhysicalDeviceTextureCompressionASTCHDRFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceTextureCompressionASTCHDRFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("textureCompressionASTC_HDR", &self.textureCompressionASTC_HDR)
		.finish()
	}
}
/// struct `VkRenderingAttachmentInfo` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingAttachmentInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderingAttachmentInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub imageView: VkImageView,
	pub imageLayout: VkImageLayout,
	pub resolveMode: VkResolveModeFlagBits,
	pub resolveImageView: VkImageView,
	pub resolveImageLayout: VkImageLayout,
	pub loadOp: VkAttachmentLoadOp,
	pub storeOp: VkAttachmentStoreOp,
	pub clearValue: VkClearValue,
}
impl Debug for VkRenderingAttachmentInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderingAttachmentInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("imageView", &self.imageView)
		.field("imageLayout", &self.imageLayout)
		.field("resolveMode", &self.resolveMode)
		.field("resolveImageView", &self.resolveImageView)
		.field("resolveImageLayout", &self.resolveImageLayout)
		.field("loadOp", &self.loadOp)
		.field("storeOp", &self.storeOp)
		.field("clearValue", &self.clearValue)
		.finish()
	}
}
/// struct `VkRenderingInfo` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderingInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkRenderingFlags,
	pub renderArea: VkRect2D,
	pub layerCount: u32,
	pub viewMask: u32,
	pub colorAttachmentCount: u32,
	pub pColorAttachments: *const VkRenderingAttachmentInfo,
	pub pDepthAttachment: *const VkRenderingAttachmentInfo,
	pub pStencilAttachment: *const VkRenderingAttachmentInfo,
}
impl Debug for VkRenderingInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderingInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_rendering_flags_to_string(self.flags)))
		.field("renderArea", &self.renderArea)
		.field("layerCount", &self.layerCount)
		.field("viewMask", &self.viewMask)
		.field("colorAttachmentCount", &self.colorAttachmentCount)
		.field("pColorAttachments", &self.pColorAttachments)
		.field("pDepthAttachment", &self.pDepthAttachment)
		.field("pStencilAttachment", &self.pStencilAttachment)
		.finish()
	}
}
/// struct `VkPipelineRenderingCreateInfo` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRenderingCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineRenderingCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub viewMask: u32,
	pub colorAttachmentCount: u32,
	pub pColorAttachmentFormats: *const VkFormat,
	pub depthAttachmentFormat: VkFormat,
	pub stencilAttachmentFormat: VkFormat,
}
impl Debug for VkPipelineRenderingCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineRenderingCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("viewMask", &self.viewMask)
		.field("colorAttachmentCount", &self.colorAttachmentCount)
		.field("pColorAttachmentFormats", &self.pColorAttachmentFormats)
		.field("depthAttachmentFormat", &self.depthAttachmentFormat)
		.field("stencilAttachmentFormat", &self.stencilAttachmentFormat)
		.finish()
	}
}
/// struct `VkPhysicalDeviceDynamicRenderingFeatures` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDynamicRenderingFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDynamicRenderingFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub dynamicRendering: VkBool32,
}
impl Debug for VkPhysicalDeviceDynamicRenderingFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDynamicRenderingFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dynamicRendering", &self.dynamicRendering)
		.finish()
	}
}
/// struct `VkCommandBufferInheritanceRenderingInfo` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferInheritanceRenderingInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCommandBufferInheritanceRenderingInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkRenderingFlags,
	pub viewMask: u32,
	pub colorAttachmentCount: u32,
	pub pColorAttachmentFormats: *const VkFormat,
	pub depthAttachmentFormat: VkFormat,
	pub stencilAttachmentFormat: VkFormat,
	pub rasterizationSamples: VkSampleCountFlagBits,
}
impl Debug for VkCommandBufferInheritanceRenderingInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCommandBufferInheritanceRenderingInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_rendering_flags_to_string(self.flags)))
		.field("viewMask", &self.viewMask)
		.field("colorAttachmentCount", &self.colorAttachmentCount)
		.field("pColorAttachmentFormats", &self.pColorAttachmentFormats)
		.field("depthAttachmentFormat", &self.depthAttachmentFormat)
		.field("stencilAttachmentFormat", &self.stencilAttachmentFormat)
		.field("rasterizationSamples", &self.rasterizationSamples)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShaderIntegerDotProductFeatures` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderIntegerDotProductFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderIntegerDotProductFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderIntegerDotProduct: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderIntegerDotProductFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderIntegerDotProductFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderIntegerDotProduct", &self.shaderIntegerDotProduct)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShaderIntegerDotProductProperties` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderIntegerDotProductProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderIntegerDotProductProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub integerDotProduct8BitUnsignedAccelerated: VkBool32,
	pub integerDotProduct8BitSignedAccelerated: VkBool32,
	pub integerDotProduct8BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProduct4x8BitPackedUnsignedAccelerated: VkBool32,
	pub integerDotProduct4x8BitPackedSignedAccelerated: VkBool32,
	pub integerDotProduct4x8BitPackedMixedSignednessAccelerated: VkBool32,
	pub integerDotProduct16BitUnsignedAccelerated: VkBool32,
	pub integerDotProduct16BitSignedAccelerated: VkBool32,
	pub integerDotProduct16BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProduct32BitUnsignedAccelerated: VkBool32,
	pub integerDotProduct32BitSignedAccelerated: VkBool32,
	pub integerDotProduct32BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProduct64BitUnsignedAccelerated: VkBool32,
	pub integerDotProduct64BitSignedAccelerated: VkBool32,
	pub integerDotProduct64BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating8BitSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating16BitSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating32BitSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating64BitSignedAccelerated: VkBool32,
	pub integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderIntegerDotProductProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderIntegerDotProductProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("integerDotProduct8BitUnsignedAccelerated", &self.integerDotProduct8BitUnsignedAccelerated)
		.field("integerDotProduct8BitSignedAccelerated", &self.integerDotProduct8BitSignedAccelerated)
		.field("integerDotProduct8BitMixedSignednessAccelerated", &self.integerDotProduct8BitMixedSignednessAccelerated)
		.field("integerDotProduct4x8BitPackedUnsignedAccelerated", &self.integerDotProduct4x8BitPackedUnsignedAccelerated)
		.field("integerDotProduct4x8BitPackedSignedAccelerated", &self.integerDotProduct4x8BitPackedSignedAccelerated)
		.field("integerDotProduct4x8BitPackedMixedSignednessAccelerated", &self.integerDotProduct4x8BitPackedMixedSignednessAccelerated)
		.field("integerDotProduct16BitUnsignedAccelerated", &self.integerDotProduct16BitUnsignedAccelerated)
		.field("integerDotProduct16BitSignedAccelerated", &self.integerDotProduct16BitSignedAccelerated)
		.field("integerDotProduct16BitMixedSignednessAccelerated", &self.integerDotProduct16BitMixedSignednessAccelerated)
		.field("integerDotProduct32BitUnsignedAccelerated", &self.integerDotProduct32BitUnsignedAccelerated)
		.field("integerDotProduct32BitSignedAccelerated", &self.integerDotProduct32BitSignedAccelerated)
		.field("integerDotProduct32BitMixedSignednessAccelerated", &self.integerDotProduct32BitMixedSignednessAccelerated)
		.field("integerDotProduct64BitUnsignedAccelerated", &self.integerDotProduct64BitUnsignedAccelerated)
		.field("integerDotProduct64BitSignedAccelerated", &self.integerDotProduct64BitSignedAccelerated)
		.field("integerDotProduct64BitMixedSignednessAccelerated", &self.integerDotProduct64BitMixedSignednessAccelerated)
		.field("integerDotProductAccumulatingSaturating8BitUnsignedAccelerated", &self.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated)
		.field("integerDotProductAccumulatingSaturating8BitSignedAccelerated", &self.integerDotProductAccumulatingSaturating8BitSignedAccelerated)
		.field("integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated", &self.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated)
		.field("integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated", &self.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated)
		.field("integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated", &self.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated)
		.field("integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated", &self.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated)
		.field("integerDotProductAccumulatingSaturating16BitUnsignedAccelerated", &self.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated)
		.field("integerDotProductAccumulatingSaturating16BitSignedAccelerated", &self.integerDotProductAccumulatingSaturating16BitSignedAccelerated)
		.field("integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated", &self.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated)
		.field("integerDotProductAccumulatingSaturating32BitUnsignedAccelerated", &self.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated)
		.field("integerDotProductAccumulatingSaturating32BitSignedAccelerated", &self.integerDotProductAccumulatingSaturating32BitSignedAccelerated)
		.field("integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated", &self.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated)
		.field("integerDotProductAccumulatingSaturating64BitUnsignedAccelerated", &self.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated)
		.field("integerDotProductAccumulatingSaturating64BitSignedAccelerated", &self.integerDotProductAccumulatingSaturating64BitSignedAccelerated)
		.field("integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated", &self.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated)
		.finish()
	}
}
/// struct `VkPhysicalDeviceTexelBufferAlignmentProperties` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTexelBufferAlignmentProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceTexelBufferAlignmentProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub storageTexelBufferOffsetAlignmentBytes: VkDeviceSize,
	pub storageTexelBufferOffsetSingleTexelAlignment: VkBool32,
	pub uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize,
	pub uniformTexelBufferOffsetSingleTexelAlignment: VkBool32,
}
impl Debug for VkPhysicalDeviceTexelBufferAlignmentProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceTexelBufferAlignmentProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("storageTexelBufferOffsetAlignmentBytes", &self.storageTexelBufferOffsetAlignmentBytes)
		.field("storageTexelBufferOffsetSingleTexelAlignment", &self.storageTexelBufferOffsetSingleTexelAlignment)
		.field("uniformTexelBufferOffsetAlignmentBytes", &self.uniformTexelBufferOffsetAlignmentBytes)
		.field("uniformTexelBufferOffsetSingleTexelAlignment", &self.uniformTexelBufferOffsetSingleTexelAlignment)
		.finish()
	}
}
/// struct `VkFormatProperties3` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormatProperties3.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkFormatProperties3 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub linearTilingFeatures: VkFormatFeatureFlags2,
	pub optimalTilingFeatures: VkFormatFeatureFlags2,
	pub bufferFeatures: VkFormatFeatureFlags2,
}
impl Debug for VkFormatProperties3 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkFormatProperties3")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("linearTilingFeatures", &self.linearTilingFeatures)
		.field("optimalTilingFeatures", &self.optimalTilingFeatures)
		.field("bufferFeatures", &self.bufferFeatures)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMaintenance4Features` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance4Features.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance4Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maintenance4: VkBool32,
}
impl Debug for VkPhysicalDeviceMaintenance4Features {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMaintenance4Features")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maintenance4", &self.maintenance4)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMaintenance4Properties` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance4Properties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance4Properties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxBufferSize: VkDeviceSize,
}
impl Debug for VkPhysicalDeviceMaintenance4Properties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMaintenance4Properties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxBufferSize", &self.maxBufferSize)
		.finish()
	}
}
/// struct `VkDeviceBufferMemoryRequirements` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceBufferMemoryRequirements.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceBufferMemoryRequirements {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pCreateInfo: *const VkBufferCreateInfo,
}
impl Debug for VkDeviceBufferMemoryRequirements {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceBufferMemoryRequirements")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pCreateInfo", &self.pCreateInfo)
		.finish()
	}
}
/// struct `VkDeviceImageMemoryRequirements` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceImageMemoryRequirements.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceImageMemoryRequirements {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pCreateInfo: *const VkImageCreateInfo,
	pub planeAspect: VkImageAspectFlagBits,
}
impl Debug for VkDeviceImageMemoryRequirements {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceImageMemoryRequirements")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pCreateInfo", &self.pCreateInfo)
		.field("planeAspect", &self.planeAspect)
		.finish()
	}
}
/// function prototype `PFN_vkGetPhysicalDeviceToolProperties` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceToolProperties.html>
type PFN_vkGetPhysicalDeviceToolProperties = extern "system" fn(physicalDevice: VkPhysicalDevice, pToolCount: *mut uint32_t, pToolProperties: *mut VkPhysicalDeviceToolProperties) -> VkResult;
/// function prototype `PFN_vkCreatePrivateDataSlot` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePrivateDataSlot.html>
type PFN_vkCreatePrivateDataSlot = extern "system" fn(device: VkDevice, pCreateInfo: *const VkPrivateDataSlotCreateInfo, pAllocator: *const VkAllocationCallbacks, pPrivateDataSlot: *mut VkPrivateDataSlot) -> VkResult;
/// function prototype `PFN_vkDestroyPrivateDataSlot` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPrivateDataSlot.html>
type PFN_vkDestroyPrivateDataSlot = extern "system" fn(device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkSetPrivateData` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetPrivateData.html>
type PFN_vkSetPrivateData = extern "system" fn(device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, data: u64) -> VkResult;
/// function prototype `PFN_vkGetPrivateData` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPrivateData.html>
type PFN_vkGetPrivateData = extern "system" fn(device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, pData: *mut uint64_t);
/// function prototype `PFN_vkCmdSetEvent2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetEvent2.html>
type PFN_vkCmdSetEvent2 = extern "system" fn(commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *const VkDependencyInfo);
/// function prototype `PFN_vkCmdResetEvent2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResetEvent2.html>
type PFN_vkCmdResetEvent2 = extern "system" fn(commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2);
/// function prototype `PFN_vkCmdWaitEvents2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWaitEvents2.html>
type PFN_vkCmdWaitEvents2 = extern "system" fn(commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, pDependencyInfos: *const VkDependencyInfo);
/// function prototype `PFN_vkCmdPipelineBarrier2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPipelineBarrier2.html>
type PFN_vkCmdPipelineBarrier2 = extern "system" fn(commandBuffer: VkCommandBuffer, pDependencyInfo: *const VkDependencyInfo);
/// function prototype `PFN_vkCmdWriteTimestamp2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteTimestamp2.html>
type PFN_vkCmdWriteTimestamp2 = extern "system" fn(commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: u32);
/// function prototype `PFN_vkQueueSubmit2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueSubmit2.html>
type PFN_vkQueueSubmit2 = extern "system" fn(queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo2, fence: VkFence) -> VkResult;
/// function prototype `PFN_vkCmdCopyBuffer2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBuffer2.html>
type PFN_vkCmdCopyBuffer2 = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2);
/// function prototype `PFN_vkCmdCopyImage2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImage2.html>
type PFN_vkCmdCopyImage2 = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyImageInfo: *const VkCopyImageInfo2);
/// function prototype `PFN_vkCmdCopyBufferToImage2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage2.html>
type PFN_vkCmdCopyBufferToImage2 = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: *const VkCopyBufferToImageInfo2);
/// function prototype `PFN_vkCmdCopyImageToBuffer2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer2.html>
type PFN_vkCmdCopyImageToBuffer2 = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: *const VkCopyImageToBufferInfo2);
/// function prototype `PFN_vkCmdBlitImage2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage2.html>
type PFN_vkCmdBlitImage2 = extern "system" fn(commandBuffer: VkCommandBuffer, pBlitImageInfo: *const VkBlitImageInfo2);
/// function prototype `PFN_vkCmdResolveImage2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResolveImage2.html>
type PFN_vkCmdResolveImage2 = extern "system" fn(commandBuffer: VkCommandBuffer, pResolveImageInfo: *const VkResolveImageInfo2);
/// function prototype `PFN_vkCmdBeginRendering` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRendering.html>
type PFN_vkCmdBeginRendering = extern "system" fn(commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo);
/// function prototype `PFN_vkCmdEndRendering` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRendering.html>
type PFN_vkCmdEndRendering = extern "system" fn(commandBuffer: VkCommandBuffer);
/// function prototype `PFN_vkCmdSetCullMode` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCullMode.html>
type PFN_vkCmdSetCullMode = extern "system" fn(commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags);
/// function prototype `PFN_vkCmdSetFrontFace` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetFrontFace.html>
type PFN_vkCmdSetFrontFace = extern "system" fn(commandBuffer: VkCommandBuffer, frontFace: VkFrontFace);
/// function prototype `PFN_vkCmdSetPrimitiveTopology` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPrimitiveTopology.html>
type PFN_vkCmdSetPrimitiveTopology = extern "system" fn(commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology);
/// function prototype `PFN_vkCmdSetViewportWithCount` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportWithCount.html>
type PFN_vkCmdSetViewportWithCount = extern "system" fn(commandBuffer: VkCommandBuffer, viewportCount: u32, pViewports: *const VkViewport);
/// function prototype `PFN_vkCmdSetScissorWithCount` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetScissorWithCount.html>
type PFN_vkCmdSetScissorWithCount = extern "system" fn(commandBuffer: VkCommandBuffer, scissorCount: u32, pScissors: *const VkRect2D);
/// function prototype `PFN_vkCmdBindVertexBuffers2` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindVertexBuffers2.html>
type PFN_vkCmdBindVertexBuffers2 = extern "system" fn(commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize, pStrides: *const VkDeviceSize);
/// function prototype `PFN_vkCmdSetDepthTestEnable` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthTestEnable.html>
type PFN_vkCmdSetDepthTestEnable = extern "system" fn(commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32);
/// function prototype `PFN_vkCmdSetDepthWriteEnable` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthWriteEnable.html>
type PFN_vkCmdSetDepthWriteEnable = extern "system" fn(commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32);
/// function prototype `PFN_vkCmdSetDepthCompareOp` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthCompareOp.html>
type PFN_vkCmdSetDepthCompareOp = extern "system" fn(commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp);
/// function prototype `PFN_vkCmdSetDepthBoundsTestEnable` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBoundsTestEnable.html>
type PFN_vkCmdSetDepthBoundsTestEnable = extern "system" fn(commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32);
/// function prototype `PFN_vkCmdSetStencilTestEnable` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilTestEnable.html>
type PFN_vkCmdSetStencilTestEnable = extern "system" fn(commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32);
/// function prototype `PFN_vkCmdSetStencilOp` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilOp.html>
type PFN_vkCmdSetStencilOp = extern "system" fn(commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp);
/// function prototype `PFN_vkCmdSetRasterizerDiscardEnable` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRasterizerDiscardEnable.html>
type PFN_vkCmdSetRasterizerDiscardEnable = extern "system" fn(commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32);
/// function prototype `PFN_vkCmdSetDepthBiasEnable` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBiasEnable.html>
type PFN_vkCmdSetDepthBiasEnable = extern "system" fn(commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32);
/// function prototype `PFN_vkCmdSetPrimitiveRestartEnable` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPrimitiveRestartEnable.html>
type PFN_vkCmdSetPrimitiveRestartEnable = extern "system" fn(commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32);
/// function prototype `PFN_vkGetDeviceBufferMemoryRequirements` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceBufferMemoryRequirements.html>
type PFN_vkGetDeviceBufferMemoryRequirements = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceBufferMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2);
/// function prototype `PFN_vkGetDeviceImageMemoryRequirements` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageMemoryRequirements.html>
type PFN_vkGetDeviceImageMemoryRequirements = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2);
/// function prototype `PFN_vkGetDeviceImageSparseMemoryRequirements` from VK_VERSION_1_3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSparseMemoryRequirements.html>
type PFN_vkGetDeviceImageSparseMemoryRequirements = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2);
/// The dummy function for `vkGetPhysicalDeviceToolProperties` from `VK_VERSION_1_3`
extern "system" fn dummy_vkGetPhysicalDeviceToolProperties(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkPhysicalDeviceToolProperties) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceToolProperties"))
}
/// The dummy function for `vkCreatePrivateDataSlot` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCreatePrivateDataSlot(_: VkDevice, _: *const VkPrivateDataSlotCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkPrivateDataSlot) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreatePrivateDataSlot"))
}
/// The dummy function for `vkDestroyPrivateDataSlot` from `VK_VERSION_1_3`
extern "system" fn dummy_vkDestroyPrivateDataSlot(_: VkDevice, _: VkPrivateDataSlot, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroyPrivateDataSlot"))
}
/// The dummy function for `vkSetPrivateData` from `VK_VERSION_1_3`
extern "system" fn dummy_vkSetPrivateData(_: VkDevice, _: VkObjectType, _: u64, _: VkPrivateDataSlot, _: u64) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkSetPrivateData"))
}
/// The dummy function for `vkGetPrivateData` from `VK_VERSION_1_3`
extern "system" fn dummy_vkGetPrivateData(_: VkDevice, _: VkObjectType, _: u64, _: VkPrivateDataSlot, _: *mut uint64_t) {
	panic_any(VkError::NullFunctionPointer("vkGetPrivateData"))
}
/// The dummy function for `vkCmdSetEvent2` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdSetEvent2(_: VkCommandBuffer, _: VkEvent, _: *const VkDependencyInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetEvent2"))
}
/// The dummy function for `vkCmdResetEvent2` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdResetEvent2(_: VkCommandBuffer, _: VkEvent, _: VkPipelineStageFlags2) {
	panic_any(VkError::NullFunctionPointer("vkCmdResetEvent2"))
}
/// The dummy function for `vkCmdWaitEvents2` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdWaitEvents2(_: VkCommandBuffer, _: u32, _: *const VkEvent, _: *const VkDependencyInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdWaitEvents2"))
}
/// The dummy function for `vkCmdPipelineBarrier2` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdPipelineBarrier2(_: VkCommandBuffer, _: *const VkDependencyInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdPipelineBarrier2"))
}
/// The dummy function for `vkCmdWriteTimestamp2` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdWriteTimestamp2(_: VkCommandBuffer, _: VkPipelineStageFlags2, _: VkQueryPool, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdWriteTimestamp2"))
}
/// The dummy function for `vkQueueSubmit2` from `VK_VERSION_1_3`
extern "system" fn dummy_vkQueueSubmit2(_: VkQueue, _: u32, _: *const VkSubmitInfo2, _: VkFence) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkQueueSubmit2"))
}
/// The dummy function for `vkCmdCopyBuffer2` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdCopyBuffer2(_: VkCommandBuffer, _: *const VkCopyBufferInfo2) {
	panic_any(VkError::NullFunctionPointer("vkCmdCopyBuffer2"))
}
/// The dummy function for `vkCmdCopyImage2` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdCopyImage2(_: VkCommandBuffer, _: *const VkCopyImageInfo2) {
	panic_any(VkError::NullFunctionPointer("vkCmdCopyImage2"))
}
/// The dummy function for `vkCmdCopyBufferToImage2` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdCopyBufferToImage2(_: VkCommandBuffer, _: *const VkCopyBufferToImageInfo2) {
	panic_any(VkError::NullFunctionPointer("vkCmdCopyBufferToImage2"))
}
/// The dummy function for `vkCmdCopyImageToBuffer2` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdCopyImageToBuffer2(_: VkCommandBuffer, _: *const VkCopyImageToBufferInfo2) {
	panic_any(VkError::NullFunctionPointer("vkCmdCopyImageToBuffer2"))
}
/// The dummy function for `vkCmdBlitImage2` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdBlitImage2(_: VkCommandBuffer, _: *const VkBlitImageInfo2) {
	panic_any(VkError::NullFunctionPointer("vkCmdBlitImage2"))
}
/// The dummy function for `vkCmdResolveImage2` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdResolveImage2(_: VkCommandBuffer, _: *const VkResolveImageInfo2) {
	panic_any(VkError::NullFunctionPointer("vkCmdResolveImage2"))
}
/// The dummy function for `vkCmdBeginRendering` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdBeginRendering(_: VkCommandBuffer, _: *const VkRenderingInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdBeginRendering"))
}
/// The dummy function for `vkCmdEndRendering` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdEndRendering(_: VkCommandBuffer) {
	panic_any(VkError::NullFunctionPointer("vkCmdEndRendering"))
}
/// The dummy function for `vkCmdSetCullMode` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdSetCullMode(_: VkCommandBuffer, _: VkCullModeFlags) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetCullMode"))
}
/// The dummy function for `vkCmdSetFrontFace` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdSetFrontFace(_: VkCommandBuffer, _: VkFrontFace) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetFrontFace"))
}
/// The dummy function for `vkCmdSetPrimitiveTopology` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdSetPrimitiveTopology(_: VkCommandBuffer, _: VkPrimitiveTopology) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetPrimitiveTopology"))
}
/// The dummy function for `vkCmdSetViewportWithCount` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdSetViewportWithCount(_: VkCommandBuffer, _: u32, _: *const VkViewport) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetViewportWithCount"))
}
/// The dummy function for `vkCmdSetScissorWithCount` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdSetScissorWithCount(_: VkCommandBuffer, _: u32, _: *const VkRect2D) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetScissorWithCount"))
}
/// The dummy function for `vkCmdBindVertexBuffers2` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdBindVertexBuffers2(_: VkCommandBuffer, _: u32, _: u32, _: *const VkBuffer, _: *const VkDeviceSize, _: *const VkDeviceSize, _: *const VkDeviceSize) {
	panic_any(VkError::NullFunctionPointer("vkCmdBindVertexBuffers2"))
}
/// The dummy function for `vkCmdSetDepthTestEnable` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdSetDepthTestEnable(_: VkCommandBuffer, _: VkBool32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetDepthTestEnable"))
}
/// The dummy function for `vkCmdSetDepthWriteEnable` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdSetDepthWriteEnable(_: VkCommandBuffer, _: VkBool32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetDepthWriteEnable"))
}
/// The dummy function for `vkCmdSetDepthCompareOp` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdSetDepthCompareOp(_: VkCommandBuffer, _: VkCompareOp) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetDepthCompareOp"))
}
/// The dummy function for `vkCmdSetDepthBoundsTestEnable` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdSetDepthBoundsTestEnable(_: VkCommandBuffer, _: VkBool32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetDepthBoundsTestEnable"))
}
/// The dummy function for `vkCmdSetStencilTestEnable` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdSetStencilTestEnable(_: VkCommandBuffer, _: VkBool32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetStencilTestEnable"))
}
/// The dummy function for `vkCmdSetStencilOp` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdSetStencilOp(_: VkCommandBuffer, _: VkStencilFaceFlags, _: VkStencilOp, _: VkStencilOp, _: VkStencilOp, _: VkCompareOp) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetStencilOp"))
}
/// The dummy function for `vkCmdSetRasterizerDiscardEnable` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdSetRasterizerDiscardEnable(_: VkCommandBuffer, _: VkBool32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetRasterizerDiscardEnable"))
}
/// The dummy function for `vkCmdSetDepthBiasEnable` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdSetDepthBiasEnable(_: VkCommandBuffer, _: VkBool32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetDepthBiasEnable"))
}
/// The dummy function for `vkCmdSetPrimitiveRestartEnable` from `VK_VERSION_1_3`
extern "system" fn dummy_vkCmdSetPrimitiveRestartEnable(_: VkCommandBuffer, _: VkBool32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetPrimitiveRestartEnable"))
}
/// The dummy function for `vkGetDeviceBufferMemoryRequirements` from `VK_VERSION_1_3`
extern "system" fn dummy_vkGetDeviceBufferMemoryRequirements(_: VkDevice, _: *const VkDeviceBufferMemoryRequirements, _: *mut VkMemoryRequirements2) {
	panic_any(VkError::NullFunctionPointer("vkGetDeviceBufferMemoryRequirements"))
}
/// The dummy function for `vkGetDeviceImageMemoryRequirements` from `VK_VERSION_1_3`
extern "system" fn dummy_vkGetDeviceImageMemoryRequirements(_: VkDevice, _: *const VkDeviceImageMemoryRequirements, _: *mut VkMemoryRequirements2) {
	panic_any(VkError::NullFunctionPointer("vkGetDeviceImageMemoryRequirements"))
}
/// The dummy function for `vkGetDeviceImageSparseMemoryRequirements` from `VK_VERSION_1_3`
extern "system" fn dummy_vkGetDeviceImageSparseMemoryRequirements(_: VkDevice, _: *const VkDeviceImageMemoryRequirements, _: *mut uint32_t, _: *mut VkSparseImageMemoryRequirements2) {
	panic_any(VkError::NullFunctionPointer("vkGetDeviceImageSparseMemoryRequirements"))
}
/// trait for `VK_VERSION_1_3`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_VERSION_1_3.html>
pub trait VK_VERSION_1_3: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceToolProperties.html>
	fn vkGetPhysicalDeviceToolProperties(&self, physicalDevice: VkPhysicalDevice, pToolCount: *mut uint32_t, pToolProperties: *mut VkPhysicalDeviceToolProperties) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePrivateDataSlot.html>
	fn vkCreatePrivateDataSlot(&self, device: VkDevice, pCreateInfo: *const VkPrivateDataSlotCreateInfo, pAllocator: *const VkAllocationCallbacks, pPrivateDataSlot: *mut VkPrivateDataSlot) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPrivateDataSlot.html>
	fn vkDestroyPrivateDataSlot(&self, device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetPrivateData.html>
	fn vkSetPrivateData(&self, device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, data: u64) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPrivateData.html>
	fn vkGetPrivateData(&self, device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, pData: *mut uint64_t) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetEvent2.html>
	fn vkCmdSetEvent2(&self, commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *const VkDependencyInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResetEvent2.html>
	fn vkCmdResetEvent2(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWaitEvents2.html>
	fn vkCmdWaitEvents2(&self, commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, pDependencyInfos: *const VkDependencyInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPipelineBarrier2.html>
	fn vkCmdPipelineBarrier2(&self, commandBuffer: VkCommandBuffer, pDependencyInfo: *const VkDependencyInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteTimestamp2.html>
	fn vkCmdWriteTimestamp2(&self, commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: u32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueSubmit2.html>
	fn vkQueueSubmit2(&self, queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo2, fence: VkFence) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBuffer2.html>
	fn vkCmdCopyBuffer2(&self, commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImage2.html>
	fn vkCmdCopyImage2(&self, commandBuffer: VkCommandBuffer, pCopyImageInfo: *const VkCopyImageInfo2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage2.html>
	fn vkCmdCopyBufferToImage2(&self, commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: *const VkCopyBufferToImageInfo2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer2.html>
	fn vkCmdCopyImageToBuffer2(&self, commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: *const VkCopyImageToBufferInfo2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage2.html>
	fn vkCmdBlitImage2(&self, commandBuffer: VkCommandBuffer, pBlitImageInfo: *const VkBlitImageInfo2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResolveImage2.html>
	fn vkCmdResolveImage2(&self, commandBuffer: VkCommandBuffer, pResolveImageInfo: *const VkResolveImageInfo2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRendering.html>
	fn vkCmdBeginRendering(&self, commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRendering.html>
	fn vkCmdEndRendering(&self, commandBuffer: VkCommandBuffer) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCullMode.html>
	fn vkCmdSetCullMode(&self, commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetFrontFace.html>
	fn vkCmdSetFrontFace(&self, commandBuffer: VkCommandBuffer, frontFace: VkFrontFace) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPrimitiveTopology.html>
	fn vkCmdSetPrimitiveTopology(&self, commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportWithCount.html>
	fn vkCmdSetViewportWithCount(&self, commandBuffer: VkCommandBuffer, viewportCount: u32, pViewports: *const VkViewport) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetScissorWithCount.html>
	fn vkCmdSetScissorWithCount(&self, commandBuffer: VkCommandBuffer, scissorCount: u32, pScissors: *const VkRect2D) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindVertexBuffers2.html>
	fn vkCmdBindVertexBuffers2(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize, pStrides: *const VkDeviceSize) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthTestEnable.html>
	fn vkCmdSetDepthTestEnable(&self, commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthWriteEnable.html>
	fn vkCmdSetDepthWriteEnable(&self, commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthCompareOp.html>
	fn vkCmdSetDepthCompareOp(&self, commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBoundsTestEnable.html>
	fn vkCmdSetDepthBoundsTestEnable(&self, commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilTestEnable.html>
	fn vkCmdSetStencilTestEnable(&self, commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilOp.html>
	fn vkCmdSetStencilOp(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRasterizerDiscardEnable.html>
	fn vkCmdSetRasterizerDiscardEnable(&self, commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBiasEnable.html>
	fn vkCmdSetDepthBiasEnable(&self, commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPrimitiveRestartEnable.html>
	fn vkCmdSetPrimitiveRestartEnable(&self, commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceBufferMemoryRequirements.html>
	fn vkGetDeviceBufferMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceBufferMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageMemoryRequirements.html>
	fn vkGetDeviceImageMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSparseMemoryRequirements.html>
	fn vkGetDeviceImageSparseMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2) -> Result<()>;
}
/// struct for `VK_VERSION_1_3`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_VERSION_1_3 {
	vk_get_physical_device_tool_properties: PFN_vkGetPhysicalDeviceToolProperties,
	vk_create_private_data_slot: PFN_vkCreatePrivateDataSlot,
	vk_destroy_private_data_slot: PFN_vkDestroyPrivateDataSlot,
	vk_set_private_data: PFN_vkSetPrivateData,
	vk_get_private_data: PFN_vkGetPrivateData,
	vk_cmd_set_event2: PFN_vkCmdSetEvent2,
	vk_cmd_reset_event2: PFN_vkCmdResetEvent2,
	vk_cmd_wait_events2: PFN_vkCmdWaitEvents2,
	vk_cmd_pipeline_barrier2: PFN_vkCmdPipelineBarrier2,
	vk_cmd_write_timestamp2: PFN_vkCmdWriteTimestamp2,
	vk_queue_submit2: PFN_vkQueueSubmit2,
	vk_cmd_copy_buffer2: PFN_vkCmdCopyBuffer2,
	vk_cmd_copy_image2: PFN_vkCmdCopyImage2,
	vk_cmd_copy_buffer_to_image2: PFN_vkCmdCopyBufferToImage2,
	vk_cmd_copy_image_to_buffer2: PFN_vkCmdCopyImageToBuffer2,
	vk_cmd_blit_image2: PFN_vkCmdBlitImage2,
	vk_cmd_resolve_image2: PFN_vkCmdResolveImage2,
	vk_cmd_begin_rendering: PFN_vkCmdBeginRendering,
	vk_cmd_end_rendering: PFN_vkCmdEndRendering,
	vk_cmd_set_cull_mode: PFN_vkCmdSetCullMode,
	vk_cmd_set_front_face: PFN_vkCmdSetFrontFace,
	vk_cmd_set_primitive_topology: PFN_vkCmdSetPrimitiveTopology,
	vk_cmd_set_viewport_with_count: PFN_vkCmdSetViewportWithCount,
	vk_cmd_set_scissor_with_count: PFN_vkCmdSetScissorWithCount,
	vk_cmd_bind_vertex_buffers2: PFN_vkCmdBindVertexBuffers2,
	vk_cmd_set_depth_test_enable: PFN_vkCmdSetDepthTestEnable,
	vk_cmd_set_depth_write_enable: PFN_vkCmdSetDepthWriteEnable,
	vk_cmd_set_depth_compare_op: PFN_vkCmdSetDepthCompareOp,
	vk_cmd_set_depth_bounds_test_enable: PFN_vkCmdSetDepthBoundsTestEnable,
	vk_cmd_set_stencil_test_enable: PFN_vkCmdSetStencilTestEnable,
	vk_cmd_set_stencil_op: PFN_vkCmdSetStencilOp,
	vk_cmd_set_rasterizer_discard_enable: PFN_vkCmdSetRasterizerDiscardEnable,
	vk_cmd_set_depth_bias_enable: PFN_vkCmdSetDepthBiasEnable,
	vk_cmd_set_primitive_restart_enable: PFN_vkCmdSetPrimitiveRestartEnable,
	vk_get_device_buffer_memory_requirements: PFN_vkGetDeviceBufferMemoryRequirements,
	vk_get_device_image_memory_requirements: PFN_vkGetDeviceImageMemoryRequirements,
	vk_get_device_image_sparse_memory_requirements: PFN_vkGetDeviceImageSparseMemoryRequirements,
}
impl VK_VERSION_1_3 for Vulkan_VERSION_1_3 {
	fn vkGetPhysicalDeviceToolProperties(&self, physicalDevice: VkPhysicalDevice, pToolCount: *mut uint32_t, pToolProperties: *mut VkPhysicalDeviceToolProperties) -> Result<()> {
		convert_result("vkGetPhysicalDeviceToolProperties", catch_unwind(||((self.vk_get_physical_device_tool_properties)(physicalDevice, pToolCount, pToolProperties))))
	}
	fn vkCreatePrivateDataSlot(&self, device: VkDevice, pCreateInfo: *const VkPrivateDataSlotCreateInfo, pAllocator: *const VkAllocationCallbacks, pPrivateDataSlot: *mut VkPrivateDataSlot) -> Result<()> {
		convert_result("vkCreatePrivateDataSlot", catch_unwind(||((self.vk_create_private_data_slot)(device, pCreateInfo, pAllocator, pPrivateDataSlot))))
	}
	fn vkDestroyPrivateDataSlot(&self, device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_private_data_slot)(device, privateDataSlot, pAllocator))))
	}
	fn vkSetPrivateData(&self, device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, data: u64) -> Result<()> {
		convert_result("vkSetPrivateData", catch_unwind(||((self.vk_set_private_data)(device, objectType, objectHandle, privateDataSlot, data))))
	}
	fn vkGetPrivateData(&self, device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, pData: *mut uint64_t) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_private_data)(device, objectType, objectHandle, privateDataSlot, pData))))
	}
	fn vkCmdSetEvent2(&self, commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *const VkDependencyInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_event2)(commandBuffer, event, pDependencyInfo))))
	}
	fn vkCmdResetEvent2(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_reset_event2)(commandBuffer, event, stageMask))))
	}
	fn vkCmdWaitEvents2(&self, commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, pDependencyInfos: *const VkDependencyInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_wait_events2)(commandBuffer, eventCount, pEvents, pDependencyInfos))))
	}
	fn vkCmdPipelineBarrier2(&self, commandBuffer: VkCommandBuffer, pDependencyInfo: *const VkDependencyInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_pipeline_barrier2)(commandBuffer, pDependencyInfo))))
	}
	fn vkCmdWriteTimestamp2(&self, commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_write_timestamp2)(commandBuffer, stage, queryPool, query))))
	}
	fn vkQueueSubmit2(&self, queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo2, fence: VkFence) -> Result<()> {
		convert_result("vkQueueSubmit2", catch_unwind(||((self.vk_queue_submit2)(queue, submitCount, pSubmits, fence))))
	}
	fn vkCmdCopyBuffer2(&self, commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_copy_buffer2)(commandBuffer, pCopyBufferInfo))))
	}
	fn vkCmdCopyImage2(&self, commandBuffer: VkCommandBuffer, pCopyImageInfo: *const VkCopyImageInfo2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_copy_image2)(commandBuffer, pCopyImageInfo))))
	}
	fn vkCmdCopyBufferToImage2(&self, commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: *const VkCopyBufferToImageInfo2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_copy_buffer_to_image2)(commandBuffer, pCopyBufferToImageInfo))))
	}
	fn vkCmdCopyImageToBuffer2(&self, commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: *const VkCopyImageToBufferInfo2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_copy_image_to_buffer2)(commandBuffer, pCopyImageToBufferInfo))))
	}
	fn vkCmdBlitImage2(&self, commandBuffer: VkCommandBuffer, pBlitImageInfo: *const VkBlitImageInfo2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_blit_image2)(commandBuffer, pBlitImageInfo))))
	}
	fn vkCmdResolveImage2(&self, commandBuffer: VkCommandBuffer, pResolveImageInfo: *const VkResolveImageInfo2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_resolve_image2)(commandBuffer, pResolveImageInfo))))
	}
	fn vkCmdBeginRendering(&self, commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_begin_rendering)(commandBuffer, pRenderingInfo))))
	}
	fn vkCmdEndRendering(&self, commandBuffer: VkCommandBuffer) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_end_rendering)(commandBuffer))))
	}
	fn vkCmdSetCullMode(&self, commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_cull_mode)(commandBuffer, cullMode))))
	}
	fn vkCmdSetFrontFace(&self, commandBuffer: VkCommandBuffer, frontFace: VkFrontFace) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_front_face)(commandBuffer, frontFace))))
	}
	fn vkCmdSetPrimitiveTopology(&self, commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_primitive_topology)(commandBuffer, primitiveTopology))))
	}
	fn vkCmdSetViewportWithCount(&self, commandBuffer: VkCommandBuffer, viewportCount: u32, pViewports: *const VkViewport) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_viewport_with_count)(commandBuffer, viewportCount, pViewports))))
	}
	fn vkCmdSetScissorWithCount(&self, commandBuffer: VkCommandBuffer, scissorCount: u32, pScissors: *const VkRect2D) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_scissor_with_count)(commandBuffer, scissorCount, pScissors))))
	}
	fn vkCmdBindVertexBuffers2(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize, pStrides: *const VkDeviceSize) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_bind_vertex_buffers2)(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides))))
	}
	fn vkCmdSetDepthTestEnable(&self, commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_depth_test_enable)(commandBuffer, depthTestEnable))))
	}
	fn vkCmdSetDepthWriteEnable(&self, commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_depth_write_enable)(commandBuffer, depthWriteEnable))))
	}
	fn vkCmdSetDepthCompareOp(&self, commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_depth_compare_op)(commandBuffer, depthCompareOp))))
	}
	fn vkCmdSetDepthBoundsTestEnable(&self, commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_depth_bounds_test_enable)(commandBuffer, depthBoundsTestEnable))))
	}
	fn vkCmdSetStencilTestEnable(&self, commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_stencil_test_enable)(commandBuffer, stencilTestEnable))))
	}
	fn vkCmdSetStencilOp(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_stencil_op)(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp))))
	}
	fn vkCmdSetRasterizerDiscardEnable(&self, commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_rasterizer_discard_enable)(commandBuffer, rasterizerDiscardEnable))))
	}
	fn vkCmdSetDepthBiasEnable(&self, commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_depth_bias_enable)(commandBuffer, depthBiasEnable))))
	}
	fn vkCmdSetPrimitiveRestartEnable(&self, commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_primitive_restart_enable)(commandBuffer, primitiveRestartEnable))))
	}
	fn vkGetDeviceBufferMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceBufferMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_device_buffer_memory_requirements)(device, pInfo, pMemoryRequirements))))
	}
	fn vkGetDeviceImageMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_device_image_memory_requirements)(device, pInfo, pMemoryRequirements))))
	}
	fn vkGetDeviceImageSparseMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_device_image_sparse_memory_requirements)(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements))))
	}
}
impl Default for Vulkan_VERSION_1_3 {
	fn default() -> Self {
		Self {
			vk_get_physical_device_tool_properties: dummy_vkGetPhysicalDeviceToolProperties,
			vk_create_private_data_slot: dummy_vkCreatePrivateDataSlot,
			vk_destroy_private_data_slot: dummy_vkDestroyPrivateDataSlot,
			vk_set_private_data: dummy_vkSetPrivateData,
			vk_get_private_data: dummy_vkGetPrivateData,
			vk_cmd_set_event2: dummy_vkCmdSetEvent2,
			vk_cmd_reset_event2: dummy_vkCmdResetEvent2,
			vk_cmd_wait_events2: dummy_vkCmdWaitEvents2,
			vk_cmd_pipeline_barrier2: dummy_vkCmdPipelineBarrier2,
			vk_cmd_write_timestamp2: dummy_vkCmdWriteTimestamp2,
			vk_queue_submit2: dummy_vkQueueSubmit2,
			vk_cmd_copy_buffer2: dummy_vkCmdCopyBuffer2,
			vk_cmd_copy_image2: dummy_vkCmdCopyImage2,
			vk_cmd_copy_buffer_to_image2: dummy_vkCmdCopyBufferToImage2,
			vk_cmd_copy_image_to_buffer2: dummy_vkCmdCopyImageToBuffer2,
			vk_cmd_blit_image2: dummy_vkCmdBlitImage2,
			vk_cmd_resolve_image2: dummy_vkCmdResolveImage2,
			vk_cmd_begin_rendering: dummy_vkCmdBeginRendering,
			vk_cmd_end_rendering: dummy_vkCmdEndRendering,
			vk_cmd_set_cull_mode: dummy_vkCmdSetCullMode,
			vk_cmd_set_front_face: dummy_vkCmdSetFrontFace,
			vk_cmd_set_primitive_topology: dummy_vkCmdSetPrimitiveTopology,
			vk_cmd_set_viewport_with_count: dummy_vkCmdSetViewportWithCount,
			vk_cmd_set_scissor_with_count: dummy_vkCmdSetScissorWithCount,
			vk_cmd_bind_vertex_buffers2: dummy_vkCmdBindVertexBuffers2,
			vk_cmd_set_depth_test_enable: dummy_vkCmdSetDepthTestEnable,
			vk_cmd_set_depth_write_enable: dummy_vkCmdSetDepthWriteEnable,
			vk_cmd_set_depth_compare_op: dummy_vkCmdSetDepthCompareOp,
			vk_cmd_set_depth_bounds_test_enable: dummy_vkCmdSetDepthBoundsTestEnable,
			vk_cmd_set_stencil_test_enable: dummy_vkCmdSetStencilTestEnable,
			vk_cmd_set_stencil_op: dummy_vkCmdSetStencilOp,
			vk_cmd_set_rasterizer_discard_enable: dummy_vkCmdSetRasterizerDiscardEnable,
			vk_cmd_set_depth_bias_enable: dummy_vkCmdSetDepthBiasEnable,
			vk_cmd_set_primitive_restart_enable: dummy_vkCmdSetPrimitiveRestartEnable,
			vk_get_device_buffer_memory_requirements: dummy_vkGetDeviceBufferMemoryRequirements,
			vk_get_device_image_memory_requirements: dummy_vkGetDeviceImageMemoryRequirements,
			vk_get_device_image_sparse_memory_requirements: dummy_vkGetDeviceImageSparseMemoryRequirements,
		}
	}
}
impl Vulkan_VERSION_1_3 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_tool_properties: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceToolProperties"); if proc == null() {dummy_vkGetPhysicalDeviceToolProperties} else {unsafe {transmute(proc)}}},
			vk_create_private_data_slot: {let proc = get_instance_proc_address(instance, "vkCreatePrivateDataSlot"); if proc == null() {dummy_vkCreatePrivateDataSlot} else {unsafe {transmute(proc)}}},
			vk_destroy_private_data_slot: {let proc = get_instance_proc_address(instance, "vkDestroyPrivateDataSlot"); if proc == null() {dummy_vkDestroyPrivateDataSlot} else {unsafe {transmute(proc)}}},
			vk_set_private_data: {let proc = get_instance_proc_address(instance, "vkSetPrivateData"); if proc == null() {dummy_vkSetPrivateData} else {unsafe {transmute(proc)}}},
			vk_get_private_data: {let proc = get_instance_proc_address(instance, "vkGetPrivateData"); if proc == null() {dummy_vkGetPrivateData} else {unsafe {transmute(proc)}}},
			vk_cmd_set_event2: {let proc = get_instance_proc_address(instance, "vkCmdSetEvent2"); if proc == null() {dummy_vkCmdSetEvent2} else {unsafe {transmute(proc)}}},
			vk_cmd_reset_event2: {let proc = get_instance_proc_address(instance, "vkCmdResetEvent2"); if proc == null() {dummy_vkCmdResetEvent2} else {unsafe {transmute(proc)}}},
			vk_cmd_wait_events2: {let proc = get_instance_proc_address(instance, "vkCmdWaitEvents2"); if proc == null() {dummy_vkCmdWaitEvents2} else {unsafe {transmute(proc)}}},
			vk_cmd_pipeline_barrier2: {let proc = get_instance_proc_address(instance, "vkCmdPipelineBarrier2"); if proc == null() {dummy_vkCmdPipelineBarrier2} else {unsafe {transmute(proc)}}},
			vk_cmd_write_timestamp2: {let proc = get_instance_proc_address(instance, "vkCmdWriteTimestamp2"); if proc == null() {dummy_vkCmdWriteTimestamp2} else {unsafe {transmute(proc)}}},
			vk_queue_submit2: {let proc = get_instance_proc_address(instance, "vkQueueSubmit2"); if proc == null() {dummy_vkQueueSubmit2} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_buffer2: {let proc = get_instance_proc_address(instance, "vkCmdCopyBuffer2"); if proc == null() {dummy_vkCmdCopyBuffer2} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_image2: {let proc = get_instance_proc_address(instance, "vkCmdCopyImage2"); if proc == null() {dummy_vkCmdCopyImage2} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_buffer_to_image2: {let proc = get_instance_proc_address(instance, "vkCmdCopyBufferToImage2"); if proc == null() {dummy_vkCmdCopyBufferToImage2} else {unsafe {transmute(proc)}}},
			vk_cmd_copy_image_to_buffer2: {let proc = get_instance_proc_address(instance, "vkCmdCopyImageToBuffer2"); if proc == null() {dummy_vkCmdCopyImageToBuffer2} else {unsafe {transmute(proc)}}},
			vk_cmd_blit_image2: {let proc = get_instance_proc_address(instance, "vkCmdBlitImage2"); if proc == null() {dummy_vkCmdBlitImage2} else {unsafe {transmute(proc)}}},
			vk_cmd_resolve_image2: {let proc = get_instance_proc_address(instance, "vkCmdResolveImage2"); if proc == null() {dummy_vkCmdResolveImage2} else {unsafe {transmute(proc)}}},
			vk_cmd_begin_rendering: {let proc = get_instance_proc_address(instance, "vkCmdBeginRendering"); if proc == null() {dummy_vkCmdBeginRendering} else {unsafe {transmute(proc)}}},
			vk_cmd_end_rendering: {let proc = get_instance_proc_address(instance, "vkCmdEndRendering"); if proc == null() {dummy_vkCmdEndRendering} else {unsafe {transmute(proc)}}},
			vk_cmd_set_cull_mode: {let proc = get_instance_proc_address(instance, "vkCmdSetCullMode"); if proc == null() {dummy_vkCmdSetCullMode} else {unsafe {transmute(proc)}}},
			vk_cmd_set_front_face: {let proc = get_instance_proc_address(instance, "vkCmdSetFrontFace"); if proc == null() {dummy_vkCmdSetFrontFace} else {unsafe {transmute(proc)}}},
			vk_cmd_set_primitive_topology: {let proc = get_instance_proc_address(instance, "vkCmdSetPrimitiveTopology"); if proc == null() {dummy_vkCmdSetPrimitiveTopology} else {unsafe {transmute(proc)}}},
			vk_cmd_set_viewport_with_count: {let proc = get_instance_proc_address(instance, "vkCmdSetViewportWithCount"); if proc == null() {dummy_vkCmdSetViewportWithCount} else {unsafe {transmute(proc)}}},
			vk_cmd_set_scissor_with_count: {let proc = get_instance_proc_address(instance, "vkCmdSetScissorWithCount"); if proc == null() {dummy_vkCmdSetScissorWithCount} else {unsafe {transmute(proc)}}},
			vk_cmd_bind_vertex_buffers2: {let proc = get_instance_proc_address(instance, "vkCmdBindVertexBuffers2"); if proc == null() {dummy_vkCmdBindVertexBuffers2} else {unsafe {transmute(proc)}}},
			vk_cmd_set_depth_test_enable: {let proc = get_instance_proc_address(instance, "vkCmdSetDepthTestEnable"); if proc == null() {dummy_vkCmdSetDepthTestEnable} else {unsafe {transmute(proc)}}},
			vk_cmd_set_depth_write_enable: {let proc = get_instance_proc_address(instance, "vkCmdSetDepthWriteEnable"); if proc == null() {dummy_vkCmdSetDepthWriteEnable} else {unsafe {transmute(proc)}}},
			vk_cmd_set_depth_compare_op: {let proc = get_instance_proc_address(instance, "vkCmdSetDepthCompareOp"); if proc == null() {dummy_vkCmdSetDepthCompareOp} else {unsafe {transmute(proc)}}},
			vk_cmd_set_depth_bounds_test_enable: {let proc = get_instance_proc_address(instance, "vkCmdSetDepthBoundsTestEnable"); if proc == null() {dummy_vkCmdSetDepthBoundsTestEnable} else {unsafe {transmute(proc)}}},
			vk_cmd_set_stencil_test_enable: {let proc = get_instance_proc_address(instance, "vkCmdSetStencilTestEnable"); if proc == null() {dummy_vkCmdSetStencilTestEnable} else {unsafe {transmute(proc)}}},
			vk_cmd_set_stencil_op: {let proc = get_instance_proc_address(instance, "vkCmdSetStencilOp"); if proc == null() {dummy_vkCmdSetStencilOp} else {unsafe {transmute(proc)}}},
			vk_cmd_set_rasterizer_discard_enable: {let proc = get_instance_proc_address(instance, "vkCmdSetRasterizerDiscardEnable"); if proc == null() {dummy_vkCmdSetRasterizerDiscardEnable} else {unsafe {transmute(proc)}}},
			vk_cmd_set_depth_bias_enable: {let proc = get_instance_proc_address(instance, "vkCmdSetDepthBiasEnable"); if proc == null() {dummy_vkCmdSetDepthBiasEnable} else {unsafe {transmute(proc)}}},
			vk_cmd_set_primitive_restart_enable: {let proc = get_instance_proc_address(instance, "vkCmdSetPrimitiveRestartEnable"); if proc == null() {dummy_vkCmdSetPrimitiveRestartEnable} else {unsafe {transmute(proc)}}},
			vk_get_device_buffer_memory_requirements: {let proc = get_instance_proc_address(instance, "vkGetDeviceBufferMemoryRequirements"); if proc == null() {dummy_vkGetDeviceBufferMemoryRequirements} else {unsafe {transmute(proc)}}},
			vk_get_device_image_memory_requirements: {let proc = get_instance_proc_address(instance, "vkGetDeviceImageMemoryRequirements"); if proc == null() {dummy_vkGetDeviceImageMemoryRequirements} else {unsafe {transmute(proc)}}},
			vk_get_device_image_sparse_memory_requirements: {let proc = get_instance_proc_address(instance, "vkGetDeviceImageSparseMemoryRequirements"); if proc == null() {dummy_vkGetDeviceImageSparseMemoryRequirements} else {unsafe {transmute(proc)}}},
		}
	}
}
/// constant `VK_API_VERSION_1_4` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_API_VERSION_1_4.html>
pub const VK_API_VERSION_1_4: u32 = 0x404000;
/// constant `VK_MAX_GLOBAL_PRIORITY_SIZE` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_GLOBAL_PRIORITY_SIZE.html>
pub const VK_MAX_GLOBAL_PRIORITY_SIZE: u32 = 16u32;
/// type definition `VkMemoryUnmapFlags` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryUnmapFlags.html>
pub type VkMemoryUnmapFlags = VkFlags;
pub fn vk_memory_unmap_flags_to_string(value: VkMemoryUnmapFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(2);
	if (value & VkMemoryUnmapFlagBits::VK_MEMORY_UNMAP_RESERVE_BIT_EXT as VkMemoryUnmapFlags) == VkMemoryUnmapFlagBits::VK_MEMORY_UNMAP_RESERVE_BIT_EXT as VkMemoryUnmapFlags {
		flags.push("VkMemoryUnmapFlagBits::VK_MEMORY_UNMAP_RESERVE_BIT_EXT");
	}
	if (value & VkMemoryUnmapFlagBits::VK_MEMORY_UNMAP_FLAG_BITS_MAX_ENUM as VkMemoryUnmapFlags) == VkMemoryUnmapFlagBits::VK_MEMORY_UNMAP_FLAG_BITS_MAX_ENUM as VkMemoryUnmapFlags {
		flags.push("VkMemoryUnmapFlagBits::VK_MEMORY_UNMAP_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// type definition `VkPipelineCreateFlags2` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreateFlags2.html>
pub type VkPipelineCreateFlags2 = VkFlags64;
/// type definition `VkPipelineCreateFlagBits2` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreateFlagBits2.html>
pub type VkPipelineCreateFlagBits2 = VkFlags64;
/// type definition `VkBufferUsageFlags2` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferUsageFlags2.html>
pub type VkBufferUsageFlags2 = VkFlags64;
/// type definition `VkBufferUsageFlagBits2` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferUsageFlagBits2.html>
pub type VkBufferUsageFlagBits2 = VkFlags64;
/// type definition `VkHostImageCopyFlags` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkHostImageCopyFlags.html>
pub type VkHostImageCopyFlags = VkFlags;
pub fn vk_host_image_copy_flags_to_string(value: VkHostImageCopyFlags) -> String {
	let mut flags = Vec::<&str>::with_capacity(5);
	if (value & VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY_BIT as VkHostImageCopyFlags) == VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY_BIT as VkHostImageCopyFlags {
		flags.push("VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY_BIT");
	}
	if (value & VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY as VkHostImageCopyFlags) == VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY as VkHostImageCopyFlags {
		flags.push("VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY");
	}
	if (value & VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY_BIT_EXT as VkHostImageCopyFlags) == VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY_BIT_EXT as VkHostImageCopyFlags {
		flags.push("VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY_BIT_EXT");
	}
	if (value & VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY_EXT as VkHostImageCopyFlags) == VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY_EXT as VkHostImageCopyFlags {
		flags.push("VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY_EXT");
	}
	if (value & VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM as VkHostImageCopyFlags) == VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM as VkHostImageCopyFlags {
		flags.push("VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM");
	}
	flags.join(" | ")
}
/// enum `VkPipelineRobustnessBufferBehavior` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRobustnessBufferBehavior.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineRobustnessBufferBehavior {
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT = 0,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED = 1,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS = 2,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 = 3,
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineRobustnessBufferBehavior {
	pub const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT: VkPipelineRobustnessBufferBehavior = VkPipelineRobustnessBufferBehavior::VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT;
	pub const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT: VkPipelineRobustnessBufferBehavior = VkPipelineRobustnessBufferBehavior::VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED;
	pub const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT: VkPipelineRobustnessBufferBehavior = VkPipelineRobustnessBufferBehavior::VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS;
	pub const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT: VkPipelineRobustnessBufferBehavior = VkPipelineRobustnessBufferBehavior::VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2;
}
/// enum `VkPipelineRobustnessImageBehavior` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRobustnessImageBehavior.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineRobustnessImageBehavior {
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT = 0,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED = 1,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS = 2,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2 = 3,
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_MAX_ENUM = 0x7fffffff,
}
impl VkPipelineRobustnessImageBehavior {
	pub const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT: VkPipelineRobustnessImageBehavior = VkPipelineRobustnessImageBehavior::VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT;
	pub const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT: VkPipelineRobustnessImageBehavior = VkPipelineRobustnessImageBehavior::VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED;
	pub const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT: VkPipelineRobustnessImageBehavior = VkPipelineRobustnessImageBehavior::VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS;
	pub const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT: VkPipelineRobustnessImageBehavior = VkPipelineRobustnessImageBehavior::VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2;
}
/// enum `VkQueueGlobalPriority` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueGlobalPriority.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueueGlobalPriority {
	VK_QUEUE_GLOBAL_PRIORITY_LOW = 128,
	VK_QUEUE_GLOBAL_PRIORITY_MEDIUM = 256,
	VK_QUEUE_GLOBAL_PRIORITY_HIGH = 512,
	VK_QUEUE_GLOBAL_PRIORITY_REALTIME = 1024,
	VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM = 0x7fffffff,
}
impl VkQueueGlobalPriority {
	pub const VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT: VkQueueGlobalPriority = VkQueueGlobalPriority::VK_QUEUE_GLOBAL_PRIORITY_LOW;
	pub const VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT: VkQueueGlobalPriority = VkQueueGlobalPriority::VK_QUEUE_GLOBAL_PRIORITY_MEDIUM;
	pub const VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT: VkQueueGlobalPriority = VkQueueGlobalPriority::VK_QUEUE_GLOBAL_PRIORITY_HIGH;
	pub const VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT: VkQueueGlobalPriority = VkQueueGlobalPriority::VK_QUEUE_GLOBAL_PRIORITY_REALTIME;
	pub const VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR: VkQueueGlobalPriority = VkQueueGlobalPriority::VK_QUEUE_GLOBAL_PRIORITY_LOW;
	pub const VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR: VkQueueGlobalPriority = VkQueueGlobalPriority::VK_QUEUE_GLOBAL_PRIORITY_MEDIUM;
	pub const VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR: VkQueueGlobalPriority = VkQueueGlobalPriority::VK_QUEUE_GLOBAL_PRIORITY_HIGH;
	pub const VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR: VkQueueGlobalPriority = VkQueueGlobalPriority::VK_QUEUE_GLOBAL_PRIORITY_REALTIME;
}
/// enum `VkLineRasterizationMode` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkLineRasterizationMode.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkLineRasterizationMode {
	VK_LINE_RASTERIZATION_MODE_DEFAULT = 0,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR = 1,
	VK_LINE_RASTERIZATION_MODE_BRESENHAM = 2,
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH = 3,
	VK_LINE_RASTERIZATION_MODE_MAX_ENUM = 0x7fffffff,
}
impl VkLineRasterizationMode {
	pub const VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT: VkLineRasterizationMode = VkLineRasterizationMode::VK_LINE_RASTERIZATION_MODE_DEFAULT;
	pub const VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT: VkLineRasterizationMode = VkLineRasterizationMode::VK_LINE_RASTERIZATION_MODE_RECTANGULAR;
	pub const VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT: VkLineRasterizationMode = VkLineRasterizationMode::VK_LINE_RASTERIZATION_MODE_BRESENHAM;
	pub const VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT: VkLineRasterizationMode = VkLineRasterizationMode::VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH;
	pub const VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR: VkLineRasterizationMode = VkLineRasterizationMode::VK_LINE_RASTERIZATION_MODE_DEFAULT;
	pub const VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR: VkLineRasterizationMode = VkLineRasterizationMode::VK_LINE_RASTERIZATION_MODE_RECTANGULAR;
	pub const VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR: VkLineRasterizationMode = VkLineRasterizationMode::VK_LINE_RASTERIZATION_MODE_BRESENHAM;
	pub const VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR: VkLineRasterizationMode = VkLineRasterizationMode::VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH;
}
/// enum `VkMemoryUnmapFlagBits` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryUnmapFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkMemoryUnmapFlagBits {
	VK_MEMORY_UNMAP_RESERVE_BIT_EXT = 0x00000001,
	VK_MEMORY_UNMAP_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
/// enum `VkHostImageCopyFlagBits` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkHostImageCopyFlagBits.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkHostImageCopyFlagBits {
	VK_HOST_IMAGE_COPY_MEMCPY_BIT = 0x00000001,
	VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM = 0x7fffffff,
}
impl VkHostImageCopyFlagBits {
	pub const VK_HOST_IMAGE_COPY_MEMCPY: VkHostImageCopyFlagBits = VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY_BIT;
	pub const VK_HOST_IMAGE_COPY_MEMCPY_BIT_EXT: VkHostImageCopyFlagBits = VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY_BIT;
	pub const VK_HOST_IMAGE_COPY_MEMCPY_EXT: VkHostImageCopyFlagBits = VkHostImageCopyFlagBits::VK_HOST_IMAGE_COPY_MEMCPY_BIT;
}
/// struct `VkPhysicalDeviceVulkan14Features` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVulkan14Features.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVulkan14Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub globalPriorityQuery: VkBool32,
	pub shaderSubgroupRotate: VkBool32,
	pub shaderSubgroupRotateClustered: VkBool32,
	pub shaderFloatControls2: VkBool32,
	pub shaderExpectAssume: VkBool32,
	pub rectangularLines: VkBool32,
	pub bresenhamLines: VkBool32,
	pub smoothLines: VkBool32,
	pub stippledRectangularLines: VkBool32,
	pub stippledBresenhamLines: VkBool32,
	pub stippledSmoothLines: VkBool32,
	pub vertexAttributeInstanceRateDivisor: VkBool32,
	pub vertexAttributeInstanceRateZeroDivisor: VkBool32,
	pub indexTypeUint8: VkBool32,
	pub dynamicRenderingLocalRead: VkBool32,
	pub maintenance5: VkBool32,
	pub maintenance6: VkBool32,
	pub pipelineProtectedAccess: VkBool32,
	pub pipelineRobustness: VkBool32,
	pub hostImageCopy: VkBool32,
	pub pushDescriptor: VkBool32,
}
impl Debug for VkPhysicalDeviceVulkan14Features {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVulkan14Features")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("globalPriorityQuery", &self.globalPriorityQuery)
		.field("shaderSubgroupRotate", &self.shaderSubgroupRotate)
		.field("shaderSubgroupRotateClustered", &self.shaderSubgroupRotateClustered)
		.field("shaderFloatControls2", &self.shaderFloatControls2)
		.field("shaderExpectAssume", &self.shaderExpectAssume)
		.field("rectangularLines", &self.rectangularLines)
		.field("bresenhamLines", &self.bresenhamLines)
		.field("smoothLines", &self.smoothLines)
		.field("stippledRectangularLines", &self.stippledRectangularLines)
		.field("stippledBresenhamLines", &self.stippledBresenhamLines)
		.field("stippledSmoothLines", &self.stippledSmoothLines)
		.field("vertexAttributeInstanceRateDivisor", &self.vertexAttributeInstanceRateDivisor)
		.field("vertexAttributeInstanceRateZeroDivisor", &self.vertexAttributeInstanceRateZeroDivisor)
		.field("indexTypeUint8", &self.indexTypeUint8)
		.field("dynamicRenderingLocalRead", &self.dynamicRenderingLocalRead)
		.field("maintenance5", &self.maintenance5)
		.field("maintenance6", &self.maintenance6)
		.field("pipelineProtectedAccess", &self.pipelineProtectedAccess)
		.field("pipelineRobustness", &self.pipelineRobustness)
		.field("hostImageCopy", &self.hostImageCopy)
		.field("pushDescriptor", &self.pushDescriptor)
		.finish()
	}
}
/// struct `VkPhysicalDeviceVulkan14Properties` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVulkan14Properties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVulkan14Properties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub lineSubPixelPrecisionBits: u32,
	pub maxVertexAttribDivisor: u32,
	pub supportsNonZeroFirstInstance: VkBool32,
	pub maxPushDescriptors: u32,
	pub dynamicRenderingLocalReadDepthStencilAttachments: VkBool32,
	pub dynamicRenderingLocalReadMultisampledAttachments: VkBool32,
	pub earlyFragmentMultisampleCoverageAfterSampleCounting: VkBool32,
	pub earlyFragmentSampleMaskTestBeforeSampleCounting: VkBool32,
	pub depthStencilSwizzleOneSupport: VkBool32,
	pub polygonModePointSize: VkBool32,
	pub nonStrictSinglePixelWideLinesUseParallelogram: VkBool32,
	pub nonStrictWideLinesUseParallelogram: VkBool32,
	pub blockTexelViewCompatibleMultipleLayers: VkBool32,
	pub maxCombinedImageSamplerDescriptorCount: u32,
	pub fragmentShadingRateClampCombinerInputs: VkBool32,
	pub defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehavior,
	pub defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehavior,
	pub defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehavior,
	pub defaultRobustnessImages: VkPipelineRobustnessImageBehavior,
	pub copySrcLayoutCount: u32,
	pub pCopySrcLayouts: *mut VkImageLayout,
	pub copyDstLayoutCount: u32,
	pub pCopyDstLayouts: *mut VkImageLayout,
	pub optimalTilingLayoutUUID: [u8; VK_UUID_SIZE as usize],
	pub identicalMemoryTypeRequirements: VkBool32,
}
impl Debug for VkPhysicalDeviceVulkan14Properties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVulkan14Properties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("lineSubPixelPrecisionBits", &self.lineSubPixelPrecisionBits)
		.field("maxVertexAttribDivisor", &self.maxVertexAttribDivisor)
		.field("supportsNonZeroFirstInstance", &self.supportsNonZeroFirstInstance)
		.field("maxPushDescriptors", &self.maxPushDescriptors)
		.field("dynamicRenderingLocalReadDepthStencilAttachments", &self.dynamicRenderingLocalReadDepthStencilAttachments)
		.field("dynamicRenderingLocalReadMultisampledAttachments", &self.dynamicRenderingLocalReadMultisampledAttachments)
		.field("earlyFragmentMultisampleCoverageAfterSampleCounting", &self.earlyFragmentMultisampleCoverageAfterSampleCounting)
		.field("earlyFragmentSampleMaskTestBeforeSampleCounting", &self.earlyFragmentSampleMaskTestBeforeSampleCounting)
		.field("depthStencilSwizzleOneSupport", &self.depthStencilSwizzleOneSupport)
		.field("polygonModePointSize", &self.polygonModePointSize)
		.field("nonStrictSinglePixelWideLinesUseParallelogram", &self.nonStrictSinglePixelWideLinesUseParallelogram)
		.field("nonStrictWideLinesUseParallelogram", &self.nonStrictWideLinesUseParallelogram)
		.field("blockTexelViewCompatibleMultipleLayers", &self.blockTexelViewCompatibleMultipleLayers)
		.field("maxCombinedImageSamplerDescriptorCount", &self.maxCombinedImageSamplerDescriptorCount)
		.field("fragmentShadingRateClampCombinerInputs", &self.fragmentShadingRateClampCombinerInputs)
		.field("defaultRobustnessStorageBuffers", &self.defaultRobustnessStorageBuffers)
		.field("defaultRobustnessUniformBuffers", &self.defaultRobustnessUniformBuffers)
		.field("defaultRobustnessVertexInputs", &self.defaultRobustnessVertexInputs)
		.field("defaultRobustnessImages", &self.defaultRobustnessImages)
		.field("copySrcLayoutCount", &self.copySrcLayoutCount)
		.field("pCopySrcLayouts", &self.pCopySrcLayouts)
		.field("copyDstLayoutCount", &self.copyDstLayoutCount)
		.field("pCopyDstLayouts", &self.pCopyDstLayouts)
		.field("optimalTilingLayoutUUID", &self.optimalTilingLayoutUUID)
		.field("identicalMemoryTypeRequirements", &self.identicalMemoryTypeRequirements)
		.finish()
	}
}
/// struct `VkDeviceQueueGlobalPriorityCreateInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceQueueGlobalPriorityCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceQueueGlobalPriorityCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub globalPriority: VkQueueGlobalPriority,
}
impl Debug for VkDeviceQueueGlobalPriorityCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceQueueGlobalPriorityCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("globalPriority", &self.globalPriority)
		.finish()
	}
}
/// struct `VkPhysicalDeviceGlobalPriorityQueryFeatures` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceGlobalPriorityQueryFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceGlobalPriorityQueryFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub globalPriorityQuery: VkBool32,
}
impl Debug for VkPhysicalDeviceGlobalPriorityQueryFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceGlobalPriorityQueryFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("globalPriorityQuery", &self.globalPriorityQuery)
		.finish()
	}
}
/// struct `VkQueueFamilyGlobalPriorityProperties` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueFamilyGlobalPriorityProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkQueueFamilyGlobalPriorityProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub priorityCount: u32,
	pub priorities: [VkQueueGlobalPriority; VK_MAX_GLOBAL_PRIORITY_SIZE as usize],
}
impl Debug for VkQueueFamilyGlobalPriorityProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkQueueFamilyGlobalPriorityProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("priorityCount", &self.priorityCount)
		.field("priorities", &self.priorities)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShaderSubgroupRotateFeatures` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderSubgroupRotateFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderSubgroupRotateFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderSubgroupRotate: VkBool32,
	pub shaderSubgroupRotateClustered: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderSubgroupRotateFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderSubgroupRotateFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderSubgroupRotate", &self.shaderSubgroupRotate)
		.field("shaderSubgroupRotateClustered", &self.shaderSubgroupRotateClustered)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShaderFloatControls2Features` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderFloatControls2Features.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderFloatControls2Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderFloatControls2: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderFloatControls2Features {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderFloatControls2Features")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderFloatControls2", &self.shaderFloatControls2)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShaderExpectAssumeFeatures` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderExpectAssumeFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderExpectAssumeFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderExpectAssume: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderExpectAssumeFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderExpectAssumeFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderExpectAssume", &self.shaderExpectAssume)
		.finish()
	}
}
/// struct `VkPhysicalDeviceLineRasterizationFeatures` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLineRasterizationFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceLineRasterizationFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rectangularLines: VkBool32,
	pub bresenhamLines: VkBool32,
	pub smoothLines: VkBool32,
	pub stippledRectangularLines: VkBool32,
	pub stippledBresenhamLines: VkBool32,
	pub stippledSmoothLines: VkBool32,
}
impl Debug for VkPhysicalDeviceLineRasterizationFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceLineRasterizationFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("rectangularLines", &self.rectangularLines)
		.field("bresenhamLines", &self.bresenhamLines)
		.field("smoothLines", &self.smoothLines)
		.field("stippledRectangularLines", &self.stippledRectangularLines)
		.field("stippledBresenhamLines", &self.stippledBresenhamLines)
		.field("stippledSmoothLines", &self.stippledSmoothLines)
		.finish()
	}
}
/// struct `VkPhysicalDeviceLineRasterizationProperties` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLineRasterizationProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceLineRasterizationProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub lineSubPixelPrecisionBits: u32,
}
impl Debug for VkPhysicalDeviceLineRasterizationProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceLineRasterizationProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("lineSubPixelPrecisionBits", &self.lineSubPixelPrecisionBits)
		.finish()
	}
}
/// struct `VkPipelineRasterizationLineStateCreateInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRasterizationLineStateCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineRasterizationLineStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub lineRasterizationMode: VkLineRasterizationMode,
	pub stippledLineEnable: VkBool32,
	pub lineStippleFactor: u32,
	pub lineStipplePattern: u16,
}
impl Debug for VkPipelineRasterizationLineStateCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineRasterizationLineStateCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("lineRasterizationMode", &self.lineRasterizationMode)
		.field("stippledLineEnable", &self.stippledLineEnable)
		.field("lineStippleFactor", &self.lineStippleFactor)
		.field("lineStipplePattern", &self.lineStipplePattern)
		.finish()
	}
}
/// struct `VkPhysicalDeviceVertexAttributeDivisorProperties` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVertexAttributeDivisorProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVertexAttributeDivisorProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxVertexAttribDivisor: u32,
	pub supportsNonZeroFirstInstance: VkBool32,
}
impl Debug for VkPhysicalDeviceVertexAttributeDivisorProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVertexAttributeDivisorProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxVertexAttribDivisor", &self.maxVertexAttribDivisor)
		.field("supportsNonZeroFirstInstance", &self.supportsNonZeroFirstInstance)
		.finish()
	}
}
/// struct `VkVertexInputBindingDivisorDescription` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVertexInputBindingDivisorDescription.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVertexInputBindingDivisorDescription {
	pub binding: u32,
	pub divisor: u32,
}
impl Debug for VkVertexInputBindingDivisorDescription {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVertexInputBindingDivisorDescription")
		.field("binding", &self.binding)
		.field("divisor", &self.divisor)
		.finish()
	}
}
/// struct `VkPipelineVertexInputDivisorStateCreateInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineVertexInputDivisorStateCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineVertexInputDivisorStateCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub vertexBindingDivisorCount: u32,
	pub pVertexBindingDivisors: *const VkVertexInputBindingDivisorDescription,
}
impl Debug for VkPipelineVertexInputDivisorStateCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineVertexInputDivisorStateCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("vertexBindingDivisorCount", &self.vertexBindingDivisorCount)
		.field("pVertexBindingDivisors", &self.pVertexBindingDivisors)
		.finish()
	}
}
/// struct `VkPhysicalDeviceVertexAttributeDivisorFeatures` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVertexAttributeDivisorFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVertexAttributeDivisorFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub vertexAttributeInstanceRateDivisor: VkBool32,
	pub vertexAttributeInstanceRateZeroDivisor: VkBool32,
}
impl Debug for VkPhysicalDeviceVertexAttributeDivisorFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVertexAttributeDivisorFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("vertexAttributeInstanceRateDivisor", &self.vertexAttributeInstanceRateDivisor)
		.field("vertexAttributeInstanceRateZeroDivisor", &self.vertexAttributeInstanceRateZeroDivisor)
		.finish()
	}
}
/// struct `VkPhysicalDeviceIndexTypeUint8Features` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceIndexTypeUint8Features.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceIndexTypeUint8Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub indexTypeUint8: VkBool32,
}
impl Debug for VkPhysicalDeviceIndexTypeUint8Features {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceIndexTypeUint8Features")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("indexTypeUint8", &self.indexTypeUint8)
		.finish()
	}
}
/// struct `VkMemoryMapInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryMapInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryMapInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkMemoryMapFlags,
	pub memory: VkDeviceMemory,
	pub offset: VkDeviceSize,
	pub size: VkDeviceSize,
}
impl Debug for VkMemoryMapInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryMapInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("memory", &self.memory)
		.field("offset", &self.offset)
		.field("size", &self.size)
		.finish()
	}
}
/// struct `VkMemoryUnmapInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryUnmapInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryUnmapInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkMemoryUnmapFlags,
	pub memory: VkDeviceMemory,
}
impl Debug for VkMemoryUnmapInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryUnmapInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_memory_unmap_flags_to_string(self.flags)))
		.field("memory", &self.memory)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMaintenance5Features` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance5Features.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance5Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maintenance5: VkBool32,
}
impl Debug for VkPhysicalDeviceMaintenance5Features {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMaintenance5Features")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maintenance5", &self.maintenance5)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMaintenance5Properties` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance5Properties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance5Properties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub earlyFragmentMultisampleCoverageAfterSampleCounting: VkBool32,
	pub earlyFragmentSampleMaskTestBeforeSampleCounting: VkBool32,
	pub depthStencilSwizzleOneSupport: VkBool32,
	pub polygonModePointSize: VkBool32,
	pub nonStrictSinglePixelWideLinesUseParallelogram: VkBool32,
	pub nonStrictWideLinesUseParallelogram: VkBool32,
}
impl Debug for VkPhysicalDeviceMaintenance5Properties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMaintenance5Properties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("earlyFragmentMultisampleCoverageAfterSampleCounting", &self.earlyFragmentMultisampleCoverageAfterSampleCounting)
		.field("earlyFragmentSampleMaskTestBeforeSampleCounting", &self.earlyFragmentSampleMaskTestBeforeSampleCounting)
		.field("depthStencilSwizzleOneSupport", &self.depthStencilSwizzleOneSupport)
		.field("polygonModePointSize", &self.polygonModePointSize)
		.field("nonStrictSinglePixelWideLinesUseParallelogram", &self.nonStrictSinglePixelWideLinesUseParallelogram)
		.field("nonStrictWideLinesUseParallelogram", &self.nonStrictWideLinesUseParallelogram)
		.finish()
	}
}
/// struct `VkRenderingAreaInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingAreaInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderingAreaInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub viewMask: u32,
	pub colorAttachmentCount: u32,
	pub pColorAttachmentFormats: *const VkFormat,
	pub depthAttachmentFormat: VkFormat,
	pub stencilAttachmentFormat: VkFormat,
}
impl Debug for VkRenderingAreaInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderingAreaInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("viewMask", &self.viewMask)
		.field("colorAttachmentCount", &self.colorAttachmentCount)
		.field("pColorAttachmentFormats", &self.pColorAttachmentFormats)
		.field("depthAttachmentFormat", &self.depthAttachmentFormat)
		.field("stencilAttachmentFormat", &self.stencilAttachmentFormat)
		.finish()
	}
}
/// struct `VkImageSubresource2` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageSubresource2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageSubresource2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageSubresource: VkImageSubresource,
}
impl Debug for VkImageSubresource2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageSubresource2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("imageSubresource", &self.imageSubresource)
		.finish()
	}
}
/// struct `VkDeviceImageSubresourceInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceImageSubresourceInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceImageSubresourceInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pCreateInfo: *const VkImageCreateInfo,
	pub pSubresource: *const VkImageSubresource2,
}
impl Debug for VkDeviceImageSubresourceInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceImageSubresourceInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pCreateInfo", &self.pCreateInfo)
		.field("pSubresource", &self.pSubresource)
		.finish()
	}
}
/// struct `VkSubresourceLayout2` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubresourceLayout2.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSubresourceLayout2 {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub subresourceLayout: VkSubresourceLayout,
}
impl Debug for VkSubresourceLayout2 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSubresourceLayout2")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("subresourceLayout", &self.subresourceLayout)
		.finish()
	}
}
/// struct `VkPipelineCreateFlags2CreateInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreateFlags2CreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineCreateFlags2CreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCreateFlags2,
}
impl Debug for VkPipelineCreateFlags2CreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineCreateFlags2CreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.finish()
	}
}
/// struct `VkBufferUsageFlags2CreateInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferUsageFlags2CreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBufferUsageFlags2CreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub usage: VkBufferUsageFlags2,
}
impl Debug for VkBufferUsageFlags2CreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBufferUsageFlags2CreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("usage", &self.usage)
		.finish()
	}
}
/// struct `VkPhysicalDevicePushDescriptorProperties` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePushDescriptorProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePushDescriptorProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxPushDescriptors: u32,
}
impl Debug for VkPhysicalDevicePushDescriptorProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePushDescriptorProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxPushDescriptors", &self.maxPushDescriptors)
		.finish()
	}
}
/// struct `VkPhysicalDeviceDynamicRenderingLocalReadFeatures` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDynamicRenderingLocalReadFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDynamicRenderingLocalReadFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub dynamicRenderingLocalRead: VkBool32,
}
impl Debug for VkPhysicalDeviceDynamicRenderingLocalReadFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDynamicRenderingLocalReadFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dynamicRenderingLocalRead", &self.dynamicRenderingLocalRead)
		.finish()
	}
}
/// struct `VkRenderingAttachmentLocationInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingAttachmentLocationInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderingAttachmentLocationInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub colorAttachmentCount: u32,
	pub pColorAttachmentLocations: *const uint32_t,
}
impl Debug for VkRenderingAttachmentLocationInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderingAttachmentLocationInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("colorAttachmentCount", &self.colorAttachmentCount)
		.field("pColorAttachmentLocations", &self.pColorAttachmentLocations)
		.finish()
	}
}
/// struct `VkRenderingInputAttachmentIndexInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingInputAttachmentIndexInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderingInputAttachmentIndexInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub colorAttachmentCount: u32,
	pub pColorAttachmentInputIndices: *const uint32_t,
	pub pDepthInputAttachmentIndex: *const uint32_t,
	pub pStencilInputAttachmentIndex: *const uint32_t,
}
impl Debug for VkRenderingInputAttachmentIndexInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderingInputAttachmentIndexInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("colorAttachmentCount", &self.colorAttachmentCount)
		.field("pColorAttachmentInputIndices", &self.pColorAttachmentInputIndices)
		.field("pDepthInputAttachmentIndex", &self.pDepthInputAttachmentIndex)
		.field("pStencilInputAttachmentIndex", &self.pStencilInputAttachmentIndex)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMaintenance6Features` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance6Features.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance6Features {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maintenance6: VkBool32,
}
impl Debug for VkPhysicalDeviceMaintenance6Features {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMaintenance6Features")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maintenance6", &self.maintenance6)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMaintenance6Properties` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance6Properties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance6Properties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub blockTexelViewCompatibleMultipleLayers: VkBool32,
	pub maxCombinedImageSamplerDescriptorCount: u32,
	pub fragmentShadingRateClampCombinerInputs: VkBool32,
}
impl Debug for VkPhysicalDeviceMaintenance6Properties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMaintenance6Properties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("blockTexelViewCompatibleMultipleLayers", &self.blockTexelViewCompatibleMultipleLayers)
		.field("maxCombinedImageSamplerDescriptorCount", &self.maxCombinedImageSamplerDescriptorCount)
		.field("fragmentShadingRateClampCombinerInputs", &self.fragmentShadingRateClampCombinerInputs)
		.finish()
	}
}
/// struct `VkBindMemoryStatus` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindMemoryStatus.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindMemoryStatus {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pResult: *mut VkResult,
}
impl Debug for VkBindMemoryStatus {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindMemoryStatus")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pResult", &self.pResult)
		.finish()
	}
}
/// struct `VkBindDescriptorSetsInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindDescriptorSetsInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindDescriptorSetsInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stageFlags: VkShaderStageFlags,
	pub layout: VkPipelineLayout,
	pub firstSet: u32,
	pub descriptorSetCount: u32,
	pub pDescriptorSets: *const VkDescriptorSet,
	pub dynamicOffsetCount: u32,
	pub pDynamicOffsets: *const uint32_t,
}
impl Debug for VkBindDescriptorSetsInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindDescriptorSetsInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stageFlags", &self.stageFlags)
		.field("layout", &self.layout)
		.field("firstSet", &self.firstSet)
		.field("descriptorSetCount", &self.descriptorSetCount)
		.field("pDescriptorSets", &self.pDescriptorSets)
		.field("dynamicOffsetCount", &self.dynamicOffsetCount)
		.field("pDynamicOffsets", &self.pDynamicOffsets)
		.finish()
	}
}
/// struct `VkPushConstantsInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPushConstantsInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPushConstantsInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub layout: VkPipelineLayout,
	pub stageFlags: VkShaderStageFlags,
	pub offset: u32,
	pub size: u32,
	pub pValues: *const c_void,
}
impl Debug for VkPushConstantsInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPushConstantsInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("layout", &self.layout)
		.field("stageFlags", &self.stageFlags)
		.field("offset", &self.offset)
		.field("size", &self.size)
		.field("pValues", &self.pValues)
		.finish()
	}
}
/// struct `VkPushDescriptorSetInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPushDescriptorSetInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPushDescriptorSetInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stageFlags: VkShaderStageFlags,
	pub layout: VkPipelineLayout,
	pub set: u32,
	pub descriptorWriteCount: u32,
	pub pDescriptorWrites: *const VkWriteDescriptorSet,
}
impl Debug for VkPushDescriptorSetInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPushDescriptorSetInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stageFlags", &self.stageFlags)
		.field("layout", &self.layout)
		.field("set", &self.set)
		.field("descriptorWriteCount", &self.descriptorWriteCount)
		.field("pDescriptorWrites", &self.pDescriptorWrites)
		.finish()
	}
}
/// struct `VkPushDescriptorSetWithTemplateInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPushDescriptorSetWithTemplateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPushDescriptorSetWithTemplateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
	pub layout: VkPipelineLayout,
	pub set: u32,
	pub pData: *const c_void,
}
impl Debug for VkPushDescriptorSetWithTemplateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPushDescriptorSetWithTemplateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("descriptorUpdateTemplate", &self.descriptorUpdateTemplate)
		.field("layout", &self.layout)
		.field("set", &self.set)
		.field("pData", &self.pData)
		.finish()
	}
}
/// struct `VkPhysicalDevicePipelineProtectedAccessFeatures` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePipelineProtectedAccessFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePipelineProtectedAccessFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineProtectedAccess: VkBool32,
}
impl Debug for VkPhysicalDevicePipelineProtectedAccessFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePipelineProtectedAccessFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelineProtectedAccess", &self.pipelineProtectedAccess)
		.finish()
	}
}
/// struct `VkPhysicalDevicePipelineRobustnessFeatures` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePipelineRobustnessFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePipelineRobustnessFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineRobustness: VkBool32,
}
impl Debug for VkPhysicalDevicePipelineRobustnessFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePipelineRobustnessFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelineRobustness", &self.pipelineRobustness)
		.finish()
	}
}
/// struct `VkPhysicalDevicePipelineRobustnessProperties` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePipelineRobustnessProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePipelineRobustnessProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehavior,
	pub defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehavior,
	pub defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehavior,
	pub defaultRobustnessImages: VkPipelineRobustnessImageBehavior,
}
impl Debug for VkPhysicalDevicePipelineRobustnessProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePipelineRobustnessProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("defaultRobustnessStorageBuffers", &self.defaultRobustnessStorageBuffers)
		.field("defaultRobustnessUniformBuffers", &self.defaultRobustnessUniformBuffers)
		.field("defaultRobustnessVertexInputs", &self.defaultRobustnessVertexInputs)
		.field("defaultRobustnessImages", &self.defaultRobustnessImages)
		.finish()
	}
}
/// struct `VkPipelineRobustnessCreateInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRobustnessCreateInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineRobustnessCreateInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub storageBuffers: VkPipelineRobustnessBufferBehavior,
	pub uniformBuffers: VkPipelineRobustnessBufferBehavior,
	pub vertexInputs: VkPipelineRobustnessBufferBehavior,
	pub images: VkPipelineRobustnessImageBehavior,
}
impl Debug for VkPipelineRobustnessCreateInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineRobustnessCreateInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("storageBuffers", &self.storageBuffers)
		.field("uniformBuffers", &self.uniformBuffers)
		.field("vertexInputs", &self.vertexInputs)
		.field("images", &self.images)
		.finish()
	}
}
/// struct `VkPhysicalDeviceHostImageCopyFeatures` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceHostImageCopyFeatures.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceHostImageCopyFeatures {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub hostImageCopy: VkBool32,
}
impl Debug for VkPhysicalDeviceHostImageCopyFeatures {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceHostImageCopyFeatures")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("hostImageCopy", &self.hostImageCopy)
		.finish()
	}
}
/// struct `VkPhysicalDeviceHostImageCopyProperties` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceHostImageCopyProperties.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceHostImageCopyProperties {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub copySrcLayoutCount: u32,
	pub pCopySrcLayouts: *mut VkImageLayout,
	pub copyDstLayoutCount: u32,
	pub pCopyDstLayouts: *mut VkImageLayout,
	pub optimalTilingLayoutUUID: [u8; VK_UUID_SIZE as usize],
	pub identicalMemoryTypeRequirements: VkBool32,
}
impl Debug for VkPhysicalDeviceHostImageCopyProperties {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceHostImageCopyProperties")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("copySrcLayoutCount", &self.copySrcLayoutCount)
		.field("pCopySrcLayouts", &self.pCopySrcLayouts)
		.field("copyDstLayoutCount", &self.copyDstLayoutCount)
		.field("pCopyDstLayouts", &self.pCopyDstLayouts)
		.field("optimalTilingLayoutUUID", &self.optimalTilingLayoutUUID)
		.field("identicalMemoryTypeRequirements", &self.identicalMemoryTypeRequirements)
		.finish()
	}
}
/// struct `VkMemoryToImageCopy` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryToImageCopy.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryToImageCopy {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pHostPointer: *const c_void,
	pub memoryRowLength: u32,
	pub memoryImageHeight: u32,
	pub imageSubresource: VkImageSubresourceLayers,
	pub imageOffset: VkOffset3D,
	pub imageExtent: VkExtent3D,
}
impl Debug for VkMemoryToImageCopy {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryToImageCopy")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pHostPointer", &self.pHostPointer)
		.field("memoryRowLength", &self.memoryRowLength)
		.field("memoryImageHeight", &self.memoryImageHeight)
		.field("imageSubresource", &self.imageSubresource)
		.field("imageOffset", &self.imageOffset)
		.field("imageExtent", &self.imageExtent)
		.finish()
	}
}
/// struct `VkImageToMemoryCopy` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageToMemoryCopy.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageToMemoryCopy {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pHostPointer: *mut c_void,
	pub memoryRowLength: u32,
	pub memoryImageHeight: u32,
	pub imageSubresource: VkImageSubresourceLayers,
	pub imageOffset: VkOffset3D,
	pub imageExtent: VkExtent3D,
}
impl Debug for VkImageToMemoryCopy {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageToMemoryCopy")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pHostPointer", &self.pHostPointer)
		.field("memoryRowLength", &self.memoryRowLength)
		.field("memoryImageHeight", &self.memoryImageHeight)
		.field("imageSubresource", &self.imageSubresource)
		.field("imageOffset", &self.imageOffset)
		.field("imageExtent", &self.imageExtent)
		.finish()
	}
}
/// struct `VkCopyMemoryToImageInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyMemoryToImageInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyMemoryToImageInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkHostImageCopyFlags,
	pub dstImage: VkImage,
	pub dstImageLayout: VkImageLayout,
	pub regionCount: u32,
	pub pRegions: *const VkMemoryToImageCopy,
}
impl Debug for VkCopyMemoryToImageInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyMemoryToImageInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_host_image_copy_flags_to_string(self.flags)))
		.field("dstImage", &self.dstImage)
		.field("dstImageLayout", &self.dstImageLayout)
		.field("regionCount", &self.regionCount)
		.field("pRegions", &self.pRegions)
		.finish()
	}
}
/// struct `VkCopyImageToMemoryInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyImageToMemoryInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyImageToMemoryInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkHostImageCopyFlags,
	pub srcImage: VkImage,
	pub srcImageLayout: VkImageLayout,
	pub regionCount: u32,
	pub pRegions: *const VkImageToMemoryCopy,
}
impl Debug for VkCopyImageToMemoryInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyImageToMemoryInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_host_image_copy_flags_to_string(self.flags)))
		.field("srcImage", &self.srcImage)
		.field("srcImageLayout", &self.srcImageLayout)
		.field("regionCount", &self.regionCount)
		.field("pRegions", &self.pRegions)
		.finish()
	}
}
/// struct `VkCopyImageToImageInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyImageToImageInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyImageToImageInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkHostImageCopyFlags,
	pub srcImage: VkImage,
	pub srcImageLayout: VkImageLayout,
	pub dstImage: VkImage,
	pub dstImageLayout: VkImageLayout,
	pub regionCount: u32,
	pub pRegions: *const VkImageCopy2,
}
impl Debug for VkCopyImageToImageInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyImageToImageInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &format_args!("{}", vk_host_image_copy_flags_to_string(self.flags)))
		.field("srcImage", &self.srcImage)
		.field("srcImageLayout", &self.srcImageLayout)
		.field("dstImage", &self.dstImage)
		.field("dstImageLayout", &self.dstImageLayout)
		.field("regionCount", &self.regionCount)
		.field("pRegions", &self.pRegions)
		.finish()
	}
}
/// struct `VkHostImageLayoutTransitionInfo` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkHostImageLayoutTransitionInfo.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkHostImageLayoutTransitionInfo {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub image: VkImage,
	pub oldLayout: VkImageLayout,
	pub newLayout: VkImageLayout,
	pub subresourceRange: VkImageSubresourceRange,
}
impl Debug for VkHostImageLayoutTransitionInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkHostImageLayoutTransitionInfo")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("image", &self.image)
		.field("oldLayout", &self.oldLayout)
		.field("newLayout", &self.newLayout)
		.field("subresourceRange", &self.subresourceRange)
		.finish()
	}
}
/// struct `VkSubresourceHostMemcpySize` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubresourceHostMemcpySize.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSubresourceHostMemcpySize {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub size: VkDeviceSize,
}
impl Debug for VkSubresourceHostMemcpySize {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSubresourceHostMemcpySize")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("size", &self.size)
		.finish()
	}
}
/// struct `VkHostImageCopyDevicePerformanceQuery` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkHostImageCopyDevicePerformanceQuery.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkHostImageCopyDevicePerformanceQuery {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub optimalDeviceAccess: VkBool32,
	pub identicalMemoryLayout: VkBool32,
}
impl Debug for VkHostImageCopyDevicePerformanceQuery {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkHostImageCopyDevicePerformanceQuery")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("optimalDeviceAccess", &self.optimalDeviceAccess)
		.field("identicalMemoryLayout", &self.identicalMemoryLayout)
		.finish()
	}
}
/// function prototype `PFN_vkCmdSetLineStipple` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLineStipple.html>
type PFN_vkCmdSetLineStipple = extern "system" fn(commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16);
/// function prototype `PFN_vkMapMemory2` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkMapMemory2.html>
type PFN_vkMapMemory2 = extern "system" fn(device: VkDevice, pMemoryMapInfo: *const VkMemoryMapInfo, ppData: *mut *mut c_void) -> VkResult;
/// function prototype `PFN_vkUnmapMemory2` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkUnmapMemory2.html>
type PFN_vkUnmapMemory2 = extern "system" fn(device: VkDevice, pMemoryUnmapInfo: *const VkMemoryUnmapInfo) -> VkResult;
/// function prototype `PFN_vkCmdBindIndexBuffer2` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindIndexBuffer2.html>
type PFN_vkCmdBindIndexBuffer2 = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType);
/// function prototype `PFN_vkGetRenderingAreaGranularity` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRenderingAreaGranularity.html>
type PFN_vkGetRenderingAreaGranularity = extern "system" fn(device: VkDevice, pRenderingAreaInfo: *const VkRenderingAreaInfo, pGranularity: *mut VkExtent2D);
/// function prototype `PFN_vkGetDeviceImageSubresourceLayout` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSubresourceLayout.html>
type PFN_vkGetDeviceImageSubresourceLayout = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceImageSubresourceInfo, pLayout: *mut VkSubresourceLayout2);
/// function prototype `PFN_vkGetImageSubresourceLayout2` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout2.html>
type PFN_vkGetImageSubresourceLayout2 = extern "system" fn(device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource2, pLayout: *mut VkSubresourceLayout2);
/// function prototype `PFN_vkCmdPushDescriptorSet` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSet.html>
type PFN_vkCmdPushDescriptorSet = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet);
/// function prototype `PFN_vkCmdPushDescriptorSetWithTemplate` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetWithTemplate.html>
type PFN_vkCmdPushDescriptorSetWithTemplate = extern "system" fn(commandBuffer: VkCommandBuffer, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: u32, pData: *const c_void);
/// function prototype `PFN_vkCmdSetRenderingAttachmentLocations` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRenderingAttachmentLocations.html>
type PFN_vkCmdSetRenderingAttachmentLocations = extern "system" fn(commandBuffer: VkCommandBuffer, pLocationInfo: *const VkRenderingAttachmentLocationInfo);
/// function prototype `PFN_vkCmdSetRenderingInputAttachmentIndices` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRenderingInputAttachmentIndices.html>
type PFN_vkCmdSetRenderingInputAttachmentIndices = extern "system" fn(commandBuffer: VkCommandBuffer, pInputAttachmentIndexInfo: *const VkRenderingInputAttachmentIndexInfo);
/// function prototype `PFN_vkCmdBindDescriptorSets2` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorSets2.html>
type PFN_vkCmdBindDescriptorSets2 = extern "system" fn(commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo);
/// function prototype `PFN_vkCmdPushConstants2` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushConstants2.html>
type PFN_vkCmdPushConstants2 = extern "system" fn(commandBuffer: VkCommandBuffer, pPushConstantsInfo: *const VkPushConstantsInfo);
/// function prototype `PFN_vkCmdPushDescriptorSet2` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSet2.html>
type PFN_vkCmdPushDescriptorSet2 = extern "system" fn(commandBuffer: VkCommandBuffer, pPushDescriptorSetInfo: *const VkPushDescriptorSetInfo);
/// function prototype `PFN_vkCmdPushDescriptorSetWithTemplate2` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetWithTemplate2.html>
type PFN_vkCmdPushDescriptorSetWithTemplate2 = extern "system" fn(commandBuffer: VkCommandBuffer, pPushDescriptorSetWithTemplateInfo: *const VkPushDescriptorSetWithTemplateInfo);
/// function prototype `PFN_vkCopyMemoryToImage` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToImage.html>
type PFN_vkCopyMemoryToImage = extern "system" fn(device: VkDevice, pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo) -> VkResult;
/// function prototype `PFN_vkCopyImageToMemory` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToMemory.html>
type PFN_vkCopyImageToMemory = extern "system" fn(device: VkDevice, pCopyImageToMemoryInfo: *const VkCopyImageToMemoryInfo) -> VkResult;
/// function prototype `PFN_vkCopyImageToImage` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToImage.html>
type PFN_vkCopyImageToImage = extern "system" fn(device: VkDevice, pCopyImageToImageInfo: *const VkCopyImageToImageInfo) -> VkResult;
/// function prototype `PFN_vkTransitionImageLayout` from VK_VERSION_1_4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkTransitionImageLayout.html>
type PFN_vkTransitionImageLayout = extern "system" fn(device: VkDevice, transitionCount: u32, pTransitions: *const VkHostImageLayoutTransitionInfo) -> VkResult;
/// The dummy function for `vkCmdSetLineStipple` from `VK_VERSION_1_4`
extern "system" fn dummy_vkCmdSetLineStipple(_: VkCommandBuffer, _: u32, _: u16) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetLineStipple"))
}
/// The dummy function for `vkMapMemory2` from `VK_VERSION_1_4`
extern "system" fn dummy_vkMapMemory2(_: VkDevice, _: *const VkMemoryMapInfo, _: *mut *mut c_void) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkMapMemory2"))
}
/// The dummy function for `vkUnmapMemory2` from `VK_VERSION_1_4`
extern "system" fn dummy_vkUnmapMemory2(_: VkDevice, _: *const VkMemoryUnmapInfo) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkUnmapMemory2"))
}
/// The dummy function for `vkCmdBindIndexBuffer2` from `VK_VERSION_1_4`
extern "system" fn dummy_vkCmdBindIndexBuffer2(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkDeviceSize, _: VkIndexType) {
	panic_any(VkError::NullFunctionPointer("vkCmdBindIndexBuffer2"))
}
/// The dummy function for `vkGetRenderingAreaGranularity` from `VK_VERSION_1_4`
extern "system" fn dummy_vkGetRenderingAreaGranularity(_: VkDevice, _: *const VkRenderingAreaInfo, _: *mut VkExtent2D) {
	panic_any(VkError::NullFunctionPointer("vkGetRenderingAreaGranularity"))
}
/// The dummy function for `vkGetDeviceImageSubresourceLayout` from `VK_VERSION_1_4`
extern "system" fn dummy_vkGetDeviceImageSubresourceLayout(_: VkDevice, _: *const VkDeviceImageSubresourceInfo, _: *mut VkSubresourceLayout2) {
	panic_any(VkError::NullFunctionPointer("vkGetDeviceImageSubresourceLayout"))
}
/// The dummy function for `vkGetImageSubresourceLayout2` from `VK_VERSION_1_4`
extern "system" fn dummy_vkGetImageSubresourceLayout2(_: VkDevice, _: VkImage, _: *const VkImageSubresource2, _: *mut VkSubresourceLayout2) {
	panic_any(VkError::NullFunctionPointer("vkGetImageSubresourceLayout2"))
}
/// The dummy function for `vkCmdPushDescriptorSet` from `VK_VERSION_1_4`
extern "system" fn dummy_vkCmdPushDescriptorSet(_: VkCommandBuffer, _: VkPipelineBindPoint, _: VkPipelineLayout, _: u32, _: u32, _: *const VkWriteDescriptorSet) {
	panic_any(VkError::NullFunctionPointer("vkCmdPushDescriptorSet"))
}
/// The dummy function for `vkCmdPushDescriptorSetWithTemplate` from `VK_VERSION_1_4`
extern "system" fn dummy_vkCmdPushDescriptorSetWithTemplate(_: VkCommandBuffer, _: VkDescriptorUpdateTemplate, _: VkPipelineLayout, _: u32, _: *const c_void) {
	panic_any(VkError::NullFunctionPointer("vkCmdPushDescriptorSetWithTemplate"))
}
/// The dummy function for `vkCmdSetRenderingAttachmentLocations` from `VK_VERSION_1_4`
extern "system" fn dummy_vkCmdSetRenderingAttachmentLocations(_: VkCommandBuffer, _: *const VkRenderingAttachmentLocationInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetRenderingAttachmentLocations"))
}
/// The dummy function for `vkCmdSetRenderingInputAttachmentIndices` from `VK_VERSION_1_4`
extern "system" fn dummy_vkCmdSetRenderingInputAttachmentIndices(_: VkCommandBuffer, _: *const VkRenderingInputAttachmentIndexInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetRenderingInputAttachmentIndices"))
}
/// The dummy function for `vkCmdBindDescriptorSets2` from `VK_VERSION_1_4`
extern "system" fn dummy_vkCmdBindDescriptorSets2(_: VkCommandBuffer, _: *const VkBindDescriptorSetsInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdBindDescriptorSets2"))
}
/// The dummy function for `vkCmdPushConstants2` from `VK_VERSION_1_4`
extern "system" fn dummy_vkCmdPushConstants2(_: VkCommandBuffer, _: *const VkPushConstantsInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdPushConstants2"))
}
/// The dummy function for `vkCmdPushDescriptorSet2` from `VK_VERSION_1_4`
extern "system" fn dummy_vkCmdPushDescriptorSet2(_: VkCommandBuffer, _: *const VkPushDescriptorSetInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdPushDescriptorSet2"))
}
/// The dummy function for `vkCmdPushDescriptorSetWithTemplate2` from `VK_VERSION_1_4`
extern "system" fn dummy_vkCmdPushDescriptorSetWithTemplate2(_: VkCommandBuffer, _: *const VkPushDescriptorSetWithTemplateInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdPushDescriptorSetWithTemplate2"))
}
/// The dummy function for `vkCopyMemoryToImage` from `VK_VERSION_1_4`
extern "system" fn dummy_vkCopyMemoryToImage(_: VkDevice, _: *const VkCopyMemoryToImageInfo) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCopyMemoryToImage"))
}
/// The dummy function for `vkCopyImageToMemory` from `VK_VERSION_1_4`
extern "system" fn dummy_vkCopyImageToMemory(_: VkDevice, _: *const VkCopyImageToMemoryInfo) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCopyImageToMemory"))
}
/// The dummy function for `vkCopyImageToImage` from `VK_VERSION_1_4`
extern "system" fn dummy_vkCopyImageToImage(_: VkDevice, _: *const VkCopyImageToImageInfo) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCopyImageToImage"))
}
/// The dummy function for `vkTransitionImageLayout` from `VK_VERSION_1_4`
extern "system" fn dummy_vkTransitionImageLayout(_: VkDevice, _: u32, _: *const VkHostImageLayoutTransitionInfo) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkTransitionImageLayout"))
}
/// trait for `VK_VERSION_1_4`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_VERSION_1_4.html>
pub trait VK_VERSION_1_4: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLineStipple.html>
	fn vkCmdSetLineStipple(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkMapMemory2.html>
	fn vkMapMemory2(&self, device: VkDevice, pMemoryMapInfo: *const VkMemoryMapInfo, ppData: *mut *mut c_void) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkUnmapMemory2.html>
	fn vkUnmapMemory2(&self, device: VkDevice, pMemoryUnmapInfo: *const VkMemoryUnmapInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindIndexBuffer2.html>
	fn vkCmdBindIndexBuffer2(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRenderingAreaGranularity.html>
	fn vkGetRenderingAreaGranularity(&self, device: VkDevice, pRenderingAreaInfo: *const VkRenderingAreaInfo, pGranularity: *mut VkExtent2D) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSubresourceLayout.html>
	fn vkGetDeviceImageSubresourceLayout(&self, device: VkDevice, pInfo: *const VkDeviceImageSubresourceInfo, pLayout: *mut VkSubresourceLayout2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout2.html>
	fn vkGetImageSubresourceLayout2(&self, device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource2, pLayout: *mut VkSubresourceLayout2) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSet.html>
	fn vkCmdPushDescriptorSet(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetWithTemplate.html>
	fn vkCmdPushDescriptorSetWithTemplate(&self, commandBuffer: VkCommandBuffer, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: u32, pData: *const c_void) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRenderingAttachmentLocations.html>
	fn vkCmdSetRenderingAttachmentLocations(&self, commandBuffer: VkCommandBuffer, pLocationInfo: *const VkRenderingAttachmentLocationInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRenderingInputAttachmentIndices.html>
	fn vkCmdSetRenderingInputAttachmentIndices(&self, commandBuffer: VkCommandBuffer, pInputAttachmentIndexInfo: *const VkRenderingInputAttachmentIndexInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorSets2.html>
	fn vkCmdBindDescriptorSets2(&self, commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushConstants2.html>
	fn vkCmdPushConstants2(&self, commandBuffer: VkCommandBuffer, pPushConstantsInfo: *const VkPushConstantsInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSet2.html>
	fn vkCmdPushDescriptorSet2(&self, commandBuffer: VkCommandBuffer, pPushDescriptorSetInfo: *const VkPushDescriptorSetInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetWithTemplate2.html>
	fn vkCmdPushDescriptorSetWithTemplate2(&self, commandBuffer: VkCommandBuffer, pPushDescriptorSetWithTemplateInfo: *const VkPushDescriptorSetWithTemplateInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToImage.html>
	fn vkCopyMemoryToImage(&self, device: VkDevice, pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToMemory.html>
	fn vkCopyImageToMemory(&self, device: VkDevice, pCopyImageToMemoryInfo: *const VkCopyImageToMemoryInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToImage.html>
	fn vkCopyImageToImage(&self, device: VkDevice, pCopyImageToImageInfo: *const VkCopyImageToImageInfo) -> Result<()>;
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkTransitionImageLayout.html>
	fn vkTransitionImageLayout(&self, device: VkDevice, transitionCount: u32, pTransitions: *const VkHostImageLayoutTransitionInfo) -> Result<()>;
}
/// struct for `VK_VERSION_1_4`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_VERSION_1_4 {
	vk_cmd_set_line_stipple: PFN_vkCmdSetLineStipple,
	vk_map_memory2: PFN_vkMapMemory2,
	vk_unmap_memory2: PFN_vkUnmapMemory2,
	vk_cmd_bind_index_buffer2: PFN_vkCmdBindIndexBuffer2,
	vk_get_rendering_area_granularity: PFN_vkGetRenderingAreaGranularity,
	vk_get_device_image_subresource_layout: PFN_vkGetDeviceImageSubresourceLayout,
	vk_get_image_subresource_layout2: PFN_vkGetImageSubresourceLayout2,
	vk_cmd_push_descriptor_set: PFN_vkCmdPushDescriptorSet,
	vk_cmd_push_descriptor_set_with_template: PFN_vkCmdPushDescriptorSetWithTemplate,
	vk_cmd_set_rendering_attachment_locations: PFN_vkCmdSetRenderingAttachmentLocations,
	vk_cmd_set_rendering_input_attachment_indices: PFN_vkCmdSetRenderingInputAttachmentIndices,
	vk_cmd_bind_descriptor_sets2: PFN_vkCmdBindDescriptorSets2,
	vk_cmd_push_constants2: PFN_vkCmdPushConstants2,
	vk_cmd_push_descriptor_set2: PFN_vkCmdPushDescriptorSet2,
	vk_cmd_push_descriptor_set_with_template2: PFN_vkCmdPushDescriptorSetWithTemplate2,
	vk_copy_memory_to_image: PFN_vkCopyMemoryToImage,
	vk_copy_image_to_memory: PFN_vkCopyImageToMemory,
	vk_copy_image_to_image: PFN_vkCopyImageToImage,
	vk_transition_image_layout: PFN_vkTransitionImageLayout,
}
impl VK_VERSION_1_4 for Vulkan_VERSION_1_4 {
	fn vkCmdSetLineStipple(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_line_stipple)(commandBuffer, lineStippleFactor, lineStipplePattern))))
	}
	fn vkMapMemory2(&self, device: VkDevice, pMemoryMapInfo: *const VkMemoryMapInfo, ppData: *mut *mut c_void) -> Result<()> {
		convert_result("vkMapMemory2", catch_unwind(||((self.vk_map_memory2)(device, pMemoryMapInfo, ppData))))
	}
	fn vkUnmapMemory2(&self, device: VkDevice, pMemoryUnmapInfo: *const VkMemoryUnmapInfo) -> Result<()> {
		convert_result("vkUnmapMemory2", catch_unwind(||((self.vk_unmap_memory2)(device, pMemoryUnmapInfo))))
	}
	fn vkCmdBindIndexBuffer2(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_bind_index_buffer2)(commandBuffer, buffer, offset, size, indexType))))
	}
	fn vkGetRenderingAreaGranularity(&self, device: VkDevice, pRenderingAreaInfo: *const VkRenderingAreaInfo, pGranularity: *mut VkExtent2D) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_rendering_area_granularity)(device, pRenderingAreaInfo, pGranularity))))
	}
	fn vkGetDeviceImageSubresourceLayout(&self, device: VkDevice, pInfo: *const VkDeviceImageSubresourceInfo, pLayout: *mut VkSubresourceLayout2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_device_image_subresource_layout)(device, pInfo, pLayout))))
	}
	fn vkGetImageSubresourceLayout2(&self, device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource2, pLayout: *mut VkSubresourceLayout2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_image_subresource_layout2)(device, image, pSubresource, pLayout))))
	}
	fn vkCmdPushDescriptorSet(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_push_descriptor_set)(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites))))
	}
	fn vkCmdPushDescriptorSetWithTemplate(&self, commandBuffer: VkCommandBuffer, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: u32, pData: *const c_void) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_push_descriptor_set_with_template)(commandBuffer, descriptorUpdateTemplate, layout, set, pData))))
	}
	fn vkCmdSetRenderingAttachmentLocations(&self, commandBuffer: VkCommandBuffer, pLocationInfo: *const VkRenderingAttachmentLocationInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_rendering_attachment_locations)(commandBuffer, pLocationInfo))))
	}
	fn vkCmdSetRenderingInputAttachmentIndices(&self, commandBuffer: VkCommandBuffer, pInputAttachmentIndexInfo: *const VkRenderingInputAttachmentIndexInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_rendering_input_attachment_indices)(commandBuffer, pInputAttachmentIndexInfo))))
	}
	fn vkCmdBindDescriptorSets2(&self, commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_bind_descriptor_sets2)(commandBuffer, pBindDescriptorSetsInfo))))
	}
	fn vkCmdPushConstants2(&self, commandBuffer: VkCommandBuffer, pPushConstantsInfo: *const VkPushConstantsInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_push_constants2)(commandBuffer, pPushConstantsInfo))))
	}
	fn vkCmdPushDescriptorSet2(&self, commandBuffer: VkCommandBuffer, pPushDescriptorSetInfo: *const VkPushDescriptorSetInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_push_descriptor_set2)(commandBuffer, pPushDescriptorSetInfo))))
	}
	fn vkCmdPushDescriptorSetWithTemplate2(&self, commandBuffer: VkCommandBuffer, pPushDescriptorSetWithTemplateInfo: *const VkPushDescriptorSetWithTemplateInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_push_descriptor_set_with_template2)(commandBuffer, pPushDescriptorSetWithTemplateInfo))))
	}
	fn vkCopyMemoryToImage(&self, device: VkDevice, pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo) -> Result<()> {
		convert_result("vkCopyMemoryToImage", catch_unwind(||((self.vk_copy_memory_to_image)(device, pCopyMemoryToImageInfo))))
	}
	fn vkCopyImageToMemory(&self, device: VkDevice, pCopyImageToMemoryInfo: *const VkCopyImageToMemoryInfo) -> Result<()> {
		convert_result("vkCopyImageToMemory", catch_unwind(||((self.vk_copy_image_to_memory)(device, pCopyImageToMemoryInfo))))
	}
	fn vkCopyImageToImage(&self, device: VkDevice, pCopyImageToImageInfo: *const VkCopyImageToImageInfo) -> Result<()> {
		convert_result("vkCopyImageToImage", catch_unwind(||((self.vk_copy_image_to_image)(device, pCopyImageToImageInfo))))
	}
	fn vkTransitionImageLayout(&self, device: VkDevice, transitionCount: u32, pTransitions: *const VkHostImageLayoutTransitionInfo) -> Result<()> {
		convert_result("vkTransitionImageLayout", catch_unwind(||((self.vk_transition_image_layout)(device, transitionCount, pTransitions))))
	}
}
impl Default for Vulkan_VERSION_1_4 {
	fn default() -> Self {
		Self {
			vk_cmd_set_line_stipple: dummy_vkCmdSetLineStipple,
			vk_map_memory2: dummy_vkMapMemory2,
			vk_unmap_memory2: dummy_vkUnmapMemory2,
			vk_cmd_bind_index_buffer2: dummy_vkCmdBindIndexBuffer2,
			vk_get_rendering_area_granularity: dummy_vkGetRenderingAreaGranularity,
			vk_get_device_image_subresource_layout: dummy_vkGetDeviceImageSubresourceLayout,
			vk_get_image_subresource_layout2: dummy_vkGetImageSubresourceLayout2,
			vk_cmd_push_descriptor_set: dummy_vkCmdPushDescriptorSet,
			vk_cmd_push_descriptor_set_with_template: dummy_vkCmdPushDescriptorSetWithTemplate,
			vk_cmd_set_rendering_attachment_locations: dummy_vkCmdSetRenderingAttachmentLocations,
			vk_cmd_set_rendering_input_attachment_indices: dummy_vkCmdSetRenderingInputAttachmentIndices,
			vk_cmd_bind_descriptor_sets2: dummy_vkCmdBindDescriptorSets2,
			vk_cmd_push_constants2: dummy_vkCmdPushConstants2,
			vk_cmd_push_descriptor_set2: dummy_vkCmdPushDescriptorSet2,
			vk_cmd_push_descriptor_set_with_template2: dummy_vkCmdPushDescriptorSetWithTemplate2,
			vk_copy_memory_to_image: dummy_vkCopyMemoryToImage,
			vk_copy_image_to_memory: dummy_vkCopyImageToMemory,
			vk_copy_image_to_image: dummy_vkCopyImageToImage,
			vk_transition_image_layout: dummy_vkTransitionImageLayout,
		}
	}
}
impl Vulkan_VERSION_1_4 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_line_stipple: {let proc = get_instance_proc_address(instance, "vkCmdSetLineStipple"); if proc == null() {dummy_vkCmdSetLineStipple} else {unsafe {transmute(proc)}}},
			vk_map_memory2: {let proc = get_instance_proc_address(instance, "vkMapMemory2"); if proc == null() {dummy_vkMapMemory2} else {unsafe {transmute(proc)}}},
			vk_unmap_memory2: {let proc = get_instance_proc_address(instance, "vkUnmapMemory2"); if proc == null() {dummy_vkUnmapMemory2} else {unsafe {transmute(proc)}}},
			vk_cmd_bind_index_buffer2: {let proc = get_instance_proc_address(instance, "vkCmdBindIndexBuffer2"); if proc == null() {dummy_vkCmdBindIndexBuffer2} else {unsafe {transmute(proc)}}},
			vk_get_rendering_area_granularity: {let proc = get_instance_proc_address(instance, "vkGetRenderingAreaGranularity"); if proc == null() {dummy_vkGetRenderingAreaGranularity} else {unsafe {transmute(proc)}}},
			vk_get_device_image_subresource_layout: {let proc = get_instance_proc_address(instance, "vkGetDeviceImageSubresourceLayout"); if proc == null() {dummy_vkGetDeviceImageSubresourceLayout} else {unsafe {transmute(proc)}}},
			vk_get_image_subresource_layout2: {let proc = get_instance_proc_address(instance, "vkGetImageSubresourceLayout2"); if proc == null() {dummy_vkGetImageSubresourceLayout2} else {unsafe {transmute(proc)}}},
			vk_cmd_push_descriptor_set: {let proc = get_instance_proc_address(instance, "vkCmdPushDescriptorSet"); if proc == null() {dummy_vkCmdPushDescriptorSet} else {unsafe {transmute(proc)}}},
			vk_cmd_push_descriptor_set_with_template: {let proc = get_instance_proc_address(instance, "vkCmdPushDescriptorSetWithTemplate"); if proc == null() {dummy_vkCmdPushDescriptorSetWithTemplate} else {unsafe {transmute(proc)}}},
			vk_cmd_set_rendering_attachment_locations: {let proc = get_instance_proc_address(instance, "vkCmdSetRenderingAttachmentLocations"); if proc == null() {dummy_vkCmdSetRenderingAttachmentLocations} else {unsafe {transmute(proc)}}},
			vk_cmd_set_rendering_input_attachment_indices: {let proc = get_instance_proc_address(instance, "vkCmdSetRenderingInputAttachmentIndices"); if proc == null() {dummy_vkCmdSetRenderingInputAttachmentIndices} else {unsafe {transmute(proc)}}},
			vk_cmd_bind_descriptor_sets2: {let proc = get_instance_proc_address(instance, "vkCmdBindDescriptorSets2"); if proc == null() {dummy_vkCmdBindDescriptorSets2} else {unsafe {transmute(proc)}}},
			vk_cmd_push_constants2: {let proc = get_instance_proc_address(instance, "vkCmdPushConstants2"); if proc == null() {dummy_vkCmdPushConstants2} else {unsafe {transmute(proc)}}},
			vk_cmd_push_descriptor_set2: {let proc = get_instance_proc_address(instance, "vkCmdPushDescriptorSet2"); if proc == null() {dummy_vkCmdPushDescriptorSet2} else {unsafe {transmute(proc)}}},
			vk_cmd_push_descriptor_set_with_template2: {let proc = get_instance_proc_address(instance, "vkCmdPushDescriptorSetWithTemplate2"); if proc == null() {dummy_vkCmdPushDescriptorSetWithTemplate2} else {unsafe {transmute(proc)}}},
			vk_copy_memory_to_image: {let proc = get_instance_proc_address(instance, "vkCopyMemoryToImage"); if proc == null() {dummy_vkCopyMemoryToImage} else {unsafe {transmute(proc)}}},
			vk_copy_image_to_memory: {let proc = get_instance_proc_address(instance, "vkCopyImageToMemory"); if proc == null() {dummy_vkCopyImageToMemory} else {unsafe {transmute(proc)}}},
			vk_copy_image_to_image: {let proc = get_instance_proc_address(instance, "vkCopyImageToImage"); if proc == null() {dummy_vkCopyImageToImage} else {unsafe {transmute(proc)}}},
			vk_transition_image_layout: {let proc = get_instance_proc_address(instance, "vkTransitionImageLayout"); if proc == null() {dummy_vkTransitionImageLayout} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkCompositeAlphaFlagsKHR` from VK_KHR_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCompositeAlphaFlagsKHR.html>
pub type VkCompositeAlphaFlagsKHR = VkFlags;
/// type definition `VkSurfaceTransformFlagsKHR` from VK_KHR_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfaceTransformFlagsKHR.html>
pub type VkSurfaceTransformFlagsKHR = VkFlags;
/// Non-dispatchable handle `VkSurfaceKHR` from VK_KHR_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfaceKHR.html
#[cfg(target_pointer_width = "32")] pub type VkSurfaceKHR = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkSurfaceKHR_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkSurfaceKHR = *const VkSurfaceKHR_T;
/// enum `VkPresentModeKHR` from VK_KHR_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentModeKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPresentModeKHR {
	VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
	VK_PRESENT_MODE_MAILBOX_KHR = 1,
	VK_PRESENT_MODE_FIFO_KHR = 2,
	VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
	VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
	VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
	VK_PRESENT_MODE_FIFO_LATEST_READY_KHR = 1000361000,
	VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkPresentModeKHR {
	pub const VK_PRESENT_MODE_FIFO_LATEST_READY_EXT: VkPresentModeKHR = VkPresentModeKHR::VK_PRESENT_MODE_FIFO_LATEST_READY_KHR;
}
/// enum `VkColorSpaceKHR` from VK_KHR_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkColorSpaceKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkColorSpaceKHR {
	VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
	VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
	VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
	VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003,
	VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
	VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
	VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
	VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
	VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
	VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
	VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
	VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
	VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
	VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
	VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
	VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000,
	VK_COLOR_SPACE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkColorSpaceKHR {
	pub const VK_COLORSPACE_SRGB_NONLINEAR_KHR: VkColorSpaceKHR = VkColorSpaceKHR::VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
	pub const VK_COLOR_SPACE_DCI_P3_LINEAR_EXT: VkColorSpaceKHR = VkColorSpaceKHR::VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT;
}
/// enum `VkSurfaceTransformFlagBitsKHR` from VK_KHR_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfaceTransformFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSurfaceTransformFlagBitsKHR {
	VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001,
	VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002,
	VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004,
	VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
	VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100,
	VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkCompositeAlphaFlagBitsKHR` from VK_KHR_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCompositeAlphaFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCompositeAlphaFlagBitsKHR {
	VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
	VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x00000002,
	VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
	VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x00000008,
	VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// struct `VkSurfaceCapabilitiesKHR` from VK_KHR_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfaceCapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSurfaceCapabilitiesKHR {
	pub minImageCount: u32,
	pub maxImageCount: u32,
	pub currentExtent: VkExtent2D,
	pub minImageExtent: VkExtent2D,
	pub maxImageExtent: VkExtent2D,
	pub maxImageArrayLayers: u32,
	pub supportedTransforms: VkSurfaceTransformFlagsKHR,
	pub currentTransform: VkSurfaceTransformFlagBitsKHR,
	pub supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
	pub supportedUsageFlags: VkImageUsageFlags,
}
impl Debug for VkSurfaceCapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSurfaceCapabilitiesKHR")
		.field("minImageCount", &self.minImageCount)
		.field("maxImageCount", &self.maxImageCount)
		.field("currentExtent", &self.currentExtent)
		.field("minImageExtent", &self.minImageExtent)
		.field("maxImageExtent", &self.maxImageExtent)
		.field("maxImageArrayLayers", &self.maxImageArrayLayers)
		.field("supportedTransforms", &self.supportedTransforms)
		.field("currentTransform", &self.currentTransform)
		.field("supportedCompositeAlpha", &self.supportedCompositeAlpha)
		.field("supportedUsageFlags", &self.supportedUsageFlags)
		.finish()
	}
}
/// struct `VkSurfaceFormatKHR` from VK_KHR_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfaceFormatKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSurfaceFormatKHR {
	pub format: VkFormat,
	pub colorSpace: VkColorSpaceKHR,
}
impl Debug for VkSurfaceFormatKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSurfaceFormatKHR")
		.field("format", &self.format)
		.field("colorSpace", &self.colorSpace)
		.finish()
	}
}
/// function prototype `PFN_vkDestroySurfaceKHR` from VK_KHR_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySurfaceKHR.html>
type PFN_vkDestroySurfaceKHR = extern "system" fn(instance: VkInstance, surface: VkSurfaceKHR, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkGetPhysicalDeviceSurfaceSupportKHR` from VK_KHR_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html>
type PFN_vkGetPhysicalDeviceSurfaceSupportKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, surface: VkSurfaceKHR, pSupported: *mut VkBool32) -> VkResult;
/// function prototype `PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR` from VK_KHR_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceCapabilitiesKHR.html>
type PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *mut VkSurfaceCapabilitiesKHR) -> VkResult;
/// function prototype `PFN_vkGetPhysicalDeviceSurfaceFormatsKHR` from VK_KHR_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceFormatsKHR.html>
type PFN_vkGetPhysicalDeviceSurfaceFormatsKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceFormatCount: *mut uint32_t, pSurfaceFormats: *mut VkSurfaceFormatKHR) -> VkResult;
/// function prototype `PFN_vkGetPhysicalDeviceSurfacePresentModesKHR` from VK_KHR_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfacePresentModesKHR.html>
type PFN_vkGetPhysicalDeviceSurfacePresentModesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pPresentModeCount: *mut uint32_t, pPresentModes: *mut VkPresentModeKHR) -> VkResult;
/// The dummy function for `vkDestroySurfaceKHR` from `VK_KHR_surface`
extern "system" fn dummy_vkDestroySurfaceKHR(_: VkInstance, _: VkSurfaceKHR, _: *const VkAllocationCallbacks) {
	panic_any(VkError::NullFunctionPointer("vkDestroySurfaceKHR"))
}
/// trait for `VK_KHR_surface`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_surface.html>
pub trait VK_KHR_surface: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySurfaceKHR.html>
	fn vkDestroySurfaceKHR(&self, instance: VkInstance, surface: VkSurfaceKHR, pAllocator: *const VkAllocationCallbacks) -> Result<()>;
}
/// struct for `VK_KHR_surface`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_surface {
	vk_destroy_surface_khr: PFN_vkDestroySurfaceKHR,
}
impl VK_KHR_surface for Vulkan_KHR_surface {
	fn vkDestroySurfaceKHR(&self, instance: VkInstance, surface: VkSurfaceKHR, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_destroy_surface_khr)(instance, surface, pAllocator))))
	}
}
impl Default for Vulkan_KHR_surface {
	fn default() -> Self {
		Self {
			vk_destroy_surface_khr: dummy_vkDestroySurfaceKHR,
		}
	}
}
impl Vulkan_KHR_surface {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_destroy_surface_khr: {let proc = get_instance_proc_address(instance, "vkDestroySurfaceKHR"); if proc == null() {dummy_vkDestroySurfaceKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkSwapchainCreateFlagsKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainCreateFlagsKHR.html>
pub type VkSwapchainCreateFlagsKHR = VkFlags;
/// type definition `VkDeviceGroupPresentModeFlagsKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupPresentModeFlagsKHR.html>
pub type VkDeviceGroupPresentModeFlagsKHR = VkFlags;
/// Non-dispatchable handle `VkSwapchainKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainKHR.html
#[cfg(target_pointer_width = "32")] pub type VkSwapchainKHR = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkSwapchainKHR_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkSwapchainKHR = *const VkSwapchainKHR_T;
/// enum `VkSwapchainCreateFlagBitsKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainCreateFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSwapchainCreateFlagBitsKHR {
	VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 0x00000001,
	VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 0x00000002,
	VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = 0x00000004,
	VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR = 0x00000040,
	VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR = 0x00000080,
	VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR = 0x00000008,
	VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkSwapchainCreateFlagBitsKHR {
	pub const VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT: VkSwapchainCreateFlagBitsKHR = VkSwapchainCreateFlagBitsKHR::VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR;
}
/// enum `VkDeviceGroupPresentModeFlagBitsKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupPresentModeFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceGroupPresentModeFlagBitsKHR {
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 0x00000001,
	VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 0x00000002,
	VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 0x00000004,
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 0x00000008,
	VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// struct `VkSwapchainCreateInfoKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSwapchainCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkSwapchainCreateFlagsKHR,
	pub surface: VkSurfaceKHR,
	pub minImageCount: u32,
	pub imageFormat: VkFormat,
	pub imageColorSpace: VkColorSpaceKHR,
	pub imageExtent: VkExtent2D,
	pub imageArrayLayers: u32,
	pub imageUsage: VkImageUsageFlags,
	pub imageSharingMode: VkSharingMode,
	pub queueFamilyIndexCount: u32,
	pub pQueueFamilyIndices: *const uint32_t,
	pub preTransform: VkSurfaceTransformFlagBitsKHR,
	pub compositeAlpha: VkCompositeAlphaFlagBitsKHR,
	pub presentMode: VkPresentModeKHR,
	pub clipped: VkBool32,
	pub oldSwapchain: VkSwapchainKHR,
}
impl Debug for VkSwapchainCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSwapchainCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("surface", &self.surface)
		.field("minImageCount", &self.minImageCount)
		.field("imageFormat", &self.imageFormat)
		.field("imageColorSpace", &self.imageColorSpace)
		.field("imageExtent", &self.imageExtent)
		.field("imageArrayLayers", &self.imageArrayLayers)
		.field("imageUsage", &self.imageUsage)
		.field("imageSharingMode", &self.imageSharingMode)
		.field("queueFamilyIndexCount", &self.queueFamilyIndexCount)
		.field("pQueueFamilyIndices", &self.pQueueFamilyIndices)
		.field("preTransform", &self.preTransform)
		.field("compositeAlpha", &self.compositeAlpha)
		.field("presentMode", &self.presentMode)
		.field("clipped", &self.clipped)
		.field("oldSwapchain", &self.oldSwapchain)
		.finish()
	}
}
/// struct `VkPresentInfoKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPresentInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub waitSemaphoreCount: u32,
	pub pWaitSemaphores: *const VkSemaphore,
	pub swapchainCount: u32,
	pub pSwapchains: *const VkSwapchainKHR,
	pub pImageIndices: *const uint32_t,
	pub pResults: *mut VkResult,
}
impl Debug for VkPresentInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPresentInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("waitSemaphoreCount", &self.waitSemaphoreCount)
		.field("pWaitSemaphores", &self.pWaitSemaphores)
		.field("swapchainCount", &self.swapchainCount)
		.field("pSwapchains", &self.pSwapchains)
		.field("pImageIndices", &self.pImageIndices)
		.field("pResults", &self.pResults)
		.finish()
	}
}
/// struct `VkImageSwapchainCreateInfoKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageSwapchainCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageSwapchainCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchain: VkSwapchainKHR,
}
impl Debug for VkImageSwapchainCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageSwapchainCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("swapchain", &self.swapchain)
		.finish()
	}
}
/// struct `VkBindImageMemorySwapchainInfoKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindImageMemorySwapchainInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindImageMemorySwapchainInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchain: VkSwapchainKHR,
	pub imageIndex: u32,
}
impl Debug for VkBindImageMemorySwapchainInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindImageMemorySwapchainInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("swapchain", &self.swapchain)
		.field("imageIndex", &self.imageIndex)
		.finish()
	}
}
/// struct `VkAcquireNextImageInfoKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAcquireNextImageInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAcquireNextImageInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchain: VkSwapchainKHR,
	pub timeout: u64,
	pub semaphore: VkSemaphore,
	pub fence: VkFence,
	pub deviceMask: u32,
}
impl Debug for VkAcquireNextImageInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAcquireNextImageInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("swapchain", &self.swapchain)
		.field("timeout", &self.timeout)
		.field("semaphore", &self.semaphore)
		.field("fence", &self.fence)
		.field("deviceMask", &self.deviceMask)
		.finish()
	}
}
/// struct `VkDeviceGroupPresentCapabilitiesKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupPresentCapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceGroupPresentCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentMask: [u32; VK_MAX_DEVICE_GROUP_SIZE as usize],
	pub modes: VkDeviceGroupPresentModeFlagsKHR,
}
impl Debug for VkDeviceGroupPresentCapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceGroupPresentCapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentMask", &self.presentMask)
		.field("modes", &self.modes)
		.finish()
	}
}
/// struct `VkDeviceGroupPresentInfoKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupPresentInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceGroupPresentInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount: u32,
	pub pDeviceMasks: *const uint32_t,
	pub mode: VkDeviceGroupPresentModeFlagBitsKHR,
}
impl Debug for VkDeviceGroupPresentInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceGroupPresentInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("swapchainCount", &self.swapchainCount)
		.field("pDeviceMasks", &self.pDeviceMasks)
		.field("mode", &self.mode)
		.finish()
	}
}
/// struct `VkDeviceGroupSwapchainCreateInfoKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupSwapchainCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceGroupSwapchainCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub modes: VkDeviceGroupPresentModeFlagsKHR,
}
impl Debug for VkDeviceGroupSwapchainCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceGroupSwapchainCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("modes", &self.modes)
		.finish()
	}
}
/// function prototype `PFN_vkCreateSwapchainKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSwapchainKHR.html>
type PFN_vkCreateSwapchainKHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchain: *mut VkSwapchainKHR) -> VkResult;
/// function prototype `PFN_vkDestroySwapchainKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySwapchainKHR.html>
type PFN_vkDestroySwapchainKHR = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkGetSwapchainImagesKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSwapchainImagesKHR.html>
type PFN_vkGetSwapchainImagesKHR = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pSwapchainImageCount: *mut uint32_t, pSwapchainImages: *mut VkImage) -> VkResult;
/// function prototype `PFN_vkAcquireNextImageKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireNextImageKHR.html>
type PFN_vkAcquireNextImageKHR = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, timeout: u64, semaphore: VkSemaphore, fence: VkFence, pImageIndex: *mut uint32_t) -> VkResult;
/// function prototype `PFN_vkQueuePresentKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueuePresentKHR.html>
type PFN_vkQueuePresentKHR = extern "system" fn(queue: VkQueue, pPresentInfo: *const VkPresentInfoKHR) -> VkResult;
/// function prototype `PFN_vkGetDeviceGroupPresentCapabilitiesKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceGroupPresentCapabilitiesKHR.html>
type PFN_vkGetDeviceGroupPresentCapabilitiesKHR = extern "system" fn(device: VkDevice, pDeviceGroupPresentCapabilities: *mut VkDeviceGroupPresentCapabilitiesKHR) -> VkResult;
/// function prototype `PFN_vkGetDeviceGroupSurfacePresentModesKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceGroupSurfacePresentModesKHR.html>
type PFN_vkGetDeviceGroupSurfacePresentModesKHR = extern "system" fn(device: VkDevice, surface: VkSurfaceKHR, pModes: *mut VkDeviceGroupPresentModeFlagsKHR) -> VkResult;
/// function prototype `PFN_vkGetPhysicalDevicePresentRectanglesKHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDevicePresentRectanglesKHR.html>
type PFN_vkGetPhysicalDevicePresentRectanglesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pRectCount: *mut uint32_t, pRects: *mut VkRect2D) -> VkResult;
/// function prototype `PFN_vkAcquireNextImage2KHR` from VK_KHR_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireNextImage2KHR.html>
type PFN_vkAcquireNextImage2KHR = extern "system" fn(device: VkDevice, pAcquireInfo: *const VkAcquireNextImageInfoKHR, pImageIndex: *mut uint32_t) -> VkResult;
/// The dummy function for `vkCreateSwapchainKHR` from `VK_KHR_swapchain`
extern "system" fn dummy_vkCreateSwapchainKHR(_: VkDevice, _: *const VkSwapchainCreateInfoKHR, _: *const VkAllocationCallbacks, _: *mut VkSwapchainKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateSwapchainKHR"))
}
/// trait for `VK_KHR_swapchain`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_swapchain.html>
pub trait VK_KHR_swapchain: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSwapchainKHR.html>
	fn vkCreateSwapchainKHR(&self, device: VkDevice, pCreateInfo: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchain: *mut VkSwapchainKHR) -> Result<()>;
}
/// struct for `VK_KHR_swapchain`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_swapchain {
	vk_create_swapchain_khr: PFN_vkCreateSwapchainKHR,
}
impl VK_KHR_swapchain for Vulkan_KHR_swapchain {
	fn vkCreateSwapchainKHR(&self, device: VkDevice, pCreateInfo: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchain: *mut VkSwapchainKHR) -> Result<()> {
		convert_result("vkCreateSwapchainKHR", catch_unwind(||((self.vk_create_swapchain_khr)(device, pCreateInfo, pAllocator, pSwapchain))))
	}
}
impl Default for Vulkan_KHR_swapchain {
	fn default() -> Self {
		Self {
			vk_create_swapchain_khr: dummy_vkCreateSwapchainKHR,
		}
	}
}
impl Vulkan_KHR_swapchain {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_swapchain_khr: {let proc = get_instance_proc_address(instance, "vkCreateSwapchainKHR"); if proc == null() {dummy_vkCreateSwapchainKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkDisplayModeCreateFlagsKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayModeCreateFlagsKHR.html>
pub type VkDisplayModeCreateFlagsKHR = VkFlags;
/// type definition `VkDisplayPlaneAlphaFlagsKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayPlaneAlphaFlagsKHR.html>
pub type VkDisplayPlaneAlphaFlagsKHR = VkFlags;
/// type definition `VkDisplaySurfaceCreateFlagsKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplaySurfaceCreateFlagsKHR.html>
pub type VkDisplaySurfaceCreateFlagsKHR = VkFlags;
/// Non-dispatchable handle `VkDisplayKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayKHR.html
#[cfg(target_pointer_width = "32")] pub type VkDisplayKHR = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkDisplayKHR_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkDisplayKHR = *const VkDisplayKHR_T;
/// Non-dispatchable handle `VkDisplayModeKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayModeKHR.html
#[cfg(target_pointer_width = "32")] pub type VkDisplayModeKHR = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkDisplayModeKHR_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkDisplayModeKHR = *const VkDisplayModeKHR_T;
/// enum `VkDisplayPlaneAlphaFlagBitsKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayPlaneAlphaFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDisplayPlaneAlphaFlagBitsKHR {
	VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
	VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002,
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004,
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
	VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// struct `VkDisplayModeParametersKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayModeParametersKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplayModeParametersKHR {
	pub visibleRegion: VkExtent2D,
	pub refreshRate: u32,
}
impl Debug for VkDisplayModeParametersKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayModeParametersKHR")
		.field("visibleRegion", &self.visibleRegion)
		.field("refreshRate", &self.refreshRate)
		.finish()
	}
}
/// struct `VkDisplayModeCreateInfoKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayModeCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplayModeCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDisplayModeCreateFlagsKHR,
	pub parameters: VkDisplayModeParametersKHR,
}
impl Debug for VkDisplayModeCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayModeCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("parameters", &self.parameters)
		.finish()
	}
}
/// struct `VkDisplayModePropertiesKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayModePropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplayModePropertiesKHR {
	pub displayMode: VkDisplayModeKHR,
	pub parameters: VkDisplayModeParametersKHR,
}
impl Debug for VkDisplayModePropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayModePropertiesKHR")
		.field("displayMode", &self.displayMode)
		.field("parameters", &self.parameters)
		.finish()
	}
}
/// struct `VkDisplayPlaneCapabilitiesKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayPlaneCapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplayPlaneCapabilitiesKHR {
	pub supportedAlpha: VkDisplayPlaneAlphaFlagsKHR,
	pub minSrcPosition: VkOffset2D,
	pub maxSrcPosition: VkOffset2D,
	pub minSrcExtent: VkExtent2D,
	pub maxSrcExtent: VkExtent2D,
	pub minDstPosition: VkOffset2D,
	pub maxDstPosition: VkOffset2D,
	pub minDstExtent: VkExtent2D,
	pub maxDstExtent: VkExtent2D,
}
impl Debug for VkDisplayPlaneCapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayPlaneCapabilitiesKHR")
		.field("supportedAlpha", &self.supportedAlpha)
		.field("minSrcPosition", &self.minSrcPosition)
		.field("maxSrcPosition", &self.maxSrcPosition)
		.field("minSrcExtent", &self.minSrcExtent)
		.field("maxSrcExtent", &self.maxSrcExtent)
		.field("minDstPosition", &self.minDstPosition)
		.field("maxDstPosition", &self.maxDstPosition)
		.field("minDstExtent", &self.minDstExtent)
		.field("maxDstExtent", &self.maxDstExtent)
		.finish()
	}
}
/// struct `VkDisplayPlanePropertiesKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayPlanePropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplayPlanePropertiesKHR {
	pub currentDisplay: VkDisplayKHR,
	pub currentStackIndex: u32,
}
impl Debug for VkDisplayPlanePropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayPlanePropertiesKHR")
		.field("currentDisplay", &self.currentDisplay)
		.field("currentStackIndex", &self.currentStackIndex)
		.finish()
	}
}
/// struct `VkDisplayPropertiesKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplayPropertiesKHR {
	pub display: VkDisplayKHR,
	pub displayName: *const i8,
	pub physicalDimensions: VkExtent2D,
	pub physicalResolution: VkExtent2D,
	pub supportedTransforms: VkSurfaceTransformFlagsKHR,
	pub planeReorderPossible: VkBool32,
	pub persistentContent: VkBool32,
}
impl Debug for VkDisplayPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayPropertiesKHR")
		.field("display", &self.display)
		.field("displayName", &self.displayName)
		.field("physicalDimensions", &self.physicalDimensions)
		.field("physicalResolution", &self.physicalResolution)
		.field("supportedTransforms", &self.supportedTransforms)
		.field("planeReorderPossible", &self.planeReorderPossible)
		.field("persistentContent", &self.persistentContent)
		.finish()
	}
}
/// struct `VkDisplaySurfaceCreateInfoKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplaySurfaceCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplaySurfaceCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDisplaySurfaceCreateFlagsKHR,
	pub displayMode: VkDisplayModeKHR,
	pub planeIndex: u32,
	pub planeStackIndex: u32,
	pub transform: VkSurfaceTransformFlagBitsKHR,
	pub globalAlpha: f32,
	pub alphaMode: VkDisplayPlaneAlphaFlagBitsKHR,
	pub imageExtent: VkExtent2D,
}
impl Debug for VkDisplaySurfaceCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplaySurfaceCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("displayMode", &self.displayMode)
		.field("planeIndex", &self.planeIndex)
		.field("planeStackIndex", &self.planeStackIndex)
		.field("transform", &self.transform)
		.field("globalAlpha", &self.globalAlpha)
		.field("alphaMode", &self.alphaMode)
		.field("imageExtent", &self.imageExtent)
		.finish()
	}
}
/// function prototype `PFN_vkGetPhysicalDeviceDisplayPropertiesKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayPropertiesKHR.html>
type PFN_vkGetPhysicalDeviceDisplayPropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayPropertiesKHR) -> VkResult;
/// function prototype `PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayPlanePropertiesKHR.html>
type PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayPlanePropertiesKHR) -> VkResult;
/// function prototype `PFN_vkGetDisplayPlaneSupportedDisplaysKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayPlaneSupportedDisplaysKHR.html>
type PFN_vkGetDisplayPlaneSupportedDisplaysKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, planeIndex: u32, pDisplayCount: *mut uint32_t, pDisplays: *mut VkDisplayKHR) -> VkResult;
/// function prototype `PFN_vkGetDisplayModePropertiesKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayModePropertiesKHR.html>
type PFN_vkGetDisplayModePropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayModePropertiesKHR) -> VkResult;
/// function prototype `PFN_vkCreateDisplayModeKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDisplayModeKHR.html>
type PFN_vkCreateDisplayModeKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pCreateInfo: *const VkDisplayModeCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pMode: *mut VkDisplayModeKHR) -> VkResult;
/// function prototype `PFN_vkGetDisplayPlaneCapabilitiesKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayPlaneCapabilitiesKHR.html>
type PFN_vkGetDisplayPlaneCapabilitiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, mode: VkDisplayModeKHR, planeIndex: u32, pCapabilities: *mut VkDisplayPlaneCapabilitiesKHR) -> VkResult;
/// function prototype `PFN_vkCreateDisplayPlaneSurfaceKHR` from VK_KHR_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDisplayPlaneSurfaceKHR.html>
type PFN_vkCreateDisplayPlaneSurfaceKHR = extern "system" fn(instance: VkInstance, pCreateInfo: *const VkDisplaySurfaceCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR) -> VkResult;
/// The dummy function for `vkGetPhysicalDeviceDisplayPropertiesKHR` from `VK_KHR_display`
extern "system" fn dummy_vkGetPhysicalDeviceDisplayPropertiesKHR(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkDisplayPropertiesKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceDisplayPropertiesKHR"))
}
/// trait for `VK_KHR_display`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_display.html>
pub trait VK_KHR_display: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayPropertiesKHR.html>
	fn vkGetPhysicalDeviceDisplayPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayPropertiesKHR) -> Result<()>;
}
/// struct for `VK_KHR_display`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_display {
	vk_get_physical_device_display_properties_khr: PFN_vkGetPhysicalDeviceDisplayPropertiesKHR,
}
impl VK_KHR_display for Vulkan_KHR_display {
	fn vkGetPhysicalDeviceDisplayPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayPropertiesKHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceDisplayPropertiesKHR", catch_unwind(||((self.vk_get_physical_device_display_properties_khr)(physicalDevice, pPropertyCount, pProperties))))
	}
}
impl Default for Vulkan_KHR_display {
	fn default() -> Self {
		Self {
			vk_get_physical_device_display_properties_khr: dummy_vkGetPhysicalDeviceDisplayPropertiesKHR,
		}
	}
}
impl Vulkan_KHR_display {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_display_properties_khr: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceDisplayPropertiesKHR"); if proc == null() {dummy_vkGetPhysicalDeviceDisplayPropertiesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkDisplayPresentInfoKHR` from VK_KHR_display_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayPresentInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplayPresentInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcRect: VkRect2D,
	pub dstRect: VkRect2D,
	pub persistent: VkBool32,
}
impl Debug for VkDisplayPresentInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayPresentInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcRect", &self.srcRect)
		.field("dstRect", &self.dstRect)
		.field("persistent", &self.persistent)
		.finish()
	}
}
/// function prototype `PFN_vkCreateSharedSwapchainsKHR` from VK_KHR_display_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSharedSwapchainsKHR.html>
type PFN_vkCreateSharedSwapchainsKHR = extern "system" fn(device: VkDevice, swapchainCount: u32, pCreateInfos: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchains: *mut VkSwapchainKHR) -> VkResult;
/// The dummy function for `vkCreateSharedSwapchainsKHR` from `VK_KHR_display_swapchain`
extern "system" fn dummy_vkCreateSharedSwapchainsKHR(_: VkDevice, _: u32, _: *const VkSwapchainCreateInfoKHR, _: *const VkAllocationCallbacks, _: *mut VkSwapchainKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateSharedSwapchainsKHR"))
}
/// trait for `VK_KHR_display_swapchain`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_display_swapchain.html>
pub trait VK_KHR_display_swapchain: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSharedSwapchainsKHR.html>
	fn vkCreateSharedSwapchainsKHR(&self, device: VkDevice, swapchainCount: u32, pCreateInfos: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchains: *mut VkSwapchainKHR) -> Result<()>;
}
/// struct for `VK_KHR_display_swapchain`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_display_swapchain {
	vk_create_shared_swapchains_khr: PFN_vkCreateSharedSwapchainsKHR,
}
impl VK_KHR_display_swapchain for Vulkan_KHR_display_swapchain {
	fn vkCreateSharedSwapchainsKHR(&self, device: VkDevice, swapchainCount: u32, pCreateInfos: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchains: *mut VkSwapchainKHR) -> Result<()> {
		convert_result("vkCreateSharedSwapchainsKHR", catch_unwind(||((self.vk_create_shared_swapchains_khr)(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains))))
	}
}
impl Default for Vulkan_KHR_display_swapchain {
	fn default() -> Self {
		Self {
			vk_create_shared_swapchains_khr: dummy_vkCreateSharedSwapchainsKHR,
		}
	}
}
impl Vulkan_KHR_display_swapchain {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_shared_swapchains_khr: {let proc = get_instance_proc_address(instance, "vkCreateSharedSwapchainsKHR"); if proc == null() {dummy_vkCreateSharedSwapchainsKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// trait for `VK_KHR_sampler_mirror_clamp_to_edge`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_sampler_mirror_clamp_to_edge.html>
pub trait VK_KHR_sampler_mirror_clamp_to_edge: Debug {}
/// struct for `VK_KHR_sampler_mirror_clamp_to_edge`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_sampler_mirror_clamp_to_edge {}
impl VK_KHR_sampler_mirror_clamp_to_edge for Vulkan_KHR_sampler_mirror_clamp_to_edge {}
impl Default for Vulkan_KHR_sampler_mirror_clamp_to_edge {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_sampler_mirror_clamp_to_edge {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkVideoCodecOperationFlagsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoCodecOperationFlagsKHR.html>
pub type VkVideoCodecOperationFlagsKHR = VkFlags;
/// type definition `VkVideoChromaSubsamplingFlagsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoChromaSubsamplingFlagsKHR.html>
pub type VkVideoChromaSubsamplingFlagsKHR = VkFlags;
/// type definition `VkVideoComponentBitDepthFlagsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoComponentBitDepthFlagsKHR.html>
pub type VkVideoComponentBitDepthFlagsKHR = VkFlags;
/// type definition `VkVideoCapabilityFlagsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoCapabilityFlagsKHR.html>
pub type VkVideoCapabilityFlagsKHR = VkFlags;
/// type definition `VkVideoSessionCreateFlagsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoSessionCreateFlagsKHR.html>
pub type VkVideoSessionCreateFlagsKHR = VkFlags;
/// type definition `VkVideoSessionParametersCreateFlagsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoSessionParametersCreateFlagsKHR.html>
pub type VkVideoSessionParametersCreateFlagsKHR = VkFlags;
/// type definition `VkVideoBeginCodingFlagsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoBeginCodingFlagsKHR.html>
pub type VkVideoBeginCodingFlagsKHR = VkFlags;
/// type definition `VkVideoEndCodingFlagsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEndCodingFlagsKHR.html>
pub type VkVideoEndCodingFlagsKHR = VkFlags;
/// type definition `VkVideoCodingControlFlagsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoCodingControlFlagsKHR.html>
pub type VkVideoCodingControlFlagsKHR = VkFlags;
/// Non-dispatchable handle `VkVideoSessionKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoSessionKHR.html
#[cfg(target_pointer_width = "32")] pub type VkVideoSessionKHR = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkVideoSessionKHR_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkVideoSessionKHR = *const VkVideoSessionKHR_T;
/// Non-dispatchable handle `VkVideoSessionParametersKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoSessionParametersKHR.html
#[cfg(target_pointer_width = "32")] pub type VkVideoSessionParametersKHR = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkVideoSessionParametersKHR_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkVideoSessionParametersKHR = *const VkVideoSessionParametersKHR_T;
/// enum `VkQueryResultStatusKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryResultStatusKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueryResultStatusKHR {
	VK_QUERY_RESULT_STATUS_ERROR_KHR = -1,
	VK_QUERY_RESULT_STATUS_NOT_READY_KHR = 0,
	VK_QUERY_RESULT_STATUS_COMPLETE_KHR = 1,
	VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR = -1000299000,
	VK_QUERY_RESULT_STATUS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoCodecOperationFlagBitsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoCodecOperationFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoCodecOperationFlagBitsKHR {
	VK_VIDEO_CODEC_OPERATION_NONE_KHR = 0,
	VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR = 0x00010000,
	VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR = 0x00020000,
	VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR = 0x00000001,
	VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR = 0x00000002,
	VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR = 0x00000004,
	VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR = 0x00040000,
	VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR = 0x00000008,
	VK_VIDEO_CODEC_OPERATION_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoChromaSubsamplingFlagBitsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoChromaSubsamplingFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoChromaSubsamplingFlagBitsKHR {
	VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR = 0,
	VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR = 0x00000001,
	VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR = 0x00000002,
	VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR = 0x00000004,
	VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR = 0x00000008,
	VK_VIDEO_CHROMA_SUBSAMPLING_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoComponentBitDepthFlagBitsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoComponentBitDepthFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoComponentBitDepthFlagBitsKHR {
	VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR = 0,
	VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR = 0x00000001,
	VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR = 0x00000004,
	VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR = 0x00000010,
	VK_VIDEO_COMPONENT_BIT_DEPTH_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoCapabilityFlagBitsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoCapabilityFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoCapabilityFlagBitsKHR {
	VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR = 0x00000001,
	VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR = 0x00000002,
	VK_VIDEO_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoSessionCreateFlagBitsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoSessionCreateFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoSessionCreateFlagBitsKHR {
	VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR = 0x00000001,
	VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR = 0x00000002,
	VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR = 0x00000004,
	VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x00000008,
	VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR = 0x00000010,
	VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR = 0x00000020,
	VK_VIDEO_SESSION_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoSessionParametersCreateFlagBitsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoSessionParametersCreateFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoSessionParametersCreateFlagBitsKHR {
	VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR = 0x00000001,
	VK_VIDEO_SESSION_PARAMETERS_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoCodingControlFlagBitsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoCodingControlFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoCodingControlFlagBitsKHR {
	VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR = 0x00000001,
	VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR = 0x00000002,
	VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR = 0x00000004,
	VK_VIDEO_CODING_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// struct `VkQueueFamilyQueryResultStatusPropertiesKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueFamilyQueryResultStatusPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkQueueFamilyQueryResultStatusPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub queryResultStatusSupport: VkBool32,
}
impl Debug for VkQueueFamilyQueryResultStatusPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkQueueFamilyQueryResultStatusPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("queryResultStatusSupport", &self.queryResultStatusSupport)
		.finish()
	}
}
/// struct `VkQueueFamilyVideoPropertiesKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueFamilyVideoPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkQueueFamilyVideoPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub videoCodecOperations: VkVideoCodecOperationFlagsKHR,
}
impl Debug for VkQueueFamilyVideoPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkQueueFamilyVideoPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("videoCodecOperations", &self.videoCodecOperations)
		.finish()
	}
}
/// struct `VkVideoProfileInfoKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoProfileInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoProfileInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub videoCodecOperation: VkVideoCodecOperationFlagBitsKHR,
	pub chromaSubsampling: VkVideoChromaSubsamplingFlagsKHR,
	pub lumaBitDepth: VkVideoComponentBitDepthFlagsKHR,
	pub chromaBitDepth: VkVideoComponentBitDepthFlagsKHR,
}
impl Debug for VkVideoProfileInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoProfileInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("videoCodecOperation", &self.videoCodecOperation)
		.field("chromaSubsampling", &self.chromaSubsampling)
		.field("lumaBitDepth", &self.lumaBitDepth)
		.field("chromaBitDepth", &self.chromaBitDepth)
		.finish()
	}
}
/// struct `VkVideoProfileListInfoKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoProfileListInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoProfileListInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub profileCount: u32,
	pub pProfiles: *const VkVideoProfileInfoKHR,
}
impl Debug for VkVideoProfileListInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoProfileListInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("profileCount", &self.profileCount)
		.field("pProfiles", &self.pProfiles)
		.finish()
	}
}
/// struct `VkVideoCapabilitiesKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoCapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkVideoCapabilityFlagsKHR,
	pub minBitstreamBufferOffsetAlignment: VkDeviceSize,
	pub minBitstreamBufferSizeAlignment: VkDeviceSize,
	pub pictureAccessGranularity: VkExtent2D,
	pub minCodedExtent: VkExtent2D,
	pub maxCodedExtent: VkExtent2D,
	pub maxDpbSlots: u32,
	pub maxActiveReferencePictures: u32,
	pub stdHeaderVersion: VkExtensionProperties,
}
impl Debug for VkVideoCapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoCapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("minBitstreamBufferOffsetAlignment", &self.minBitstreamBufferOffsetAlignment)
		.field("minBitstreamBufferSizeAlignment", &self.minBitstreamBufferSizeAlignment)
		.field("pictureAccessGranularity", &self.pictureAccessGranularity)
		.field("minCodedExtent", &self.minCodedExtent)
		.field("maxCodedExtent", &self.maxCodedExtent)
		.field("maxDpbSlots", &self.maxDpbSlots)
		.field("maxActiveReferencePictures", &self.maxActiveReferencePictures)
		.field("stdHeaderVersion", &self.stdHeaderVersion)
		.finish()
	}
}
/// struct `VkPhysicalDeviceVideoFormatInfoKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVideoFormatInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVideoFormatInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub imageUsage: VkImageUsageFlags,
}
impl Debug for VkPhysicalDeviceVideoFormatInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVideoFormatInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("imageUsage", &self.imageUsage)
		.finish()
	}
}
/// struct `VkVideoFormatPropertiesKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoFormatPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoFormatPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub format: VkFormat,
	pub componentMapping: VkComponentMapping,
	pub imageCreateFlags: VkImageCreateFlags,
	pub imageType: VkImageType,
	pub imageTiling: VkImageTiling,
	pub imageUsageFlags: VkImageUsageFlags,
}
impl Debug for VkVideoFormatPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoFormatPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("format", &self.format)
		.field("componentMapping", &self.componentMapping)
		.field("imageCreateFlags", &self.imageCreateFlags)
		.field("imageType", &self.imageType)
		.field("imageTiling", &self.imageTiling)
		.field("imageUsageFlags", &self.imageUsageFlags)
		.finish()
	}
}
/// struct `VkVideoPictureResourceInfoKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoPictureResourceInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoPictureResourceInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub codedOffset: VkOffset2D,
	pub codedExtent: VkExtent2D,
	pub baseArrayLayer: u32,
	pub imageViewBinding: VkImageView,
}
impl Debug for VkVideoPictureResourceInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoPictureResourceInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("codedOffset", &self.codedOffset)
		.field("codedExtent", &self.codedExtent)
		.field("baseArrayLayer", &self.baseArrayLayer)
		.field("imageViewBinding", &self.imageViewBinding)
		.finish()
	}
}
/// struct `VkVideoReferenceSlotInfoKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoReferenceSlotInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoReferenceSlotInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub slotIndex: i32,
	pub pPictureResource: *const VkVideoPictureResourceInfoKHR,
}
impl Debug for VkVideoReferenceSlotInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoReferenceSlotInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("slotIndex", &self.slotIndex)
		.field("pPictureResource", &self.pPictureResource)
		.finish()
	}
}
/// struct `VkVideoSessionMemoryRequirementsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoSessionMemoryRequirementsKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoSessionMemoryRequirementsKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryBindIndex: u32,
	pub memoryRequirements: VkMemoryRequirements,
}
impl Debug for VkVideoSessionMemoryRequirementsKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoSessionMemoryRequirementsKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("memoryBindIndex", &self.memoryBindIndex)
		.field("memoryRequirements", &self.memoryRequirements)
		.finish()
	}
}
/// struct `VkBindVideoSessionMemoryInfoKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindVideoSessionMemoryInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindVideoSessionMemoryInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub memoryBindIndex: u32,
	pub memory: VkDeviceMemory,
	pub memoryOffset: VkDeviceSize,
	pub memorySize: VkDeviceSize,
}
impl Debug for VkBindVideoSessionMemoryInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindVideoSessionMemoryInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("memoryBindIndex", &self.memoryBindIndex)
		.field("memory", &self.memory)
		.field("memoryOffset", &self.memoryOffset)
		.field("memorySize", &self.memorySize)
		.finish()
	}
}
/// struct `VkVideoSessionCreateInfoKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoSessionCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoSessionCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub queueFamilyIndex: u32,
	pub flags: VkVideoSessionCreateFlagsKHR,
	pub pVideoProfile: *const VkVideoProfileInfoKHR,
	pub pictureFormat: VkFormat,
	pub maxCodedExtent: VkExtent2D,
	pub referencePictureFormat: VkFormat,
	pub maxDpbSlots: u32,
	pub maxActiveReferencePictures: u32,
	pub pStdHeaderVersion: *const VkExtensionProperties,
}
impl Debug for VkVideoSessionCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoSessionCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("queueFamilyIndex", &self.queueFamilyIndex)
		.field("flags", &self.flags)
		.field("pVideoProfile", &self.pVideoProfile)
		.field("pictureFormat", &self.pictureFormat)
		.field("maxCodedExtent", &self.maxCodedExtent)
		.field("referencePictureFormat", &self.referencePictureFormat)
		.field("maxDpbSlots", &self.maxDpbSlots)
		.field("maxActiveReferencePictures", &self.maxActiveReferencePictures)
		.field("pStdHeaderVersion", &self.pStdHeaderVersion)
		.finish()
	}
}
/// struct `VkVideoSessionParametersCreateInfoKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoSessionParametersCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoSessionParametersCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoSessionParametersCreateFlagsKHR,
	pub videoSessionParametersTemplate: VkVideoSessionParametersKHR,
	pub videoSession: VkVideoSessionKHR,
}
impl Debug for VkVideoSessionParametersCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoSessionParametersCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("videoSessionParametersTemplate", &self.videoSessionParametersTemplate)
		.field("videoSession", &self.videoSession)
		.finish()
	}
}
/// struct `VkVideoSessionParametersUpdateInfoKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoSessionParametersUpdateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoSessionParametersUpdateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub updateSequenceCount: u32,
}
impl Debug for VkVideoSessionParametersUpdateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoSessionParametersUpdateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("updateSequenceCount", &self.updateSequenceCount)
		.finish()
	}
}
/// struct `VkVideoBeginCodingInfoKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoBeginCodingInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoBeginCodingInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoBeginCodingFlagsKHR,
	pub videoSession: VkVideoSessionKHR,
	pub videoSessionParameters: VkVideoSessionParametersKHR,
	pub referenceSlotCount: u32,
	pub pReferenceSlots: *const VkVideoReferenceSlotInfoKHR,
}
impl Debug for VkVideoBeginCodingInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoBeginCodingInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("videoSession", &self.videoSession)
		.field("videoSessionParameters", &self.videoSessionParameters)
		.field("referenceSlotCount", &self.referenceSlotCount)
		.field("pReferenceSlots", &self.pReferenceSlots)
		.finish()
	}
}
/// struct `VkVideoEndCodingInfoKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEndCodingInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEndCodingInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoEndCodingFlagsKHR,
}
impl Debug for VkVideoEndCodingInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEndCodingInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.finish()
	}
}
/// struct `VkVideoCodingControlInfoKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoCodingControlInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoCodingControlInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoCodingControlFlagsKHR,
}
impl Debug for VkVideoCodingControlInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoCodingControlInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.finish()
	}
}
/// function prototype `PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceVideoCapabilitiesKHR.html>
type PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pVideoProfile: *const VkVideoProfileInfoKHR, pCapabilities: *mut VkVideoCapabilitiesKHR) -> VkResult;
/// function prototype `PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceVideoFormatPropertiesKHR.html>
type PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pVideoFormatInfo: *const VkPhysicalDeviceVideoFormatInfoKHR, pVideoFormatPropertyCount: *mut uint32_t, pVideoFormatProperties: *mut VkVideoFormatPropertiesKHR) -> VkResult;
/// function prototype `PFN_vkCreateVideoSessionKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateVideoSessionKHR.html>
type PFN_vkCreateVideoSessionKHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkVideoSessionCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pVideoSession: *mut VkVideoSessionKHR) -> VkResult;
/// function prototype `PFN_vkDestroyVideoSessionKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyVideoSessionKHR.html>
type PFN_vkDestroyVideoSessionKHR = extern "system" fn(device: VkDevice, videoSession: VkVideoSessionKHR, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkGetVideoSessionMemoryRequirementsKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetVideoSessionMemoryRequirementsKHR.html>
type PFN_vkGetVideoSessionMemoryRequirementsKHR = extern "system" fn(device: VkDevice, videoSession: VkVideoSessionKHR, pMemoryRequirementsCount: *mut uint32_t, pMemoryRequirements: *mut VkVideoSessionMemoryRequirementsKHR) -> VkResult;
/// function prototype `PFN_vkBindVideoSessionMemoryKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindVideoSessionMemoryKHR.html>
type PFN_vkBindVideoSessionMemoryKHR = extern "system" fn(device: VkDevice, videoSession: VkVideoSessionKHR, bindSessionMemoryInfoCount: u32, pBindSessionMemoryInfos: *const VkBindVideoSessionMemoryInfoKHR) -> VkResult;
/// function prototype `PFN_vkCreateVideoSessionParametersKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateVideoSessionParametersKHR.html>
type PFN_vkCreateVideoSessionParametersKHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkVideoSessionParametersCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pVideoSessionParameters: *mut VkVideoSessionParametersKHR) -> VkResult;
/// function prototype `PFN_vkUpdateVideoSessionParametersKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateVideoSessionParametersKHR.html>
type PFN_vkUpdateVideoSessionParametersKHR = extern "system" fn(device: VkDevice, videoSessionParameters: VkVideoSessionParametersKHR, pUpdateInfo: *const VkVideoSessionParametersUpdateInfoKHR) -> VkResult;
/// function prototype `PFN_vkDestroyVideoSessionParametersKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyVideoSessionParametersKHR.html>
type PFN_vkDestroyVideoSessionParametersKHR = extern "system" fn(device: VkDevice, videoSessionParameters: VkVideoSessionParametersKHR, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCmdBeginVideoCodingKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginVideoCodingKHR.html>
type PFN_vkCmdBeginVideoCodingKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pBeginInfo: *const VkVideoBeginCodingInfoKHR);
/// function prototype `PFN_vkCmdEndVideoCodingKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndVideoCodingKHR.html>
type PFN_vkCmdEndVideoCodingKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pEndCodingInfo: *const VkVideoEndCodingInfoKHR);
/// function prototype `PFN_vkCmdControlVideoCodingKHR` from VK_KHR_video_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdControlVideoCodingKHR.html>
type PFN_vkCmdControlVideoCodingKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pCodingControlInfo: *const VkVideoCodingControlInfoKHR);
/// The dummy function for `vkGetPhysicalDeviceVideoCapabilitiesKHR` from `VK_KHR_video_queue`
extern "system" fn dummy_vkGetPhysicalDeviceVideoCapabilitiesKHR(_: VkPhysicalDevice, _: *const VkVideoProfileInfoKHR, _: *mut VkVideoCapabilitiesKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceVideoCapabilitiesKHR"))
}
/// trait for `VK_KHR_video_queue`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_video_queue.html>
pub trait VK_KHR_video_queue: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceVideoCapabilitiesKHR.html>
	fn vkGetPhysicalDeviceVideoCapabilitiesKHR(&self, physicalDevice: VkPhysicalDevice, pVideoProfile: *const VkVideoProfileInfoKHR, pCapabilities: *mut VkVideoCapabilitiesKHR) -> Result<()>;
}
/// struct for `VK_KHR_video_queue`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_queue {
	vk_get_physical_device_video_capabilities_khr: PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR,
}
impl VK_KHR_video_queue for Vulkan_KHR_video_queue {
	fn vkGetPhysicalDeviceVideoCapabilitiesKHR(&self, physicalDevice: VkPhysicalDevice, pVideoProfile: *const VkVideoProfileInfoKHR, pCapabilities: *mut VkVideoCapabilitiesKHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceVideoCapabilitiesKHR", catch_unwind(||((self.vk_get_physical_device_video_capabilities_khr)(physicalDevice, pVideoProfile, pCapabilities))))
	}
}
impl Default for Vulkan_KHR_video_queue {
	fn default() -> Self {
		Self {
			vk_get_physical_device_video_capabilities_khr: dummy_vkGetPhysicalDeviceVideoCapabilitiesKHR,
		}
	}
}
impl Vulkan_KHR_video_queue {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_video_capabilities_khr: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceVideoCapabilitiesKHR"); if proc == null() {dummy_vkGetPhysicalDeviceVideoCapabilitiesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkVideoDecodeCapabilityFlagsKHR` from VK_KHR_video_decode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeCapabilityFlagsKHR.html>
pub type VkVideoDecodeCapabilityFlagsKHR = VkFlags;
/// type definition `VkVideoDecodeUsageFlagsKHR` from VK_KHR_video_decode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeUsageFlagsKHR.html>
pub type VkVideoDecodeUsageFlagsKHR = VkFlags;
/// type definition `VkVideoDecodeFlagsKHR` from VK_KHR_video_decode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeFlagsKHR.html>
pub type VkVideoDecodeFlagsKHR = VkFlags;
/// enum `VkVideoDecodeCapabilityFlagBitsKHR` from VK_KHR_video_decode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeCapabilityFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoDecodeCapabilityFlagBitsKHR {
	VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR = 0x00000001,
	VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR = 0x00000002,
	VK_VIDEO_DECODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoDecodeUsageFlagBitsKHR` from VK_KHR_video_decode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeUsageFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoDecodeUsageFlagBitsKHR {
	VK_VIDEO_DECODE_USAGE_DEFAULT_KHR = 0,
	VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR = 0x00000001,
	VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR = 0x00000002,
	VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR = 0x00000004,
	VK_VIDEO_DECODE_USAGE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// struct `VkVideoDecodeCapabilitiesKHR` from VK_KHR_video_decode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeCapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkVideoDecodeCapabilityFlagsKHR,
}
impl Debug for VkVideoDecodeCapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeCapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.finish()
	}
}
/// struct `VkVideoDecodeUsageInfoKHR` from VK_KHR_video_decode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeUsageInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeUsageInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub videoUsageHints: VkVideoDecodeUsageFlagsKHR,
}
impl Debug for VkVideoDecodeUsageInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeUsageInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("videoUsageHints", &self.videoUsageHints)
		.finish()
	}
}
/// struct `VkVideoDecodeInfoKHR` from VK_KHR_video_decode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoDecodeFlagsKHR,
	pub srcBuffer: VkBuffer,
	pub srcBufferOffset: VkDeviceSize,
	pub srcBufferRange: VkDeviceSize,
	pub dstPictureResource: VkVideoPictureResourceInfoKHR,
	pub pSetupReferenceSlot: *const VkVideoReferenceSlotInfoKHR,
	pub referenceSlotCount: u32,
	pub pReferenceSlots: *const VkVideoReferenceSlotInfoKHR,
}
impl Debug for VkVideoDecodeInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("srcBuffer", &self.srcBuffer)
		.field("srcBufferOffset", &self.srcBufferOffset)
		.field("srcBufferRange", &self.srcBufferRange)
		.field("dstPictureResource", &self.dstPictureResource)
		.field("pSetupReferenceSlot", &self.pSetupReferenceSlot)
		.field("referenceSlotCount", &self.referenceSlotCount)
		.field("pReferenceSlots", &self.pReferenceSlots)
		.finish()
	}
}
/// function prototype `PFN_vkCmdDecodeVideoKHR` from VK_KHR_video_decode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDecodeVideoKHR.html>
type PFN_vkCmdDecodeVideoKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pDecodeInfo: *const VkVideoDecodeInfoKHR);
/// The dummy function for `vkCmdDecodeVideoKHR` from `VK_KHR_video_decode_queue`
extern "system" fn dummy_vkCmdDecodeVideoKHR(_: VkCommandBuffer, _: *const VkVideoDecodeInfoKHR) {
	panic_any(VkError::NullFunctionPointer("vkCmdDecodeVideoKHR"))
}
/// trait for `VK_KHR_video_decode_queue`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_video_decode_queue.html>
pub trait VK_KHR_video_decode_queue: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDecodeVideoKHR.html>
	fn vkCmdDecodeVideoKHR(&self, commandBuffer: VkCommandBuffer, pDecodeInfo: *const VkVideoDecodeInfoKHR) -> Result<()>;
}
/// struct for `VK_KHR_video_decode_queue`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_decode_queue {
	vk_cmd_decode_video_khr: PFN_vkCmdDecodeVideoKHR,
}
impl VK_KHR_video_decode_queue for Vulkan_KHR_video_decode_queue {
	fn vkCmdDecodeVideoKHR(&self, commandBuffer: VkCommandBuffer, pDecodeInfo: *const VkVideoDecodeInfoKHR) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_decode_video_khr)(commandBuffer, pDecodeInfo))))
	}
}
impl Default for Vulkan_KHR_video_decode_queue {
	fn default() -> Self {
		Self {
			vk_cmd_decode_video_khr: dummy_vkCmdDecodeVideoKHR,
		}
	}
}
impl Vulkan_KHR_video_decode_queue {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_decode_video_khr: {let proc = get_instance_proc_address(instance, "vkCmdDecodeVideoKHR"); if proc == null() {dummy_vkCmdDecodeVideoKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkVideoEncodeH264CapabilityFlagsKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264CapabilityFlagsKHR.html>
pub type VkVideoEncodeH264CapabilityFlagsKHR = VkFlags;
/// type definition `VkVideoEncodeH264StdFlagsKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264StdFlagsKHR.html>
pub type VkVideoEncodeH264StdFlagsKHR = VkFlags;
/// type definition `VkVideoEncodeH264RateControlFlagsKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264RateControlFlagsKHR.html>
pub type VkVideoEncodeH264RateControlFlagsKHR = VkFlags;
/// enum `VkVideoEncodeH264CapabilityFlagBitsKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264CapabilityFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeH264CapabilityFlagBitsKHR {
	VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR = 0x00000040,
	VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR = 0x00000080,
	VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR = 0x00000100,
	VK_VIDEO_ENCODE_H264_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR = 0x00000400,
	VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR = 0x00000200,
	VK_VIDEO_ENCODE_H264_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeH264StdFlagBitsKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264StdFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeH264StdFlagBitsKHR {
	VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR = 0x00000040,
	VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR = 0x00000080,
	VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR = 0x00000100,
	VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR = 0x00000200,
	VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR = 0x00000400,
	VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR = 0x00000800,
	VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR = 0x00001000,
	VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR = 0x00002000,
	VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR = 0x00004000,
	VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR = 0x00008000,
	VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR = 0x00010000,
	VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR = 0x00020000,
	VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR = 0x00080000,
	VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR = 0x00100000,
	VK_VIDEO_ENCODE_H264_STD_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeH264RateControlFlagBitsKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264RateControlFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeH264RateControlFlagBitsKHR {
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H264_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// struct `VkVideoEncodeH264CapabilitiesKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264CapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264CapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkVideoEncodeH264CapabilityFlagsKHR,
	pub maxLevelIdc: StdVideoH264LevelIdc,
	pub maxSliceCount: u32,
	pub maxPPictureL0ReferenceCount: u32,
	pub maxBPictureL0ReferenceCount: u32,
	pub maxL1ReferenceCount: u32,
	pub maxTemporalLayerCount: u32,
	pub expectDyadicTemporalLayerPattern: VkBool32,
	pub minQp: i32,
	pub maxQp: i32,
	pub prefersGopRemainingFrames: VkBool32,
	pub requiresGopRemainingFrames: VkBool32,
	pub stdSyntaxFlags: VkVideoEncodeH264StdFlagsKHR,
}
impl Debug for VkVideoEncodeH264CapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264CapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("maxLevelIdc", &self.maxLevelIdc)
		.field("maxSliceCount", &self.maxSliceCount)
		.field("maxPPictureL0ReferenceCount", &self.maxPPictureL0ReferenceCount)
		.field("maxBPictureL0ReferenceCount", &self.maxBPictureL0ReferenceCount)
		.field("maxL1ReferenceCount", &self.maxL1ReferenceCount)
		.field("maxTemporalLayerCount", &self.maxTemporalLayerCount)
		.field("expectDyadicTemporalLayerPattern", &self.expectDyadicTemporalLayerPattern)
		.field("minQp", &self.minQp)
		.field("maxQp", &self.maxQp)
		.field("prefersGopRemainingFrames", &self.prefersGopRemainingFrames)
		.field("requiresGopRemainingFrames", &self.requiresGopRemainingFrames)
		.field("stdSyntaxFlags", &self.stdSyntaxFlags)
		.finish()
	}
}
/// struct `VkVideoEncodeH264QpKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264QpKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264QpKHR {
	pub qpI: i32,
	pub qpP: i32,
	pub qpB: i32,
}
impl Debug for VkVideoEncodeH264QpKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264QpKHR")
		.field("qpI", &self.qpI)
		.field("qpP", &self.qpP)
		.field("qpB", &self.qpB)
		.finish()
	}
}
/// struct `VkVideoEncodeH264QualityLevelPropertiesKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264QualityLevelPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264QualityLevelPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub preferredRateControlFlags: VkVideoEncodeH264RateControlFlagsKHR,
	pub preferredGopFrameCount: u32,
	pub preferredIdrPeriod: u32,
	pub preferredConsecutiveBFrameCount: u32,
	pub preferredTemporalLayerCount: u32,
	pub preferredConstantQp: VkVideoEncodeH264QpKHR,
	pub preferredMaxL0ReferenceCount: u32,
	pub preferredMaxL1ReferenceCount: u32,
	pub preferredStdEntropyCodingModeFlag: VkBool32,
}
impl Debug for VkVideoEncodeH264QualityLevelPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264QualityLevelPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("preferredRateControlFlags", &self.preferredRateControlFlags)
		.field("preferredGopFrameCount", &self.preferredGopFrameCount)
		.field("preferredIdrPeriod", &self.preferredIdrPeriod)
		.field("preferredConsecutiveBFrameCount", &self.preferredConsecutiveBFrameCount)
		.field("preferredTemporalLayerCount", &self.preferredTemporalLayerCount)
		.field("preferredConstantQp", &self.preferredConstantQp)
		.field("preferredMaxL0ReferenceCount", &self.preferredMaxL0ReferenceCount)
		.field("preferredMaxL1ReferenceCount", &self.preferredMaxL1ReferenceCount)
		.field("preferredStdEntropyCodingModeFlag", &self.preferredStdEntropyCodingModeFlag)
		.finish()
	}
}
/// struct `VkVideoEncodeH264SessionCreateInfoKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264SessionCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264SessionCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useMaxLevelIdc: VkBool32,
	pub maxLevelIdc: StdVideoH264LevelIdc,
}
impl Debug for VkVideoEncodeH264SessionCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264SessionCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("useMaxLevelIdc", &self.useMaxLevelIdc)
		.field("maxLevelIdc", &self.maxLevelIdc)
		.finish()
	}
}
/// struct `VkVideoEncodeH264SessionParametersAddInfoKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264SessionParametersAddInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264SessionParametersAddInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdSPSCount: u32,
	pub pStdSPSs: *const StdVideoH264SequenceParameterSet,
	pub stdPPSCount: u32,
	pub pStdPPSs: *const StdVideoH264PictureParameterSet,
}
impl Debug for VkVideoEncodeH264SessionParametersAddInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264SessionParametersAddInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stdSPSCount", &self.stdSPSCount)
		.field("pStdSPSs", &self.pStdSPSs)
		.field("stdPPSCount", &self.stdPPSCount)
		.field("pStdPPSs", &self.pStdPPSs)
		.finish()
	}
}
/// struct `VkVideoEncodeH264SessionParametersCreateInfoKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264SessionParametersCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264SessionParametersCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maxStdSPSCount: u32,
	pub maxStdPPSCount: u32,
	pub pParametersAddInfo: *const VkVideoEncodeH264SessionParametersAddInfoKHR,
}
impl Debug for VkVideoEncodeH264SessionParametersCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264SessionParametersCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxStdSPSCount", &self.maxStdSPSCount)
		.field("maxStdPPSCount", &self.maxStdPPSCount)
		.field("pParametersAddInfo", &self.pParametersAddInfo)
		.finish()
	}
}
/// struct `VkVideoEncodeH264SessionParametersGetInfoKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264SessionParametersGetInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264SessionParametersGetInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub writeStdSPS: VkBool32,
	pub writeStdPPS: VkBool32,
	pub stdSPSId: u32,
	pub stdPPSId: u32,
}
impl Debug for VkVideoEncodeH264SessionParametersGetInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264SessionParametersGetInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("writeStdSPS", &self.writeStdSPS)
		.field("writeStdPPS", &self.writeStdPPS)
		.field("stdSPSId", &self.stdSPSId)
		.field("stdPPSId", &self.stdPPSId)
		.finish()
	}
}
/// struct `VkVideoEncodeH264SessionParametersFeedbackInfoKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264SessionParametersFeedbackInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264SessionParametersFeedbackInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub hasStdSPSOverrides: VkBool32,
	pub hasStdPPSOverrides: VkBool32,
}
impl Debug for VkVideoEncodeH264SessionParametersFeedbackInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264SessionParametersFeedbackInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("hasStdSPSOverrides", &self.hasStdSPSOverrides)
		.field("hasStdPPSOverrides", &self.hasStdPPSOverrides)
		.finish()
	}
}
/// struct `VkVideoEncodeH264NaluSliceInfoKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264NaluSliceInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264NaluSliceInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub constantQp: i32,
	pub pStdSliceHeader: *const StdVideoEncodeH264SliceHeader,
}
impl Debug for VkVideoEncodeH264NaluSliceInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264NaluSliceInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("constantQp", &self.constantQp)
		.field("pStdSliceHeader", &self.pStdSliceHeader)
		.finish()
	}
}
/// struct `VkVideoEncodeH264PictureInfoKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264PictureInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264PictureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub naluSliceEntryCount: u32,
	pub pNaluSliceEntries: *const VkVideoEncodeH264NaluSliceInfoKHR,
	pub pStdPictureInfo: *const StdVideoEncodeH264PictureInfo,
	pub generatePrefixNalu: VkBool32,
}
impl Debug for VkVideoEncodeH264PictureInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264PictureInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("naluSliceEntryCount", &self.naluSliceEntryCount)
		.field("pNaluSliceEntries", &self.pNaluSliceEntries)
		.field("pStdPictureInfo", &self.pStdPictureInfo)
		.field("generatePrefixNalu", &self.generatePrefixNalu)
		.finish()
	}
}
/// struct `VkVideoEncodeH264DpbSlotInfoKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264DpbSlotInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264DpbSlotInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdReferenceInfo: *const StdVideoEncodeH264ReferenceInfo,
}
impl Debug for VkVideoEncodeH264DpbSlotInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264DpbSlotInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pStdReferenceInfo", &self.pStdReferenceInfo)
		.finish()
	}
}
/// struct `VkVideoEncodeH264ProfileInfoKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264ProfileInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264ProfileInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdProfileIdc: StdVideoH264ProfileIdc,
}
impl Debug for VkVideoEncodeH264ProfileInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264ProfileInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stdProfileIdc", &self.stdProfileIdc)
		.finish()
	}
}
/// struct `VkVideoEncodeH264RateControlInfoKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264RateControlInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264RateControlInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoEncodeH264RateControlFlagsKHR,
	pub gopFrameCount: u32,
	pub idrPeriod: u32,
	pub consecutiveBFrameCount: u32,
	pub temporalLayerCount: u32,
}
impl Debug for VkVideoEncodeH264RateControlInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264RateControlInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("gopFrameCount", &self.gopFrameCount)
		.field("idrPeriod", &self.idrPeriod)
		.field("consecutiveBFrameCount", &self.consecutiveBFrameCount)
		.field("temporalLayerCount", &self.temporalLayerCount)
		.finish()
	}
}
/// struct `VkVideoEncodeH264FrameSizeKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264FrameSizeKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264FrameSizeKHR {
	pub frameISize: u32,
	pub framePSize: u32,
	pub frameBSize: u32,
}
impl Debug for VkVideoEncodeH264FrameSizeKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264FrameSizeKHR")
		.field("frameISize", &self.frameISize)
		.field("framePSize", &self.framePSize)
		.field("frameBSize", &self.frameBSize)
		.finish()
	}
}
/// struct `VkVideoEncodeH264RateControlLayerInfoKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264RateControlLayerInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264RateControlLayerInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useMinQp: VkBool32,
	pub minQp: VkVideoEncodeH264QpKHR,
	pub useMaxQp: VkBool32,
	pub maxQp: VkVideoEncodeH264QpKHR,
	pub useMaxFrameSize: VkBool32,
	pub maxFrameSize: VkVideoEncodeH264FrameSizeKHR,
}
impl Debug for VkVideoEncodeH264RateControlLayerInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264RateControlLayerInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("useMinQp", &self.useMinQp)
		.field("minQp", &self.minQp)
		.field("useMaxQp", &self.useMaxQp)
		.field("maxQp", &self.maxQp)
		.field("useMaxFrameSize", &self.useMaxFrameSize)
		.field("maxFrameSize", &self.maxFrameSize)
		.finish()
	}
}
/// struct `VkVideoEncodeH264GopRemainingFrameInfoKHR` from VK_KHR_video_encode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264GopRemainingFrameInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264GopRemainingFrameInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useGopRemainingFrames: VkBool32,
	pub gopRemainingI: u32,
	pub gopRemainingP: u32,
	pub gopRemainingB: u32,
}
impl Debug for VkVideoEncodeH264GopRemainingFrameInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264GopRemainingFrameInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("useGopRemainingFrames", &self.useGopRemainingFrames)
		.field("gopRemainingI", &self.gopRemainingI)
		.field("gopRemainingP", &self.gopRemainingP)
		.field("gopRemainingB", &self.gopRemainingB)
		.finish()
	}
}
/// trait for `VK_KHR_video_encode_h264`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_video_encode_h264.html>
pub trait VK_KHR_video_encode_h264: Debug {}
/// struct for `VK_KHR_video_encode_h264`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_encode_h264 {}
impl VK_KHR_video_encode_h264 for Vulkan_KHR_video_encode_h264 {}
impl Default for Vulkan_KHR_video_encode_h264 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_encode_h264 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `STD_VIDEO_H264_CPB_CNT_LIST_SIZE` from vulkan_video_codec_h264std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H264_CPB_CNT_LIST_SIZE.html>
pub const STD_VIDEO_H264_CPB_CNT_LIST_SIZE: u32 = 32u32;
/// constant `STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS` from vulkan_video_codec_h264std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS.html>
pub const STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS: u32 = 6u32;
/// constant `STD_VIDEO_H264_SCALING_LIST_4X4_NUM_ELEMENTS` from vulkan_video_codec_h264std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H264_SCALING_LIST_4X4_NUM_ELEMENTS.html>
pub const STD_VIDEO_H264_SCALING_LIST_4X4_NUM_ELEMENTS: u32 = 16u32;
/// constant `STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS` from vulkan_video_codec_h264std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS.html>
pub const STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS: u32 = 6u32;
/// constant `STD_VIDEO_H264_SCALING_LIST_8X8_NUM_ELEMENTS` from vulkan_video_codec_h264std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H264_SCALING_LIST_8X8_NUM_ELEMENTS.html>
pub const STD_VIDEO_H264_SCALING_LIST_8X8_NUM_ELEMENTS: u32 = 64u32;
/// constant `STD_VIDEO_H264_MAX_NUM_LIST_REF` from vulkan_video_codec_h264std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H264_MAX_NUM_LIST_REF.html>
pub const STD_VIDEO_H264_MAX_NUM_LIST_REF: u32 = 32u32;
/// constant `STD_VIDEO_H264_MAX_CHROMA_PLANES` from vulkan_video_codec_h264std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H264_MAX_CHROMA_PLANES.html>
pub const STD_VIDEO_H264_MAX_CHROMA_PLANES: u32 = 2u32;
/// constant `STD_VIDEO_H264_NO_REFERENCE_PICTURE` from vulkan_video_codec_h264std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H264_NO_REFERENCE_PICTURE.html>
pub const STD_VIDEO_H264_NO_REFERENCE_PICTURE: u32 = 0xffu32;
/// enum `StdVideoH264ChromaFormatIdc` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264ChromaFormatIdc {
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_MONOCHROME = 0,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_420 = 1,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_422 = 2,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_444 = 3,
	STD_VIDEO_H264_CHROMA_FORMAT_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH264ChromaFormatIdc {
	pub const STD_VIDEO_H264_CHROMA_FORMAT_IDC_MAX_ENUM: StdVideoH264ChromaFormatIdc = StdVideoH264ChromaFormatIdc::STD_VIDEO_H264_CHROMA_FORMAT_IDC_INVALID;
}
/// enum `StdVideoH264ProfileIdc` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264ProfileIdc {
	STD_VIDEO_H264_PROFILE_IDC_BASELINE = 66,
	STD_VIDEO_H264_PROFILE_IDC_MAIN = 77,
	STD_VIDEO_H264_PROFILE_IDC_HIGH = 100,
	STD_VIDEO_H264_PROFILE_IDC_HIGH_444_PREDICTIVE = 244,
	STD_VIDEO_H264_PROFILE_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH264ProfileIdc {
	pub const STD_VIDEO_H264_PROFILE_IDC_MAX_ENUM: StdVideoH264ProfileIdc = StdVideoH264ProfileIdc::STD_VIDEO_H264_PROFILE_IDC_INVALID;
}
/// enum `StdVideoH264LevelIdc` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264LevelIdc {
	STD_VIDEO_H264_LEVEL_IDC_1_0 = 0,
	STD_VIDEO_H264_LEVEL_IDC_1_1 = 1,
	STD_VIDEO_H264_LEVEL_IDC_1_2 = 2,
	STD_VIDEO_H264_LEVEL_IDC_1_3 = 3,
	STD_VIDEO_H264_LEVEL_IDC_2_0 = 4,
	STD_VIDEO_H264_LEVEL_IDC_2_1 = 5,
	STD_VIDEO_H264_LEVEL_IDC_2_2 = 6,
	STD_VIDEO_H264_LEVEL_IDC_3_0 = 7,
	STD_VIDEO_H264_LEVEL_IDC_3_1 = 8,
	STD_VIDEO_H264_LEVEL_IDC_3_2 = 9,
	STD_VIDEO_H264_LEVEL_IDC_4_0 = 10,
	STD_VIDEO_H264_LEVEL_IDC_4_1 = 11,
	STD_VIDEO_H264_LEVEL_IDC_4_2 = 12,
	STD_VIDEO_H264_LEVEL_IDC_5_0 = 13,
	STD_VIDEO_H264_LEVEL_IDC_5_1 = 14,
	STD_VIDEO_H264_LEVEL_IDC_5_2 = 15,
	STD_VIDEO_H264_LEVEL_IDC_6_0 = 16,
	STD_VIDEO_H264_LEVEL_IDC_6_1 = 17,
	STD_VIDEO_H264_LEVEL_IDC_6_2 = 18,
	STD_VIDEO_H264_LEVEL_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH264LevelIdc {
	pub const STD_VIDEO_H264_LEVEL_IDC_MAX_ENUM: StdVideoH264LevelIdc = StdVideoH264LevelIdc::STD_VIDEO_H264_LEVEL_IDC_INVALID;
}
/// enum `StdVideoH264PocType` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264PocType {
	STD_VIDEO_H264_POC_TYPE_0 = 0,
	STD_VIDEO_H264_POC_TYPE_1 = 1,
	STD_VIDEO_H264_POC_TYPE_2 = 2,
	STD_VIDEO_H264_POC_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoH264PocType {
	pub const STD_VIDEO_H264_POC_TYPE_MAX_ENUM: StdVideoH264PocType = StdVideoH264PocType::STD_VIDEO_H264_POC_TYPE_INVALID;
}
/// enum `StdVideoH264AspectRatioIdc` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264AspectRatioIdc {
	STD_VIDEO_H264_ASPECT_RATIO_IDC_UNSPECIFIED = 0,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_SQUARE = 1,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_12_11 = 2,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_10_11 = 3,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_16_11 = 4,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_40_33 = 5,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_24_11 = 6,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_20_11 = 7,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_32_11 = 8,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_80_33 = 9,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_18_11 = 10,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_15_11 = 11,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_64_33 = 12,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_160_99 = 13,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_4_3 = 14,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_3_2 = 15,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_2_1 = 16,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_EXTENDED_SAR = 255,
	STD_VIDEO_H264_ASPECT_RATIO_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH264AspectRatioIdc {
	pub const STD_VIDEO_H264_ASPECT_RATIO_IDC_MAX_ENUM: StdVideoH264AspectRatioIdc = StdVideoH264AspectRatioIdc::STD_VIDEO_H264_ASPECT_RATIO_IDC_INVALID;
}
/// enum `StdVideoH264WeightedBipredIdc` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264WeightedBipredIdc {
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_DEFAULT = 0,
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_EXPLICIT = 1,
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_IMPLICIT = 2,
	STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH264WeightedBipredIdc {
	pub const STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_MAX_ENUM: StdVideoH264WeightedBipredIdc = StdVideoH264WeightedBipredIdc::STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_INVALID;
}
/// enum `StdVideoH264ModificationOfPicNumsIdc` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264ModificationOfPicNumsIdc {
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_SUBTRACT = 0,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_ADD = 1,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_LONG_TERM = 2,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_END = 3,
	STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH264ModificationOfPicNumsIdc {
	pub const STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_MAX_ENUM: StdVideoH264ModificationOfPicNumsIdc = StdVideoH264ModificationOfPicNumsIdc::STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_INVALID;
}
/// enum `StdVideoH264MemMgmtControlOp` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264MemMgmtControlOp {
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_END = 0,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_SHORT_TERM = 1,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_LONG_TERM = 2,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_LONG_TERM = 3,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_SET_MAX_LONG_TERM_INDEX = 4,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_ALL = 5,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_CURRENT_AS_LONG_TERM = 6,
	STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_INVALID = 0x7fffffff,
}
impl StdVideoH264MemMgmtControlOp {
	pub const STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MAX_ENUM: StdVideoH264MemMgmtControlOp = StdVideoH264MemMgmtControlOp::STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_INVALID;
}
/// enum `StdVideoH264CabacInitIdc` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264CabacInitIdc {
	STD_VIDEO_H264_CABAC_INIT_IDC_0 = 0,
	STD_VIDEO_H264_CABAC_INIT_IDC_1 = 1,
	STD_VIDEO_H264_CABAC_INIT_IDC_2 = 2,
	STD_VIDEO_H264_CABAC_INIT_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH264CabacInitIdc {
	pub const STD_VIDEO_H264_CABAC_INIT_IDC_MAX_ENUM: StdVideoH264CabacInitIdc = StdVideoH264CabacInitIdc::STD_VIDEO_H264_CABAC_INIT_IDC_INVALID;
}
/// enum `StdVideoH264DisableDeblockingFilterIdc` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264DisableDeblockingFilterIdc {
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_DISABLED = 0,
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_ENABLED = 1,
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_PARTIAL = 2,
	STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH264DisableDeblockingFilterIdc {
	pub const STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_MAX_ENUM: StdVideoH264DisableDeblockingFilterIdc = StdVideoH264DisableDeblockingFilterIdc::STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_INVALID;
}
/// enum `StdVideoH264SliceType` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264SliceType {
	STD_VIDEO_H264_SLICE_TYPE_P = 0,
	STD_VIDEO_H264_SLICE_TYPE_B = 1,
	STD_VIDEO_H264_SLICE_TYPE_I = 2,
	STD_VIDEO_H264_SLICE_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoH264SliceType {
	pub const STD_VIDEO_H264_SLICE_TYPE_MAX_ENUM: StdVideoH264SliceType = StdVideoH264SliceType::STD_VIDEO_H264_SLICE_TYPE_INVALID;
}
/// enum `StdVideoH264PictureType` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264PictureType {
	STD_VIDEO_H264_PICTURE_TYPE_P = 0,
	STD_VIDEO_H264_PICTURE_TYPE_B = 1,
	STD_VIDEO_H264_PICTURE_TYPE_I = 2,
	STD_VIDEO_H264_PICTURE_TYPE_IDR = 5,
	STD_VIDEO_H264_PICTURE_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoH264PictureType {
	pub const STD_VIDEO_H264_PICTURE_TYPE_MAX_ENUM: StdVideoH264PictureType = StdVideoH264PictureType::STD_VIDEO_H264_PICTURE_TYPE_INVALID;
}
/// enum `StdVideoH264NonVclNaluType` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH264NonVclNaluType {
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_SPS = 0,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_PPS = 1,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_AUD = 2,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_PREFIX = 3,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_SEQUENCE = 4,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_STREAM = 5,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_PRECODED = 6,
	STD_VIDEO_H264_NON_VCL_NALU_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoH264NonVclNaluType {
	pub const STD_VIDEO_H264_NON_VCL_NALU_TYPE_MAX_ENUM: StdVideoH264NonVclNaluType = StdVideoH264NonVclNaluType::STD_VIDEO_H264_NON_VCL_NALU_TYPE_INVALID;
}
/// struct `StdVideoH264SpsVuiFlags` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH264SpsVuiFlags {
	/// Bitfield: aspect_ratio_info_present_flag: u32 in 1 bits
	/// Bitfield: overscan_info_present_flag: u32 in 1 bits
	/// Bitfield: overscan_appropriate_flag: u32 in 1 bits
	/// Bitfield: video_signal_type_present_flag: u32 in 1 bits
	/// Bitfield: video_full_range_flag: u32 in 1 bits
	/// Bitfield: color_description_present_flag: u32 in 1 bits
	/// Bitfield: chroma_loc_info_present_flag: u32 in 1 bits
	/// Bitfield: timing_info_present_flag: u32 in 1 bits
	/// Bitfield: fixed_frame_rate_flag: u32 in 1 bits
	/// Bitfield: bitstream_restriction_flag: u32 in 1 bits
	/// Bitfield: nal_hrd_parameters_present_flag: u32 in 1 bits
	/// Bitfield: vcl_hrd_parameters_present_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH264SpsVuiFlags {
	pub fn get_aspect_ratio_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_aspect_ratio_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_overscan_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_overscan_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_overscan_appropriate_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_overscan_appropriate_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_video_signal_type_present_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_video_signal_type_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_video_full_range_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_video_full_range_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_color_description_present_flag(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_color_description_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_chroma_loc_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_chroma_loc_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_timing_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_timing_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_fixed_frame_rate_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_fixed_frame_rate_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_bitstream_restriction_flag(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_bitstream_restriction_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_nal_hrd_parameters_present_flag(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_nal_hrd_parameters_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_vcl_hrd_parameters_present_flag(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_vcl_hrd_parameters_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
}
impl Debug for StdVideoH264SpsVuiFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH264SpsVuiFlags")
		.field("aspect_ratio_info_present_flag", &self.get_aspect_ratio_info_present_flag())
		.field("overscan_info_present_flag", &self.get_overscan_info_present_flag())
		.field("overscan_appropriate_flag", &self.get_overscan_appropriate_flag())
		.field("video_signal_type_present_flag", &self.get_video_signal_type_present_flag())
		.field("video_full_range_flag", &self.get_video_full_range_flag())
		.field("color_description_present_flag", &self.get_color_description_present_flag())
		.field("chroma_loc_info_present_flag", &self.get_chroma_loc_info_present_flag())
		.field("timing_info_present_flag", &self.get_timing_info_present_flag())
		.field("fixed_frame_rate_flag", &self.get_fixed_frame_rate_flag())
		.field("bitstream_restriction_flag", &self.get_bitstream_restriction_flag())
		.field("nal_hrd_parameters_present_flag", &self.get_nal_hrd_parameters_present_flag())
		.field("vcl_hrd_parameters_present_flag", &self.get_vcl_hrd_parameters_present_flag())
		.finish()
	}
}
/// struct `StdVideoH264HrdParameters` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH264HrdParameters {
	pub cpb_cnt_minus1: u8,
	pub bit_rate_scale: u8,
	pub cpb_size_scale: u8,
	pub reserved1: u8,
	pub bit_rate_value_minus1: [u32; STD_VIDEO_H264_CPB_CNT_LIST_SIZE as usize],
	pub cpb_size_value_minus1: [u32; STD_VIDEO_H264_CPB_CNT_LIST_SIZE as usize],
	pub cbr_flag: [u8; STD_VIDEO_H264_CPB_CNT_LIST_SIZE as usize],
	pub initial_cpb_removal_delay_length_minus1: u32,
	pub cpb_removal_delay_length_minus1: u32,
	pub dpb_output_delay_length_minus1: u32,
	pub time_offset_length: u32,
}
impl Debug for StdVideoH264HrdParameters {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH264HrdParameters")
		.field("cpb_cnt_minus1", &self.cpb_cnt_minus1)
		.field("bit_rate_scale", &self.bit_rate_scale)
		.field("cpb_size_scale", &self.cpb_size_scale)
		.field("reserved1", &self.reserved1)
		.field("bit_rate_value_minus1", &self.bit_rate_value_minus1)
		.field("cpb_size_value_minus1", &self.cpb_size_value_minus1)
		.field("cbr_flag", &self.cbr_flag)
		.field("initial_cpb_removal_delay_length_minus1", &self.initial_cpb_removal_delay_length_minus1)
		.field("cpb_removal_delay_length_minus1", &self.cpb_removal_delay_length_minus1)
		.field("dpb_output_delay_length_minus1", &self.dpb_output_delay_length_minus1)
		.field("time_offset_length", &self.time_offset_length)
		.finish()
	}
}
/// struct `StdVideoH264SequenceParameterSetVui` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH264SequenceParameterSetVui {
	pub flags: StdVideoH264SpsVuiFlags,
	pub aspect_ratio_idc: StdVideoH264AspectRatioIdc,
	pub sar_width: u16,
	pub sar_height: u16,
	pub video_format: u8,
	pub colour_primaries: u8,
	pub transfer_characteristics: u8,
	pub matrix_coefficients: u8,
	pub num_units_in_tick: u32,
	pub time_scale: u32,
	pub max_num_reorder_frames: u8,
	pub max_dec_frame_buffering: u8,
	pub chroma_sample_loc_type_top_field: u8,
	pub chroma_sample_loc_type_bottom_field: u8,
	pub reserved1: u32,
	pub pHrdParameters: *const StdVideoH264HrdParameters,
}
impl Debug for StdVideoH264SequenceParameterSetVui {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH264SequenceParameterSetVui")
		.field("flags", &self.flags)
		.field("aspect_ratio_idc", &self.aspect_ratio_idc)
		.field("sar_width", &self.sar_width)
		.field("sar_height", &self.sar_height)
		.field("video_format", &self.video_format)
		.field("colour_primaries", &self.colour_primaries)
		.field("transfer_characteristics", &self.transfer_characteristics)
		.field("matrix_coefficients", &self.matrix_coefficients)
		.field("num_units_in_tick", &self.num_units_in_tick)
		.field("time_scale", &self.time_scale)
		.field("max_num_reorder_frames", &self.max_num_reorder_frames)
		.field("max_dec_frame_buffering", &self.max_dec_frame_buffering)
		.field("chroma_sample_loc_type_top_field", &self.chroma_sample_loc_type_top_field)
		.field("chroma_sample_loc_type_bottom_field", &self.chroma_sample_loc_type_bottom_field)
		.field("reserved1", &self.reserved1)
		.field("pHrdParameters", &self.pHrdParameters)
		.finish()
	}
}
/// struct `StdVideoH264SpsFlags` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH264SpsFlags {
	/// Bitfield: constraint_set0_flag: u32 in 1 bits
	/// Bitfield: constraint_set1_flag: u32 in 1 bits
	/// Bitfield: constraint_set2_flag: u32 in 1 bits
	/// Bitfield: constraint_set3_flag: u32 in 1 bits
	/// Bitfield: constraint_set4_flag: u32 in 1 bits
	/// Bitfield: constraint_set5_flag: u32 in 1 bits
	/// Bitfield: direct_8x8_inference_flag: u32 in 1 bits
	/// Bitfield: mb_adaptive_frame_field_flag: u32 in 1 bits
	/// Bitfield: frame_mbs_only_flag: u32 in 1 bits
	/// Bitfield: delta_pic_order_always_zero_flag: u32 in 1 bits
	/// Bitfield: separate_colour_plane_flag: u32 in 1 bits
	/// Bitfield: gaps_in_frame_num_value_allowed_flag: u32 in 1 bits
	/// Bitfield: qpprime_y_zero_transform_bypass_flag: u32 in 1 bits
	/// Bitfield: frame_cropping_flag: u32 in 1 bits
	/// Bitfield: seq_scaling_matrix_present_flag: u32 in 1 bits
	/// Bitfield: vui_parameters_present_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH264SpsFlags {
	pub fn get_constraint_set0_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_constraint_set0_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_constraint_set1_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_constraint_set1_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_constraint_set2_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_constraint_set2_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_constraint_set3_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_constraint_set3_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_constraint_set4_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_constraint_set4_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_constraint_set5_flag(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_constraint_set5_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_direct_8x8_inference_flag(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_direct_8x8_inference_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_mb_adaptive_frame_field_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_mb_adaptive_frame_field_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_frame_mbs_only_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_frame_mbs_only_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_delta_pic_order_always_zero_flag(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_delta_pic_order_always_zero_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_separate_colour_plane_flag(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_separate_colour_plane_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_gaps_in_frame_num_value_allowed_flag(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_gaps_in_frame_num_value_allowed_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
	pub fn get_qpprime_y_zero_transform_bypass_flag(&self) -> u32 {
		(self.bitfield1 >> 12) & 0x1
	}
	pub fn set_qpprime_y_zero_transform_bypass_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 12;
	}
	pub fn get_frame_cropping_flag(&self) -> u32 {
		(self.bitfield1 >> 13) & 0x1
	}
	pub fn set_frame_cropping_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 13;
	}
	pub fn get_seq_scaling_matrix_present_flag(&self) -> u32 {
		(self.bitfield1 >> 14) & 0x1
	}
	pub fn set_seq_scaling_matrix_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 14;
	}
	pub fn get_vui_parameters_present_flag(&self) -> u32 {
		(self.bitfield1 >> 15) & 0x1
	}
	pub fn set_vui_parameters_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 15;
	}
}
impl Debug for StdVideoH264SpsFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH264SpsFlags")
		.field("constraint_set0_flag", &self.get_constraint_set0_flag())
		.field("constraint_set1_flag", &self.get_constraint_set1_flag())
		.field("constraint_set2_flag", &self.get_constraint_set2_flag())
		.field("constraint_set3_flag", &self.get_constraint_set3_flag())
		.field("constraint_set4_flag", &self.get_constraint_set4_flag())
		.field("constraint_set5_flag", &self.get_constraint_set5_flag())
		.field("direct_8x8_inference_flag", &self.get_direct_8x8_inference_flag())
		.field("mb_adaptive_frame_field_flag", &self.get_mb_adaptive_frame_field_flag())
		.field("frame_mbs_only_flag", &self.get_frame_mbs_only_flag())
		.field("delta_pic_order_always_zero_flag", &self.get_delta_pic_order_always_zero_flag())
		.field("separate_colour_plane_flag", &self.get_separate_colour_plane_flag())
		.field("gaps_in_frame_num_value_allowed_flag", &self.get_gaps_in_frame_num_value_allowed_flag())
		.field("qpprime_y_zero_transform_bypass_flag", &self.get_qpprime_y_zero_transform_bypass_flag())
		.field("frame_cropping_flag", &self.get_frame_cropping_flag())
		.field("seq_scaling_matrix_present_flag", &self.get_seq_scaling_matrix_present_flag())
		.field("vui_parameters_present_flag", &self.get_vui_parameters_present_flag())
		.finish()
	}
}
/// struct `StdVideoH264ScalingLists` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH264ScalingLists {
	pub scaling_list_present_mask: u16,
	pub use_default_scaling_matrix_mask: u16,
	pub ScalingList4x4: [[u8; STD_VIDEO_H264_SCALING_LIST_4X4_NUM_ELEMENTS as usize]; STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS as usize],
	pub ScalingList8x8: [[u8; STD_VIDEO_H264_SCALING_LIST_8X8_NUM_ELEMENTS as usize]; STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS as usize],
}
impl Debug for StdVideoH264ScalingLists {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH264ScalingLists")
		.field("scaling_list_present_mask", &self.scaling_list_present_mask)
		.field("use_default_scaling_matrix_mask", &self.use_default_scaling_matrix_mask)
		.field("ScalingList4x4", &self.ScalingList4x4)
		.field("ScalingList8x8", &self.ScalingList8x8)
		.finish()
	}
}
/// struct `StdVideoH264SequenceParameterSet` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH264SequenceParameterSet {
	pub flags: StdVideoH264SpsFlags,
	pub profile_idc: StdVideoH264ProfileIdc,
	pub level_idc: StdVideoH264LevelIdc,
	pub chroma_format_idc: StdVideoH264ChromaFormatIdc,
	pub seq_parameter_set_id: u8,
	pub bit_depth_luma_minus8: u8,
	pub bit_depth_chroma_minus8: u8,
	pub log2_max_frame_num_minus4: u8,
	pub pic_order_cnt_type: StdVideoH264PocType,
	pub offset_for_non_ref_pic: i32,
	pub offset_for_top_to_bottom_field: i32,
	pub log2_max_pic_order_cnt_lsb_minus4: u8,
	pub num_ref_frames_in_pic_order_cnt_cycle: u8,
	pub max_num_ref_frames: u8,
	pub reserved1: u8,
	pub pic_width_in_mbs_minus1: u32,
	pub pic_height_in_map_units_minus1: u32,
	pub frame_crop_left_offset: u32,
	pub frame_crop_right_offset: u32,
	pub frame_crop_top_offset: u32,
	pub frame_crop_bottom_offset: u32,
	pub reserved2: u32,
	pub pOffsetForRefFrame: *const int32_t,
	pub pScalingLists: *const StdVideoH264ScalingLists,
	pub pSequenceParameterSetVui: *const StdVideoH264SequenceParameterSetVui,
}
impl Debug for StdVideoH264SequenceParameterSet {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH264SequenceParameterSet")
		.field("flags", &self.flags)
		.field("profile_idc", &self.profile_idc)
		.field("level_idc", &self.level_idc)
		.field("chroma_format_idc", &self.chroma_format_idc)
		.field("seq_parameter_set_id", &self.seq_parameter_set_id)
		.field("bit_depth_luma_minus8", &self.bit_depth_luma_minus8)
		.field("bit_depth_chroma_minus8", &self.bit_depth_chroma_minus8)
		.field("log2_max_frame_num_minus4", &self.log2_max_frame_num_minus4)
		.field("pic_order_cnt_type", &self.pic_order_cnt_type)
		.field("offset_for_non_ref_pic", &self.offset_for_non_ref_pic)
		.field("offset_for_top_to_bottom_field", &self.offset_for_top_to_bottom_field)
		.field("log2_max_pic_order_cnt_lsb_minus4", &self.log2_max_pic_order_cnt_lsb_minus4)
		.field("num_ref_frames_in_pic_order_cnt_cycle", &self.num_ref_frames_in_pic_order_cnt_cycle)
		.field("max_num_ref_frames", &self.max_num_ref_frames)
		.field("reserved1", &self.reserved1)
		.field("pic_width_in_mbs_minus1", &self.pic_width_in_mbs_minus1)
		.field("pic_height_in_map_units_minus1", &self.pic_height_in_map_units_minus1)
		.field("frame_crop_left_offset", &self.frame_crop_left_offset)
		.field("frame_crop_right_offset", &self.frame_crop_right_offset)
		.field("frame_crop_top_offset", &self.frame_crop_top_offset)
		.field("frame_crop_bottom_offset", &self.frame_crop_bottom_offset)
		.field("reserved2", &self.reserved2)
		.field("pOffsetForRefFrame", &self.pOffsetForRefFrame)
		.field("pScalingLists", &self.pScalingLists)
		.field("pSequenceParameterSetVui", &self.pSequenceParameterSetVui)
		.finish()
	}
}
/// struct `StdVideoH264PpsFlags` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH264PpsFlags {
	/// Bitfield: transform_8x8_mode_flag: u32 in 1 bits
	/// Bitfield: redundant_pic_cnt_present_flag: u32 in 1 bits
	/// Bitfield: constrained_intra_pred_flag: u32 in 1 bits
	/// Bitfield: deblocking_filter_control_present_flag: u32 in 1 bits
	/// Bitfield: weighted_pred_flag: u32 in 1 bits
	/// Bitfield: bottom_field_pic_order_in_frame_present_flag: u32 in 1 bits
	/// Bitfield: entropy_coding_mode_flag: u32 in 1 bits
	/// Bitfield: pic_scaling_matrix_present_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH264PpsFlags {
	pub fn get_transform_8x8_mode_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_transform_8x8_mode_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_redundant_pic_cnt_present_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_redundant_pic_cnt_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_constrained_intra_pred_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_constrained_intra_pred_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_deblocking_filter_control_present_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_deblocking_filter_control_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_weighted_pred_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_weighted_pred_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_bottom_field_pic_order_in_frame_present_flag(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_bottom_field_pic_order_in_frame_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_entropy_coding_mode_flag(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_entropy_coding_mode_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_pic_scaling_matrix_present_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_pic_scaling_matrix_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
}
impl Debug for StdVideoH264PpsFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH264PpsFlags")
		.field("transform_8x8_mode_flag", &self.get_transform_8x8_mode_flag())
		.field("redundant_pic_cnt_present_flag", &self.get_redundant_pic_cnt_present_flag())
		.field("constrained_intra_pred_flag", &self.get_constrained_intra_pred_flag())
		.field("deblocking_filter_control_present_flag", &self.get_deblocking_filter_control_present_flag())
		.field("weighted_pred_flag", &self.get_weighted_pred_flag())
		.field("bottom_field_pic_order_in_frame_present_flag", &self.get_bottom_field_pic_order_in_frame_present_flag())
		.field("entropy_coding_mode_flag", &self.get_entropy_coding_mode_flag())
		.field("pic_scaling_matrix_present_flag", &self.get_pic_scaling_matrix_present_flag())
		.finish()
	}
}
/// struct `StdVideoH264PictureParameterSet` from vulkan_video_codec_h264std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH264PictureParameterSet {
	pub flags: StdVideoH264PpsFlags,
	pub seq_parameter_set_id: u8,
	pub pic_parameter_set_id: u8,
	pub num_ref_idx_l0_default_active_minus1: u8,
	pub num_ref_idx_l1_default_active_minus1: u8,
	pub weighted_bipred_idc: StdVideoH264WeightedBipredIdc,
	pub pic_init_qp_minus26: i8,
	pub pic_init_qs_minus26: i8,
	pub chroma_qp_index_offset: i8,
	pub second_chroma_qp_index_offset: i8,
	pub pScalingLists: *const StdVideoH264ScalingLists,
}
impl Debug for StdVideoH264PictureParameterSet {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH264PictureParameterSet")
		.field("flags", &self.flags)
		.field("seq_parameter_set_id", &self.seq_parameter_set_id)
		.field("pic_parameter_set_id", &self.pic_parameter_set_id)
		.field("num_ref_idx_l0_default_active_minus1", &self.num_ref_idx_l0_default_active_minus1)
		.field("num_ref_idx_l1_default_active_minus1", &self.num_ref_idx_l1_default_active_minus1)
		.field("weighted_bipred_idc", &self.weighted_bipred_idc)
		.field("pic_init_qp_minus26", &self.pic_init_qp_minus26)
		.field("pic_init_qs_minus26", &self.pic_init_qs_minus26)
		.field("chroma_qp_index_offset", &self.chroma_qp_index_offset)
		.field("second_chroma_qp_index_offset", &self.second_chroma_qp_index_offset)
		.field("pScalingLists", &self.pScalingLists)
		.finish()
	}
}
/// trait for `vulkan_video_codec_h264std`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vulkan_video_codec_h264std.html>
pub trait vulkan_video_codec_h264std: Debug {}
/// struct for `vulkan_video_codec_h264std`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_h264std {}
impl vulkan_video_codec_h264std for Vulkan_video_codec_h264std {}
impl Default for Vulkan_video_codec_h264std {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_h264std {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `vulkan_video_codecs_common`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vulkan_video_codecs_common.html>
pub trait vulkan_video_codecs_common: Debug {}
/// struct for `vulkan_video_codecs_common`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codecs_common {}
impl vulkan_video_codecs_common for Vulkan_video_codecs_common {}
impl Default for Vulkan_video_codecs_common {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codecs_common {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_API_VERSION_1_0_0` from vulkan_video_codec_h264std_encode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_API_VERSION_1_0_0.html>
pub const VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_API_VERSION_1_0_0: u32 = 0x400000;
/// struct `StdVideoEncodeH264WeightTableFlags` from vulkan_video_codec_h264std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH264WeightTableFlags {
	pub luma_weight_l0_flag: u32,
	pub chroma_weight_l0_flag: u32,
	pub luma_weight_l1_flag: u32,
	pub chroma_weight_l1_flag: u32,
}
impl Debug for StdVideoEncodeH264WeightTableFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH264WeightTableFlags")
		.field("luma_weight_l0_flag", &self.luma_weight_l0_flag)
		.field("chroma_weight_l0_flag", &self.chroma_weight_l0_flag)
		.field("luma_weight_l1_flag", &self.luma_weight_l1_flag)
		.field("chroma_weight_l1_flag", &self.chroma_weight_l1_flag)
		.finish()
	}
}
/// struct `StdVideoEncodeH264WeightTable` from vulkan_video_codec_h264std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH264WeightTable {
	pub flags: StdVideoEncodeH264WeightTableFlags,
	pub luma_log2_weight_denom: u8,
	pub chroma_log2_weight_denom: u8,
	pub luma_weight_l0: [i8; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub luma_offset_l0: [i8; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub chroma_weight_l0: [[i8; STD_VIDEO_H264_MAX_CHROMA_PLANES as usize]; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub chroma_offset_l0: [[i8; STD_VIDEO_H264_MAX_CHROMA_PLANES as usize]; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub luma_weight_l1: [i8; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub luma_offset_l1: [i8; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub chroma_weight_l1: [[i8; STD_VIDEO_H264_MAX_CHROMA_PLANES as usize]; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub chroma_offset_l1: [[i8; STD_VIDEO_H264_MAX_CHROMA_PLANES as usize]; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
}
impl Debug for StdVideoEncodeH264WeightTable {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH264WeightTable")
		.field("flags", &self.flags)
		.field("luma_log2_weight_denom", &self.luma_log2_weight_denom)
		.field("chroma_log2_weight_denom", &self.chroma_log2_weight_denom)
		.field("luma_weight_l0", &format_args!("{}", maybe_string(&self.luma_weight_l0)))
		.field("luma_offset_l0", &format_args!("{}", maybe_string(&self.luma_offset_l0)))
		.field("chroma_weight_l0", &self.chroma_weight_l0)
		.field("chroma_offset_l0", &self.chroma_offset_l0)
		.field("luma_weight_l1", &format_args!("{}", maybe_string(&self.luma_weight_l1)))
		.field("luma_offset_l1", &format_args!("{}", maybe_string(&self.luma_offset_l1)))
		.field("chroma_weight_l1", &self.chroma_weight_l1)
		.field("chroma_offset_l1", &self.chroma_offset_l1)
		.finish()
	}
}
/// struct `StdVideoEncodeH264SliceHeaderFlags` from vulkan_video_codec_h264std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH264SliceHeaderFlags {
	/// Bitfield: direct_spatial_mv_pred_flag: u32 in 1 bits
	/// Bitfield: num_ref_idx_active_override_flag: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoEncodeH264SliceHeaderFlags {
	pub fn get_direct_spatial_mv_pred_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_direct_spatial_mv_pred_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_num_ref_idx_active_override_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_num_ref_idx_active_override_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
impl Debug for StdVideoEncodeH264SliceHeaderFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH264SliceHeaderFlags")
		.field("direct_spatial_mv_pred_flag", &self.get_direct_spatial_mv_pred_flag())
		.field("num_ref_idx_active_override_flag", &self.get_num_ref_idx_active_override_flag())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoEncodeH264PictureInfoFlags` from vulkan_video_codec_h264std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH264PictureInfoFlags {
	/// Bitfield: IdrPicFlag: u32 in 1 bits
	/// Bitfield: is_reference: u32 in 1 bits
	/// Bitfield: no_output_of_prior_pics_flag: u32 in 1 bits
	/// Bitfield: long_term_reference_flag: u32 in 1 bits
	/// Bitfield: adaptive_ref_pic_marking_mode_flag: u32 in 1 bits
	/// Bitfield: reserved: u32 in 27 bits
	bitfield1: u32,
}
impl StdVideoEncodeH264PictureInfoFlags {
	pub fn get_IdrPicFlag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_IdrPicFlag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_is_reference(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_is_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_no_output_of_prior_pics_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_no_output_of_prior_pics_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_long_term_reference_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_long_term_reference_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_adaptive_ref_pic_marking_mode_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_adaptive_ref_pic_marking_mode_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x7ffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7ffffff) << 5;
	}
}
impl Debug for StdVideoEncodeH264PictureInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH264PictureInfoFlags")
		.field("IdrPicFlag", &self.get_IdrPicFlag())
		.field("is_reference", &self.get_is_reference())
		.field("no_output_of_prior_pics_flag", &self.get_no_output_of_prior_pics_flag())
		.field("long_term_reference_flag", &self.get_long_term_reference_flag())
		.field("adaptive_ref_pic_marking_mode_flag", &self.get_adaptive_ref_pic_marking_mode_flag())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoEncodeH264ReferenceInfoFlags` from vulkan_video_codec_h264std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH264ReferenceInfoFlags {
	/// Bitfield: used_for_long_term_reference: u32 in 1 bits
	/// Bitfield: reserved: u32 in 31 bits
	bitfield1: u32,
}
impl StdVideoEncodeH264ReferenceInfoFlags {
	pub fn get_used_for_long_term_reference(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_used_for_long_term_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x7fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7fffffff) << 1;
	}
}
impl Debug for StdVideoEncodeH264ReferenceInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH264ReferenceInfoFlags")
		.field("used_for_long_term_reference", &self.get_used_for_long_term_reference())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoEncodeH264ReferenceListsInfoFlags` from vulkan_video_codec_h264std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH264ReferenceListsInfoFlags {
	/// Bitfield: ref_pic_list_modification_flag_l0: u32 in 1 bits
	/// Bitfield: ref_pic_list_modification_flag_l1: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoEncodeH264ReferenceListsInfoFlags {
	pub fn get_ref_pic_list_modification_flag_l0(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_ref_pic_list_modification_flag_l0(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_ref_pic_list_modification_flag_l1(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_ref_pic_list_modification_flag_l1(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
impl Debug for StdVideoEncodeH264ReferenceListsInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH264ReferenceListsInfoFlags")
		.field("ref_pic_list_modification_flag_l0", &self.get_ref_pic_list_modification_flag_l0())
		.field("ref_pic_list_modification_flag_l1", &self.get_ref_pic_list_modification_flag_l1())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoEncodeH264RefListModEntry` from vulkan_video_codec_h264std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH264RefListModEntry {
	pub modification_of_pic_nums_idc: StdVideoH264ModificationOfPicNumsIdc,
	pub abs_diff_pic_num_minus1: u16,
	pub long_term_pic_num: u16,
}
impl Debug for StdVideoEncodeH264RefListModEntry {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH264RefListModEntry")
		.field("modification_of_pic_nums_idc", &self.modification_of_pic_nums_idc)
		.field("abs_diff_pic_num_minus1", &self.abs_diff_pic_num_minus1)
		.field("long_term_pic_num", &self.long_term_pic_num)
		.finish()
	}
}
/// struct `StdVideoEncodeH264RefPicMarkingEntry` from vulkan_video_codec_h264std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH264RefPicMarkingEntry {
	pub memory_management_control_operation: StdVideoH264MemMgmtControlOp,
	pub difference_of_pic_nums_minus1: u16,
	pub long_term_pic_num: u16,
	pub long_term_frame_idx: u16,
	pub max_long_term_frame_idx_plus1: u16,
}
impl Debug for StdVideoEncodeH264RefPicMarkingEntry {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH264RefPicMarkingEntry")
		.field("memory_management_control_operation", &self.memory_management_control_operation)
		.field("difference_of_pic_nums_minus1", &self.difference_of_pic_nums_minus1)
		.field("long_term_pic_num", &self.long_term_pic_num)
		.field("long_term_frame_idx", &self.long_term_frame_idx)
		.field("max_long_term_frame_idx_plus1", &self.max_long_term_frame_idx_plus1)
		.finish()
	}
}
/// struct `StdVideoEncodeH264ReferenceListsInfo` from vulkan_video_codec_h264std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH264ReferenceListsInfo {
	pub flags: StdVideoEncodeH264ReferenceListsInfoFlags,
	pub num_ref_idx_l0_active_minus1: u8,
	pub num_ref_idx_l1_active_minus1: u8,
	pub RefPicList0: [u8; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub RefPicList1: [u8; STD_VIDEO_H264_MAX_NUM_LIST_REF as usize],
	pub refList0ModOpCount: u8,
	pub refList1ModOpCount: u8,
	pub refPicMarkingOpCount: u8,
	pub reserved1: [u8; 7 as usize],
	pub pRefList0ModOperations: *const StdVideoEncodeH264RefListModEntry,
	pub pRefList1ModOperations: *const StdVideoEncodeH264RefListModEntry,
	pub pRefPicMarkingOperations: *const StdVideoEncodeH264RefPicMarkingEntry,
}
impl Debug for StdVideoEncodeH264ReferenceListsInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH264ReferenceListsInfo")
		.field("flags", &self.flags)
		.field("num_ref_idx_l0_active_minus1", &self.num_ref_idx_l0_active_minus1)
		.field("num_ref_idx_l1_active_minus1", &self.num_ref_idx_l1_active_minus1)
		.field("RefPicList0", &self.RefPicList0)
		.field("RefPicList1", &self.RefPicList1)
		.field("refList0ModOpCount", &self.refList0ModOpCount)
		.field("refList1ModOpCount", &self.refList1ModOpCount)
		.field("refPicMarkingOpCount", &self.refPicMarkingOpCount)
		.field("reserved1", &self.reserved1)
		.field("pRefList0ModOperations", &self.pRefList0ModOperations)
		.field("pRefList1ModOperations", &self.pRefList1ModOperations)
		.field("pRefPicMarkingOperations", &self.pRefPicMarkingOperations)
		.finish()
	}
}
/// struct `StdVideoEncodeH264PictureInfo` from vulkan_video_codec_h264std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH264PictureInfo {
	pub flags: StdVideoEncodeH264PictureInfoFlags,
	pub seq_parameter_set_id: u8,
	pub pic_parameter_set_id: u8,
	pub idr_pic_id: u16,
	pub primary_pic_type: StdVideoH264PictureType,
	pub frame_num: u32,
	pub PicOrderCnt: i32,
	pub temporal_id: u8,
	pub reserved1: [u8; 3 as usize],
	pub pRefLists: *const StdVideoEncodeH264ReferenceListsInfo,
}
impl Debug for StdVideoEncodeH264PictureInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH264PictureInfo")
		.field("flags", &self.flags)
		.field("seq_parameter_set_id", &self.seq_parameter_set_id)
		.field("pic_parameter_set_id", &self.pic_parameter_set_id)
		.field("idr_pic_id", &self.idr_pic_id)
		.field("primary_pic_type", &self.primary_pic_type)
		.field("frame_num", &self.frame_num)
		.field("PicOrderCnt", &self.PicOrderCnt)
		.field("temporal_id", &self.temporal_id)
		.field("reserved1", &self.reserved1)
		.field("pRefLists", &self.pRefLists)
		.finish()
	}
}
/// struct `StdVideoEncodeH264ReferenceInfo` from vulkan_video_codec_h264std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH264ReferenceInfo {
	pub flags: StdVideoEncodeH264ReferenceInfoFlags,
	pub primary_pic_type: StdVideoH264PictureType,
	pub FrameNum: u32,
	pub PicOrderCnt: i32,
	pub long_term_pic_num: u16,
	pub long_term_frame_idx: u16,
	pub temporal_id: u8,
}
impl Debug for StdVideoEncodeH264ReferenceInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH264ReferenceInfo")
		.field("flags", &self.flags)
		.field("primary_pic_type", &self.primary_pic_type)
		.field("FrameNum", &self.FrameNum)
		.field("PicOrderCnt", &self.PicOrderCnt)
		.field("long_term_pic_num", &self.long_term_pic_num)
		.field("long_term_frame_idx", &self.long_term_frame_idx)
		.field("temporal_id", &self.temporal_id)
		.finish()
	}
}
/// struct `StdVideoEncodeH264SliceHeader` from vulkan_video_codec_h264std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH264SliceHeader {
	pub flags: StdVideoEncodeH264SliceHeaderFlags,
	pub first_mb_in_slice: u32,
	pub slice_type: StdVideoH264SliceType,
	pub slice_alpha_c0_offset_div2: i8,
	pub slice_beta_offset_div2: i8,
	pub slice_qp_delta: i8,
	pub reserved1: u8,
	pub cabac_init_idc: StdVideoH264CabacInitIdc,
	pub disable_deblocking_filter_idc: StdVideoH264DisableDeblockingFilterIdc,
	pub pWeightTable: *const StdVideoEncodeH264WeightTable,
}
impl Debug for StdVideoEncodeH264SliceHeader {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH264SliceHeader")
		.field("flags", &self.flags)
		.field("first_mb_in_slice", &self.first_mb_in_slice)
		.field("slice_type", &self.slice_type)
		.field("slice_alpha_c0_offset_div2", &self.slice_alpha_c0_offset_div2)
		.field("slice_beta_offset_div2", &self.slice_beta_offset_div2)
		.field("slice_qp_delta", &self.slice_qp_delta)
		.field("reserved1", &self.reserved1)
		.field("cabac_init_idc", &self.cabac_init_idc)
		.field("disable_deblocking_filter_idc", &self.disable_deblocking_filter_idc)
		.field("pWeightTable", &self.pWeightTable)
		.finish()
	}
}
/// trait for `vulkan_video_codec_h264std_encode`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vulkan_video_codec_h264std_encode.html>
pub trait vulkan_video_codec_h264std_encode: Debug {}
/// struct for `vulkan_video_codec_h264std_encode`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_h264std_encode {}
impl vulkan_video_codec_h264std_encode for Vulkan_video_codec_h264std_encode {}
impl Default for Vulkan_video_codec_h264std_encode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_h264std_encode {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkVideoEncodeH265CapabilityFlagsKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265CapabilityFlagsKHR.html>
pub type VkVideoEncodeH265CapabilityFlagsKHR = VkFlags;
/// type definition `VkVideoEncodeH265StdFlagsKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265StdFlagsKHR.html>
pub type VkVideoEncodeH265StdFlagsKHR = VkFlags;
/// type definition `VkVideoEncodeH265CtbSizeFlagsKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265CtbSizeFlagsKHR.html>
pub type VkVideoEncodeH265CtbSizeFlagsKHR = VkFlags;
/// type definition `VkVideoEncodeH265TransformBlockSizeFlagsKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265TransformBlockSizeFlagsKHR.html>
pub type VkVideoEncodeH265TransformBlockSizeFlagsKHR = VkFlags;
/// type definition `VkVideoEncodeH265RateControlFlagsKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265RateControlFlagsKHR.html>
pub type VkVideoEncodeH265RateControlFlagsKHR = VkFlags;
/// enum `VkVideoEncodeH265CapabilityFlagBitsKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265CapabilityFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeH265CapabilityFlagBitsKHR {
	VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR = 0x00000040,
	VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR = 0x00000080,
	VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR = 0x00000100,
	VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR = 0x00000200,
	VK_VIDEO_ENCODE_H265_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR = 0x00000800,
	VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR = 0x00000400,
	VK_VIDEO_ENCODE_H265_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeH265StdFlagBitsKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265StdFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeH265StdFlagBitsKHR {
	VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR = 0x00000040,
	VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR = 0x00000080,
	VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR = 0x00000100,
	VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR = 0x00000200,
	VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR = 0x00000400,
	VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR = 0x00000800,
	VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR = 0x00001000,
	VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR = 0x00002000,
	VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR = 0x00004000,
	VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR = 0x00008000,
	VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR = 0x00010000,
	VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR = 0x00020000,
	VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR = 0x00040000,
	VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR = 0x00080000,
	VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR = 0x00100000,
	VK_VIDEO_ENCODE_H265_STD_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeH265CtbSizeFlagBitsKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265CtbSizeFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeH265CtbSizeFlagBitsKHR {
	VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_CTB_SIZE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeH265TransformBlockSizeFlagBitsKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265TransformBlockSizeFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeH265TransformBlockSizeFlagBitsKHR {
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeH265RateControlFlagBitsKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265RateControlFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeH265RateControlFlagBitsKHR {
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_H265_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// struct `VkVideoEncodeH265CapabilitiesKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265CapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265CapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkVideoEncodeH265CapabilityFlagsKHR,
	pub maxLevelIdc: StdVideoH265LevelIdc,
	pub maxSliceSegmentCount: u32,
	pub maxTiles: VkExtent2D,
	pub ctbSizes: VkVideoEncodeH265CtbSizeFlagsKHR,
	pub transformBlockSizes: VkVideoEncodeH265TransformBlockSizeFlagsKHR,
	pub maxPPictureL0ReferenceCount: u32,
	pub maxBPictureL0ReferenceCount: u32,
	pub maxL1ReferenceCount: u32,
	pub maxSubLayerCount: u32,
	pub expectDyadicTemporalSubLayerPattern: VkBool32,
	pub minQp: i32,
	pub maxQp: i32,
	pub prefersGopRemainingFrames: VkBool32,
	pub requiresGopRemainingFrames: VkBool32,
	pub stdSyntaxFlags: VkVideoEncodeH265StdFlagsKHR,
}
impl Debug for VkVideoEncodeH265CapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265CapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("maxLevelIdc", &self.maxLevelIdc)
		.field("maxSliceSegmentCount", &self.maxSliceSegmentCount)
		.field("maxTiles", &self.maxTiles)
		.field("ctbSizes", &self.ctbSizes)
		.field("transformBlockSizes", &self.transformBlockSizes)
		.field("maxPPictureL0ReferenceCount", &self.maxPPictureL0ReferenceCount)
		.field("maxBPictureL0ReferenceCount", &self.maxBPictureL0ReferenceCount)
		.field("maxL1ReferenceCount", &self.maxL1ReferenceCount)
		.field("maxSubLayerCount", &self.maxSubLayerCount)
		.field("expectDyadicTemporalSubLayerPattern", &self.expectDyadicTemporalSubLayerPattern)
		.field("minQp", &self.minQp)
		.field("maxQp", &self.maxQp)
		.field("prefersGopRemainingFrames", &self.prefersGopRemainingFrames)
		.field("requiresGopRemainingFrames", &self.requiresGopRemainingFrames)
		.field("stdSyntaxFlags", &self.stdSyntaxFlags)
		.finish()
	}
}
/// struct `VkVideoEncodeH265SessionCreateInfoKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265SessionCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265SessionCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useMaxLevelIdc: VkBool32,
	pub maxLevelIdc: StdVideoH265LevelIdc,
}
impl Debug for VkVideoEncodeH265SessionCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265SessionCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("useMaxLevelIdc", &self.useMaxLevelIdc)
		.field("maxLevelIdc", &self.maxLevelIdc)
		.finish()
	}
}
/// struct `VkVideoEncodeH265QpKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265QpKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265QpKHR {
	pub qpI: i32,
	pub qpP: i32,
	pub qpB: i32,
}
impl Debug for VkVideoEncodeH265QpKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265QpKHR")
		.field("qpI", &self.qpI)
		.field("qpP", &self.qpP)
		.field("qpB", &self.qpB)
		.finish()
	}
}
/// struct `VkVideoEncodeH265QualityLevelPropertiesKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265QualityLevelPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265QualityLevelPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub preferredRateControlFlags: VkVideoEncodeH265RateControlFlagsKHR,
	pub preferredGopFrameCount: u32,
	pub preferredIdrPeriod: u32,
	pub preferredConsecutiveBFrameCount: u32,
	pub preferredSubLayerCount: u32,
	pub preferredConstantQp: VkVideoEncodeH265QpKHR,
	pub preferredMaxL0ReferenceCount: u32,
	pub preferredMaxL1ReferenceCount: u32,
}
impl Debug for VkVideoEncodeH265QualityLevelPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265QualityLevelPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("preferredRateControlFlags", &self.preferredRateControlFlags)
		.field("preferredGopFrameCount", &self.preferredGopFrameCount)
		.field("preferredIdrPeriod", &self.preferredIdrPeriod)
		.field("preferredConsecutiveBFrameCount", &self.preferredConsecutiveBFrameCount)
		.field("preferredSubLayerCount", &self.preferredSubLayerCount)
		.field("preferredConstantQp", &self.preferredConstantQp)
		.field("preferredMaxL0ReferenceCount", &self.preferredMaxL0ReferenceCount)
		.field("preferredMaxL1ReferenceCount", &self.preferredMaxL1ReferenceCount)
		.finish()
	}
}
/// struct `VkVideoEncodeH265SessionParametersAddInfoKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265SessionParametersAddInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265SessionParametersAddInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdVPSCount: u32,
	pub pStdVPSs: *const StdVideoH265VideoParameterSet,
	pub stdSPSCount: u32,
	pub pStdSPSs: *const StdVideoH265SequenceParameterSet,
	pub stdPPSCount: u32,
	pub pStdPPSs: *const StdVideoH265PictureParameterSet,
}
impl Debug for VkVideoEncodeH265SessionParametersAddInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265SessionParametersAddInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stdVPSCount", &self.stdVPSCount)
		.field("pStdVPSs", &self.pStdVPSs)
		.field("stdSPSCount", &self.stdSPSCount)
		.field("pStdSPSs", &self.pStdSPSs)
		.field("stdPPSCount", &self.stdPPSCount)
		.field("pStdPPSs", &self.pStdPPSs)
		.finish()
	}
}
/// struct `VkVideoEncodeH265SessionParametersCreateInfoKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265SessionParametersCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265SessionParametersCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maxStdVPSCount: u32,
	pub maxStdSPSCount: u32,
	pub maxStdPPSCount: u32,
	pub pParametersAddInfo: *const VkVideoEncodeH265SessionParametersAddInfoKHR,
}
impl Debug for VkVideoEncodeH265SessionParametersCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265SessionParametersCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxStdVPSCount", &self.maxStdVPSCount)
		.field("maxStdSPSCount", &self.maxStdSPSCount)
		.field("maxStdPPSCount", &self.maxStdPPSCount)
		.field("pParametersAddInfo", &self.pParametersAddInfo)
		.finish()
	}
}
/// struct `VkVideoEncodeH265SessionParametersGetInfoKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265SessionParametersGetInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265SessionParametersGetInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub writeStdVPS: VkBool32,
	pub writeStdSPS: VkBool32,
	pub writeStdPPS: VkBool32,
	pub stdVPSId: u32,
	pub stdSPSId: u32,
	pub stdPPSId: u32,
}
impl Debug for VkVideoEncodeH265SessionParametersGetInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265SessionParametersGetInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("writeStdVPS", &self.writeStdVPS)
		.field("writeStdSPS", &self.writeStdSPS)
		.field("writeStdPPS", &self.writeStdPPS)
		.field("stdVPSId", &self.stdVPSId)
		.field("stdSPSId", &self.stdSPSId)
		.field("stdPPSId", &self.stdPPSId)
		.finish()
	}
}
/// struct `VkVideoEncodeH265SessionParametersFeedbackInfoKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265SessionParametersFeedbackInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265SessionParametersFeedbackInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub hasStdVPSOverrides: VkBool32,
	pub hasStdSPSOverrides: VkBool32,
	pub hasStdPPSOverrides: VkBool32,
}
impl Debug for VkVideoEncodeH265SessionParametersFeedbackInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265SessionParametersFeedbackInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("hasStdVPSOverrides", &self.hasStdVPSOverrides)
		.field("hasStdSPSOverrides", &self.hasStdSPSOverrides)
		.field("hasStdPPSOverrides", &self.hasStdPPSOverrides)
		.finish()
	}
}
/// struct `VkVideoEncodeH265NaluSliceSegmentInfoKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265NaluSliceSegmentInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265NaluSliceSegmentInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub constantQp: i32,
	pub pStdSliceSegmentHeader: *const StdVideoEncodeH265SliceSegmentHeader,
}
impl Debug for VkVideoEncodeH265NaluSliceSegmentInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265NaluSliceSegmentInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("constantQp", &self.constantQp)
		.field("pStdSliceSegmentHeader", &self.pStdSliceSegmentHeader)
		.finish()
	}
}
/// struct `VkVideoEncodeH265PictureInfoKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265PictureInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265PictureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub naluSliceSegmentEntryCount: u32,
	pub pNaluSliceSegmentEntries: *const VkVideoEncodeH265NaluSliceSegmentInfoKHR,
	pub pStdPictureInfo: *const StdVideoEncodeH265PictureInfo,
}
impl Debug for VkVideoEncodeH265PictureInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265PictureInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("naluSliceSegmentEntryCount", &self.naluSliceSegmentEntryCount)
		.field("pNaluSliceSegmentEntries", &self.pNaluSliceSegmentEntries)
		.field("pStdPictureInfo", &self.pStdPictureInfo)
		.finish()
	}
}
/// struct `VkVideoEncodeH265DpbSlotInfoKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265DpbSlotInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265DpbSlotInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdReferenceInfo: *const StdVideoEncodeH265ReferenceInfo,
}
impl Debug for VkVideoEncodeH265DpbSlotInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265DpbSlotInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pStdReferenceInfo", &self.pStdReferenceInfo)
		.finish()
	}
}
/// struct `VkVideoEncodeH265ProfileInfoKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265ProfileInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265ProfileInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdProfileIdc: StdVideoH265ProfileIdc,
}
impl Debug for VkVideoEncodeH265ProfileInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265ProfileInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stdProfileIdc", &self.stdProfileIdc)
		.finish()
	}
}
/// struct `VkVideoEncodeH265RateControlInfoKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265RateControlInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265RateControlInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoEncodeH265RateControlFlagsKHR,
	pub gopFrameCount: u32,
	pub idrPeriod: u32,
	pub consecutiveBFrameCount: u32,
	pub subLayerCount: u32,
}
impl Debug for VkVideoEncodeH265RateControlInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265RateControlInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("gopFrameCount", &self.gopFrameCount)
		.field("idrPeriod", &self.idrPeriod)
		.field("consecutiveBFrameCount", &self.consecutiveBFrameCount)
		.field("subLayerCount", &self.subLayerCount)
		.finish()
	}
}
/// struct `VkVideoEncodeH265FrameSizeKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265FrameSizeKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265FrameSizeKHR {
	pub frameISize: u32,
	pub framePSize: u32,
	pub frameBSize: u32,
}
impl Debug for VkVideoEncodeH265FrameSizeKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265FrameSizeKHR")
		.field("frameISize", &self.frameISize)
		.field("framePSize", &self.framePSize)
		.field("frameBSize", &self.frameBSize)
		.finish()
	}
}
/// struct `VkVideoEncodeH265RateControlLayerInfoKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265RateControlLayerInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265RateControlLayerInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useMinQp: VkBool32,
	pub minQp: VkVideoEncodeH265QpKHR,
	pub useMaxQp: VkBool32,
	pub maxQp: VkVideoEncodeH265QpKHR,
	pub useMaxFrameSize: VkBool32,
	pub maxFrameSize: VkVideoEncodeH265FrameSizeKHR,
}
impl Debug for VkVideoEncodeH265RateControlLayerInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265RateControlLayerInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("useMinQp", &self.useMinQp)
		.field("minQp", &self.minQp)
		.field("useMaxQp", &self.useMaxQp)
		.field("maxQp", &self.maxQp)
		.field("useMaxFrameSize", &self.useMaxFrameSize)
		.field("maxFrameSize", &self.maxFrameSize)
		.finish()
	}
}
/// struct `VkVideoEncodeH265GopRemainingFrameInfoKHR` from VK_KHR_video_encode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265GopRemainingFrameInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265GopRemainingFrameInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useGopRemainingFrames: VkBool32,
	pub gopRemainingI: u32,
	pub gopRemainingP: u32,
	pub gopRemainingB: u32,
}
impl Debug for VkVideoEncodeH265GopRemainingFrameInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265GopRemainingFrameInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("useGopRemainingFrames", &self.useGopRemainingFrames)
		.field("gopRemainingI", &self.gopRemainingI)
		.field("gopRemainingP", &self.gopRemainingP)
		.field("gopRemainingB", &self.gopRemainingB)
		.finish()
	}
}
/// trait for `VK_KHR_video_encode_h265`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_video_encode_h265.html>
pub trait VK_KHR_video_encode_h265: Debug {}
/// struct for `VK_KHR_video_encode_h265`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_encode_h265 {}
impl VK_KHR_video_encode_h265 for Vulkan_KHR_video_encode_h265 {}
impl Default for Vulkan_KHR_video_encode_h265 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_encode_h265 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `STD_VIDEO_H265_CPB_CNT_LIST_SIZE` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_CPB_CNT_LIST_SIZE.html>
pub const STD_VIDEO_H265_CPB_CNT_LIST_SIZE: u32 = 32u32;
/// constant `STD_VIDEO_H265_SUBLAYERS_LIST_SIZE` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_SUBLAYERS_LIST_SIZE.html>
pub const STD_VIDEO_H265_SUBLAYERS_LIST_SIZE: u32 = 7u32;
/// constant `STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS.html>
pub const STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS: u32 = 6u32;
/// constant `STD_VIDEO_H265_SCALING_LIST_4X4_NUM_ELEMENTS` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_SCALING_LIST_4X4_NUM_ELEMENTS.html>
pub const STD_VIDEO_H265_SCALING_LIST_4X4_NUM_ELEMENTS: u32 = 16u32;
/// constant `STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS.html>
pub const STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS: u32 = 6u32;
/// constant `STD_VIDEO_H265_SCALING_LIST_8X8_NUM_ELEMENTS` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_SCALING_LIST_8X8_NUM_ELEMENTS.html>
pub const STD_VIDEO_H265_SCALING_LIST_8X8_NUM_ELEMENTS: u32 = 64u32;
/// constant `STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS.html>
pub const STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS: u32 = 6u32;
/// constant `STD_VIDEO_H265_SCALING_LIST_16X16_NUM_ELEMENTS` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_SCALING_LIST_16X16_NUM_ELEMENTS.html>
pub const STD_VIDEO_H265_SCALING_LIST_16X16_NUM_ELEMENTS: u32 = 64u32;
/// constant `STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS.html>
pub const STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS: u32 = 2u32;
/// constant `STD_VIDEO_H265_SCALING_LIST_32X32_NUM_ELEMENTS` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_SCALING_LIST_32X32_NUM_ELEMENTS.html>
pub const STD_VIDEO_H265_SCALING_LIST_32X32_NUM_ELEMENTS: u32 = 64u32;
/// constant `STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE.html>
pub const STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE: u32 = 6u32;
/// constant `STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE.html>
pub const STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE: u32 = 19u32;
/// constant `STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE.html>
pub const STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE: u32 = 21u32;
/// constant `STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE.html>
pub const STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE: u32 = 3u32;
/// constant `STD_VIDEO_H265_PREDICTOR_PALETTE_COMP_ENTRIES_LIST_SIZE` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_PREDICTOR_PALETTE_COMP_ENTRIES_LIST_SIZE.html>
pub const STD_VIDEO_H265_PREDICTOR_PALETTE_COMP_ENTRIES_LIST_SIZE: u32 = 128u32;
/// constant `STD_VIDEO_H265_MAX_NUM_LIST_REF` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_MAX_NUM_LIST_REF.html>
pub const STD_VIDEO_H265_MAX_NUM_LIST_REF: u32 = 15u32;
/// constant `STD_VIDEO_H265_MAX_CHROMA_PLANES` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_MAX_CHROMA_PLANES.html>
pub const STD_VIDEO_H265_MAX_CHROMA_PLANES: u32 = 2u32;
/// constant `STD_VIDEO_H265_MAX_SHORT_TERM_REF_PIC_SETS` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_MAX_SHORT_TERM_REF_PIC_SETS.html>
pub const STD_VIDEO_H265_MAX_SHORT_TERM_REF_PIC_SETS: u32 = 64u32;
/// constant `STD_VIDEO_H265_MAX_DPB_SIZE` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_MAX_DPB_SIZE.html>
pub const STD_VIDEO_H265_MAX_DPB_SIZE: u32 = 16u32;
/// constant `STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS.html>
pub const STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS: u32 = 32u32;
/// constant `STD_VIDEO_H265_MAX_LONG_TERM_PICS` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_MAX_LONG_TERM_PICS.html>
pub const STD_VIDEO_H265_MAX_LONG_TERM_PICS: u32 = 16u32;
/// constant `STD_VIDEO_H265_MAX_DELTA_POC` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_MAX_DELTA_POC.html>
pub const STD_VIDEO_H265_MAX_DELTA_POC: u32 = 48u32;
/// constant `STD_VIDEO_H265_NO_REFERENCE_PICTURE` from vulkan_video_codec_h265std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_H265_NO_REFERENCE_PICTURE.html>
pub const STD_VIDEO_H265_NO_REFERENCE_PICTURE: u32 = 0xffu32;
/// enum `StdVideoH265ChromaFormatIdc` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH265ChromaFormatIdc {
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_MONOCHROME = 0,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_420 = 1,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_422 = 2,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_444 = 3,
	STD_VIDEO_H265_CHROMA_FORMAT_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH265ChromaFormatIdc {
	pub const STD_VIDEO_H265_CHROMA_FORMAT_IDC_MAX_ENUM: StdVideoH265ChromaFormatIdc = StdVideoH265ChromaFormatIdc::STD_VIDEO_H265_CHROMA_FORMAT_IDC_INVALID;
}
/// enum `StdVideoH265ProfileIdc` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH265ProfileIdc {
	STD_VIDEO_H265_PROFILE_IDC_MAIN = 1,
	STD_VIDEO_H265_PROFILE_IDC_MAIN_10 = 2,
	STD_VIDEO_H265_PROFILE_IDC_MAIN_STILL_PICTURE = 3,
	STD_VIDEO_H265_PROFILE_IDC_FORMAT_RANGE_EXTENSIONS = 4,
	STD_VIDEO_H265_PROFILE_IDC_SCC_EXTENSIONS = 9,
	STD_VIDEO_H265_PROFILE_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH265ProfileIdc {
	pub const STD_VIDEO_H265_PROFILE_IDC_MAX_ENUM: StdVideoH265ProfileIdc = StdVideoH265ProfileIdc::STD_VIDEO_H265_PROFILE_IDC_INVALID;
}
/// enum `StdVideoH265LevelIdc` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH265LevelIdc {
	STD_VIDEO_H265_LEVEL_IDC_1_0 = 0,
	STD_VIDEO_H265_LEVEL_IDC_2_0 = 1,
	STD_VIDEO_H265_LEVEL_IDC_2_1 = 2,
	STD_VIDEO_H265_LEVEL_IDC_3_0 = 3,
	STD_VIDEO_H265_LEVEL_IDC_3_1 = 4,
	STD_VIDEO_H265_LEVEL_IDC_4_0 = 5,
	STD_VIDEO_H265_LEVEL_IDC_4_1 = 6,
	STD_VIDEO_H265_LEVEL_IDC_5_0 = 7,
	STD_VIDEO_H265_LEVEL_IDC_5_1 = 8,
	STD_VIDEO_H265_LEVEL_IDC_5_2 = 9,
	STD_VIDEO_H265_LEVEL_IDC_6_0 = 10,
	STD_VIDEO_H265_LEVEL_IDC_6_1 = 11,
	STD_VIDEO_H265_LEVEL_IDC_6_2 = 12,
	STD_VIDEO_H265_LEVEL_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH265LevelIdc {
	pub const STD_VIDEO_H265_LEVEL_IDC_MAX_ENUM: StdVideoH265LevelIdc = StdVideoH265LevelIdc::STD_VIDEO_H265_LEVEL_IDC_INVALID;
}
/// enum `StdVideoH265SliceType` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH265SliceType {
	STD_VIDEO_H265_SLICE_TYPE_B = 0,
	STD_VIDEO_H265_SLICE_TYPE_P = 1,
	STD_VIDEO_H265_SLICE_TYPE_I = 2,
	STD_VIDEO_H265_SLICE_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoH265SliceType {
	pub const STD_VIDEO_H265_SLICE_TYPE_MAX_ENUM: StdVideoH265SliceType = StdVideoH265SliceType::STD_VIDEO_H265_SLICE_TYPE_INVALID;
}
/// enum `StdVideoH265PictureType` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH265PictureType {
	STD_VIDEO_H265_PICTURE_TYPE_P = 0,
	STD_VIDEO_H265_PICTURE_TYPE_B = 1,
	STD_VIDEO_H265_PICTURE_TYPE_I = 2,
	STD_VIDEO_H265_PICTURE_TYPE_IDR = 3,
	STD_VIDEO_H265_PICTURE_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoH265PictureType {
	pub const STD_VIDEO_H265_PICTURE_TYPE_MAX_ENUM: StdVideoH265PictureType = StdVideoH265PictureType::STD_VIDEO_H265_PICTURE_TYPE_INVALID;
}
/// enum `StdVideoH265AspectRatioIdc` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoH265AspectRatioIdc {
	STD_VIDEO_H265_ASPECT_RATIO_IDC_UNSPECIFIED = 0,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_SQUARE = 1,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_12_11 = 2,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_10_11 = 3,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_16_11 = 4,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_40_33 = 5,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_24_11 = 6,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_20_11 = 7,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_32_11 = 8,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_80_33 = 9,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_18_11 = 10,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_15_11 = 11,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_64_33 = 12,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_160_99 = 13,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_4_3 = 14,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_3_2 = 15,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_2_1 = 16,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_EXTENDED_SAR = 255,
	STD_VIDEO_H265_ASPECT_RATIO_IDC_INVALID = 0x7fffffff,
}
impl StdVideoH265AspectRatioIdc {
	pub const STD_VIDEO_H265_ASPECT_RATIO_IDC_MAX_ENUM: StdVideoH265AspectRatioIdc = StdVideoH265AspectRatioIdc::STD_VIDEO_H265_ASPECT_RATIO_IDC_INVALID;
}
/// struct `StdVideoH265DecPicBufMgr` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265DecPicBufMgr {
	pub max_latency_increase_plus1: [u32; STD_VIDEO_H265_SUBLAYERS_LIST_SIZE as usize],
	pub max_dec_pic_buffering_minus1: [u8; STD_VIDEO_H265_SUBLAYERS_LIST_SIZE as usize],
	pub max_num_reorder_pics: [u8; STD_VIDEO_H265_SUBLAYERS_LIST_SIZE as usize],
}
impl Debug for StdVideoH265DecPicBufMgr {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265DecPicBufMgr")
		.field("max_latency_increase_plus1", &self.max_latency_increase_plus1)
		.field("max_dec_pic_buffering_minus1", &self.max_dec_pic_buffering_minus1)
		.field("max_num_reorder_pics", &self.max_num_reorder_pics)
		.finish()
	}
}
/// struct `StdVideoH265SubLayerHrdParameters` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265SubLayerHrdParameters {
	pub bit_rate_value_minus1: [u32; STD_VIDEO_H265_CPB_CNT_LIST_SIZE as usize],
	pub cpb_size_value_minus1: [u32; STD_VIDEO_H265_CPB_CNT_LIST_SIZE as usize],
	pub cpb_size_du_value_minus1: [u32; STD_VIDEO_H265_CPB_CNT_LIST_SIZE as usize],
	pub bit_rate_du_value_minus1: [u32; STD_VIDEO_H265_CPB_CNT_LIST_SIZE as usize],
	pub cbr_flag: u32,
}
impl Debug for StdVideoH265SubLayerHrdParameters {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265SubLayerHrdParameters")
		.field("bit_rate_value_minus1", &self.bit_rate_value_minus1)
		.field("cpb_size_value_minus1", &self.cpb_size_value_minus1)
		.field("cpb_size_du_value_minus1", &self.cpb_size_du_value_minus1)
		.field("bit_rate_du_value_minus1", &self.bit_rate_du_value_minus1)
		.field("cbr_flag", &self.cbr_flag)
		.finish()
	}
}
/// struct `StdVideoH265HrdFlags` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265HrdFlags {
	/// Bitfield: nal_hrd_parameters_present_flag: u32 in 1 bits
	/// Bitfield: vcl_hrd_parameters_present_flag: u32 in 1 bits
	/// Bitfield: sub_pic_hrd_params_present_flag: u32 in 1 bits
	/// Bitfield: sub_pic_cpb_params_in_pic_timing_sei_flag: u32 in 1 bits
	/// Bitfield: fixed_pic_rate_general_flag: u32 in 8 bits
	/// Bitfield: fixed_pic_rate_within_cvs_flag: u32 in 8 bits
	/// Bitfield: low_delay_hrd_flag: u32 in 8 bits
	pub bitfield1: u32,
}
impl StdVideoH265HrdFlags {
	pub fn get_nal_hrd_parameters_present_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_nal_hrd_parameters_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_vcl_hrd_parameters_present_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_vcl_hrd_parameters_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_sub_pic_hrd_params_present_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_sub_pic_hrd_params_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_sub_pic_cpb_params_in_pic_timing_sei_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_sub_pic_cpb_params_in_pic_timing_sei_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_fixed_pic_rate_general_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0xff
	}
	pub fn set_fixed_pic_rate_general_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0xff) << 4;
	}
	pub fn get_fixed_pic_rate_within_cvs_flag(&self) -> u32 {
		(self.bitfield1 >> 12) & 0xff
	}
	pub fn set_fixed_pic_rate_within_cvs_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0xff) << 12;
	}
	pub fn get_low_delay_hrd_flag(&self) -> u32 {
		(self.bitfield1 >> 20) & 0xff
	}
	pub fn set_low_delay_hrd_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0xff) << 20;
	}
}
impl Debug for StdVideoH265HrdFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265HrdFlags")
		.field("nal_hrd_parameters_present_flag", &self.get_nal_hrd_parameters_present_flag())
		.field("vcl_hrd_parameters_present_flag", &self.get_vcl_hrd_parameters_present_flag())
		.field("sub_pic_hrd_params_present_flag", &self.get_sub_pic_hrd_params_present_flag())
		.field("sub_pic_cpb_params_in_pic_timing_sei_flag", &self.get_sub_pic_cpb_params_in_pic_timing_sei_flag())
		.field("fixed_pic_rate_general_flag", &self.get_fixed_pic_rate_general_flag())
		.field("fixed_pic_rate_within_cvs_flag", &self.get_fixed_pic_rate_within_cvs_flag())
		.field("low_delay_hrd_flag", &self.get_low_delay_hrd_flag())
		.finish()
	}
}
/// struct `StdVideoH265HrdParameters` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265HrdParameters {
	pub flags: StdVideoH265HrdFlags,
	pub tick_divisor_minus2: u8,
	pub du_cpb_removal_delay_increment_length_minus1: u8,
	pub dpb_output_delay_du_length_minus1: u8,
	pub bit_rate_scale: u8,
	pub cpb_size_scale: u8,
	pub cpb_size_du_scale: u8,
	pub initial_cpb_removal_delay_length_minus1: u8,
	pub au_cpb_removal_delay_length_minus1: u8,
	pub dpb_output_delay_length_minus1: u8,
	pub cpb_cnt_minus1: [u8; STD_VIDEO_H265_SUBLAYERS_LIST_SIZE as usize],
	pub elemental_duration_in_tc_minus1: [u16; STD_VIDEO_H265_SUBLAYERS_LIST_SIZE as usize],
	pub reserved: [u16; 3 as usize],
	pub pSubLayerHrdParametersNal: *const StdVideoH265SubLayerHrdParameters,
	pub pSubLayerHrdParametersVcl: *const StdVideoH265SubLayerHrdParameters,
}
impl Debug for StdVideoH265HrdParameters {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265HrdParameters")
		.field("flags", &self.flags)
		.field("tick_divisor_minus2", &self.tick_divisor_minus2)
		.field("du_cpb_removal_delay_increment_length_minus1", &self.du_cpb_removal_delay_increment_length_minus1)
		.field("dpb_output_delay_du_length_minus1", &self.dpb_output_delay_du_length_minus1)
		.field("bit_rate_scale", &self.bit_rate_scale)
		.field("cpb_size_scale", &self.cpb_size_scale)
		.field("cpb_size_du_scale", &self.cpb_size_du_scale)
		.field("initial_cpb_removal_delay_length_minus1", &self.initial_cpb_removal_delay_length_minus1)
		.field("au_cpb_removal_delay_length_minus1", &self.au_cpb_removal_delay_length_minus1)
		.field("dpb_output_delay_length_minus1", &self.dpb_output_delay_length_minus1)
		.field("cpb_cnt_minus1", &self.cpb_cnt_minus1)
		.field("elemental_duration_in_tc_minus1", &self.elemental_duration_in_tc_minus1)
		.field("reserved", &self.reserved)
		.field("pSubLayerHrdParametersNal", &self.pSubLayerHrdParametersNal)
		.field("pSubLayerHrdParametersVcl", &self.pSubLayerHrdParametersVcl)
		.finish()
	}
}
/// struct `StdVideoH265VpsFlags` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265VpsFlags {
	/// Bitfield: vps_temporal_id_nesting_flag: u32 in 1 bits
	/// Bitfield: vps_sub_layer_ordering_info_present_flag: u32 in 1 bits
	/// Bitfield: vps_timing_info_present_flag: u32 in 1 bits
	/// Bitfield: vps_poc_proportional_to_timing_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH265VpsFlags {
	pub fn get_vps_temporal_id_nesting_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_vps_temporal_id_nesting_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_vps_sub_layer_ordering_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_vps_sub_layer_ordering_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_vps_timing_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_vps_timing_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_vps_poc_proportional_to_timing_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_vps_poc_proportional_to_timing_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
}
impl Debug for StdVideoH265VpsFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265VpsFlags")
		.field("vps_temporal_id_nesting_flag", &self.get_vps_temporal_id_nesting_flag())
		.field("vps_sub_layer_ordering_info_present_flag", &self.get_vps_sub_layer_ordering_info_present_flag())
		.field("vps_timing_info_present_flag", &self.get_vps_timing_info_present_flag())
		.field("vps_poc_proportional_to_timing_flag", &self.get_vps_poc_proportional_to_timing_flag())
		.finish()
	}
}
/// struct `StdVideoH265ProfileTierLevelFlags` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265ProfileTierLevelFlags {
	/// Bitfield: general_tier_flag: u32 in 1 bits
	/// Bitfield: general_progressive_source_flag: u32 in 1 bits
	/// Bitfield: general_interlaced_source_flag: u32 in 1 bits
	/// Bitfield: general_non_packed_constraint_flag: u32 in 1 bits
	/// Bitfield: general_frame_only_constraint_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH265ProfileTierLevelFlags {
	pub fn get_general_tier_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_general_tier_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_general_progressive_source_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_general_progressive_source_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_general_interlaced_source_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_general_interlaced_source_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_general_non_packed_constraint_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_general_non_packed_constraint_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_general_frame_only_constraint_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_general_frame_only_constraint_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
}
impl Debug for StdVideoH265ProfileTierLevelFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265ProfileTierLevelFlags")
		.field("general_tier_flag", &self.get_general_tier_flag())
		.field("general_progressive_source_flag", &self.get_general_progressive_source_flag())
		.field("general_interlaced_source_flag", &self.get_general_interlaced_source_flag())
		.field("general_non_packed_constraint_flag", &self.get_general_non_packed_constraint_flag())
		.field("general_frame_only_constraint_flag", &self.get_general_frame_only_constraint_flag())
		.finish()
	}
}
/// struct `StdVideoH265ProfileTierLevel` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265ProfileTierLevel {
	pub flags: StdVideoH265ProfileTierLevelFlags,
	pub general_profile_idc: StdVideoH265ProfileIdc,
	pub general_level_idc: StdVideoH265LevelIdc,
}
impl Debug for StdVideoH265ProfileTierLevel {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265ProfileTierLevel")
		.field("flags", &self.flags)
		.field("general_profile_idc", &self.general_profile_idc)
		.field("general_level_idc", &self.general_level_idc)
		.finish()
	}
}
/// struct `StdVideoH265VideoParameterSet` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265VideoParameterSet {
	pub flags: StdVideoH265VpsFlags,
	pub vps_video_parameter_set_id: u8,
	pub vps_max_sub_layers_minus1: u8,
	pub reserved1: u8,
	pub reserved2: u8,
	pub vps_num_units_in_tick: u32,
	pub vps_time_scale: u32,
	pub vps_num_ticks_poc_diff_one_minus1: u32,
	pub reserved3: u32,
	pub pDecPicBufMgr: *const StdVideoH265DecPicBufMgr,
	pub pHrdParameters: *const StdVideoH265HrdParameters,
	pub pProfileTierLevel: *const StdVideoH265ProfileTierLevel,
}
impl Debug for StdVideoH265VideoParameterSet {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265VideoParameterSet")
		.field("flags", &self.flags)
		.field("vps_video_parameter_set_id", &self.vps_video_parameter_set_id)
		.field("vps_max_sub_layers_minus1", &self.vps_max_sub_layers_minus1)
		.field("reserved1", &self.reserved1)
		.field("reserved2", &self.reserved2)
		.field("vps_num_units_in_tick", &self.vps_num_units_in_tick)
		.field("vps_time_scale", &self.vps_time_scale)
		.field("vps_num_ticks_poc_diff_one_minus1", &self.vps_num_ticks_poc_diff_one_minus1)
		.field("reserved3", &self.reserved3)
		.field("pDecPicBufMgr", &self.pDecPicBufMgr)
		.field("pHrdParameters", &self.pHrdParameters)
		.field("pProfileTierLevel", &self.pProfileTierLevel)
		.finish()
	}
}
/// struct `StdVideoH265ScalingLists` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265ScalingLists {
	pub ScalingList4x4: [[u8; STD_VIDEO_H265_SCALING_LIST_4X4_NUM_ELEMENTS as usize]; STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS as usize],
	pub ScalingList8x8: [[u8; STD_VIDEO_H265_SCALING_LIST_8X8_NUM_ELEMENTS as usize]; STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS as usize],
	pub ScalingList16x16: [[u8; STD_VIDEO_H265_SCALING_LIST_16X16_NUM_ELEMENTS as usize]; STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS as usize],
	pub ScalingList32x32: [[u8; STD_VIDEO_H265_SCALING_LIST_32X32_NUM_ELEMENTS as usize]; STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS as usize],
	pub ScalingListDCCoef16x16: [u8; STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS as usize],
	pub ScalingListDCCoef32x32: [u8; STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS as usize],
}
impl Debug for StdVideoH265ScalingLists {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265ScalingLists")
		.field("ScalingList4x4", &self.ScalingList4x4)
		.field("ScalingList8x8", &self.ScalingList8x8)
		.field("ScalingList16x16", &self.ScalingList16x16)
		.field("ScalingList32x32", &self.ScalingList32x32)
		.field("ScalingListDCCoef16x16", &self.ScalingListDCCoef16x16)
		.field("ScalingListDCCoef32x32", &self.ScalingListDCCoef32x32)
		.finish()
	}
}
/// struct `StdVideoH265SpsVuiFlags` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265SpsVuiFlags {
	/// Bitfield: aspect_ratio_info_present_flag: u32 in 1 bits
	/// Bitfield: overscan_info_present_flag: u32 in 1 bits
	/// Bitfield: overscan_appropriate_flag: u32 in 1 bits
	/// Bitfield: video_signal_type_present_flag: u32 in 1 bits
	/// Bitfield: video_full_range_flag: u32 in 1 bits
	/// Bitfield: colour_description_present_flag: u32 in 1 bits
	/// Bitfield: chroma_loc_info_present_flag: u32 in 1 bits
	/// Bitfield: neutral_chroma_indication_flag: u32 in 1 bits
	/// Bitfield: field_seq_flag: u32 in 1 bits
	/// Bitfield: frame_field_info_present_flag: u32 in 1 bits
	/// Bitfield: default_display_window_flag: u32 in 1 bits
	/// Bitfield: vui_timing_info_present_flag: u32 in 1 bits
	/// Bitfield: vui_poc_proportional_to_timing_flag: u32 in 1 bits
	/// Bitfield: vui_hrd_parameters_present_flag: u32 in 1 bits
	/// Bitfield: bitstream_restriction_flag: u32 in 1 bits
	/// Bitfield: tiles_fixed_structure_flag: u32 in 1 bits
	/// Bitfield: motion_vectors_over_pic_boundaries_flag: u32 in 1 bits
	/// Bitfield: restricted_ref_pic_lists_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH265SpsVuiFlags {
	pub fn get_aspect_ratio_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_aspect_ratio_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_overscan_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_overscan_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_overscan_appropriate_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_overscan_appropriate_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_video_signal_type_present_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_video_signal_type_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_video_full_range_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_video_full_range_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_colour_description_present_flag(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_colour_description_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_chroma_loc_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_chroma_loc_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_neutral_chroma_indication_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_neutral_chroma_indication_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_field_seq_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_field_seq_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_frame_field_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_frame_field_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_default_display_window_flag(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_default_display_window_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_vui_timing_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_vui_timing_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
	pub fn get_vui_poc_proportional_to_timing_flag(&self) -> u32 {
		(self.bitfield1 >> 12) & 0x1
	}
	pub fn set_vui_poc_proportional_to_timing_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 12;
	}
	pub fn get_vui_hrd_parameters_present_flag(&self) -> u32 {
		(self.bitfield1 >> 13) & 0x1
	}
	pub fn set_vui_hrd_parameters_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 13;
	}
	pub fn get_bitstream_restriction_flag(&self) -> u32 {
		(self.bitfield1 >> 14) & 0x1
	}
	pub fn set_bitstream_restriction_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 14;
	}
	pub fn get_tiles_fixed_structure_flag(&self) -> u32 {
		(self.bitfield1 >> 15) & 0x1
	}
	pub fn set_tiles_fixed_structure_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 15;
	}
	pub fn get_motion_vectors_over_pic_boundaries_flag(&self) -> u32 {
		(self.bitfield1 >> 16) & 0x1
	}
	pub fn set_motion_vectors_over_pic_boundaries_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 16;
	}
	pub fn get_restricted_ref_pic_lists_flag(&self) -> u32 {
		(self.bitfield1 >> 17) & 0x1
	}
	pub fn set_restricted_ref_pic_lists_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 17;
	}
}
impl Debug for StdVideoH265SpsVuiFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265SpsVuiFlags")
		.field("aspect_ratio_info_present_flag", &self.get_aspect_ratio_info_present_flag())
		.field("overscan_info_present_flag", &self.get_overscan_info_present_flag())
		.field("overscan_appropriate_flag", &self.get_overscan_appropriate_flag())
		.field("video_signal_type_present_flag", &self.get_video_signal_type_present_flag())
		.field("video_full_range_flag", &self.get_video_full_range_flag())
		.field("colour_description_present_flag", &self.get_colour_description_present_flag())
		.field("chroma_loc_info_present_flag", &self.get_chroma_loc_info_present_flag())
		.field("neutral_chroma_indication_flag", &self.get_neutral_chroma_indication_flag())
		.field("field_seq_flag", &self.get_field_seq_flag())
		.field("frame_field_info_present_flag", &self.get_frame_field_info_present_flag())
		.field("default_display_window_flag", &self.get_default_display_window_flag())
		.field("vui_timing_info_present_flag", &self.get_vui_timing_info_present_flag())
		.field("vui_poc_proportional_to_timing_flag", &self.get_vui_poc_proportional_to_timing_flag())
		.field("vui_hrd_parameters_present_flag", &self.get_vui_hrd_parameters_present_flag())
		.field("bitstream_restriction_flag", &self.get_bitstream_restriction_flag())
		.field("tiles_fixed_structure_flag", &self.get_tiles_fixed_structure_flag())
		.field("motion_vectors_over_pic_boundaries_flag", &self.get_motion_vectors_over_pic_boundaries_flag())
		.field("restricted_ref_pic_lists_flag", &self.get_restricted_ref_pic_lists_flag())
		.finish()
	}
}
/// struct `StdVideoH265SequenceParameterSetVui` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265SequenceParameterSetVui {
	pub flags: StdVideoH265SpsVuiFlags,
	pub aspect_ratio_idc: StdVideoH265AspectRatioIdc,
	pub sar_width: u16,
	pub sar_height: u16,
	pub video_format: u8,
	pub colour_primaries: u8,
	pub transfer_characteristics: u8,
	pub matrix_coeffs: u8,
	pub chroma_sample_loc_type_top_field: u8,
	pub chroma_sample_loc_type_bottom_field: u8,
	pub reserved1: u8,
	pub reserved2: u8,
	pub def_disp_win_left_offset: u16,
	pub def_disp_win_right_offset: u16,
	pub def_disp_win_top_offset: u16,
	pub def_disp_win_bottom_offset: u16,
	pub vui_num_units_in_tick: u32,
	pub vui_time_scale: u32,
	pub vui_num_ticks_poc_diff_one_minus1: u32,
	pub min_spatial_segmentation_idc: u16,
	pub reserved3: u16,
	pub max_bytes_per_pic_denom: u8,
	pub max_bits_per_min_cu_denom: u8,
	pub log2_max_mv_length_horizontal: u8,
	pub log2_max_mv_length_vertical: u8,
	pub pHrdParameters: *const StdVideoH265HrdParameters,
}
impl Debug for StdVideoH265SequenceParameterSetVui {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265SequenceParameterSetVui")
		.field("flags", &self.flags)
		.field("aspect_ratio_idc", &self.aspect_ratio_idc)
		.field("sar_width", &self.sar_width)
		.field("sar_height", &self.sar_height)
		.field("video_format", &self.video_format)
		.field("colour_primaries", &self.colour_primaries)
		.field("transfer_characteristics", &self.transfer_characteristics)
		.field("matrix_coeffs", &self.matrix_coeffs)
		.field("chroma_sample_loc_type_top_field", &self.chroma_sample_loc_type_top_field)
		.field("chroma_sample_loc_type_bottom_field", &self.chroma_sample_loc_type_bottom_field)
		.field("reserved1", &self.reserved1)
		.field("reserved2", &self.reserved2)
		.field("def_disp_win_left_offset", &self.def_disp_win_left_offset)
		.field("def_disp_win_right_offset", &self.def_disp_win_right_offset)
		.field("def_disp_win_top_offset", &self.def_disp_win_top_offset)
		.field("def_disp_win_bottom_offset", &self.def_disp_win_bottom_offset)
		.field("vui_num_units_in_tick", &self.vui_num_units_in_tick)
		.field("vui_time_scale", &self.vui_time_scale)
		.field("vui_num_ticks_poc_diff_one_minus1", &self.vui_num_ticks_poc_diff_one_minus1)
		.field("min_spatial_segmentation_idc", &self.min_spatial_segmentation_idc)
		.field("reserved3", &self.reserved3)
		.field("max_bytes_per_pic_denom", &self.max_bytes_per_pic_denom)
		.field("max_bits_per_min_cu_denom", &self.max_bits_per_min_cu_denom)
		.field("log2_max_mv_length_horizontal", &self.log2_max_mv_length_horizontal)
		.field("log2_max_mv_length_vertical", &self.log2_max_mv_length_vertical)
		.field("pHrdParameters", &self.pHrdParameters)
		.finish()
	}
}
/// struct `StdVideoH265PredictorPaletteEntries` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265PredictorPaletteEntries {
	pub PredictorPaletteEntries: [[u16; STD_VIDEO_H265_PREDICTOR_PALETTE_COMP_ENTRIES_LIST_SIZE as usize]; STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE as usize],
}
impl Debug for StdVideoH265PredictorPaletteEntries {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265PredictorPaletteEntries")
		.field("PredictorPaletteEntries", &self.PredictorPaletteEntries)
		.finish()
	}
}
/// struct `StdVideoH265SpsFlags` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265SpsFlags {
	/// Bitfield: sps_temporal_id_nesting_flag: u32 in 1 bits
	/// Bitfield: separate_colour_plane_flag: u32 in 1 bits
	/// Bitfield: conformance_window_flag: u32 in 1 bits
	/// Bitfield: sps_sub_layer_ordering_info_present_flag: u32 in 1 bits
	/// Bitfield: scaling_list_enabled_flag: u32 in 1 bits
	/// Bitfield: sps_scaling_list_data_present_flag: u32 in 1 bits
	/// Bitfield: amp_enabled_flag: u32 in 1 bits
	/// Bitfield: sample_adaptive_offset_enabled_flag: u32 in 1 bits
	/// Bitfield: pcm_enabled_flag: u32 in 1 bits
	/// Bitfield: pcm_loop_filter_disabled_flag: u32 in 1 bits
	/// Bitfield: long_term_ref_pics_present_flag: u32 in 1 bits
	/// Bitfield: sps_temporal_mvp_enabled_flag: u32 in 1 bits
	/// Bitfield: strong_intra_smoothing_enabled_flag: u32 in 1 bits
	/// Bitfield: vui_parameters_present_flag: u32 in 1 bits
	/// Bitfield: sps_extension_present_flag: u32 in 1 bits
	/// Bitfield: sps_range_extension_flag: u32 in 1 bits
	/// Bitfield: transform_skip_rotation_enabled_flag: u32 in 1 bits
	/// Bitfield: transform_skip_context_enabled_flag: u32 in 1 bits
	/// Bitfield: implicit_rdpcm_enabled_flag: u32 in 1 bits
	/// Bitfield: explicit_rdpcm_enabled_flag: u32 in 1 bits
	/// Bitfield: extended_precision_processing_flag: u32 in 1 bits
	/// Bitfield: intra_smoothing_disabled_flag: u32 in 1 bits
	/// Bitfield: high_precision_offsets_enabled_flag: u32 in 1 bits
	/// Bitfield: persistent_rice_adaptation_enabled_flag: u32 in 1 bits
	/// Bitfield: cabac_bypass_alignment_enabled_flag: u32 in 1 bits
	/// Bitfield: sps_scc_extension_flag: u32 in 1 bits
	/// Bitfield: sps_curr_pic_ref_enabled_flag: u32 in 1 bits
	/// Bitfield: palette_mode_enabled_flag: u32 in 1 bits
	/// Bitfield: sps_palette_predictor_initializers_present_flag: u32 in 1 bits
	/// Bitfield: intra_boundary_filtering_disabled_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH265SpsFlags {
	pub fn get_sps_temporal_id_nesting_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_sps_temporal_id_nesting_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_separate_colour_plane_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_separate_colour_plane_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_conformance_window_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_conformance_window_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_sps_sub_layer_ordering_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_sps_sub_layer_ordering_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_scaling_list_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_scaling_list_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_sps_scaling_list_data_present_flag(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_sps_scaling_list_data_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_amp_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_amp_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_sample_adaptive_offset_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_sample_adaptive_offset_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_pcm_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_pcm_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_pcm_loop_filter_disabled_flag(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_pcm_loop_filter_disabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_long_term_ref_pics_present_flag(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_long_term_ref_pics_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_sps_temporal_mvp_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_sps_temporal_mvp_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
	pub fn get_strong_intra_smoothing_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 12) & 0x1
	}
	pub fn set_strong_intra_smoothing_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 12;
	}
	pub fn get_vui_parameters_present_flag(&self) -> u32 {
		(self.bitfield1 >> 13) & 0x1
	}
	pub fn set_vui_parameters_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 13;
	}
	pub fn get_sps_extension_present_flag(&self) -> u32 {
		(self.bitfield1 >> 14) & 0x1
	}
	pub fn set_sps_extension_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 14;
	}
	pub fn get_sps_range_extension_flag(&self) -> u32 {
		(self.bitfield1 >> 15) & 0x1
	}
	pub fn set_sps_range_extension_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 15;
	}
	pub fn get_transform_skip_rotation_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 16) & 0x1
	}
	pub fn set_transform_skip_rotation_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 16;
	}
	pub fn get_transform_skip_context_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 17) & 0x1
	}
	pub fn set_transform_skip_context_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 17;
	}
	pub fn get_implicit_rdpcm_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 18) & 0x1
	}
	pub fn set_implicit_rdpcm_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 18;
	}
	pub fn get_explicit_rdpcm_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 19) & 0x1
	}
	pub fn set_explicit_rdpcm_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 19;
	}
	pub fn get_extended_precision_processing_flag(&self) -> u32 {
		(self.bitfield1 >> 20) & 0x1
	}
	pub fn set_extended_precision_processing_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 20;
	}
	pub fn get_intra_smoothing_disabled_flag(&self) -> u32 {
		(self.bitfield1 >> 21) & 0x1
	}
	pub fn set_intra_smoothing_disabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 21;
	}
	pub fn get_high_precision_offsets_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 22) & 0x1
	}
	pub fn set_high_precision_offsets_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 22;
	}
	pub fn get_persistent_rice_adaptation_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 23) & 0x1
	}
	pub fn set_persistent_rice_adaptation_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 23;
	}
	pub fn get_cabac_bypass_alignment_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 24) & 0x1
	}
	pub fn set_cabac_bypass_alignment_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 24;
	}
	pub fn get_sps_scc_extension_flag(&self) -> u32 {
		(self.bitfield1 >> 25) & 0x1
	}
	pub fn set_sps_scc_extension_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 25;
	}
	pub fn get_sps_curr_pic_ref_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 26) & 0x1
	}
	pub fn set_sps_curr_pic_ref_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 26;
	}
	pub fn get_palette_mode_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 27) & 0x1
	}
	pub fn set_palette_mode_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 27;
	}
	pub fn get_sps_palette_predictor_initializers_present_flag(&self) -> u32 {
		(self.bitfield1 >> 28) & 0x1
	}
	pub fn set_sps_palette_predictor_initializers_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 28;
	}
	pub fn get_intra_boundary_filtering_disabled_flag(&self) -> u32 {
		(self.bitfield1 >> 29) & 0x1
	}
	pub fn set_intra_boundary_filtering_disabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 29;
	}
}
impl Debug for StdVideoH265SpsFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265SpsFlags")
		.field("sps_temporal_id_nesting_flag", &self.get_sps_temporal_id_nesting_flag())
		.field("separate_colour_plane_flag", &self.get_separate_colour_plane_flag())
		.field("conformance_window_flag", &self.get_conformance_window_flag())
		.field("sps_sub_layer_ordering_info_present_flag", &self.get_sps_sub_layer_ordering_info_present_flag())
		.field("scaling_list_enabled_flag", &self.get_scaling_list_enabled_flag())
		.field("sps_scaling_list_data_present_flag", &self.get_sps_scaling_list_data_present_flag())
		.field("amp_enabled_flag", &self.get_amp_enabled_flag())
		.field("sample_adaptive_offset_enabled_flag", &self.get_sample_adaptive_offset_enabled_flag())
		.field("pcm_enabled_flag", &self.get_pcm_enabled_flag())
		.field("pcm_loop_filter_disabled_flag", &self.get_pcm_loop_filter_disabled_flag())
		.field("long_term_ref_pics_present_flag", &self.get_long_term_ref_pics_present_flag())
		.field("sps_temporal_mvp_enabled_flag", &self.get_sps_temporal_mvp_enabled_flag())
		.field("strong_intra_smoothing_enabled_flag", &self.get_strong_intra_smoothing_enabled_flag())
		.field("vui_parameters_present_flag", &self.get_vui_parameters_present_flag())
		.field("sps_extension_present_flag", &self.get_sps_extension_present_flag())
		.field("sps_range_extension_flag", &self.get_sps_range_extension_flag())
		.field("transform_skip_rotation_enabled_flag", &self.get_transform_skip_rotation_enabled_flag())
		.field("transform_skip_context_enabled_flag", &self.get_transform_skip_context_enabled_flag())
		.field("implicit_rdpcm_enabled_flag", &self.get_implicit_rdpcm_enabled_flag())
		.field("explicit_rdpcm_enabled_flag", &self.get_explicit_rdpcm_enabled_flag())
		.field("extended_precision_processing_flag", &self.get_extended_precision_processing_flag())
		.field("intra_smoothing_disabled_flag", &self.get_intra_smoothing_disabled_flag())
		.field("high_precision_offsets_enabled_flag", &self.get_high_precision_offsets_enabled_flag())
		.field("persistent_rice_adaptation_enabled_flag", &self.get_persistent_rice_adaptation_enabled_flag())
		.field("cabac_bypass_alignment_enabled_flag", &self.get_cabac_bypass_alignment_enabled_flag())
		.field("sps_scc_extension_flag", &self.get_sps_scc_extension_flag())
		.field("sps_curr_pic_ref_enabled_flag", &self.get_sps_curr_pic_ref_enabled_flag())
		.field("palette_mode_enabled_flag", &self.get_palette_mode_enabled_flag())
		.field("sps_palette_predictor_initializers_present_flag", &self.get_sps_palette_predictor_initializers_present_flag())
		.field("intra_boundary_filtering_disabled_flag", &self.get_intra_boundary_filtering_disabled_flag())
		.finish()
	}
}
/// struct `StdVideoH265ShortTermRefPicSetFlags` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265ShortTermRefPicSetFlags {
	/// Bitfield: inter_ref_pic_set_prediction_flag: u32 in 1 bits
	/// Bitfield: delta_rps_sign: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH265ShortTermRefPicSetFlags {
	pub fn get_inter_ref_pic_set_prediction_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_inter_ref_pic_set_prediction_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_delta_rps_sign(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_delta_rps_sign(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
}
impl Debug for StdVideoH265ShortTermRefPicSetFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265ShortTermRefPicSetFlags")
		.field("inter_ref_pic_set_prediction_flag", &self.get_inter_ref_pic_set_prediction_flag())
		.field("delta_rps_sign", &self.get_delta_rps_sign())
		.finish()
	}
}
/// struct `StdVideoH265ShortTermRefPicSet` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265ShortTermRefPicSet {
	pub flags: StdVideoH265ShortTermRefPicSetFlags,
	pub delta_idx_minus1: u32,
	pub use_delta_flag: u16,
	pub abs_delta_rps_minus1: u16,
	pub used_by_curr_pic_flag: u16,
	pub used_by_curr_pic_s0_flag: u16,
	pub used_by_curr_pic_s1_flag: u16,
	pub reserved1: u16,
	pub reserved2: u8,
	pub reserved3: u8,
	pub num_negative_pics: u8,
	pub num_positive_pics: u8,
	pub delta_poc_s0_minus1: [u16; STD_VIDEO_H265_MAX_DPB_SIZE as usize],
	pub delta_poc_s1_minus1: [u16; STD_VIDEO_H265_MAX_DPB_SIZE as usize],
}
impl Debug for StdVideoH265ShortTermRefPicSet {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265ShortTermRefPicSet")
		.field("flags", &self.flags)
		.field("delta_idx_minus1", &self.delta_idx_minus1)
		.field("use_delta_flag", &self.use_delta_flag)
		.field("abs_delta_rps_minus1", &self.abs_delta_rps_minus1)
		.field("used_by_curr_pic_flag", &self.used_by_curr_pic_flag)
		.field("used_by_curr_pic_s0_flag", &self.used_by_curr_pic_s0_flag)
		.field("used_by_curr_pic_s1_flag", &self.used_by_curr_pic_s1_flag)
		.field("reserved1", &self.reserved1)
		.field("reserved2", &self.reserved2)
		.field("reserved3", &self.reserved3)
		.field("num_negative_pics", &self.num_negative_pics)
		.field("num_positive_pics", &self.num_positive_pics)
		.field("delta_poc_s0_minus1", &self.delta_poc_s0_minus1)
		.field("delta_poc_s1_minus1", &self.delta_poc_s1_minus1)
		.finish()
	}
}
/// struct `StdVideoH265LongTermRefPicsSps` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265LongTermRefPicsSps {
	pub used_by_curr_pic_lt_sps_flag: u32,
	pub lt_ref_pic_poc_lsb_sps: [u32; STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS as usize],
}
impl Debug for StdVideoH265LongTermRefPicsSps {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265LongTermRefPicsSps")
		.field("used_by_curr_pic_lt_sps_flag", &self.used_by_curr_pic_lt_sps_flag)
		.field("lt_ref_pic_poc_lsb_sps", &self.lt_ref_pic_poc_lsb_sps)
		.finish()
	}
}
/// struct `StdVideoH265SequenceParameterSet` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265SequenceParameterSet {
	pub flags: StdVideoH265SpsFlags,
	pub chroma_format_idc: StdVideoH265ChromaFormatIdc,
	pub pic_width_in_luma_samples: u32,
	pub pic_height_in_luma_samples: u32,
	pub sps_video_parameter_set_id: u8,
	pub sps_max_sub_layers_minus1: u8,
	pub sps_seq_parameter_set_id: u8,
	pub bit_depth_luma_minus8: u8,
	pub bit_depth_chroma_minus8: u8,
	pub log2_max_pic_order_cnt_lsb_minus4: u8,
	pub log2_min_luma_coding_block_size_minus3: u8,
	pub log2_diff_max_min_luma_coding_block_size: u8,
	pub log2_min_luma_transform_block_size_minus2: u8,
	pub log2_diff_max_min_luma_transform_block_size: u8,
	pub max_transform_hierarchy_depth_inter: u8,
	pub max_transform_hierarchy_depth_intra: u8,
	pub num_short_term_ref_pic_sets: u8,
	pub num_long_term_ref_pics_sps: u8,
	pub pcm_sample_bit_depth_luma_minus1: u8,
	pub pcm_sample_bit_depth_chroma_minus1: u8,
	pub log2_min_pcm_luma_coding_block_size_minus3: u8,
	pub log2_diff_max_min_pcm_luma_coding_block_size: u8,
	pub reserved1: u8,
	pub reserved2: u8,
	pub palette_max_size: u8,
	pub delta_palette_max_predictor_size: u8,
	pub motion_vector_resolution_control_idc: u8,
	pub sps_num_palette_predictor_initializers_minus1: u8,
	pub conf_win_left_offset: u32,
	pub conf_win_right_offset: u32,
	pub conf_win_top_offset: u32,
	pub conf_win_bottom_offset: u32,
	pub pProfileTierLevel: *const StdVideoH265ProfileTierLevel,
	pub pDecPicBufMgr: *const StdVideoH265DecPicBufMgr,
	pub pScalingLists: *const StdVideoH265ScalingLists,
	pub pShortTermRefPicSet: *const StdVideoH265ShortTermRefPicSet,
	pub pLongTermRefPicsSps: *const StdVideoH265LongTermRefPicsSps,
	pub pSequenceParameterSetVui: *const StdVideoH265SequenceParameterSetVui,
	pub pPredictorPaletteEntries: *const StdVideoH265PredictorPaletteEntries,
}
impl Debug for StdVideoH265SequenceParameterSet {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265SequenceParameterSet")
		.field("flags", &self.flags)
		.field("chroma_format_idc", &self.chroma_format_idc)
		.field("pic_width_in_luma_samples", &self.pic_width_in_luma_samples)
		.field("pic_height_in_luma_samples", &self.pic_height_in_luma_samples)
		.field("sps_video_parameter_set_id", &self.sps_video_parameter_set_id)
		.field("sps_max_sub_layers_minus1", &self.sps_max_sub_layers_minus1)
		.field("sps_seq_parameter_set_id", &self.sps_seq_parameter_set_id)
		.field("bit_depth_luma_minus8", &self.bit_depth_luma_minus8)
		.field("bit_depth_chroma_minus8", &self.bit_depth_chroma_minus8)
		.field("log2_max_pic_order_cnt_lsb_minus4", &self.log2_max_pic_order_cnt_lsb_minus4)
		.field("log2_min_luma_coding_block_size_minus3", &self.log2_min_luma_coding_block_size_minus3)
		.field("log2_diff_max_min_luma_coding_block_size", &self.log2_diff_max_min_luma_coding_block_size)
		.field("log2_min_luma_transform_block_size_minus2", &self.log2_min_luma_transform_block_size_minus2)
		.field("log2_diff_max_min_luma_transform_block_size", &self.log2_diff_max_min_luma_transform_block_size)
		.field("max_transform_hierarchy_depth_inter", &self.max_transform_hierarchy_depth_inter)
		.field("max_transform_hierarchy_depth_intra", &self.max_transform_hierarchy_depth_intra)
		.field("num_short_term_ref_pic_sets", &self.num_short_term_ref_pic_sets)
		.field("num_long_term_ref_pics_sps", &self.num_long_term_ref_pics_sps)
		.field("pcm_sample_bit_depth_luma_minus1", &self.pcm_sample_bit_depth_luma_minus1)
		.field("pcm_sample_bit_depth_chroma_minus1", &self.pcm_sample_bit_depth_chroma_minus1)
		.field("log2_min_pcm_luma_coding_block_size_minus3", &self.log2_min_pcm_luma_coding_block_size_minus3)
		.field("log2_diff_max_min_pcm_luma_coding_block_size", &self.log2_diff_max_min_pcm_luma_coding_block_size)
		.field("reserved1", &self.reserved1)
		.field("reserved2", &self.reserved2)
		.field("palette_max_size", &self.palette_max_size)
		.field("delta_palette_max_predictor_size", &self.delta_palette_max_predictor_size)
		.field("motion_vector_resolution_control_idc", &self.motion_vector_resolution_control_idc)
		.field("sps_num_palette_predictor_initializers_minus1", &self.sps_num_palette_predictor_initializers_minus1)
		.field("conf_win_left_offset", &self.conf_win_left_offset)
		.field("conf_win_right_offset", &self.conf_win_right_offset)
		.field("conf_win_top_offset", &self.conf_win_top_offset)
		.field("conf_win_bottom_offset", &self.conf_win_bottom_offset)
		.field("pProfileTierLevel", &self.pProfileTierLevel)
		.field("pDecPicBufMgr", &self.pDecPicBufMgr)
		.field("pScalingLists", &self.pScalingLists)
		.field("pShortTermRefPicSet", &self.pShortTermRefPicSet)
		.field("pLongTermRefPicsSps", &self.pLongTermRefPicsSps)
		.field("pSequenceParameterSetVui", &self.pSequenceParameterSetVui)
		.field("pPredictorPaletteEntries", &self.pPredictorPaletteEntries)
		.finish()
	}
}
/// struct `StdVideoH265PpsFlags` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265PpsFlags {
	/// Bitfield: dependent_slice_segments_enabled_flag: u32 in 1 bits
	/// Bitfield: output_flag_present_flag: u32 in 1 bits
	/// Bitfield: sign_data_hiding_enabled_flag: u32 in 1 bits
	/// Bitfield: cabac_init_present_flag: u32 in 1 bits
	/// Bitfield: constrained_intra_pred_flag: u32 in 1 bits
	/// Bitfield: transform_skip_enabled_flag: u32 in 1 bits
	/// Bitfield: cu_qp_delta_enabled_flag: u32 in 1 bits
	/// Bitfield: pps_slice_chroma_qp_offsets_present_flag: u32 in 1 bits
	/// Bitfield: weighted_pred_flag: u32 in 1 bits
	/// Bitfield: weighted_bipred_flag: u32 in 1 bits
	/// Bitfield: transquant_bypass_enabled_flag: u32 in 1 bits
	/// Bitfield: tiles_enabled_flag: u32 in 1 bits
	/// Bitfield: entropy_coding_sync_enabled_flag: u32 in 1 bits
	/// Bitfield: uniform_spacing_flag: u32 in 1 bits
	/// Bitfield: loop_filter_across_tiles_enabled_flag: u32 in 1 bits
	/// Bitfield: pps_loop_filter_across_slices_enabled_flag: u32 in 1 bits
	/// Bitfield: deblocking_filter_control_present_flag: u32 in 1 bits
	/// Bitfield: deblocking_filter_override_enabled_flag: u32 in 1 bits
	/// Bitfield: pps_deblocking_filter_disabled_flag: u32 in 1 bits
	/// Bitfield: pps_scaling_list_data_present_flag: u32 in 1 bits
	/// Bitfield: lists_modification_present_flag: u32 in 1 bits
	/// Bitfield: slice_segment_header_extension_present_flag: u32 in 1 bits
	/// Bitfield: pps_extension_present_flag: u32 in 1 bits
	/// Bitfield: cross_component_prediction_enabled_flag: u32 in 1 bits
	/// Bitfield: chroma_qp_offset_list_enabled_flag: u32 in 1 bits
	/// Bitfield: pps_curr_pic_ref_enabled_flag: u32 in 1 bits
	/// Bitfield: residual_adaptive_colour_transform_enabled_flag: u32 in 1 bits
	/// Bitfield: pps_slice_act_qp_offsets_present_flag: u32 in 1 bits
	/// Bitfield: pps_palette_predictor_initializers_present_flag: u32 in 1 bits
	/// Bitfield: monochrome_palette_flag: u32 in 1 bits
	/// Bitfield: pps_range_extension_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoH265PpsFlags {
	pub fn get_dependent_slice_segments_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_dependent_slice_segments_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_output_flag_present_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_output_flag_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_sign_data_hiding_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_sign_data_hiding_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_cabac_init_present_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_cabac_init_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_constrained_intra_pred_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_constrained_intra_pred_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_transform_skip_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_transform_skip_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_cu_qp_delta_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_cu_qp_delta_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_pps_slice_chroma_qp_offsets_present_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_pps_slice_chroma_qp_offsets_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_weighted_pred_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_weighted_pred_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_weighted_bipred_flag(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_weighted_bipred_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_transquant_bypass_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_transquant_bypass_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_tiles_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_tiles_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
	pub fn get_entropy_coding_sync_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 12) & 0x1
	}
	pub fn set_entropy_coding_sync_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 12;
	}
	pub fn get_uniform_spacing_flag(&self) -> u32 {
		(self.bitfield1 >> 13) & 0x1
	}
	pub fn set_uniform_spacing_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 13;
	}
	pub fn get_loop_filter_across_tiles_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 14) & 0x1
	}
	pub fn set_loop_filter_across_tiles_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 14;
	}
	pub fn get_pps_loop_filter_across_slices_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 15) & 0x1
	}
	pub fn set_pps_loop_filter_across_slices_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 15;
	}
	pub fn get_deblocking_filter_control_present_flag(&self) -> u32 {
		(self.bitfield1 >> 16) & 0x1
	}
	pub fn set_deblocking_filter_control_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 16;
	}
	pub fn get_deblocking_filter_override_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 17) & 0x1
	}
	pub fn set_deblocking_filter_override_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 17;
	}
	pub fn get_pps_deblocking_filter_disabled_flag(&self) -> u32 {
		(self.bitfield1 >> 18) & 0x1
	}
	pub fn set_pps_deblocking_filter_disabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 18;
	}
	pub fn get_pps_scaling_list_data_present_flag(&self) -> u32 {
		(self.bitfield1 >> 19) & 0x1
	}
	pub fn set_pps_scaling_list_data_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 19;
	}
	pub fn get_lists_modification_present_flag(&self) -> u32 {
		(self.bitfield1 >> 20) & 0x1
	}
	pub fn set_lists_modification_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 20;
	}
	pub fn get_slice_segment_header_extension_present_flag(&self) -> u32 {
		(self.bitfield1 >> 21) & 0x1
	}
	pub fn set_slice_segment_header_extension_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 21;
	}
	pub fn get_pps_extension_present_flag(&self) -> u32 {
		(self.bitfield1 >> 22) & 0x1
	}
	pub fn set_pps_extension_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 22;
	}
	pub fn get_cross_component_prediction_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 23) & 0x1
	}
	pub fn set_cross_component_prediction_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 23;
	}
	pub fn get_chroma_qp_offset_list_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 24) & 0x1
	}
	pub fn set_chroma_qp_offset_list_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 24;
	}
	pub fn get_pps_curr_pic_ref_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 25) & 0x1
	}
	pub fn set_pps_curr_pic_ref_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 25;
	}
	pub fn get_residual_adaptive_colour_transform_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 26) & 0x1
	}
	pub fn set_residual_adaptive_colour_transform_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 26;
	}
	pub fn get_pps_slice_act_qp_offsets_present_flag(&self) -> u32 {
		(self.bitfield1 >> 27) & 0x1
	}
	pub fn set_pps_slice_act_qp_offsets_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 27;
	}
	pub fn get_pps_palette_predictor_initializers_present_flag(&self) -> u32 {
		(self.bitfield1 >> 28) & 0x1
	}
	pub fn set_pps_palette_predictor_initializers_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 28;
	}
	pub fn get_monochrome_palette_flag(&self) -> u32 {
		(self.bitfield1 >> 29) & 0x1
	}
	pub fn set_monochrome_palette_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 29;
	}
	pub fn get_pps_range_extension_flag(&self) -> u32 {
		(self.bitfield1 >> 30) & 0x1
	}
	pub fn set_pps_range_extension_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 30;
	}
}
impl Debug for StdVideoH265PpsFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265PpsFlags")
		.field("dependent_slice_segments_enabled_flag", &self.get_dependent_slice_segments_enabled_flag())
		.field("output_flag_present_flag", &self.get_output_flag_present_flag())
		.field("sign_data_hiding_enabled_flag", &self.get_sign_data_hiding_enabled_flag())
		.field("cabac_init_present_flag", &self.get_cabac_init_present_flag())
		.field("constrained_intra_pred_flag", &self.get_constrained_intra_pred_flag())
		.field("transform_skip_enabled_flag", &self.get_transform_skip_enabled_flag())
		.field("cu_qp_delta_enabled_flag", &self.get_cu_qp_delta_enabled_flag())
		.field("pps_slice_chroma_qp_offsets_present_flag", &self.get_pps_slice_chroma_qp_offsets_present_flag())
		.field("weighted_pred_flag", &self.get_weighted_pred_flag())
		.field("weighted_bipred_flag", &self.get_weighted_bipred_flag())
		.field("transquant_bypass_enabled_flag", &self.get_transquant_bypass_enabled_flag())
		.field("tiles_enabled_flag", &self.get_tiles_enabled_flag())
		.field("entropy_coding_sync_enabled_flag", &self.get_entropy_coding_sync_enabled_flag())
		.field("uniform_spacing_flag", &self.get_uniform_spacing_flag())
		.field("loop_filter_across_tiles_enabled_flag", &self.get_loop_filter_across_tiles_enabled_flag())
		.field("pps_loop_filter_across_slices_enabled_flag", &self.get_pps_loop_filter_across_slices_enabled_flag())
		.field("deblocking_filter_control_present_flag", &self.get_deblocking_filter_control_present_flag())
		.field("deblocking_filter_override_enabled_flag", &self.get_deblocking_filter_override_enabled_flag())
		.field("pps_deblocking_filter_disabled_flag", &self.get_pps_deblocking_filter_disabled_flag())
		.field("pps_scaling_list_data_present_flag", &self.get_pps_scaling_list_data_present_flag())
		.field("lists_modification_present_flag", &self.get_lists_modification_present_flag())
		.field("slice_segment_header_extension_present_flag", &self.get_slice_segment_header_extension_present_flag())
		.field("pps_extension_present_flag", &self.get_pps_extension_present_flag())
		.field("cross_component_prediction_enabled_flag", &self.get_cross_component_prediction_enabled_flag())
		.field("chroma_qp_offset_list_enabled_flag", &self.get_chroma_qp_offset_list_enabled_flag())
		.field("pps_curr_pic_ref_enabled_flag", &self.get_pps_curr_pic_ref_enabled_flag())
		.field("residual_adaptive_colour_transform_enabled_flag", &self.get_residual_adaptive_colour_transform_enabled_flag())
		.field("pps_slice_act_qp_offsets_present_flag", &self.get_pps_slice_act_qp_offsets_present_flag())
		.field("pps_palette_predictor_initializers_present_flag", &self.get_pps_palette_predictor_initializers_present_flag())
		.field("monochrome_palette_flag", &self.get_monochrome_palette_flag())
		.field("pps_range_extension_flag", &self.get_pps_range_extension_flag())
		.finish()
	}
}
/// struct `StdVideoH265PictureParameterSet` from vulkan_video_codec_h265std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoH265PictureParameterSet {
	pub flags: StdVideoH265PpsFlags,
	pub pps_pic_parameter_set_id: u8,
	pub pps_seq_parameter_set_id: u8,
	pub sps_video_parameter_set_id: u8,
	pub num_extra_slice_header_bits: u8,
	pub num_ref_idx_l0_default_active_minus1: u8,
	pub num_ref_idx_l1_default_active_minus1: u8,
	pub init_qp_minus26: i8,
	pub diff_cu_qp_delta_depth: u8,
	pub pps_cb_qp_offset: i8,
	pub pps_cr_qp_offset: i8,
	pub pps_beta_offset_div2: i8,
	pub pps_tc_offset_div2: i8,
	pub log2_parallel_merge_level_minus2: u8,
	pub log2_max_transform_skip_block_size_minus2: u8,
	pub diff_cu_chroma_qp_offset_depth: u8,
	pub chroma_qp_offset_list_len_minus1: u8,
	pub cb_qp_offset_list: [i8; STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE as usize],
	pub cr_qp_offset_list: [i8; STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE as usize],
	pub log2_sao_offset_scale_luma: u8,
	pub log2_sao_offset_scale_chroma: u8,
	pub pps_act_y_qp_offset_plus5: i8,
	pub pps_act_cb_qp_offset_plus5: i8,
	pub pps_act_cr_qp_offset_plus3: i8,
	pub pps_num_palette_predictor_initializers: u8,
	pub luma_bit_depth_entry_minus8: u8,
	pub chroma_bit_depth_entry_minus8: u8,
	pub num_tile_columns_minus1: u8,
	pub num_tile_rows_minus1: u8,
	pub reserved1: u8,
	pub reserved2: u8,
	pub column_width_minus1: [u16; STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE as usize],
	pub row_height_minus1: [u16; STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE as usize],
	pub reserved3: u32,
	pub pScalingLists: *const StdVideoH265ScalingLists,
	pub pPredictorPaletteEntries: *const StdVideoH265PredictorPaletteEntries,
}
impl Debug for StdVideoH265PictureParameterSet {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoH265PictureParameterSet")
		.field("flags", &self.flags)
		.field("pps_pic_parameter_set_id", &self.pps_pic_parameter_set_id)
		.field("pps_seq_parameter_set_id", &self.pps_seq_parameter_set_id)
		.field("sps_video_parameter_set_id", &self.sps_video_parameter_set_id)
		.field("num_extra_slice_header_bits", &self.num_extra_slice_header_bits)
		.field("num_ref_idx_l0_default_active_minus1", &self.num_ref_idx_l0_default_active_minus1)
		.field("num_ref_idx_l1_default_active_minus1", &self.num_ref_idx_l1_default_active_minus1)
		.field("init_qp_minus26", &self.init_qp_minus26)
		.field("diff_cu_qp_delta_depth", &self.diff_cu_qp_delta_depth)
		.field("pps_cb_qp_offset", &self.pps_cb_qp_offset)
		.field("pps_cr_qp_offset", &self.pps_cr_qp_offset)
		.field("pps_beta_offset_div2", &self.pps_beta_offset_div2)
		.field("pps_tc_offset_div2", &self.pps_tc_offset_div2)
		.field("log2_parallel_merge_level_minus2", &self.log2_parallel_merge_level_minus2)
		.field("log2_max_transform_skip_block_size_minus2", &self.log2_max_transform_skip_block_size_minus2)
		.field("diff_cu_chroma_qp_offset_depth", &self.diff_cu_chroma_qp_offset_depth)
		.field("chroma_qp_offset_list_len_minus1", &self.chroma_qp_offset_list_len_minus1)
		.field("cb_qp_offset_list", &format_args!("{}", maybe_string(&self.cb_qp_offset_list)))
		.field("cr_qp_offset_list", &format_args!("{}", maybe_string(&self.cr_qp_offset_list)))
		.field("log2_sao_offset_scale_luma", &self.log2_sao_offset_scale_luma)
		.field("log2_sao_offset_scale_chroma", &self.log2_sao_offset_scale_chroma)
		.field("pps_act_y_qp_offset_plus5", &self.pps_act_y_qp_offset_plus5)
		.field("pps_act_cb_qp_offset_plus5", &self.pps_act_cb_qp_offset_plus5)
		.field("pps_act_cr_qp_offset_plus3", &self.pps_act_cr_qp_offset_plus3)
		.field("pps_num_palette_predictor_initializers", &self.pps_num_palette_predictor_initializers)
		.field("luma_bit_depth_entry_minus8", &self.luma_bit_depth_entry_minus8)
		.field("chroma_bit_depth_entry_minus8", &self.chroma_bit_depth_entry_minus8)
		.field("num_tile_columns_minus1", &self.num_tile_columns_minus1)
		.field("num_tile_rows_minus1", &self.num_tile_rows_minus1)
		.field("reserved1", &self.reserved1)
		.field("reserved2", &self.reserved2)
		.field("column_width_minus1", &self.column_width_minus1)
		.field("row_height_minus1", &self.row_height_minus1)
		.field("reserved3", &self.reserved3)
		.field("pScalingLists", &self.pScalingLists)
		.field("pPredictorPaletteEntries", &self.pPredictorPaletteEntries)
		.finish()
	}
}
/// trait for `vulkan_video_codec_h265std`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vulkan_video_codec_h265std.html>
pub trait vulkan_video_codec_h265std: Debug {}
/// struct for `vulkan_video_codec_h265std`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_h265std {}
impl vulkan_video_codec_h265std for Vulkan_video_codec_h265std {}
impl Default for Vulkan_video_codec_h265std {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_h265std {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_API_VERSION_1_0_0` from vulkan_video_codec_h265std_encode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_API_VERSION_1_0_0.html>
pub const VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_API_VERSION_1_0_0: u32 = 0x400000;
/// struct `StdVideoEncodeH265WeightTableFlags` from vulkan_video_codec_h265std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH265WeightTableFlags {
	pub luma_weight_l0_flag: u16,
	pub chroma_weight_l0_flag: u16,
	pub luma_weight_l1_flag: u16,
	pub chroma_weight_l1_flag: u16,
}
impl Debug for StdVideoEncodeH265WeightTableFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH265WeightTableFlags")
		.field("luma_weight_l0_flag", &self.luma_weight_l0_flag)
		.field("chroma_weight_l0_flag", &self.chroma_weight_l0_flag)
		.field("luma_weight_l1_flag", &self.luma_weight_l1_flag)
		.field("chroma_weight_l1_flag", &self.chroma_weight_l1_flag)
		.finish()
	}
}
/// struct `StdVideoEncodeH265WeightTable` from vulkan_video_codec_h265std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH265WeightTable {
	pub flags: StdVideoEncodeH265WeightTableFlags,
	pub luma_log2_weight_denom: u8,
	pub delta_chroma_log2_weight_denom: i8,
	pub delta_luma_weight_l0: [i8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub luma_offset_l0: [i8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub delta_chroma_weight_l0: [[i8; STD_VIDEO_H265_MAX_CHROMA_PLANES as usize]; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub delta_chroma_offset_l0: [[i8; STD_VIDEO_H265_MAX_CHROMA_PLANES as usize]; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub delta_luma_weight_l1: [i8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub luma_offset_l1: [i8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub delta_chroma_weight_l1: [[i8; STD_VIDEO_H265_MAX_CHROMA_PLANES as usize]; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub delta_chroma_offset_l1: [[i8; STD_VIDEO_H265_MAX_CHROMA_PLANES as usize]; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
}
impl Debug for StdVideoEncodeH265WeightTable {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH265WeightTable")
		.field("flags", &self.flags)
		.field("luma_log2_weight_denom", &self.luma_log2_weight_denom)
		.field("delta_chroma_log2_weight_denom", &self.delta_chroma_log2_weight_denom)
		.field("delta_luma_weight_l0", &format_args!("{}", maybe_string(&self.delta_luma_weight_l0)))
		.field("luma_offset_l0", &format_args!("{}", maybe_string(&self.luma_offset_l0)))
		.field("delta_chroma_weight_l0", &self.delta_chroma_weight_l0)
		.field("delta_chroma_offset_l0", &self.delta_chroma_offset_l0)
		.field("delta_luma_weight_l1", &format_args!("{}", maybe_string(&self.delta_luma_weight_l1)))
		.field("luma_offset_l1", &format_args!("{}", maybe_string(&self.luma_offset_l1)))
		.field("delta_chroma_weight_l1", &self.delta_chroma_weight_l1)
		.field("delta_chroma_offset_l1", &self.delta_chroma_offset_l1)
		.finish()
	}
}
/// struct `StdVideoEncodeH265SliceSegmentHeaderFlags` from vulkan_video_codec_h265std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH265SliceSegmentHeaderFlags {
	/// Bitfield: first_slice_segment_in_pic_flag: u32 in 1 bits
	/// Bitfield: dependent_slice_segment_flag: u32 in 1 bits
	/// Bitfield: slice_sao_luma_flag: u32 in 1 bits
	/// Bitfield: slice_sao_chroma_flag: u32 in 1 bits
	/// Bitfield: num_ref_idx_active_override_flag: u32 in 1 bits
	/// Bitfield: mvd_l1_zero_flag: u32 in 1 bits
	/// Bitfield: cabac_init_flag: u32 in 1 bits
	/// Bitfield: cu_chroma_qp_offset_enabled_flag: u32 in 1 bits
	/// Bitfield: deblocking_filter_override_flag: u32 in 1 bits
	/// Bitfield: slice_deblocking_filter_disabled_flag: u32 in 1 bits
	/// Bitfield: collocated_from_l0_flag: u32 in 1 bits
	/// Bitfield: slice_loop_filter_across_slices_enabled_flag: u32 in 1 bits
	/// Bitfield: reserved: u32 in 20 bits
	bitfield1: u32,
}
impl StdVideoEncodeH265SliceSegmentHeaderFlags {
	pub fn get_first_slice_segment_in_pic_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_first_slice_segment_in_pic_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_dependent_slice_segment_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_dependent_slice_segment_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_slice_sao_luma_flag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_slice_sao_luma_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_slice_sao_chroma_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_slice_sao_chroma_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_num_ref_idx_active_override_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_num_ref_idx_active_override_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_mvd_l1_zero_flag(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_mvd_l1_zero_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_cabac_init_flag(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_cabac_init_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_cu_chroma_qp_offset_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_cu_chroma_qp_offset_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_deblocking_filter_override_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_deblocking_filter_override_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_slice_deblocking_filter_disabled_flag(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_slice_deblocking_filter_disabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_collocated_from_l0_flag(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_collocated_from_l0_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_slice_loop_filter_across_slices_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_slice_loop_filter_across_slices_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 12) & 0xfffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0xfffff) << 12;
	}
}
impl Debug for StdVideoEncodeH265SliceSegmentHeaderFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH265SliceSegmentHeaderFlags")
		.field("first_slice_segment_in_pic_flag", &self.get_first_slice_segment_in_pic_flag())
		.field("dependent_slice_segment_flag", &self.get_dependent_slice_segment_flag())
		.field("slice_sao_luma_flag", &self.get_slice_sao_luma_flag())
		.field("slice_sao_chroma_flag", &self.get_slice_sao_chroma_flag())
		.field("num_ref_idx_active_override_flag", &self.get_num_ref_idx_active_override_flag())
		.field("mvd_l1_zero_flag", &self.get_mvd_l1_zero_flag())
		.field("cabac_init_flag", &self.get_cabac_init_flag())
		.field("cu_chroma_qp_offset_enabled_flag", &self.get_cu_chroma_qp_offset_enabled_flag())
		.field("deblocking_filter_override_flag", &self.get_deblocking_filter_override_flag())
		.field("slice_deblocking_filter_disabled_flag", &self.get_slice_deblocking_filter_disabled_flag())
		.field("collocated_from_l0_flag", &self.get_collocated_from_l0_flag())
		.field("slice_loop_filter_across_slices_enabled_flag", &self.get_slice_loop_filter_across_slices_enabled_flag())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoEncodeH265SliceSegmentHeader` from vulkan_video_codec_h265std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH265SliceSegmentHeader {
	pub flags: StdVideoEncodeH265SliceSegmentHeaderFlags,
	pub slice_type: StdVideoH265SliceType,
	pub slice_segment_address: u32,
	pub collocated_ref_idx: u8,
	pub MaxNumMergeCand: u8,
	pub slice_cb_qp_offset: i8,
	pub slice_cr_qp_offset: i8,
	pub slice_beta_offset_div2: i8,
	pub slice_tc_offset_div2: i8,
	pub slice_act_y_qp_offset: i8,
	pub slice_act_cb_qp_offset: i8,
	pub slice_act_cr_qp_offset: i8,
	pub slice_qp_delta: i8,
	pub reserved1: u16,
	pub pWeightTable: *const StdVideoEncodeH265WeightTable,
}
impl Debug for StdVideoEncodeH265SliceSegmentHeader {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH265SliceSegmentHeader")
		.field("flags", &self.flags)
		.field("slice_type", &self.slice_type)
		.field("slice_segment_address", &self.slice_segment_address)
		.field("collocated_ref_idx", &self.collocated_ref_idx)
		.field("MaxNumMergeCand", &self.MaxNumMergeCand)
		.field("slice_cb_qp_offset", &self.slice_cb_qp_offset)
		.field("slice_cr_qp_offset", &self.slice_cr_qp_offset)
		.field("slice_beta_offset_div2", &self.slice_beta_offset_div2)
		.field("slice_tc_offset_div2", &self.slice_tc_offset_div2)
		.field("slice_act_y_qp_offset", &self.slice_act_y_qp_offset)
		.field("slice_act_cb_qp_offset", &self.slice_act_cb_qp_offset)
		.field("slice_act_cr_qp_offset", &self.slice_act_cr_qp_offset)
		.field("slice_qp_delta", &self.slice_qp_delta)
		.field("reserved1", &self.reserved1)
		.field("pWeightTable", &self.pWeightTable)
		.finish()
	}
}
/// struct `StdVideoEncodeH265ReferenceListsInfoFlags` from vulkan_video_codec_h265std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH265ReferenceListsInfoFlags {
	/// Bitfield: ref_pic_list_modification_flag_l0: u32 in 1 bits
	/// Bitfield: ref_pic_list_modification_flag_l1: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoEncodeH265ReferenceListsInfoFlags {
	pub fn get_ref_pic_list_modification_flag_l0(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_ref_pic_list_modification_flag_l0(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_ref_pic_list_modification_flag_l1(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_ref_pic_list_modification_flag_l1(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
impl Debug for StdVideoEncodeH265ReferenceListsInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH265ReferenceListsInfoFlags")
		.field("ref_pic_list_modification_flag_l0", &self.get_ref_pic_list_modification_flag_l0())
		.field("ref_pic_list_modification_flag_l1", &self.get_ref_pic_list_modification_flag_l1())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoEncodeH265ReferenceListsInfo` from vulkan_video_codec_h265std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH265ReferenceListsInfo {
	pub flags: StdVideoEncodeH265ReferenceListsInfoFlags,
	pub num_ref_idx_l0_active_minus1: u8,
	pub num_ref_idx_l1_active_minus1: u8,
	pub RefPicList0: [u8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub RefPicList1: [u8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub list_entry_l0: [u8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
	pub list_entry_l1: [u8; STD_VIDEO_H265_MAX_NUM_LIST_REF as usize],
}
impl Debug for StdVideoEncodeH265ReferenceListsInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH265ReferenceListsInfo")
		.field("flags", &self.flags)
		.field("num_ref_idx_l0_active_minus1", &self.num_ref_idx_l0_active_minus1)
		.field("num_ref_idx_l1_active_minus1", &self.num_ref_idx_l1_active_minus1)
		.field("RefPicList0", &self.RefPicList0)
		.field("RefPicList1", &self.RefPicList1)
		.field("list_entry_l0", &self.list_entry_l0)
		.field("list_entry_l1", &self.list_entry_l1)
		.finish()
	}
}
/// struct `StdVideoEncodeH265PictureInfoFlags` from vulkan_video_codec_h265std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH265PictureInfoFlags {
	/// Bitfield: is_reference: u32 in 1 bits
	/// Bitfield: IrapPicFlag: u32 in 1 bits
	/// Bitfield: used_for_long_term_reference: u32 in 1 bits
	/// Bitfield: discardable_flag: u32 in 1 bits
	/// Bitfield: cross_layer_bla_flag: u32 in 1 bits
	/// Bitfield: pic_output_flag: u32 in 1 bits
	/// Bitfield: no_output_of_prior_pics_flag: u32 in 1 bits
	/// Bitfield: short_term_ref_pic_set_sps_flag: u32 in 1 bits
	/// Bitfield: slice_temporal_mvp_enabled_flag: u32 in 1 bits
	/// Bitfield: reserved: u32 in 23 bits
	bitfield1: u32,
}
impl StdVideoEncodeH265PictureInfoFlags {
	pub fn get_is_reference(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_is_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_IrapPicFlag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_IrapPicFlag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_used_for_long_term_reference(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_used_for_long_term_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_discardable_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_discardable_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_cross_layer_bla_flag(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_cross_layer_bla_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_pic_output_flag(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_pic_output_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_no_output_of_prior_pics_flag(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_no_output_of_prior_pics_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_short_term_ref_pic_set_sps_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_short_term_ref_pic_set_sps_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_slice_temporal_mvp_enabled_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_slice_temporal_mvp_enabled_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x7fffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7fffff) << 9;
	}
}
impl Debug for StdVideoEncodeH265PictureInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH265PictureInfoFlags")
		.field("is_reference", &self.get_is_reference())
		.field("IrapPicFlag", &self.get_IrapPicFlag())
		.field("used_for_long_term_reference", &self.get_used_for_long_term_reference())
		.field("discardable_flag", &self.get_discardable_flag())
		.field("cross_layer_bla_flag", &self.get_cross_layer_bla_flag())
		.field("pic_output_flag", &self.get_pic_output_flag())
		.field("no_output_of_prior_pics_flag", &self.get_no_output_of_prior_pics_flag())
		.field("short_term_ref_pic_set_sps_flag", &self.get_short_term_ref_pic_set_sps_flag())
		.field("slice_temporal_mvp_enabled_flag", &self.get_slice_temporal_mvp_enabled_flag())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoEncodeH265LongTermRefPics` from vulkan_video_codec_h265std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH265LongTermRefPics {
	pub num_long_term_sps: u8,
	pub num_long_term_pics: u8,
	pub lt_idx_sps: [u8; STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS as usize],
	pub poc_lsb_lt: [u8; STD_VIDEO_H265_MAX_LONG_TERM_PICS as usize],
	pub used_by_curr_pic_lt_flag: u16,
	pub delta_poc_msb_present_flag: [u8; STD_VIDEO_H265_MAX_DELTA_POC as usize],
	pub delta_poc_msb_cycle_lt: [u8; STD_VIDEO_H265_MAX_DELTA_POC as usize],
}
impl Debug for StdVideoEncodeH265LongTermRefPics {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH265LongTermRefPics")
		.field("num_long_term_sps", &self.num_long_term_sps)
		.field("num_long_term_pics", &self.num_long_term_pics)
		.field("lt_idx_sps", &self.lt_idx_sps)
		.field("poc_lsb_lt", &self.poc_lsb_lt)
		.field("used_by_curr_pic_lt_flag", &self.used_by_curr_pic_lt_flag)
		.field("delta_poc_msb_present_flag", &self.delta_poc_msb_present_flag)
		.field("delta_poc_msb_cycle_lt", &self.delta_poc_msb_cycle_lt)
		.finish()
	}
}
/// struct `StdVideoEncodeH265PictureInfo` from vulkan_video_codec_h265std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH265PictureInfo {
	pub flags: StdVideoEncodeH265PictureInfoFlags,
	pub pic_type: StdVideoH265PictureType,
	pub sps_video_parameter_set_id: u8,
	pub pps_seq_parameter_set_id: u8,
	pub pps_pic_parameter_set_id: u8,
	pub short_term_ref_pic_set_idx: u8,
	pub PicOrderCntVal: i32,
	pub TemporalId: u8,
	pub reserved1: [u8; 7 as usize],
	pub pRefLists: *const StdVideoEncodeH265ReferenceListsInfo,
	pub pShortTermRefPicSet: *const StdVideoH265ShortTermRefPicSet,
	pub pLongTermRefPics: *const StdVideoEncodeH265LongTermRefPics,
}
impl Debug for StdVideoEncodeH265PictureInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH265PictureInfo")
		.field("flags", &self.flags)
		.field("pic_type", &self.pic_type)
		.field("sps_video_parameter_set_id", &self.sps_video_parameter_set_id)
		.field("pps_seq_parameter_set_id", &self.pps_seq_parameter_set_id)
		.field("pps_pic_parameter_set_id", &self.pps_pic_parameter_set_id)
		.field("short_term_ref_pic_set_idx", &self.short_term_ref_pic_set_idx)
		.field("PicOrderCntVal", &self.PicOrderCntVal)
		.field("TemporalId", &self.TemporalId)
		.field("reserved1", &self.reserved1)
		.field("pRefLists", &self.pRefLists)
		.field("pShortTermRefPicSet", &self.pShortTermRefPicSet)
		.field("pLongTermRefPics", &self.pLongTermRefPics)
		.finish()
	}
}
/// struct `StdVideoEncodeH265ReferenceInfoFlags` from vulkan_video_codec_h265std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH265ReferenceInfoFlags {
	/// Bitfield: used_for_long_term_reference: u32 in 1 bits
	/// Bitfield: unused_for_reference: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoEncodeH265ReferenceInfoFlags {
	pub fn get_used_for_long_term_reference(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_used_for_long_term_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_unused_for_reference(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_unused_for_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
impl Debug for StdVideoEncodeH265ReferenceInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH265ReferenceInfoFlags")
		.field("used_for_long_term_reference", &self.get_used_for_long_term_reference())
		.field("unused_for_reference", &self.get_unused_for_reference())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoEncodeH265ReferenceInfo` from vulkan_video_codec_h265std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeH265ReferenceInfo {
	pub flags: StdVideoEncodeH265ReferenceInfoFlags,
	pub pic_type: StdVideoH265PictureType,
	pub PicOrderCntVal: i32,
	pub TemporalId: u8,
}
impl Debug for StdVideoEncodeH265ReferenceInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeH265ReferenceInfo")
		.field("flags", &self.flags)
		.field("pic_type", &self.pic_type)
		.field("PicOrderCntVal", &self.PicOrderCntVal)
		.field("TemporalId", &self.TemporalId)
		.finish()
	}
}
/// trait for `vulkan_video_codec_h265std_encode`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vulkan_video_codec_h265std_encode.html>
pub trait vulkan_video_codec_h265std_encode: Debug {}
/// struct for `vulkan_video_codec_h265std_encode`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_h265std_encode {}
impl vulkan_video_codec_h265std_encode for Vulkan_video_codec_h265std_encode {}
impl Default for Vulkan_video_codec_h265std_encode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_h265std_encode {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkVideoDecodeH264PictureLayoutFlagsKHR` from VK_KHR_video_decode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeH264PictureLayoutFlagsKHR.html>
pub type VkVideoDecodeH264PictureLayoutFlagsKHR = VkFlags;
/// enum `VkVideoDecodeH264PictureLayoutFlagBitsKHR` from VK_KHR_video_decode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeH264PictureLayoutFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoDecodeH264PictureLayoutFlagBitsKHR {
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR = 0,
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR = 0x00000001,
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR = 0x00000002,
	VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// struct `VkVideoDecodeH264ProfileInfoKHR` from VK_KHR_video_decode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeH264ProfileInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeH264ProfileInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdProfileIdc: StdVideoH264ProfileIdc,
	pub pictureLayout: VkVideoDecodeH264PictureLayoutFlagBitsKHR,
}
impl Debug for VkVideoDecodeH264ProfileInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH264ProfileInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stdProfileIdc", &self.stdProfileIdc)
		.field("pictureLayout", &self.pictureLayout)
		.finish()
	}
}
/// struct `VkVideoDecodeH264CapabilitiesKHR` from VK_KHR_video_decode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeH264CapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeH264CapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxLevelIdc: StdVideoH264LevelIdc,
	pub fieldOffsetGranularity: VkOffset2D,
}
impl Debug for VkVideoDecodeH264CapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH264CapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxLevelIdc", &self.maxLevelIdc)
		.field("fieldOffsetGranularity", &self.fieldOffsetGranularity)
		.finish()
	}
}
/// struct `VkVideoDecodeH264SessionParametersAddInfoKHR` from VK_KHR_video_decode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeH264SessionParametersAddInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeH264SessionParametersAddInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdSPSCount: u32,
	pub pStdSPSs: *const StdVideoH264SequenceParameterSet,
	pub stdPPSCount: u32,
	pub pStdPPSs: *const StdVideoH264PictureParameterSet,
}
impl Debug for VkVideoDecodeH264SessionParametersAddInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH264SessionParametersAddInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stdSPSCount", &self.stdSPSCount)
		.field("pStdSPSs", &self.pStdSPSs)
		.field("stdPPSCount", &self.stdPPSCount)
		.field("pStdPPSs", &self.pStdPPSs)
		.finish()
	}
}
/// struct `VkVideoDecodeH264SessionParametersCreateInfoKHR` from VK_KHR_video_decode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeH264SessionParametersCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeH264SessionParametersCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maxStdSPSCount: u32,
	pub maxStdPPSCount: u32,
	pub pParametersAddInfo: *const VkVideoDecodeH264SessionParametersAddInfoKHR,
}
impl Debug for VkVideoDecodeH264SessionParametersCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH264SessionParametersCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxStdSPSCount", &self.maxStdSPSCount)
		.field("maxStdPPSCount", &self.maxStdPPSCount)
		.field("pParametersAddInfo", &self.pParametersAddInfo)
		.finish()
	}
}
/// struct `VkVideoDecodeH264PictureInfoKHR` from VK_KHR_video_decode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeH264PictureInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeH264PictureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdPictureInfo: *const StdVideoDecodeH264PictureInfo,
	pub sliceCount: u32,
	pub pSliceOffsets: *const uint32_t,
}
impl Debug for VkVideoDecodeH264PictureInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH264PictureInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pStdPictureInfo", &self.pStdPictureInfo)
		.field("sliceCount", &self.sliceCount)
		.field("pSliceOffsets", &self.pSliceOffsets)
		.finish()
	}
}
/// struct `VkVideoDecodeH264DpbSlotInfoKHR` from VK_KHR_video_decode_h264
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeH264DpbSlotInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeH264DpbSlotInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdReferenceInfo: *const StdVideoDecodeH264ReferenceInfo,
}
impl Debug for VkVideoDecodeH264DpbSlotInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH264DpbSlotInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pStdReferenceInfo", &self.pStdReferenceInfo)
		.finish()
	}
}
/// trait for `VK_KHR_video_decode_h264`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_video_decode_h264.html>
pub trait VK_KHR_video_decode_h264: Debug {}
/// struct for `VK_KHR_video_decode_h264`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_decode_h264 {}
impl VK_KHR_video_decode_h264 for Vulkan_KHR_video_decode_h264 {}
impl Default for Vulkan_KHR_video_decode_h264 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_decode_h264 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_API_VERSION_1_0_0` from vulkan_video_codec_h264std_decode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_API_VERSION_1_0_0.html>
pub const VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_API_VERSION_1_0_0: u32 = 0x400000;
/// constant `STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE` from vulkan_video_codec_h264std_decode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE.html>
pub const STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE: u32 = 2u32;
/// enum `StdVideoDecodeH264FieldOrderCount` from vulkan_video_codec_h264std_decode
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoDecodeH264FieldOrderCount {
	STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_TOP = 0,
	STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_BOTTOM = 1,
	STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_INVALID = 0x7fffffff,
}
impl StdVideoDecodeH264FieldOrderCount {
	pub const STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_MAX_ENUM: StdVideoDecodeH264FieldOrderCount = StdVideoDecodeH264FieldOrderCount::STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_INVALID;
}
/// struct `StdVideoDecodeH264PictureInfoFlags` from vulkan_video_codec_h264std_decode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoDecodeH264PictureInfoFlags {
	/// Bitfield: field_pic_flag: u32 in 1 bits
	/// Bitfield: is_intra: u32 in 1 bits
	/// Bitfield: IdrPicFlag: u32 in 1 bits
	/// Bitfield: bottom_field_flag: u32 in 1 bits
	/// Bitfield: is_reference: u32 in 1 bits
	/// Bitfield: complementary_field_pair: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoDecodeH264PictureInfoFlags {
	pub fn get_field_pic_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_field_pic_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_is_intra(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_is_intra(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_IdrPicFlag(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_IdrPicFlag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_bottom_field_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_bottom_field_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_is_reference(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_is_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_complementary_field_pair(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_complementary_field_pair(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
}
impl Debug for StdVideoDecodeH264PictureInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoDecodeH264PictureInfoFlags")
		.field("field_pic_flag", &self.get_field_pic_flag())
		.field("is_intra", &self.get_is_intra())
		.field("IdrPicFlag", &self.get_IdrPicFlag())
		.field("bottom_field_flag", &self.get_bottom_field_flag())
		.field("is_reference", &self.get_is_reference())
		.field("complementary_field_pair", &self.get_complementary_field_pair())
		.finish()
	}
}
/// struct `StdVideoDecodeH264PictureInfo` from vulkan_video_codec_h264std_decode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoDecodeH264PictureInfo {
	pub flags: StdVideoDecodeH264PictureInfoFlags,
	pub seq_parameter_set_id: u8,
	pub pic_parameter_set_id: u8,
	pub reserved1: u8,
	pub reserved2: u8,
	pub frame_num: u16,
	pub idr_pic_id: u16,
	pub PicOrderCnt: [i32; STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE as usize],
}
impl Debug for StdVideoDecodeH264PictureInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoDecodeH264PictureInfo")
		.field("flags", &self.flags)
		.field("seq_parameter_set_id", &self.seq_parameter_set_id)
		.field("pic_parameter_set_id", &self.pic_parameter_set_id)
		.field("reserved1", &self.reserved1)
		.field("reserved2", &self.reserved2)
		.field("frame_num", &self.frame_num)
		.field("idr_pic_id", &self.idr_pic_id)
		.field("PicOrderCnt", &self.PicOrderCnt)
		.finish()
	}
}
/// struct `StdVideoDecodeH264ReferenceInfoFlags` from vulkan_video_codec_h264std_decode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoDecodeH264ReferenceInfoFlags {
	/// Bitfield: top_field_flag: u32 in 1 bits
	/// Bitfield: bottom_field_flag: u32 in 1 bits
	/// Bitfield: used_for_long_term_reference: u32 in 1 bits
	/// Bitfield: is_non_existing: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoDecodeH264ReferenceInfoFlags {
	pub fn get_top_field_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_top_field_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_bottom_field_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_bottom_field_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_used_for_long_term_reference(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_used_for_long_term_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_is_non_existing(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_is_non_existing(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
}
impl Debug for StdVideoDecodeH264ReferenceInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoDecodeH264ReferenceInfoFlags")
		.field("top_field_flag", &self.get_top_field_flag())
		.field("bottom_field_flag", &self.get_bottom_field_flag())
		.field("used_for_long_term_reference", &self.get_used_for_long_term_reference())
		.field("is_non_existing", &self.get_is_non_existing())
		.finish()
	}
}
/// struct `StdVideoDecodeH264ReferenceInfo` from vulkan_video_codec_h264std_decode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoDecodeH264ReferenceInfo {
	pub flags: StdVideoDecodeH264ReferenceInfoFlags,
	pub FrameNum: u16,
	pub reserved: u16,
	pub PicOrderCnt: [i32; STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE as usize],
}
impl Debug for StdVideoDecodeH264ReferenceInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoDecodeH264ReferenceInfo")
		.field("flags", &self.flags)
		.field("FrameNum", &self.FrameNum)
		.field("reserved", &self.reserved)
		.field("PicOrderCnt", &self.PicOrderCnt)
		.finish()
	}
}
/// trait for `vulkan_video_codec_h264std_decode`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vulkan_video_codec_h264std_decode.html>
pub trait vulkan_video_codec_h264std_decode: Debug {}
/// struct for `vulkan_video_codec_h264std_decode`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_h264std_decode {}
impl vulkan_video_codec_h264std_decode for Vulkan_video_codec_h264std_decode {}
impl Default for Vulkan_video_codec_h264std_decode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_h264std_decode {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkRenderingFlagsKHR` from VK_KHR_dynamic_rendering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingFlagsKHR.html>
pub type VkRenderingFlagsKHR = VkRenderingFlags;
/// type definition `VkRenderingFlagBitsKHR` from VK_KHR_dynamic_rendering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingFlagBitsKHR.html>
pub type VkRenderingFlagBitsKHR = VkRenderingFlagBits;
/// type definition `VkRenderingInfoKHR` from VK_KHR_dynamic_rendering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingInfoKHR.html>
pub type VkRenderingInfoKHR = VkRenderingInfo;
/// type definition `VkRenderingAttachmentInfoKHR` from VK_KHR_dynamic_rendering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingAttachmentInfoKHR.html>
pub type VkRenderingAttachmentInfoKHR = VkRenderingAttachmentInfo;
/// type definition `VkPipelineRenderingCreateInfoKHR` from VK_KHR_dynamic_rendering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRenderingCreateInfoKHR.html>
pub type VkPipelineRenderingCreateInfoKHR = VkPipelineRenderingCreateInfo;
/// type definition `VkPhysicalDeviceDynamicRenderingFeaturesKHR` from VK_KHR_dynamic_rendering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDynamicRenderingFeaturesKHR.html>
pub type VkPhysicalDeviceDynamicRenderingFeaturesKHR = VkPhysicalDeviceDynamicRenderingFeatures;
/// type definition `VkCommandBufferInheritanceRenderingInfoKHR` from VK_KHR_dynamic_rendering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferInheritanceRenderingInfoKHR.html>
pub type VkCommandBufferInheritanceRenderingInfoKHR = VkCommandBufferInheritanceRenderingInfo;
/// function prototype `PFN_vkCmdBeginRenderingKHR` from VK_KHR_dynamic_rendering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderingKHR.html>
type PFN_vkCmdBeginRenderingKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo);
/// function prototype `PFN_vkCmdEndRenderingKHR` from VK_KHR_dynamic_rendering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRenderingKHR.html>
type PFN_vkCmdEndRenderingKHR = extern "system" fn(commandBuffer: VkCommandBuffer);
/// The dummy function for `vkCmdBeginRenderingKHR` from `VK_KHR_dynamic_rendering`
extern "system" fn dummy_vkCmdBeginRenderingKHR(_: VkCommandBuffer, _: *const VkRenderingInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdBeginRenderingKHR"))
}
/// trait for `VK_KHR_dynamic_rendering`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_dynamic_rendering.html>
pub trait VK_KHR_dynamic_rendering: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderingKHR.html>
	fn vkCmdBeginRenderingKHR(&self, commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo) -> Result<()>;
}
/// struct for `VK_KHR_dynamic_rendering`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_dynamic_rendering {
	vk_cmd_begin_rendering_khr: PFN_vkCmdBeginRenderingKHR,
}
impl VK_KHR_dynamic_rendering for Vulkan_KHR_dynamic_rendering {
	fn vkCmdBeginRenderingKHR(&self, commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_begin_rendering_khr)(commandBuffer, pRenderingInfo))))
	}
}
impl Default for Vulkan_KHR_dynamic_rendering {
	fn default() -> Self {
		Self {
			vk_cmd_begin_rendering_khr: dummy_vkCmdBeginRenderingKHR,
		}
	}
}
impl Vulkan_KHR_dynamic_rendering {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_begin_rendering_khr: {let proc = get_instance_proc_address(instance, "vkCmdBeginRenderingKHR"); if proc == null() {dummy_vkCmdBeginRenderingKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkRenderPassMultiviewCreateInfoKHR` from VK_KHR_multiview
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassMultiviewCreateInfoKHR.html>
pub type VkRenderPassMultiviewCreateInfoKHR = VkRenderPassMultiviewCreateInfo;
/// type definition `VkPhysicalDeviceMultiviewFeaturesKHR` from VK_KHR_multiview
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMultiviewFeaturesKHR.html>
pub type VkPhysicalDeviceMultiviewFeaturesKHR = VkPhysicalDeviceMultiviewFeatures;
/// type definition `VkPhysicalDeviceMultiviewPropertiesKHR` from VK_KHR_multiview
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMultiviewPropertiesKHR.html>
pub type VkPhysicalDeviceMultiviewPropertiesKHR = VkPhysicalDeviceMultiviewProperties;
/// trait for `VK_KHR_multiview`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_multiview.html>
pub trait VK_KHR_multiview: Debug {}
/// struct for `VK_KHR_multiview`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_multiview {}
impl VK_KHR_multiview for Vulkan_KHR_multiview {}
impl Default for Vulkan_KHR_multiview {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_multiview {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceFeatures2KHR` from VK_KHR_get_physical_device_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFeatures2KHR.html>
pub type VkPhysicalDeviceFeatures2KHR = VkPhysicalDeviceFeatures2;
/// type definition `VkPhysicalDeviceProperties2KHR` from VK_KHR_get_physical_device_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceProperties2KHR.html>
pub type VkPhysicalDeviceProperties2KHR = VkPhysicalDeviceProperties2;
/// type definition `VkFormatProperties2KHR` from VK_KHR_get_physical_device_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormatProperties2KHR.html>
pub type VkFormatProperties2KHR = VkFormatProperties2;
/// type definition `VkImageFormatProperties2KHR` from VK_KHR_get_physical_device_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageFormatProperties2KHR.html>
pub type VkImageFormatProperties2KHR = VkImageFormatProperties2;
/// type definition `VkPhysicalDeviceImageFormatInfo2KHR` from VK_KHR_get_physical_device_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImageFormatInfo2KHR.html>
pub type VkPhysicalDeviceImageFormatInfo2KHR = VkPhysicalDeviceImageFormatInfo2;
/// type definition `VkQueueFamilyProperties2KHR` from VK_KHR_get_physical_device_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueFamilyProperties2KHR.html>
pub type VkQueueFamilyProperties2KHR = VkQueueFamilyProperties2;
/// type definition `VkPhysicalDeviceMemoryProperties2KHR` from VK_KHR_get_physical_device_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMemoryProperties2KHR.html>
pub type VkPhysicalDeviceMemoryProperties2KHR = VkPhysicalDeviceMemoryProperties2;
/// type definition `VkSparseImageFormatProperties2KHR` from VK_KHR_get_physical_device_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSparseImageFormatProperties2KHR.html>
pub type VkSparseImageFormatProperties2KHR = VkSparseImageFormatProperties2;
/// type definition `VkPhysicalDeviceSparseImageFormatInfo2KHR` from VK_KHR_get_physical_device_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSparseImageFormatInfo2KHR.html>
pub type VkPhysicalDeviceSparseImageFormatInfo2KHR = VkPhysicalDeviceSparseImageFormatInfo2;
/// function prototype `PFN_vkGetPhysicalDeviceFeatures2KHR` from VK_KHR_get_physical_device_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures2KHR.html>
type PFN_vkGetPhysicalDeviceFeatures2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2);
/// function prototype `PFN_vkGetPhysicalDeviceProperties2KHR` from VK_KHR_get_physical_device_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceProperties2KHR.html>
type PFN_vkGetPhysicalDeviceProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties2);
/// function prototype `PFN_vkGetPhysicalDeviceFormatProperties2KHR` from VK_KHR_get_physical_device_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFormatProperties2KHR.html>
type PFN_vkGetPhysicalDeviceFormatProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties2);
/// function prototype `PFN_vkGetPhysicalDeviceImageFormatProperties2KHR` from VK_KHR_get_physical_device_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceImageFormatProperties2KHR.html>
type PFN_vkGetPhysicalDeviceImageFormatProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *mut VkImageFormatProperties2) -> VkResult;
/// function prototype `PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR` from VK_KHR_get_physical_device_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties2KHR.html>
type PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties2);
/// function prototype `PFN_vkGetPhysicalDeviceMemoryProperties2KHR` from VK_KHR_get_physical_device_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMemoryProperties2KHR.html>
type PFN_vkGetPhysicalDeviceMemoryProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2);
/// function prototype `PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR` from VK_KHR_get_physical_device_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2KHR.html>
type PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties2);
/// The dummy function for `vkGetPhysicalDeviceFeatures2KHR` from `VK_KHR_get_physical_device_properties2`
extern "system" fn dummy_vkGetPhysicalDeviceFeatures2KHR(_: VkPhysicalDevice, _: *mut VkPhysicalDeviceFeatures2) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceFeatures2KHR"))
}
/// trait for `VK_KHR_get_physical_device_properties2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_get_physical_device_properties2.html>
pub trait VK_KHR_get_physical_device_properties2: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures2KHR.html>
	fn vkGetPhysicalDeviceFeatures2KHR(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2) -> Result<()>;
}
/// struct for `VK_KHR_get_physical_device_properties2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_get_physical_device_properties2 {
	vk_get_physical_device_features2_khr: PFN_vkGetPhysicalDeviceFeatures2KHR,
}
impl VK_KHR_get_physical_device_properties2 for Vulkan_KHR_get_physical_device_properties2 {
	fn vkGetPhysicalDeviceFeatures2KHR(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_features2_khr)(physicalDevice, pFeatures))))
	}
}
impl Default for Vulkan_KHR_get_physical_device_properties2 {
	fn default() -> Self {
		Self {
			vk_get_physical_device_features2_khr: dummy_vkGetPhysicalDeviceFeatures2KHR,
		}
	}
}
impl Vulkan_KHR_get_physical_device_properties2 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_features2_khr: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceFeatures2KHR"); if proc == null() {dummy_vkGetPhysicalDeviceFeatures2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPeerMemoryFeatureFlagsKHR` from VK_KHR_device_group
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPeerMemoryFeatureFlagsKHR.html>
pub type VkPeerMemoryFeatureFlagsKHR = VkPeerMemoryFeatureFlags;
/// type definition `VkPeerMemoryFeatureFlagBitsKHR` from VK_KHR_device_group
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPeerMemoryFeatureFlagBitsKHR.html>
pub type VkPeerMemoryFeatureFlagBitsKHR = VkPeerMemoryFeatureFlagBits;
/// type definition `VkMemoryAllocateFlagsKHR` from VK_KHR_device_group
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryAllocateFlagsKHR.html>
pub type VkMemoryAllocateFlagsKHR = VkMemoryAllocateFlags;
/// type definition `VkMemoryAllocateFlagBitsKHR` from VK_KHR_device_group
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryAllocateFlagBitsKHR.html>
pub type VkMemoryAllocateFlagBitsKHR = VkMemoryAllocateFlagBits;
/// type definition `VkMemoryAllocateFlagsInfoKHR` from VK_KHR_device_group
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryAllocateFlagsInfoKHR.html>
pub type VkMemoryAllocateFlagsInfoKHR = VkMemoryAllocateFlagsInfo;
/// type definition `VkDeviceGroupRenderPassBeginInfoKHR` from VK_KHR_device_group
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupRenderPassBeginInfoKHR.html>
pub type VkDeviceGroupRenderPassBeginInfoKHR = VkDeviceGroupRenderPassBeginInfo;
/// type definition `VkDeviceGroupCommandBufferBeginInfoKHR` from VK_KHR_device_group
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupCommandBufferBeginInfoKHR.html>
pub type VkDeviceGroupCommandBufferBeginInfoKHR = VkDeviceGroupCommandBufferBeginInfo;
/// type definition `VkDeviceGroupSubmitInfoKHR` from VK_KHR_device_group
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupSubmitInfoKHR.html>
pub type VkDeviceGroupSubmitInfoKHR = VkDeviceGroupSubmitInfo;
/// type definition `VkDeviceGroupBindSparseInfoKHR` from VK_KHR_device_group
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupBindSparseInfoKHR.html>
pub type VkDeviceGroupBindSparseInfoKHR = VkDeviceGroupBindSparseInfo;
/// type definition `VkBindBufferMemoryDeviceGroupInfoKHR` from VK_KHR_device_group
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindBufferMemoryDeviceGroupInfoKHR.html>
pub type VkBindBufferMemoryDeviceGroupInfoKHR = VkBindBufferMemoryDeviceGroupInfo;
/// type definition `VkBindImageMemoryDeviceGroupInfoKHR` from VK_KHR_device_group
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindImageMemoryDeviceGroupInfoKHR.html>
pub type VkBindImageMemoryDeviceGroupInfoKHR = VkBindImageMemoryDeviceGroupInfo;
/// function prototype `PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR` from VK_KHR_device_group
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceGroupPeerMemoryFeaturesKHR.html>
type PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR = extern "system" fn(device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags);
/// function prototype `PFN_vkCmdSetDeviceMaskKHR` from VK_KHR_device_group
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDeviceMaskKHR.html>
type PFN_vkCmdSetDeviceMaskKHR = extern "system" fn(commandBuffer: VkCommandBuffer, deviceMask: u32);
/// function prototype `PFN_vkCmdDispatchBaseKHR` from VK_KHR_device_group
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchBaseKHR.html>
type PFN_vkCmdDispatchBaseKHR = extern "system" fn(commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32);
/// The dummy function for `vkGetDeviceGroupPeerMemoryFeaturesKHR` from `VK_KHR_device_group`
extern "system" fn dummy_vkGetDeviceGroupPeerMemoryFeaturesKHR(_: VkDevice, _: u32, _: u32, _: u32, _: *mut VkPeerMemoryFeatureFlags) {
	panic_any(VkError::NullFunctionPointer("vkGetDeviceGroupPeerMemoryFeaturesKHR"))
}
/// trait for `VK_KHR_device_group`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_device_group.html>
pub trait VK_KHR_device_group: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceGroupPeerMemoryFeaturesKHR.html>
	fn vkGetDeviceGroupPeerMemoryFeaturesKHR(&self, device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags) -> Result<()>;
}
/// struct for `VK_KHR_device_group`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_device_group {
	vk_get_device_group_peer_memory_features_khr: PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR,
}
impl VK_KHR_device_group for Vulkan_KHR_device_group {
	fn vkGetDeviceGroupPeerMemoryFeaturesKHR(&self, device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_device_group_peer_memory_features_khr)(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures))))
	}
}
impl Default for Vulkan_KHR_device_group {
	fn default() -> Self {
		Self {
			vk_get_device_group_peer_memory_features_khr: dummy_vkGetDeviceGroupPeerMemoryFeaturesKHR,
		}
	}
}
impl Vulkan_KHR_device_group {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_device_group_peer_memory_features_khr: {let proc = get_instance_proc_address(instance, "vkGetDeviceGroupPeerMemoryFeaturesKHR"); if proc == null() {dummy_vkGetDeviceGroupPeerMemoryFeaturesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// trait for `VK_KHR_shader_draw_parameters`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_draw_parameters.html>
pub trait VK_KHR_shader_draw_parameters: Debug {}
/// struct for `VK_KHR_shader_draw_parameters`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_draw_parameters {}
impl VK_KHR_shader_draw_parameters for Vulkan_KHR_shader_draw_parameters {}
impl Default for Vulkan_KHR_shader_draw_parameters {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_draw_parameters {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkCommandPoolTrimFlagsKHR` from VK_KHR_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandPoolTrimFlagsKHR.html>
pub type VkCommandPoolTrimFlagsKHR = VkCommandPoolTrimFlags;
/// function prototype `PFN_vkTrimCommandPoolKHR` from VK_KHR_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkTrimCommandPoolKHR.html>
type PFN_vkTrimCommandPoolKHR = extern "system" fn(device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags);
/// The dummy function for `vkTrimCommandPoolKHR` from `VK_KHR_maintenance1`
extern "system" fn dummy_vkTrimCommandPoolKHR(_: VkDevice, _: VkCommandPool, _: VkCommandPoolTrimFlags) {
	panic_any(VkError::NullFunctionPointer("vkTrimCommandPoolKHR"))
}
/// trait for `VK_KHR_maintenance1`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_maintenance1.html>
pub trait VK_KHR_maintenance1: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkTrimCommandPoolKHR.html>
	fn vkTrimCommandPoolKHR(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) -> Result<()>;
}
/// struct for `VK_KHR_maintenance1`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance1 {
	vk_trim_command_pool_khr: PFN_vkTrimCommandPoolKHR,
}
impl VK_KHR_maintenance1 for Vulkan_KHR_maintenance1 {
	fn vkTrimCommandPoolKHR(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_trim_command_pool_khr)(device, commandPool, flags))))
	}
}
impl Default for Vulkan_KHR_maintenance1 {
	fn default() -> Self {
		Self {
			vk_trim_command_pool_khr: dummy_vkTrimCommandPoolKHR,
		}
	}
}
impl Vulkan_KHR_maintenance1 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_trim_command_pool_khr: {let proc = get_instance_proc_address(instance, "vkTrimCommandPoolKHR"); if proc == null() {dummy_vkTrimCommandPoolKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// constant `VK_MAX_DEVICE_GROUP_SIZE_KHR` from VK_KHR_device_group_creation
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_DEVICE_GROUP_SIZE_KHR.html>
pub const VK_MAX_DEVICE_GROUP_SIZE_KHR: u32 = 32u32;
/// type definition `VkPhysicalDeviceGroupPropertiesKHR` from VK_KHR_device_group_creation
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceGroupPropertiesKHR.html>
pub type VkPhysicalDeviceGroupPropertiesKHR = VkPhysicalDeviceGroupProperties;
/// type definition `VkDeviceGroupDeviceCreateInfoKHR` from VK_KHR_device_group_creation
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceGroupDeviceCreateInfoKHR.html>
pub type VkDeviceGroupDeviceCreateInfoKHR = VkDeviceGroupDeviceCreateInfo;
/// function prototype `PFN_vkEnumeratePhysicalDeviceGroupsKHR` from VK_KHR_device_group_creation
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceGroupsKHR.html>
type PFN_vkEnumeratePhysicalDeviceGroupsKHR = extern "system" fn(instance: VkInstance, pPhysicalDeviceGroupCount: *mut uint32_t, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties) -> VkResult;
/// The dummy function for `vkEnumeratePhysicalDeviceGroupsKHR` from `VK_KHR_device_group_creation`
extern "system" fn dummy_vkEnumeratePhysicalDeviceGroupsKHR(_: VkInstance, _: *mut uint32_t, _: *mut VkPhysicalDeviceGroupProperties) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkEnumeratePhysicalDeviceGroupsKHR"))
}
/// trait for `VK_KHR_device_group_creation`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_device_group_creation.html>
pub trait VK_KHR_device_group_creation: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceGroupsKHR.html>
	fn vkEnumeratePhysicalDeviceGroupsKHR(&self, instance: VkInstance, pPhysicalDeviceGroupCount: *mut uint32_t, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties) -> Result<()>;
}
/// struct for `VK_KHR_device_group_creation`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_device_group_creation {
	vk_enumerate_physical_device_groups_khr: PFN_vkEnumeratePhysicalDeviceGroupsKHR,
}
impl VK_KHR_device_group_creation for Vulkan_KHR_device_group_creation {
	fn vkEnumeratePhysicalDeviceGroupsKHR(&self, instance: VkInstance, pPhysicalDeviceGroupCount: *mut uint32_t, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties) -> Result<()> {
		convert_result("vkEnumeratePhysicalDeviceGroupsKHR", catch_unwind(||((self.vk_enumerate_physical_device_groups_khr)(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties))))
	}
}
impl Default for Vulkan_KHR_device_group_creation {
	fn default() -> Self {
		Self {
			vk_enumerate_physical_device_groups_khr: dummy_vkEnumeratePhysicalDeviceGroupsKHR,
		}
	}
}
impl Vulkan_KHR_device_group_creation {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_enumerate_physical_device_groups_khr: {let proc = get_instance_proc_address(instance, "vkEnumeratePhysicalDeviceGroupsKHR"); if proc == null() {dummy_vkEnumeratePhysicalDeviceGroupsKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// constant `VK_LUID_SIZE_KHR` from VK_KHR_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_LUID_SIZE_KHR.html>
pub const VK_LUID_SIZE_KHR: u32 = 8u32;
/// type definition `VkExternalMemoryHandleTypeFlagsKHR` from VK_KHR_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryHandleTypeFlagsKHR.html>
pub type VkExternalMemoryHandleTypeFlagsKHR = VkExternalMemoryHandleTypeFlags;
/// type definition `VkExternalMemoryHandleTypeFlagBitsKHR` from VK_KHR_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryHandleTypeFlagBitsKHR.html>
pub type VkExternalMemoryHandleTypeFlagBitsKHR = VkExternalMemoryHandleTypeFlagBits;
/// type definition `VkExternalMemoryFeatureFlagsKHR` from VK_KHR_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryFeatureFlagsKHR.html>
pub type VkExternalMemoryFeatureFlagsKHR = VkExternalMemoryFeatureFlags;
/// type definition `VkExternalMemoryFeatureFlagBitsKHR` from VK_KHR_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryFeatureFlagBitsKHR.html>
pub type VkExternalMemoryFeatureFlagBitsKHR = VkExternalMemoryFeatureFlagBits;
/// type definition `VkExternalMemoryPropertiesKHR` from VK_KHR_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryPropertiesKHR.html>
pub type VkExternalMemoryPropertiesKHR = VkExternalMemoryProperties;
/// type definition `VkPhysicalDeviceExternalImageFormatInfoKHR` from VK_KHR_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExternalImageFormatInfoKHR.html>
pub type VkPhysicalDeviceExternalImageFormatInfoKHR = VkPhysicalDeviceExternalImageFormatInfo;
/// type definition `VkExternalImageFormatPropertiesKHR` from VK_KHR_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalImageFormatPropertiesKHR.html>
pub type VkExternalImageFormatPropertiesKHR = VkExternalImageFormatProperties;
/// type definition `VkPhysicalDeviceExternalBufferInfoKHR` from VK_KHR_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExternalBufferInfoKHR.html>
pub type VkPhysicalDeviceExternalBufferInfoKHR = VkPhysicalDeviceExternalBufferInfo;
/// type definition `VkExternalBufferPropertiesKHR` from VK_KHR_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalBufferPropertiesKHR.html>
pub type VkExternalBufferPropertiesKHR = VkExternalBufferProperties;
/// type definition `VkPhysicalDeviceIDPropertiesKHR` from VK_KHR_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceIDPropertiesKHR.html>
pub type VkPhysicalDeviceIDPropertiesKHR = VkPhysicalDeviceIDProperties;
/// function prototype `PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR` from VK_KHR_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalBufferPropertiesKHR.html>
type PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut VkExternalBufferProperties);
/// The dummy function for `vkGetPhysicalDeviceExternalBufferPropertiesKHR` from `VK_KHR_external_memory_capabilities`
extern "system" fn dummy_vkGetPhysicalDeviceExternalBufferPropertiesKHR(_: VkPhysicalDevice, _: *const VkPhysicalDeviceExternalBufferInfo, _: *mut VkExternalBufferProperties) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceExternalBufferPropertiesKHR"))
}
/// trait for `VK_KHR_external_memory_capabilities`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_external_memory_capabilities.html>
pub trait VK_KHR_external_memory_capabilities: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalBufferPropertiesKHR.html>
	fn vkGetPhysicalDeviceExternalBufferPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut VkExternalBufferProperties) -> Result<()>;
}
/// struct for `VK_KHR_external_memory_capabilities`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_memory_capabilities {
	vk_get_physical_device_external_buffer_properties_khr: PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR,
}
impl VK_KHR_external_memory_capabilities for Vulkan_KHR_external_memory_capabilities {
	fn vkGetPhysicalDeviceExternalBufferPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut VkExternalBufferProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_external_buffer_properties_khr)(physicalDevice, pExternalBufferInfo, pExternalBufferProperties))))
	}
}
impl Default for Vulkan_KHR_external_memory_capabilities {
	fn default() -> Self {
		Self {
			vk_get_physical_device_external_buffer_properties_khr: dummy_vkGetPhysicalDeviceExternalBufferPropertiesKHR,
		}
	}
}
impl Vulkan_KHR_external_memory_capabilities {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_external_buffer_properties_khr: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceExternalBufferPropertiesKHR"); if proc == null() {dummy_vkGetPhysicalDeviceExternalBufferPropertiesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// constant `VK_QUEUE_FAMILY_EXTERNAL_KHR` from VK_KHR_external_memory
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QUEUE_FAMILY_EXTERNAL_KHR.html>
pub const VK_QUEUE_FAMILY_EXTERNAL_KHR: u32 = !1u32;
/// type definition `VkExternalMemoryImageCreateInfoKHR` from VK_KHR_external_memory
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryImageCreateInfoKHR.html>
pub type VkExternalMemoryImageCreateInfoKHR = VkExternalMemoryImageCreateInfo;
/// type definition `VkExternalMemoryBufferCreateInfoKHR` from VK_KHR_external_memory
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryBufferCreateInfoKHR.html>
pub type VkExternalMemoryBufferCreateInfoKHR = VkExternalMemoryBufferCreateInfo;
/// type definition `VkExportMemoryAllocateInfoKHR` from VK_KHR_external_memory
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExportMemoryAllocateInfoKHR.html>
pub type VkExportMemoryAllocateInfoKHR = VkExportMemoryAllocateInfo;
/// trait for `VK_KHR_external_memory`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_external_memory.html>
pub trait VK_KHR_external_memory: Debug {}
/// struct for `VK_KHR_external_memory`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_memory {}
impl VK_KHR_external_memory for Vulkan_KHR_external_memory {}
impl Default for Vulkan_KHR_external_memory {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_external_memory {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkImportMemoryFdInfoKHR` from VK_KHR_external_memory_fd
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImportMemoryFdInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImportMemoryFdInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleType: VkExternalMemoryHandleTypeFlagBits,
	pub fd: i32,
}
impl Debug for VkImportMemoryFdInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImportMemoryFdInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("handleType", &self.handleType)
		.field("fd", &self.fd)
		.finish()
	}
}
/// struct `VkMemoryFdPropertiesKHR` from VK_KHR_external_memory_fd
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryFdPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryFdPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryTypeBits: u32,
}
impl Debug for VkMemoryFdPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryFdPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("memoryTypeBits", &self.memoryTypeBits)
		.finish()
	}
}
/// struct `VkMemoryGetFdInfoKHR` from VK_KHR_external_memory_fd
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryGetFdInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryGetFdInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub memory: VkDeviceMemory,
	pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
impl Debug for VkMemoryGetFdInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryGetFdInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("memory", &self.memory)
		.field("handleType", &self.handleType)
		.finish()
	}
}
/// function prototype `PFN_vkGetMemoryFdKHR` from VK_KHR_external_memory_fd
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryFdKHR.html>
type PFN_vkGetMemoryFdKHR = extern "system" fn(device: VkDevice, pGetFdInfo: *const VkMemoryGetFdInfoKHR, pFd: *mut int) -> VkResult;
/// function prototype `PFN_vkGetMemoryFdPropertiesKHR` from VK_KHR_external_memory_fd
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryFdPropertiesKHR.html>
type PFN_vkGetMemoryFdPropertiesKHR = extern "system" fn(device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, fd: i32, pMemoryFdProperties: *mut VkMemoryFdPropertiesKHR) -> VkResult;
/// The dummy function for `vkGetMemoryFdKHR` from `VK_KHR_external_memory_fd`
extern "system" fn dummy_vkGetMemoryFdKHR(_: VkDevice, _: *const VkMemoryGetFdInfoKHR, _: *mut int) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetMemoryFdKHR"))
}
/// trait for `VK_KHR_external_memory_fd`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_external_memory_fd.html>
pub trait VK_KHR_external_memory_fd: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryFdKHR.html>
	fn vkGetMemoryFdKHR(&self, device: VkDevice, pGetFdInfo: *const VkMemoryGetFdInfoKHR, pFd: *mut int) -> Result<()>;
}
/// struct for `VK_KHR_external_memory_fd`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_memory_fd {
	vk_get_memory_fd_khr: PFN_vkGetMemoryFdKHR,
}
impl VK_KHR_external_memory_fd for Vulkan_KHR_external_memory_fd {
	fn vkGetMemoryFdKHR(&self, device: VkDevice, pGetFdInfo: *const VkMemoryGetFdInfoKHR, pFd: *mut int) -> Result<()> {
		convert_result("vkGetMemoryFdKHR", catch_unwind(||((self.vk_get_memory_fd_khr)(device, pGetFdInfo, pFd))))
	}
}
impl Default for Vulkan_KHR_external_memory_fd {
	fn default() -> Self {
		Self {
			vk_get_memory_fd_khr: dummy_vkGetMemoryFdKHR,
		}
	}
}
impl Vulkan_KHR_external_memory_fd {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_memory_fd_khr: {let proc = get_instance_proc_address(instance, "vkGetMemoryFdKHR"); if proc == null() {dummy_vkGetMemoryFdKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkExternalSemaphoreHandleTypeFlagsKHR` from VK_KHR_external_semaphore_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalSemaphoreHandleTypeFlagsKHR.html>
pub type VkExternalSemaphoreHandleTypeFlagsKHR = VkExternalSemaphoreHandleTypeFlags;
/// type definition `VkExternalSemaphoreHandleTypeFlagBitsKHR` from VK_KHR_external_semaphore_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalSemaphoreHandleTypeFlagBitsKHR.html>
pub type VkExternalSemaphoreHandleTypeFlagBitsKHR = VkExternalSemaphoreHandleTypeFlagBits;
/// type definition `VkExternalSemaphoreFeatureFlagsKHR` from VK_KHR_external_semaphore_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalSemaphoreFeatureFlagsKHR.html>
pub type VkExternalSemaphoreFeatureFlagsKHR = VkExternalSemaphoreFeatureFlags;
/// type definition `VkExternalSemaphoreFeatureFlagBitsKHR` from VK_KHR_external_semaphore_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalSemaphoreFeatureFlagBitsKHR.html>
pub type VkExternalSemaphoreFeatureFlagBitsKHR = VkExternalSemaphoreFeatureFlagBits;
/// type definition `VkPhysicalDeviceExternalSemaphoreInfoKHR` from VK_KHR_external_semaphore_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExternalSemaphoreInfoKHR.html>
pub type VkPhysicalDeviceExternalSemaphoreInfoKHR = VkPhysicalDeviceExternalSemaphoreInfo;
/// type definition `VkExternalSemaphorePropertiesKHR` from VK_KHR_external_semaphore_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalSemaphorePropertiesKHR.html>
pub type VkExternalSemaphorePropertiesKHR = VkExternalSemaphoreProperties;
/// function prototype `PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR` from VK_KHR_external_semaphore_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.html>
type PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties);
/// The dummy function for `vkGetPhysicalDeviceExternalSemaphorePropertiesKHR` from `VK_KHR_external_semaphore_capabilities`
extern "system" fn dummy_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(_: VkPhysicalDevice, _: *const VkPhysicalDeviceExternalSemaphoreInfo, _: *mut VkExternalSemaphoreProperties) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"))
}
/// trait for `VK_KHR_external_semaphore_capabilities`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_external_semaphore_capabilities.html>
pub trait VK_KHR_external_semaphore_capabilities: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.html>
	fn vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties) -> Result<()>;
}
/// struct for `VK_KHR_external_semaphore_capabilities`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_semaphore_capabilities {
	vk_get_physical_device_external_semaphore_properties_khr: PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR,
}
impl VK_KHR_external_semaphore_capabilities for Vulkan_KHR_external_semaphore_capabilities {
	fn vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_external_semaphore_properties_khr)(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties))))
	}
}
impl Default for Vulkan_KHR_external_semaphore_capabilities {
	fn default() -> Self {
		Self {
			vk_get_physical_device_external_semaphore_properties_khr: dummy_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR,
		}
	}
}
impl Vulkan_KHR_external_semaphore_capabilities {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_external_semaphore_properties_khr: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"); if proc == null() {dummy_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkSemaphoreImportFlagsKHR` from VK_KHR_external_semaphore
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreImportFlagsKHR.html>
pub type VkSemaphoreImportFlagsKHR = VkSemaphoreImportFlags;
/// type definition `VkSemaphoreImportFlagBitsKHR` from VK_KHR_external_semaphore
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreImportFlagBitsKHR.html>
pub type VkSemaphoreImportFlagBitsKHR = VkSemaphoreImportFlagBits;
/// type definition `VkExportSemaphoreCreateInfoKHR` from VK_KHR_external_semaphore
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExportSemaphoreCreateInfoKHR.html>
pub type VkExportSemaphoreCreateInfoKHR = VkExportSemaphoreCreateInfo;
/// trait for `VK_KHR_external_semaphore`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_external_semaphore.html>
pub trait VK_KHR_external_semaphore: Debug {}
/// struct for `VK_KHR_external_semaphore`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_semaphore {}
impl VK_KHR_external_semaphore for Vulkan_KHR_external_semaphore {}
impl Default for Vulkan_KHR_external_semaphore {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_external_semaphore {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkImportSemaphoreFdInfoKHR` from VK_KHR_external_semaphore_fd
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImportSemaphoreFdInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImportSemaphoreFdInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub semaphore: VkSemaphore,
	pub flags: VkSemaphoreImportFlags,
	pub handleType: VkExternalSemaphoreHandleTypeFlagBits,
	pub fd: i32,
}
impl Debug for VkImportSemaphoreFdInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImportSemaphoreFdInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("semaphore", &self.semaphore)
		.field("flags", &self.flags)
		.field("handleType", &self.handleType)
		.field("fd", &self.fd)
		.finish()
	}
}
/// struct `VkSemaphoreGetFdInfoKHR` from VK_KHR_external_semaphore_fd
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreGetFdInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSemaphoreGetFdInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub semaphore: VkSemaphore,
	pub handleType: VkExternalSemaphoreHandleTypeFlagBits,
}
impl Debug for VkSemaphoreGetFdInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSemaphoreGetFdInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("semaphore", &self.semaphore)
		.field("handleType", &self.handleType)
		.finish()
	}
}
/// function prototype `PFN_vkImportSemaphoreFdKHR` from VK_KHR_external_semaphore_fd
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkImportSemaphoreFdKHR.html>
type PFN_vkImportSemaphoreFdKHR = extern "system" fn(device: VkDevice, pImportSemaphoreFdInfo: *const VkImportSemaphoreFdInfoKHR) -> VkResult;
/// function prototype `PFN_vkGetSemaphoreFdKHR` from VK_KHR_external_semaphore_fd
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSemaphoreFdKHR.html>
type PFN_vkGetSemaphoreFdKHR = extern "system" fn(device: VkDevice, pGetFdInfo: *const VkSemaphoreGetFdInfoKHR, pFd: *mut int) -> VkResult;
/// The dummy function for `vkImportSemaphoreFdKHR` from `VK_KHR_external_semaphore_fd`
extern "system" fn dummy_vkImportSemaphoreFdKHR(_: VkDevice, _: *const VkImportSemaphoreFdInfoKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkImportSemaphoreFdKHR"))
}
/// trait for `VK_KHR_external_semaphore_fd`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_external_semaphore_fd.html>
pub trait VK_KHR_external_semaphore_fd: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkImportSemaphoreFdKHR.html>
	fn vkImportSemaphoreFdKHR(&self, device: VkDevice, pImportSemaphoreFdInfo: *const VkImportSemaphoreFdInfoKHR) -> Result<()>;
}
/// struct for `VK_KHR_external_semaphore_fd`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_semaphore_fd {
	vk_import_semaphore_fd_khr: PFN_vkImportSemaphoreFdKHR,
}
impl VK_KHR_external_semaphore_fd for Vulkan_KHR_external_semaphore_fd {
	fn vkImportSemaphoreFdKHR(&self, device: VkDevice, pImportSemaphoreFdInfo: *const VkImportSemaphoreFdInfoKHR) -> Result<()> {
		convert_result("vkImportSemaphoreFdKHR", catch_unwind(||((self.vk_import_semaphore_fd_khr)(device, pImportSemaphoreFdInfo))))
	}
}
impl Default for Vulkan_KHR_external_semaphore_fd {
	fn default() -> Self {
		Self {
			vk_import_semaphore_fd_khr: dummy_vkImportSemaphoreFdKHR,
		}
	}
}
impl Vulkan_KHR_external_semaphore_fd {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_import_semaphore_fd_khr: {let proc = get_instance_proc_address(instance, "vkImportSemaphoreFdKHR"); if proc == null() {dummy_vkImportSemaphoreFdKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDevicePushDescriptorPropertiesKHR` from VK_KHR_push_descriptor
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePushDescriptorPropertiesKHR.html>
pub type VkPhysicalDevicePushDescriptorPropertiesKHR = VkPhysicalDevicePushDescriptorProperties;
/// function prototype `PFN_vkCmdPushDescriptorSetKHR` from VK_KHR_push_descriptor
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetKHR.html>
type PFN_vkCmdPushDescriptorSetKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet);
/// function prototype `PFN_vkCmdPushDescriptorSetWithTemplateKHR` from VK_KHR_push_descriptor
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetWithTemplateKHR.html>
type PFN_vkCmdPushDescriptorSetWithTemplateKHR = extern "system" fn(commandBuffer: VkCommandBuffer, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: u32, pData: *const c_void);
/// The dummy function for `vkCmdPushDescriptorSetKHR` from `VK_KHR_push_descriptor`
extern "system" fn dummy_vkCmdPushDescriptorSetKHR(_: VkCommandBuffer, _: VkPipelineBindPoint, _: VkPipelineLayout, _: u32, _: u32, _: *const VkWriteDescriptorSet) {
	panic_any(VkError::NullFunctionPointer("vkCmdPushDescriptorSetKHR"))
}
/// trait for `VK_KHR_push_descriptor`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_push_descriptor.html>
pub trait VK_KHR_push_descriptor: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetKHR.html>
	fn vkCmdPushDescriptorSetKHR(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet) -> Result<()>;
}
/// struct for `VK_KHR_push_descriptor`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_push_descriptor {
	vk_cmd_push_descriptor_set_khr: PFN_vkCmdPushDescriptorSetKHR,
}
impl VK_KHR_push_descriptor for Vulkan_KHR_push_descriptor {
	fn vkCmdPushDescriptorSetKHR(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_push_descriptor_set_khr)(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites))))
	}
}
impl Default for Vulkan_KHR_push_descriptor {
	fn default() -> Self {
		Self {
			vk_cmd_push_descriptor_set_khr: dummy_vkCmdPushDescriptorSetKHR,
		}
	}
}
impl Vulkan_KHR_push_descriptor {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_push_descriptor_set_khr: {let proc = get_instance_proc_address(instance, "vkCmdPushDescriptorSetKHR"); if proc == null() {dummy_vkCmdPushDescriptorSetKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceShaderFloat16Int8FeaturesKHR` from VK_KHR_shader_float16_int8
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderFloat16Int8FeaturesKHR.html>
pub type VkPhysicalDeviceShaderFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;
/// type definition `VkPhysicalDeviceFloat16Int8FeaturesKHR` from VK_KHR_shader_float16_int8
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFloat16Int8FeaturesKHR.html>
pub type VkPhysicalDeviceFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;
/// trait for `VK_KHR_shader_float16_int8`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_float16_int8.html>
pub trait VK_KHR_shader_float16_int8: Debug {}
/// struct for `VK_KHR_shader_float16_int8`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_float16_int8 {}
impl VK_KHR_shader_float16_int8 for Vulkan_KHR_shader_float16_int8 {}
impl Default for Vulkan_KHR_shader_float16_int8 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_float16_int8 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDevice16BitStorageFeaturesKHR` from VK_KHR_16bit_storage
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevice16BitStorageFeaturesKHR.html>
pub type VkPhysicalDevice16BitStorageFeaturesKHR = VkPhysicalDevice16BitStorageFeatures;
/// trait for `VK_KHR_16bit_storage`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_16bit_storage.html>
pub trait VK_KHR_16bit_storage: Debug {}
/// struct for `VK_KHR_16bit_storage`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_16bit_storage {}
impl VK_KHR_16bit_storage for Vulkan_KHR_16bit_storage {}
impl Default for Vulkan_KHR_16bit_storage {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_16bit_storage {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkRectLayerKHR` from VK_KHR_incremental_present
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRectLayerKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRectLayerKHR {
	pub offset: VkOffset2D,
	pub extent: VkExtent2D,
	pub layer: u32,
}
impl Debug for VkRectLayerKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRectLayerKHR")
		.field("offset", &self.offset)
		.field("extent", &self.extent)
		.field("layer", &self.layer)
		.finish()
	}
}
/// struct `VkPresentRegionKHR` from VK_KHR_incremental_present
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentRegionKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPresentRegionKHR {
	pub rectangleCount: u32,
	pub pRectangles: *const VkRectLayerKHR,
}
impl Debug for VkPresentRegionKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPresentRegionKHR")
		.field("rectangleCount", &self.rectangleCount)
		.field("pRectangles", &self.pRectangles)
		.finish()
	}
}
/// struct `VkPresentRegionsKHR` from VK_KHR_incremental_present
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentRegionsKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPresentRegionsKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount: u32,
	pub pRegions: *const VkPresentRegionKHR,
}
impl Debug for VkPresentRegionsKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPresentRegionsKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("swapchainCount", &self.swapchainCount)
		.field("pRegions", &self.pRegions)
		.finish()
	}
}
/// trait for `VK_KHR_incremental_present`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_incremental_present.html>
pub trait VK_KHR_incremental_present: Debug {}
/// struct for `VK_KHR_incremental_present`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_incremental_present {}
impl VK_KHR_incremental_present for Vulkan_KHR_incremental_present {}
impl Default for Vulkan_KHR_incremental_present {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_incremental_present {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkDescriptorUpdateTemplateKHR` from VK_KHR_descriptor_update_template
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorUpdateTemplateKHR.html>
pub type VkDescriptorUpdateTemplateKHR = VkDescriptorUpdateTemplate;
/// type definition `VkDescriptorUpdateTemplateTypeKHR` from VK_KHR_descriptor_update_template
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorUpdateTemplateTypeKHR.html>
pub type VkDescriptorUpdateTemplateTypeKHR = VkDescriptorUpdateTemplateType;
/// type definition `VkDescriptorUpdateTemplateCreateFlagsKHR` from VK_KHR_descriptor_update_template
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorUpdateTemplateCreateFlagsKHR.html>
pub type VkDescriptorUpdateTemplateCreateFlagsKHR = VkDescriptorUpdateTemplateCreateFlags;
/// type definition `VkDescriptorUpdateTemplateEntryKHR` from VK_KHR_descriptor_update_template
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorUpdateTemplateEntryKHR.html>
pub type VkDescriptorUpdateTemplateEntryKHR = VkDescriptorUpdateTemplateEntry;
/// type definition `VkDescriptorUpdateTemplateCreateInfoKHR` from VK_KHR_descriptor_update_template
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorUpdateTemplateCreateInfoKHR.html>
pub type VkDescriptorUpdateTemplateCreateInfoKHR = VkDescriptorUpdateTemplateCreateInfo;
/// function prototype `PFN_vkCreateDescriptorUpdateTemplateKHR` from VK_KHR_descriptor_update_template
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorUpdateTemplateKHR.html>
type PFN_vkCreateDescriptorUpdateTemplateKHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate) -> VkResult;
/// function prototype `PFN_vkDestroyDescriptorUpdateTemplateKHR` from VK_KHR_descriptor_update_template
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorUpdateTemplateKHR.html>
type PFN_vkDestroyDescriptorUpdateTemplateKHR = extern "system" fn(device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkUpdateDescriptorSetWithTemplateKHR` from VK_KHR_descriptor_update_template
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSetWithTemplateKHR.html>
type PFN_vkUpdateDescriptorSetWithTemplateKHR = extern "system" fn(device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: *const c_void);
/// The dummy function for `vkCreateDescriptorUpdateTemplateKHR` from `VK_KHR_descriptor_update_template`
extern "system" fn dummy_vkCreateDescriptorUpdateTemplateKHR(_: VkDevice, _: *const VkDescriptorUpdateTemplateCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkDescriptorUpdateTemplate) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateDescriptorUpdateTemplateKHR"))
}
/// trait for `VK_KHR_descriptor_update_template`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_descriptor_update_template.html>
pub trait VK_KHR_descriptor_update_template: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorUpdateTemplateKHR.html>
	fn vkCreateDescriptorUpdateTemplateKHR(&self, device: VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate) -> Result<()>;
}
/// struct for `VK_KHR_descriptor_update_template`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_descriptor_update_template {
	vk_create_descriptor_update_template_khr: PFN_vkCreateDescriptorUpdateTemplateKHR,
}
impl VK_KHR_descriptor_update_template for Vulkan_KHR_descriptor_update_template {
	fn vkCreateDescriptorUpdateTemplateKHR(&self, device: VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate) -> Result<()> {
		convert_result("vkCreateDescriptorUpdateTemplateKHR", catch_unwind(||((self.vk_create_descriptor_update_template_khr)(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate))))
	}
}
impl Default for Vulkan_KHR_descriptor_update_template {
	fn default() -> Self {
		Self {
			vk_create_descriptor_update_template_khr: dummy_vkCreateDescriptorUpdateTemplateKHR,
		}
	}
}
impl Vulkan_KHR_descriptor_update_template {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_descriptor_update_template_khr: {let proc = get_instance_proc_address(instance, "vkCreateDescriptorUpdateTemplateKHR"); if proc == null() {dummy_vkCreateDescriptorUpdateTemplateKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceImagelessFramebufferFeaturesKHR` from VK_KHR_imageless_framebuffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImagelessFramebufferFeaturesKHR.html>
pub type VkPhysicalDeviceImagelessFramebufferFeaturesKHR = VkPhysicalDeviceImagelessFramebufferFeatures;
/// type definition `VkFramebufferAttachmentsCreateInfoKHR` from VK_KHR_imageless_framebuffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFramebufferAttachmentsCreateInfoKHR.html>
pub type VkFramebufferAttachmentsCreateInfoKHR = VkFramebufferAttachmentsCreateInfo;
/// type definition `VkFramebufferAttachmentImageInfoKHR` from VK_KHR_imageless_framebuffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFramebufferAttachmentImageInfoKHR.html>
pub type VkFramebufferAttachmentImageInfoKHR = VkFramebufferAttachmentImageInfo;
/// type definition `VkRenderPassAttachmentBeginInfoKHR` from VK_KHR_imageless_framebuffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassAttachmentBeginInfoKHR.html>
pub type VkRenderPassAttachmentBeginInfoKHR = VkRenderPassAttachmentBeginInfo;
/// trait for `VK_KHR_imageless_framebuffer`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_imageless_framebuffer.html>
pub trait VK_KHR_imageless_framebuffer: Debug {}
/// struct for `VK_KHR_imageless_framebuffer`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_imageless_framebuffer {}
impl VK_KHR_imageless_framebuffer for Vulkan_KHR_imageless_framebuffer {}
impl Default for Vulkan_KHR_imageless_framebuffer {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_imageless_framebuffer {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkRenderPassCreateInfo2KHR` from VK_KHR_create_renderpass2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassCreateInfo2KHR.html>
pub type VkRenderPassCreateInfo2KHR = VkRenderPassCreateInfo2;
/// type definition `VkAttachmentDescription2KHR` from VK_KHR_create_renderpass2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentDescription2KHR.html>
pub type VkAttachmentDescription2KHR = VkAttachmentDescription2;
/// type definition `VkAttachmentReference2KHR` from VK_KHR_create_renderpass2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentReference2KHR.html>
pub type VkAttachmentReference2KHR = VkAttachmentReference2;
/// type definition `VkSubpassDescription2KHR` from VK_KHR_create_renderpass2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassDescription2KHR.html>
pub type VkSubpassDescription2KHR = VkSubpassDescription2;
/// type definition `VkSubpassDependency2KHR` from VK_KHR_create_renderpass2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassDependency2KHR.html>
pub type VkSubpassDependency2KHR = VkSubpassDependency2;
/// type definition `VkSubpassBeginInfoKHR` from VK_KHR_create_renderpass2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassBeginInfoKHR.html>
pub type VkSubpassBeginInfoKHR = VkSubpassBeginInfo;
/// type definition `VkSubpassEndInfoKHR` from VK_KHR_create_renderpass2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassEndInfoKHR.html>
pub type VkSubpassEndInfoKHR = VkSubpassEndInfo;
/// function prototype `PFN_vkCreateRenderPass2KHR` from VK_KHR_create_renderpass2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRenderPass2KHR.html>
type PFN_vkCreateRenderPass2KHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo2, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult;
/// function prototype `PFN_vkCmdBeginRenderPass2KHR` from VK_KHR_create_renderpass2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderPass2KHR.html>
type PFN_vkCmdBeginRenderPass2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, pSubpassBeginInfo: *const VkSubpassBeginInfo);
/// function prototype `PFN_vkCmdNextSubpass2KHR` from VK_KHR_create_renderpass2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdNextSubpass2KHR.html>
type PFN_vkCmdNextSubpass2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pSubpassBeginInfo: *const VkSubpassBeginInfo, pSubpassEndInfo: *const VkSubpassEndInfo);
/// function prototype `PFN_vkCmdEndRenderPass2KHR` from VK_KHR_create_renderpass2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRenderPass2KHR.html>
type PFN_vkCmdEndRenderPass2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pSubpassEndInfo: *const VkSubpassEndInfo);
/// The dummy function for `vkCreateRenderPass2KHR` from `VK_KHR_create_renderpass2`
extern "system" fn dummy_vkCreateRenderPass2KHR(_: VkDevice, _: *const VkRenderPassCreateInfo2, _: *const VkAllocationCallbacks, _: *mut VkRenderPass) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateRenderPass2KHR"))
}
/// trait for `VK_KHR_create_renderpass2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_create_renderpass2.html>
pub trait VK_KHR_create_renderpass2: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRenderPass2KHR.html>
	fn vkCreateRenderPass2KHR(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo2, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> Result<()>;
}
/// struct for `VK_KHR_create_renderpass2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_create_renderpass2 {
	vk_create_render_pass2_khr: PFN_vkCreateRenderPass2KHR,
}
impl VK_KHR_create_renderpass2 for Vulkan_KHR_create_renderpass2 {
	fn vkCreateRenderPass2KHR(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo2, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> Result<()> {
		convert_result("vkCreateRenderPass2KHR", catch_unwind(||((self.vk_create_render_pass2_khr)(device, pCreateInfo, pAllocator, pRenderPass))))
	}
}
impl Default for Vulkan_KHR_create_renderpass2 {
	fn default() -> Self {
		Self {
			vk_create_render_pass2_khr: dummy_vkCreateRenderPass2KHR,
		}
	}
}
impl Vulkan_KHR_create_renderpass2 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_render_pass2_khr: {let proc = get_instance_proc_address(instance, "vkCreateRenderPass2KHR"); if proc == null() {dummy_vkCreateRenderPass2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkSharedPresentSurfaceCapabilitiesKHR` from VK_KHR_shared_presentable_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSharedPresentSurfaceCapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSharedPresentSurfaceCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub sharedPresentSupportedUsageFlags: VkImageUsageFlags,
}
impl Debug for VkSharedPresentSurfaceCapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSharedPresentSurfaceCapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("sharedPresentSupportedUsageFlags", &self.sharedPresentSupportedUsageFlags)
		.finish()
	}
}
/// function prototype `PFN_vkGetSwapchainStatusKHR` from VK_KHR_shared_presentable_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSwapchainStatusKHR.html>
type PFN_vkGetSwapchainStatusKHR = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR) -> VkResult;
/// The dummy function for `vkGetSwapchainStatusKHR` from `VK_KHR_shared_presentable_image`
extern "system" fn dummy_vkGetSwapchainStatusKHR(_: VkDevice, _: VkSwapchainKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetSwapchainStatusKHR"))
}
/// trait for `VK_KHR_shared_presentable_image`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shared_presentable_image.html>
pub trait VK_KHR_shared_presentable_image: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSwapchainStatusKHR.html>
	fn vkGetSwapchainStatusKHR(&self, device: VkDevice, swapchain: VkSwapchainKHR) -> Result<()>;
}
/// struct for `VK_KHR_shared_presentable_image`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shared_presentable_image {
	vk_get_swapchain_status_khr: PFN_vkGetSwapchainStatusKHR,
}
impl VK_KHR_shared_presentable_image for Vulkan_KHR_shared_presentable_image {
	fn vkGetSwapchainStatusKHR(&self, device: VkDevice, swapchain: VkSwapchainKHR) -> Result<()> {
		convert_result("vkGetSwapchainStatusKHR", catch_unwind(||((self.vk_get_swapchain_status_khr)(device, swapchain))))
	}
}
impl Default for Vulkan_KHR_shared_presentable_image {
	fn default() -> Self {
		Self {
			vk_get_swapchain_status_khr: dummy_vkGetSwapchainStatusKHR,
		}
	}
}
impl Vulkan_KHR_shared_presentable_image {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_swapchain_status_khr: {let proc = get_instance_proc_address(instance, "vkGetSwapchainStatusKHR"); if proc == null() {dummy_vkGetSwapchainStatusKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkExternalFenceHandleTypeFlagsKHR` from VK_KHR_external_fence_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalFenceHandleTypeFlagsKHR.html>
pub type VkExternalFenceHandleTypeFlagsKHR = VkExternalFenceHandleTypeFlags;
/// type definition `VkExternalFenceHandleTypeFlagBitsKHR` from VK_KHR_external_fence_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalFenceHandleTypeFlagBitsKHR.html>
pub type VkExternalFenceHandleTypeFlagBitsKHR = VkExternalFenceHandleTypeFlagBits;
/// type definition `VkExternalFenceFeatureFlagsKHR` from VK_KHR_external_fence_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalFenceFeatureFlagsKHR.html>
pub type VkExternalFenceFeatureFlagsKHR = VkExternalFenceFeatureFlags;
/// type definition `VkExternalFenceFeatureFlagBitsKHR` from VK_KHR_external_fence_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalFenceFeatureFlagBitsKHR.html>
pub type VkExternalFenceFeatureFlagBitsKHR = VkExternalFenceFeatureFlagBits;
/// type definition `VkPhysicalDeviceExternalFenceInfoKHR` from VK_KHR_external_fence_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExternalFenceInfoKHR.html>
pub type VkPhysicalDeviceExternalFenceInfoKHR = VkPhysicalDeviceExternalFenceInfo;
/// type definition `VkExternalFencePropertiesKHR` from VK_KHR_external_fence_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalFencePropertiesKHR.html>
pub type VkExternalFencePropertiesKHR = VkExternalFenceProperties;
/// function prototype `PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR` from VK_KHR_external_fence_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalFencePropertiesKHR.html>
type PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut VkExternalFenceProperties);
/// The dummy function for `vkGetPhysicalDeviceExternalFencePropertiesKHR` from `VK_KHR_external_fence_capabilities`
extern "system" fn dummy_vkGetPhysicalDeviceExternalFencePropertiesKHR(_: VkPhysicalDevice, _: *const VkPhysicalDeviceExternalFenceInfo, _: *mut VkExternalFenceProperties) {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceExternalFencePropertiesKHR"))
}
/// trait for `VK_KHR_external_fence_capabilities`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_external_fence_capabilities.html>
pub trait VK_KHR_external_fence_capabilities: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalFencePropertiesKHR.html>
	fn vkGetPhysicalDeviceExternalFencePropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut VkExternalFenceProperties) -> Result<()>;
}
/// struct for `VK_KHR_external_fence_capabilities`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_fence_capabilities {
	vk_get_physical_device_external_fence_properties_khr: PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR,
}
impl VK_KHR_external_fence_capabilities for Vulkan_KHR_external_fence_capabilities {
	fn vkGetPhysicalDeviceExternalFencePropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut VkExternalFenceProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_physical_device_external_fence_properties_khr)(physicalDevice, pExternalFenceInfo, pExternalFenceProperties))))
	}
}
impl Default for Vulkan_KHR_external_fence_capabilities {
	fn default() -> Self {
		Self {
			vk_get_physical_device_external_fence_properties_khr: dummy_vkGetPhysicalDeviceExternalFencePropertiesKHR,
		}
	}
}
impl Vulkan_KHR_external_fence_capabilities {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_external_fence_properties_khr: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceExternalFencePropertiesKHR"); if proc == null() {dummy_vkGetPhysicalDeviceExternalFencePropertiesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkFenceImportFlagsKHR` from VK_KHR_external_fence
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFenceImportFlagsKHR.html>
pub type VkFenceImportFlagsKHR = VkFenceImportFlags;
/// type definition `VkFenceImportFlagBitsKHR` from VK_KHR_external_fence
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFenceImportFlagBitsKHR.html>
pub type VkFenceImportFlagBitsKHR = VkFenceImportFlagBits;
/// type definition `VkExportFenceCreateInfoKHR` from VK_KHR_external_fence
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExportFenceCreateInfoKHR.html>
pub type VkExportFenceCreateInfoKHR = VkExportFenceCreateInfo;
/// trait for `VK_KHR_external_fence`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_external_fence.html>
pub trait VK_KHR_external_fence: Debug {}
/// struct for `VK_KHR_external_fence`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_fence {}
impl VK_KHR_external_fence for Vulkan_KHR_external_fence {}
impl Default for Vulkan_KHR_external_fence {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_external_fence {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkImportFenceFdInfoKHR` from VK_KHR_external_fence_fd
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImportFenceFdInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImportFenceFdInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub fence: VkFence,
	pub flags: VkFenceImportFlags,
	pub handleType: VkExternalFenceHandleTypeFlagBits,
	pub fd: i32,
}
impl Debug for VkImportFenceFdInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImportFenceFdInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("fence", &self.fence)
		.field("flags", &self.flags)
		.field("handleType", &self.handleType)
		.field("fd", &self.fd)
		.finish()
	}
}
/// struct `VkFenceGetFdInfoKHR` from VK_KHR_external_fence_fd
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFenceGetFdInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkFenceGetFdInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub fence: VkFence,
	pub handleType: VkExternalFenceHandleTypeFlagBits,
}
impl Debug for VkFenceGetFdInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkFenceGetFdInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("fence", &self.fence)
		.field("handleType", &self.handleType)
		.finish()
	}
}
/// function prototype `PFN_vkImportFenceFdKHR` from VK_KHR_external_fence_fd
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkImportFenceFdKHR.html>
type PFN_vkImportFenceFdKHR = extern "system" fn(device: VkDevice, pImportFenceFdInfo: *const VkImportFenceFdInfoKHR) -> VkResult;
/// function prototype `PFN_vkGetFenceFdKHR` from VK_KHR_external_fence_fd
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetFenceFdKHR.html>
type PFN_vkGetFenceFdKHR = extern "system" fn(device: VkDevice, pGetFdInfo: *const VkFenceGetFdInfoKHR, pFd: *mut int) -> VkResult;
/// The dummy function for `vkImportFenceFdKHR` from `VK_KHR_external_fence_fd`
extern "system" fn dummy_vkImportFenceFdKHR(_: VkDevice, _: *const VkImportFenceFdInfoKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkImportFenceFdKHR"))
}
/// trait for `VK_KHR_external_fence_fd`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_external_fence_fd.html>
pub trait VK_KHR_external_fence_fd: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkImportFenceFdKHR.html>
	fn vkImportFenceFdKHR(&self, device: VkDevice, pImportFenceFdInfo: *const VkImportFenceFdInfoKHR) -> Result<()>;
}
/// struct for `VK_KHR_external_fence_fd`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_external_fence_fd {
	vk_import_fence_fd_khr: PFN_vkImportFenceFdKHR,
}
impl VK_KHR_external_fence_fd for Vulkan_KHR_external_fence_fd {
	fn vkImportFenceFdKHR(&self, device: VkDevice, pImportFenceFdInfo: *const VkImportFenceFdInfoKHR) -> Result<()> {
		convert_result("vkImportFenceFdKHR", catch_unwind(||((self.vk_import_fence_fd_khr)(device, pImportFenceFdInfo))))
	}
}
impl Default for Vulkan_KHR_external_fence_fd {
	fn default() -> Self {
		Self {
			vk_import_fence_fd_khr: dummy_vkImportFenceFdKHR,
		}
	}
}
impl Vulkan_KHR_external_fence_fd {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_import_fence_fd_khr: {let proc = get_instance_proc_address(instance, "vkImportFenceFdKHR"); if proc == null() {dummy_vkImportFenceFdKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPerformanceCounterDescriptionFlagsKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceCounterDescriptionFlagsKHR.html>
pub type VkPerformanceCounterDescriptionFlagsKHR = VkFlags;
/// type definition `VkAcquireProfilingLockFlagsKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAcquireProfilingLockFlagsKHR.html>
pub type VkAcquireProfilingLockFlagsKHR = VkFlags;
/// enum `VkPerformanceCounterUnitKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceCounterUnitKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPerformanceCounterUnitKHR {
	VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0,
	VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1,
	VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2,
	VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3,
	VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4,
	VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5,
	VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6,
	VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7,
	VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8,
	VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9,
	VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10,
	VK_PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkPerformanceCounterScopeKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceCounterScopeKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPerformanceCounterScopeKHR {
	VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0,
	VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1,
	VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2,
	VK_PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkPerformanceCounterScopeKHR {
	pub const VK_QUERY_SCOPE_COMMAND_BUFFER_KHR: VkPerformanceCounterScopeKHR = VkPerformanceCounterScopeKHR::VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR;
	pub const VK_QUERY_SCOPE_RENDER_PASS_KHR: VkPerformanceCounterScopeKHR = VkPerformanceCounterScopeKHR::VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR;
	pub const VK_QUERY_SCOPE_COMMAND_KHR: VkPerformanceCounterScopeKHR = VkPerformanceCounterScopeKHR::VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR;
}
/// enum `VkPerformanceCounterStorageKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceCounterStorageKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPerformanceCounterStorageKHR {
	VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0,
	VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1,
	VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2,
	VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3,
	VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4,
	VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5,
	VK_PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkPerformanceCounterDescriptionFlagBitsKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceCounterDescriptionFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPerformanceCounterDescriptionFlagBitsKHR {
	VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR = 0x00000001,
	VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR = 0x00000002,
	VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkPerformanceCounterDescriptionFlagBitsKHR {
	pub const VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR: VkPerformanceCounterDescriptionFlagBitsKHR = VkPerformanceCounterDescriptionFlagBitsKHR::VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR;
	pub const VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR: VkPerformanceCounterDescriptionFlagBitsKHR = VkPerformanceCounterDescriptionFlagBitsKHR::VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR;
}
/// enum `VkAcquireProfilingLockFlagBitsKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAcquireProfilingLockFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAcquireProfilingLockFlagBitsKHR {
	VK_ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// union `VkPerformanceCounterResultKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceCounterResultKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkPerformanceCounterResultKHR {
	pub int32: i32,
	pub int64: i64,
	pub uint32: u32,
	pub uint64: u64,
	pub float32: f32,
	pub float64: f64,
}
impl Debug for VkPerformanceCounterResultKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceCounterResultKHR")
		.field("int32", unsafe {&self.int32})
		.field("int64", unsafe {&self.int64})
		.field("uint32", unsafe {&self.uint32})
		.field("uint64", unsafe {&self.uint64})
		.field("float32", unsafe {&self.float32})
		.field("float64", unsafe {&self.float64})
		.finish()
	}
}
/// struct `VkPhysicalDevicePerformanceQueryFeaturesKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePerformanceQueryFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePerformanceQueryFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub performanceCounterQueryPools: VkBool32,
	pub performanceCounterMultipleQueryPools: VkBool32,
}
impl Debug for VkPhysicalDevicePerformanceQueryFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePerformanceQueryFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("performanceCounterQueryPools", &self.performanceCounterQueryPools)
		.field("performanceCounterMultipleQueryPools", &self.performanceCounterMultipleQueryPools)
		.finish()
	}
}
/// struct `VkPhysicalDevicePerformanceQueryPropertiesKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePerformanceQueryPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePerformanceQueryPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub allowCommandBufferQueryCopies: VkBool32,
}
impl Debug for VkPhysicalDevicePerformanceQueryPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePerformanceQueryPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("allowCommandBufferQueryCopies", &self.allowCommandBufferQueryCopies)
		.finish()
	}
}
/// struct `VkPerformanceCounterKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceCounterKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPerformanceCounterKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub unit: VkPerformanceCounterUnitKHR,
	pub scope: VkPerformanceCounterScopeKHR,
	pub storage: VkPerformanceCounterStorageKHR,
	pub uuid: [u8; VK_UUID_SIZE as usize],
}
impl Debug for VkPerformanceCounterKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceCounterKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("unit", &self.unit)
		.field("scope", &self.scope)
		.field("storage", &self.storage)
		.field("uuid", &self.uuid)
		.finish()
	}
}
/// struct `VkPerformanceCounterDescriptionKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceCounterDescriptionKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPerformanceCounterDescriptionKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkPerformanceCounterDescriptionFlagsKHR,
	pub name: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub category: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
}
impl Debug for VkPerformanceCounterDescriptionKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceCounterDescriptionKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("name", &format_args!("{}", maybe_string(&self.name)))
		.field("category", &format_args!("{}", maybe_string(&self.category)))
		.field("description", &format_args!("{}", maybe_string(&self.description)))
		.finish()
	}
}
/// struct `VkQueryPoolPerformanceCreateInfoKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryPoolPerformanceCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkQueryPoolPerformanceCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub queueFamilyIndex: u32,
	pub counterIndexCount: u32,
	pub pCounterIndices: *const uint32_t,
}
impl Debug for VkQueryPoolPerformanceCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkQueryPoolPerformanceCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("queueFamilyIndex", &self.queueFamilyIndex)
		.field("counterIndexCount", &self.counterIndexCount)
		.field("pCounterIndices", &self.pCounterIndices)
		.finish()
	}
}
/// struct `VkAcquireProfilingLockInfoKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAcquireProfilingLockInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAcquireProfilingLockInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkAcquireProfilingLockFlagsKHR,
	pub timeout: u64,
}
impl Debug for VkAcquireProfilingLockInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAcquireProfilingLockInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("timeout", &self.timeout)
		.finish()
	}
}
/// struct `VkPerformanceQuerySubmitInfoKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceQuerySubmitInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPerformanceQuerySubmitInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub counterPassIndex: u32,
}
impl Debug for VkPerformanceQuerySubmitInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceQuerySubmitInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("counterPassIndex", &self.counterPassIndex)
		.finish()
	}
}
/// function prototype `PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.html>
type PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, pCounterCount: *mut uint32_t, pCounters: *mut VkPerformanceCounterKHR, pCounterDescriptions: *mut VkPerformanceCounterDescriptionKHR) -> VkResult;
/// function prototype `PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR.html>
type PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pPerformanceQueryCreateInfo: *const VkQueryPoolPerformanceCreateInfoKHR, pNumPasses: *mut uint32_t);
/// function prototype `PFN_vkAcquireProfilingLockKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireProfilingLockKHR.html>
type PFN_vkAcquireProfilingLockKHR = extern "system" fn(device: VkDevice, pInfo: *const VkAcquireProfilingLockInfoKHR) -> VkResult;
/// function prototype `PFN_vkReleaseProfilingLockKHR` from VK_KHR_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseProfilingLockKHR.html>
type PFN_vkReleaseProfilingLockKHR = extern "system" fn(device: VkDevice);
/// The dummy function for `vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR` from `VK_KHR_performance_query`
extern "system" fn dummy_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(_: VkPhysicalDevice, _: u32, _: *mut uint32_t, _: *mut VkPerformanceCounterKHR, _: *mut VkPerformanceCounterDescriptionKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR"))
}
/// trait for `VK_KHR_performance_query`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_performance_query.html>
pub trait VK_KHR_performance_query: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.html>
	fn vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(&self, physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, pCounterCount: *mut uint32_t, pCounters: *mut VkPerformanceCounterKHR, pCounterDescriptions: *mut VkPerformanceCounterDescriptionKHR) -> Result<()>;
}
/// struct for `VK_KHR_performance_query`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_performance_query {
	vk_enumerate_physical_device_queue_family_performance_query_counters_khr: PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR,
}
impl VK_KHR_performance_query for Vulkan_KHR_performance_query {
	fn vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(&self, physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, pCounterCount: *mut uint32_t, pCounters: *mut VkPerformanceCounterKHR, pCounterDescriptions: *mut VkPerformanceCounterDescriptionKHR) -> Result<()> {
		convert_result("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR", catch_unwind(||((self.vk_enumerate_physical_device_queue_family_performance_query_counters_khr)(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions))))
	}
}
impl Default for Vulkan_KHR_performance_query {
	fn default() -> Self {
		Self {
			vk_enumerate_physical_device_queue_family_performance_query_counters_khr: dummy_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR,
		}
	}
}
impl Vulkan_KHR_performance_query {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_enumerate_physical_device_queue_family_performance_query_counters_khr: {let proc = get_instance_proc_address(instance, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR"); if proc == null() {dummy_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPointClippingBehaviorKHR` from VK_KHR_maintenance2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPointClippingBehaviorKHR.html>
pub type VkPointClippingBehaviorKHR = VkPointClippingBehavior;
/// type definition `VkTessellationDomainOriginKHR` from VK_KHR_maintenance2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTessellationDomainOriginKHR.html>
pub type VkTessellationDomainOriginKHR = VkTessellationDomainOrigin;
/// type definition `VkPhysicalDevicePointClippingPropertiesKHR` from VK_KHR_maintenance2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePointClippingPropertiesKHR.html>
pub type VkPhysicalDevicePointClippingPropertiesKHR = VkPhysicalDevicePointClippingProperties;
/// type definition `VkRenderPassInputAttachmentAspectCreateInfoKHR` from VK_KHR_maintenance2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassInputAttachmentAspectCreateInfoKHR.html>
pub type VkRenderPassInputAttachmentAspectCreateInfoKHR = VkRenderPassInputAttachmentAspectCreateInfo;
/// type definition `VkInputAttachmentAspectReferenceKHR` from VK_KHR_maintenance2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkInputAttachmentAspectReferenceKHR.html>
pub type VkInputAttachmentAspectReferenceKHR = VkInputAttachmentAspectReference;
/// type definition `VkImageViewUsageCreateInfoKHR` from VK_KHR_maintenance2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageViewUsageCreateInfoKHR.html>
pub type VkImageViewUsageCreateInfoKHR = VkImageViewUsageCreateInfo;
/// type definition `VkPipelineTessellationDomainOriginStateCreateInfoKHR` from VK_KHR_maintenance2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineTessellationDomainOriginStateCreateInfoKHR.html>
pub type VkPipelineTessellationDomainOriginStateCreateInfoKHR = VkPipelineTessellationDomainOriginStateCreateInfo;
/// trait for `VK_KHR_maintenance2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_maintenance2.html>
pub trait VK_KHR_maintenance2: Debug {}
/// struct for `VK_KHR_maintenance2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance2 {}
impl VK_KHR_maintenance2 for Vulkan_KHR_maintenance2 {}
impl Default for Vulkan_KHR_maintenance2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_maintenance2 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceSurfaceInfo2KHR` from VK_KHR_get_surface_capabilities2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSurfaceInfo2KHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSurfaceInfo2KHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub surface: VkSurfaceKHR,
}
impl Debug for VkPhysicalDeviceSurfaceInfo2KHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSurfaceInfo2KHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("surface", &self.surface)
		.finish()
	}
}
/// struct `VkSurfaceCapabilities2KHR` from VK_KHR_get_surface_capabilities2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfaceCapabilities2KHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSurfaceCapabilities2KHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub surfaceCapabilities: VkSurfaceCapabilitiesKHR,
}
impl Debug for VkSurfaceCapabilities2KHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSurfaceCapabilities2KHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("surfaceCapabilities", &self.surfaceCapabilities)
		.finish()
	}
}
/// struct `VkSurfaceFormat2KHR` from VK_KHR_get_surface_capabilities2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfaceFormat2KHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSurfaceFormat2KHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub surfaceFormat: VkSurfaceFormatKHR,
}
impl Debug for VkSurfaceFormat2KHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSurfaceFormat2KHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("surfaceFormat", &self.surfaceFormat)
		.finish()
	}
}
/// function prototype `PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR` from VK_KHR_get_surface_capabilities2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceCapabilities2KHR.html>
type PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2KHR) -> VkResult;
/// function prototype `PFN_vkGetPhysicalDeviceSurfaceFormats2KHR` from VK_KHR_get_surface_capabilities2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceFormats2KHR.html>
type PFN_vkGetPhysicalDeviceSurfaceFormats2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceFormatCount: *mut uint32_t, pSurfaceFormats: *mut VkSurfaceFormat2KHR) -> VkResult;
/// The dummy function for `vkGetPhysicalDeviceSurfaceCapabilities2KHR` from `VK_KHR_get_surface_capabilities2`
extern "system" fn dummy_vkGetPhysicalDeviceSurfaceCapabilities2KHR(_: VkPhysicalDevice, _: *const VkPhysicalDeviceSurfaceInfo2KHR, _: *mut VkSurfaceCapabilities2KHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceSurfaceCapabilities2KHR"))
}
/// trait for `VK_KHR_get_surface_capabilities2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_get_surface_capabilities2.html>
pub trait VK_KHR_get_surface_capabilities2: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceCapabilities2KHR.html>
	fn vkGetPhysicalDeviceSurfaceCapabilities2KHR(&self, physicalDevice: VkPhysicalDevice, pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2KHR) -> Result<()>;
}
/// struct for `VK_KHR_get_surface_capabilities2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_get_surface_capabilities2 {
	vk_get_physical_device_surface_capabilities2_khr: PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
}
impl VK_KHR_get_surface_capabilities2 for Vulkan_KHR_get_surface_capabilities2 {
	fn vkGetPhysicalDeviceSurfaceCapabilities2KHR(&self, physicalDevice: VkPhysicalDevice, pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2KHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceSurfaceCapabilities2KHR", catch_unwind(||((self.vk_get_physical_device_surface_capabilities2_khr)(physicalDevice, pSurfaceInfo, pSurfaceCapabilities))))
	}
}
impl Default for Vulkan_KHR_get_surface_capabilities2 {
	fn default() -> Self {
		Self {
			vk_get_physical_device_surface_capabilities2_khr: dummy_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
		}
	}
}
impl Vulkan_KHR_get_surface_capabilities2 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_surface_capabilities2_khr: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceSurfaceCapabilities2KHR"); if proc == null() {dummy_vkGetPhysicalDeviceSurfaceCapabilities2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceVariablePointerFeaturesKHR` from VK_KHR_variable_pointers
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVariablePointerFeaturesKHR.html>
pub type VkPhysicalDeviceVariablePointerFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;
/// type definition `VkPhysicalDeviceVariablePointersFeaturesKHR` from VK_KHR_variable_pointers
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVariablePointersFeaturesKHR.html>
pub type VkPhysicalDeviceVariablePointersFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;
/// trait for `VK_KHR_variable_pointers`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_variable_pointers.html>
pub trait VK_KHR_variable_pointers: Debug {}
/// struct for `VK_KHR_variable_pointers`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_variable_pointers {}
impl VK_KHR_variable_pointers for Vulkan_KHR_variable_pointers {}
impl Default for Vulkan_KHR_variable_pointers {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_variable_pointers {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkDisplayProperties2KHR` from VK_KHR_get_display_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayProperties2KHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplayProperties2KHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub displayProperties: VkDisplayPropertiesKHR,
}
impl Debug for VkDisplayProperties2KHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayProperties2KHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("displayProperties", &self.displayProperties)
		.finish()
	}
}
/// struct `VkDisplayPlaneProperties2KHR` from VK_KHR_get_display_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayPlaneProperties2KHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplayPlaneProperties2KHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub displayPlaneProperties: VkDisplayPlanePropertiesKHR,
}
impl Debug for VkDisplayPlaneProperties2KHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayPlaneProperties2KHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("displayPlaneProperties", &self.displayPlaneProperties)
		.finish()
	}
}
/// struct `VkDisplayModeProperties2KHR` from VK_KHR_get_display_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayModeProperties2KHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplayModeProperties2KHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub displayModeProperties: VkDisplayModePropertiesKHR,
}
impl Debug for VkDisplayModeProperties2KHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayModeProperties2KHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("displayModeProperties", &self.displayModeProperties)
		.finish()
	}
}
/// struct `VkDisplayPlaneInfo2KHR` from VK_KHR_get_display_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayPlaneInfo2KHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplayPlaneInfo2KHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub mode: VkDisplayModeKHR,
	pub planeIndex: u32,
}
impl Debug for VkDisplayPlaneInfo2KHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayPlaneInfo2KHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("mode", &self.mode)
		.field("planeIndex", &self.planeIndex)
		.finish()
	}
}
/// struct `VkDisplayPlaneCapabilities2KHR` from VK_KHR_get_display_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayPlaneCapabilities2KHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplayPlaneCapabilities2KHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub capabilities: VkDisplayPlaneCapabilitiesKHR,
}
impl Debug for VkDisplayPlaneCapabilities2KHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayPlaneCapabilities2KHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("capabilities", &self.capabilities)
		.finish()
	}
}
/// function prototype `PFN_vkGetPhysicalDeviceDisplayProperties2KHR` from VK_KHR_get_display_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayProperties2KHR.html>
type PFN_vkGetPhysicalDeviceDisplayProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayProperties2KHR) -> VkResult;
/// function prototype `PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR` from VK_KHR_get_display_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayPlaneProperties2KHR.html>
type PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayPlaneProperties2KHR) -> VkResult;
/// function prototype `PFN_vkGetDisplayModeProperties2KHR` from VK_KHR_get_display_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayModeProperties2KHR.html>
type PFN_vkGetDisplayModeProperties2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayModeProperties2KHR) -> VkResult;
/// function prototype `PFN_vkGetDisplayPlaneCapabilities2KHR` from VK_KHR_get_display_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayPlaneCapabilities2KHR.html>
type PFN_vkGetDisplayPlaneCapabilities2KHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pDisplayPlaneInfo: *const VkDisplayPlaneInfo2KHR, pCapabilities: *mut VkDisplayPlaneCapabilities2KHR) -> VkResult;
/// The dummy function for `vkGetPhysicalDeviceDisplayProperties2KHR` from `VK_KHR_get_display_properties2`
extern "system" fn dummy_vkGetPhysicalDeviceDisplayProperties2KHR(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkDisplayProperties2KHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceDisplayProperties2KHR"))
}
/// trait for `VK_KHR_get_display_properties2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_get_display_properties2.html>
pub trait VK_KHR_get_display_properties2: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayProperties2KHR.html>
	fn vkGetPhysicalDeviceDisplayProperties2KHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayProperties2KHR) -> Result<()>;
}
/// struct for `VK_KHR_get_display_properties2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_get_display_properties2 {
	vk_get_physical_device_display_properties2_khr: PFN_vkGetPhysicalDeviceDisplayProperties2KHR,
}
impl VK_KHR_get_display_properties2 for Vulkan_KHR_get_display_properties2 {
	fn vkGetPhysicalDeviceDisplayProperties2KHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayProperties2KHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceDisplayProperties2KHR", catch_unwind(||((self.vk_get_physical_device_display_properties2_khr)(physicalDevice, pPropertyCount, pProperties))))
	}
}
impl Default for Vulkan_KHR_get_display_properties2 {
	fn default() -> Self {
		Self {
			vk_get_physical_device_display_properties2_khr: dummy_vkGetPhysicalDeviceDisplayProperties2KHR,
		}
	}
}
impl Vulkan_KHR_get_display_properties2 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_display_properties2_khr: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceDisplayProperties2KHR"); if proc == null() {dummy_vkGetPhysicalDeviceDisplayProperties2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkMemoryDedicatedRequirementsKHR` from VK_KHR_dedicated_allocation
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryDedicatedRequirementsKHR.html>
pub type VkMemoryDedicatedRequirementsKHR = VkMemoryDedicatedRequirements;
/// type definition `VkMemoryDedicatedAllocateInfoKHR` from VK_KHR_dedicated_allocation
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryDedicatedAllocateInfoKHR.html>
pub type VkMemoryDedicatedAllocateInfoKHR = VkMemoryDedicatedAllocateInfo;
/// trait for `VK_KHR_dedicated_allocation`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_dedicated_allocation.html>
pub trait VK_KHR_dedicated_allocation: Debug {}
/// struct for `VK_KHR_dedicated_allocation`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_dedicated_allocation {}
impl VK_KHR_dedicated_allocation for Vulkan_KHR_dedicated_allocation {}
impl Default for Vulkan_KHR_dedicated_allocation {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_dedicated_allocation {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_KHR_storage_buffer_storage_class`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_storage_buffer_storage_class.html>
pub trait VK_KHR_storage_buffer_storage_class: Debug {}
/// struct for `VK_KHR_storage_buffer_storage_class`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_storage_buffer_storage_class {}
impl VK_KHR_storage_buffer_storage_class for Vulkan_KHR_storage_buffer_storage_class {}
impl Default for Vulkan_KHR_storage_buffer_storage_class {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_storage_buffer_storage_class {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceShaderBfloat16FeaturesKHR` from VK_KHR_shader_bfloat16
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderBfloat16FeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderBfloat16FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderBFloat16Type: VkBool32,
	pub shaderBFloat16DotProduct: VkBool32,
	pub shaderBFloat16CooperativeMatrix: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderBfloat16FeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderBfloat16FeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderBFloat16Type", &self.shaderBFloat16Type)
		.field("shaderBFloat16DotProduct", &self.shaderBFloat16DotProduct)
		.field("shaderBFloat16CooperativeMatrix", &self.shaderBFloat16CooperativeMatrix)
		.finish()
	}
}
/// trait for `VK_KHR_shader_bfloat16`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_bfloat16.html>
pub trait VK_KHR_shader_bfloat16: Debug {}
/// struct for `VK_KHR_shader_bfloat16`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_bfloat16 {}
impl VK_KHR_shader_bfloat16 for Vulkan_KHR_shader_bfloat16 {}
impl Default for Vulkan_KHR_shader_bfloat16 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_bfloat16 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_KHR_relaxed_block_layout`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_relaxed_block_layout.html>
pub trait VK_KHR_relaxed_block_layout: Debug {}
/// struct for `VK_KHR_relaxed_block_layout`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_relaxed_block_layout {}
impl VK_KHR_relaxed_block_layout for Vulkan_KHR_relaxed_block_layout {}
impl Default for Vulkan_KHR_relaxed_block_layout {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_relaxed_block_layout {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkBufferMemoryRequirementsInfo2KHR` from VK_KHR_get_memory_requirements2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferMemoryRequirementsInfo2KHR.html>
pub type VkBufferMemoryRequirementsInfo2KHR = VkBufferMemoryRequirementsInfo2;
/// type definition `VkImageMemoryRequirementsInfo2KHR` from VK_KHR_get_memory_requirements2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryRequirementsInfo2KHR.html>
pub type VkImageMemoryRequirementsInfo2KHR = VkImageMemoryRequirementsInfo2;
/// type definition `VkImageSparseMemoryRequirementsInfo2KHR` from VK_KHR_get_memory_requirements2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageSparseMemoryRequirementsInfo2KHR.html>
pub type VkImageSparseMemoryRequirementsInfo2KHR = VkImageSparseMemoryRequirementsInfo2;
/// type definition `VkMemoryRequirements2KHR` from VK_KHR_get_memory_requirements2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryRequirements2KHR.html>
pub type VkMemoryRequirements2KHR = VkMemoryRequirements2;
/// type definition `VkSparseImageMemoryRequirements2KHR` from VK_KHR_get_memory_requirements2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSparseImageMemoryRequirements2KHR.html>
pub type VkSparseImageMemoryRequirements2KHR = VkSparseImageMemoryRequirements2;
/// function prototype `PFN_vkGetImageMemoryRequirements2KHR` from VK_KHR_get_memory_requirements2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageMemoryRequirements2KHR.html>
type PFN_vkGetImageMemoryRequirements2KHR = extern "system" fn(device: VkDevice, pInfo: *const VkImageMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2);
/// function prototype `PFN_vkGetBufferMemoryRequirements2KHR` from VK_KHR_get_memory_requirements2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferMemoryRequirements2KHR.html>
type PFN_vkGetBufferMemoryRequirements2KHR = extern "system" fn(device: VkDevice, pInfo: *const VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2);
/// function prototype `PFN_vkGetImageSparseMemoryRequirements2KHR` from VK_KHR_get_memory_requirements2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSparseMemoryRequirements2KHR.html>
type PFN_vkGetImageSparseMemoryRequirements2KHR = extern "system" fn(device: VkDevice, pInfo: *const VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2);
/// The dummy function for `vkGetImageMemoryRequirements2KHR` from `VK_KHR_get_memory_requirements2`
extern "system" fn dummy_vkGetImageMemoryRequirements2KHR(_: VkDevice, _: *const VkImageMemoryRequirementsInfo2, _: *mut VkMemoryRequirements2) {
	panic_any(VkError::NullFunctionPointer("vkGetImageMemoryRequirements2KHR"))
}
/// trait for `VK_KHR_get_memory_requirements2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_get_memory_requirements2.html>
pub trait VK_KHR_get_memory_requirements2: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageMemoryRequirements2KHR.html>
	fn vkGetImageMemoryRequirements2KHR(&self, device: VkDevice, pInfo: *const VkImageMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()>;
}
/// struct for `VK_KHR_get_memory_requirements2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_get_memory_requirements2 {
	vk_get_image_memory_requirements2_khr: PFN_vkGetImageMemoryRequirements2KHR,
}
impl VK_KHR_get_memory_requirements2 for Vulkan_KHR_get_memory_requirements2 {
	fn vkGetImageMemoryRequirements2KHR(&self, device: VkDevice, pInfo: *const VkImageMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_image_memory_requirements2_khr)(device, pInfo, pMemoryRequirements))))
	}
}
impl Default for Vulkan_KHR_get_memory_requirements2 {
	fn default() -> Self {
		Self {
			vk_get_image_memory_requirements2_khr: dummy_vkGetImageMemoryRequirements2KHR,
		}
	}
}
impl Vulkan_KHR_get_memory_requirements2 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_image_memory_requirements2_khr: {let proc = get_instance_proc_address(instance, "vkGetImageMemoryRequirements2KHR"); if proc == null() {dummy_vkGetImageMemoryRequirements2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkImageFormatListCreateInfoKHR` from VK_KHR_image_format_list
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageFormatListCreateInfoKHR.html>
pub type VkImageFormatListCreateInfoKHR = VkImageFormatListCreateInfo;
/// trait for `VK_KHR_image_format_list`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_image_format_list.html>
pub trait VK_KHR_image_format_list: Debug {}
/// struct for `VK_KHR_image_format_list`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_image_format_list {}
impl VK_KHR_image_format_list for Vulkan_KHR_image_format_list {}
impl Default for Vulkan_KHR_image_format_list {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_image_format_list {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkSamplerYcbcrConversionKHR` from VK_KHR_sampler_ycbcr_conversion
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerYcbcrConversionKHR.html>
pub type VkSamplerYcbcrConversionKHR = VkSamplerYcbcrConversion;
/// type definition `VkSamplerYcbcrModelConversionKHR` from VK_KHR_sampler_ycbcr_conversion
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerYcbcrModelConversionKHR.html>
pub type VkSamplerYcbcrModelConversionKHR = VkSamplerYcbcrModelConversion;
/// type definition `VkSamplerYcbcrRangeKHR` from VK_KHR_sampler_ycbcr_conversion
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerYcbcrRangeKHR.html>
pub type VkSamplerYcbcrRangeKHR = VkSamplerYcbcrRange;
/// type definition `VkChromaLocationKHR` from VK_KHR_sampler_ycbcr_conversion
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkChromaLocationKHR.html>
pub type VkChromaLocationKHR = VkChromaLocation;
/// type definition `VkSamplerYcbcrConversionCreateInfoKHR` from VK_KHR_sampler_ycbcr_conversion
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerYcbcrConversionCreateInfoKHR.html>
pub type VkSamplerYcbcrConversionCreateInfoKHR = VkSamplerYcbcrConversionCreateInfo;
/// type definition `VkSamplerYcbcrConversionInfoKHR` from VK_KHR_sampler_ycbcr_conversion
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerYcbcrConversionInfoKHR.html>
pub type VkSamplerYcbcrConversionInfoKHR = VkSamplerYcbcrConversionInfo;
/// type definition `VkBindImagePlaneMemoryInfoKHR` from VK_KHR_sampler_ycbcr_conversion
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindImagePlaneMemoryInfoKHR.html>
pub type VkBindImagePlaneMemoryInfoKHR = VkBindImagePlaneMemoryInfo;
/// type definition `VkImagePlaneMemoryRequirementsInfoKHR` from VK_KHR_sampler_ycbcr_conversion
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImagePlaneMemoryRequirementsInfoKHR.html>
pub type VkImagePlaneMemoryRequirementsInfoKHR = VkImagePlaneMemoryRequirementsInfo;
/// type definition `VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR` from VK_KHR_sampler_ycbcr_conversion
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.html>
pub type VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR = VkPhysicalDeviceSamplerYcbcrConversionFeatures;
/// type definition `VkSamplerYcbcrConversionImageFormatPropertiesKHR` from VK_KHR_sampler_ycbcr_conversion
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerYcbcrConversionImageFormatPropertiesKHR.html>
pub type VkSamplerYcbcrConversionImageFormatPropertiesKHR = VkSamplerYcbcrConversionImageFormatProperties;
/// function prototype `PFN_vkCreateSamplerYcbcrConversionKHR` from VK_KHR_sampler_ycbcr_conversion
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSamplerYcbcrConversionKHR.html>
type PFN_vkCreateSamplerYcbcrConversionKHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo, pAllocator: *const VkAllocationCallbacks, pYcbcrConversion: *mut VkSamplerYcbcrConversion) -> VkResult;
/// function prototype `PFN_vkDestroySamplerYcbcrConversionKHR` from VK_KHR_sampler_ycbcr_conversion
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySamplerYcbcrConversionKHR.html>
type PFN_vkDestroySamplerYcbcrConversionKHR = extern "system" fn(device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *const VkAllocationCallbacks);
/// The dummy function for `vkCreateSamplerYcbcrConversionKHR` from `VK_KHR_sampler_ycbcr_conversion`
extern "system" fn dummy_vkCreateSamplerYcbcrConversionKHR(_: VkDevice, _: *const VkSamplerYcbcrConversionCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkSamplerYcbcrConversion) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateSamplerYcbcrConversionKHR"))
}
/// trait for `VK_KHR_sampler_ycbcr_conversion`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_sampler_ycbcr_conversion.html>
pub trait VK_KHR_sampler_ycbcr_conversion: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSamplerYcbcrConversionKHR.html>
	fn vkCreateSamplerYcbcrConversionKHR(&self, device: VkDevice, pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo, pAllocator: *const VkAllocationCallbacks, pYcbcrConversion: *mut VkSamplerYcbcrConversion) -> Result<()>;
}
/// struct for `VK_KHR_sampler_ycbcr_conversion`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_sampler_ycbcr_conversion {
	vk_create_sampler_ycbcr_conversion_khr: PFN_vkCreateSamplerYcbcrConversionKHR,
}
impl VK_KHR_sampler_ycbcr_conversion for Vulkan_KHR_sampler_ycbcr_conversion {
	fn vkCreateSamplerYcbcrConversionKHR(&self, device: VkDevice, pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo, pAllocator: *const VkAllocationCallbacks, pYcbcrConversion: *mut VkSamplerYcbcrConversion) -> Result<()> {
		convert_result("vkCreateSamplerYcbcrConversionKHR", catch_unwind(||((self.vk_create_sampler_ycbcr_conversion_khr)(device, pCreateInfo, pAllocator, pYcbcrConversion))))
	}
}
impl Default for Vulkan_KHR_sampler_ycbcr_conversion {
	fn default() -> Self {
		Self {
			vk_create_sampler_ycbcr_conversion_khr: dummy_vkCreateSamplerYcbcrConversionKHR,
		}
	}
}
impl Vulkan_KHR_sampler_ycbcr_conversion {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_sampler_ycbcr_conversion_khr: {let proc = get_instance_proc_address(instance, "vkCreateSamplerYcbcrConversionKHR"); if proc == null() {dummy_vkCreateSamplerYcbcrConversionKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkBindBufferMemoryInfoKHR` from VK_KHR_bind_memory2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindBufferMemoryInfoKHR.html>
pub type VkBindBufferMemoryInfoKHR = VkBindBufferMemoryInfo;
/// type definition `VkBindImageMemoryInfoKHR` from VK_KHR_bind_memory2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindImageMemoryInfoKHR.html>
pub type VkBindImageMemoryInfoKHR = VkBindImageMemoryInfo;
/// function prototype `PFN_vkBindBufferMemory2KHR` from VK_KHR_bind_memory2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindBufferMemory2KHR.html>
type PFN_vkBindBufferMemory2KHR = extern "system" fn(device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindBufferMemoryInfo) -> VkResult;
/// function prototype `PFN_vkBindImageMemory2KHR` from VK_KHR_bind_memory2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindImageMemory2KHR.html>
type PFN_vkBindImageMemory2KHR = extern "system" fn(device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindImageMemoryInfo) -> VkResult;
/// The dummy function for `vkBindBufferMemory2KHR` from `VK_KHR_bind_memory2`
extern "system" fn dummy_vkBindBufferMemory2KHR(_: VkDevice, _: u32, _: *const VkBindBufferMemoryInfo) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkBindBufferMemory2KHR"))
}
/// trait for `VK_KHR_bind_memory2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_bind_memory2.html>
pub trait VK_KHR_bind_memory2: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindBufferMemory2KHR.html>
	fn vkBindBufferMemory2KHR(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindBufferMemoryInfo) -> Result<()>;
}
/// struct for `VK_KHR_bind_memory2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_bind_memory2 {
	vk_bind_buffer_memory2_khr: PFN_vkBindBufferMemory2KHR,
}
impl VK_KHR_bind_memory2 for Vulkan_KHR_bind_memory2 {
	fn vkBindBufferMemory2KHR(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindBufferMemoryInfo) -> Result<()> {
		convert_result("vkBindBufferMemory2KHR", catch_unwind(||((self.vk_bind_buffer_memory2_khr)(device, bindInfoCount, pBindInfos))))
	}
}
impl Default for Vulkan_KHR_bind_memory2 {
	fn default() -> Self {
		Self {
			vk_bind_buffer_memory2_khr: dummy_vkBindBufferMemory2KHR,
		}
	}
}
impl Vulkan_KHR_bind_memory2 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_bind_buffer_memory2_khr: {let proc = get_instance_proc_address(instance, "vkBindBufferMemory2KHR"); if proc == null() {dummy_vkBindBufferMemory2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceMaintenance3PropertiesKHR` from VK_KHR_maintenance3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance3PropertiesKHR.html>
pub type VkPhysicalDeviceMaintenance3PropertiesKHR = VkPhysicalDeviceMaintenance3Properties;
/// type definition `VkDescriptorSetLayoutSupportKHR` from VK_KHR_maintenance3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutSupportKHR.html>
pub type VkDescriptorSetLayoutSupportKHR = VkDescriptorSetLayoutSupport;
/// function prototype `PFN_vkGetDescriptorSetLayoutSupportKHR` from VK_KHR_maintenance3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutSupportKHR.html>
type PFN_vkGetDescriptorSetLayoutSupportKHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pSupport: *mut VkDescriptorSetLayoutSupport);
/// The dummy function for `vkGetDescriptorSetLayoutSupportKHR` from `VK_KHR_maintenance3`
extern "system" fn dummy_vkGetDescriptorSetLayoutSupportKHR(_: VkDevice, _: *const VkDescriptorSetLayoutCreateInfo, _: *mut VkDescriptorSetLayoutSupport) {
	panic_any(VkError::NullFunctionPointer("vkGetDescriptorSetLayoutSupportKHR"))
}
/// trait for `VK_KHR_maintenance3`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_maintenance3.html>
pub trait VK_KHR_maintenance3: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutSupportKHR.html>
	fn vkGetDescriptorSetLayoutSupportKHR(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pSupport: *mut VkDescriptorSetLayoutSupport) -> Result<()>;
}
/// struct for `VK_KHR_maintenance3`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance3 {
	vk_get_descriptor_set_layout_support_khr: PFN_vkGetDescriptorSetLayoutSupportKHR,
}
impl VK_KHR_maintenance3 for Vulkan_KHR_maintenance3 {
	fn vkGetDescriptorSetLayoutSupportKHR(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pSupport: *mut VkDescriptorSetLayoutSupport) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_descriptor_set_layout_support_khr)(device, pCreateInfo, pSupport))))
	}
}
impl Default for Vulkan_KHR_maintenance3 {
	fn default() -> Self {
		Self {
			vk_get_descriptor_set_layout_support_khr: dummy_vkGetDescriptorSetLayoutSupportKHR,
		}
	}
}
impl Vulkan_KHR_maintenance3 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_descriptor_set_layout_support_khr: {let proc = get_instance_proc_address(instance, "vkGetDescriptorSetLayoutSupportKHR"); if proc == null() {dummy_vkGetDescriptorSetLayoutSupportKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// function prototype `PFN_vkCmdDrawIndirectCountKHR` from VK_KHR_draw_indirect_count
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndirectCountKHR.html>
type PFN_vkCmdDrawIndirectCountKHR = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
/// function prototype `PFN_vkCmdDrawIndexedIndirectCountKHR` from VK_KHR_draw_indirect_count
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexedIndirectCountKHR.html>
type PFN_vkCmdDrawIndexedIndirectCountKHR = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
/// The dummy function for `vkCmdDrawIndirectCountKHR` from `VK_KHR_draw_indirect_count`
extern "system" fn dummy_vkCmdDrawIndirectCountKHR(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkBuffer, _: VkDeviceSize, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdDrawIndirectCountKHR"))
}
/// trait for `VK_KHR_draw_indirect_count`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_draw_indirect_count.html>
pub trait VK_KHR_draw_indirect_count: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndirectCountKHR.html>
	fn vkCmdDrawIndirectCountKHR(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> Result<()>;
}
/// struct for `VK_KHR_draw_indirect_count`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_draw_indirect_count {
	vk_cmd_draw_indirect_count_khr: PFN_vkCmdDrawIndirectCountKHR,
}
impl VK_KHR_draw_indirect_count for Vulkan_KHR_draw_indirect_count {
	fn vkCmdDrawIndirectCountKHR(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_draw_indirect_count_khr)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride))))
	}
}
impl Default for Vulkan_KHR_draw_indirect_count {
	fn default() -> Self {
		Self {
			vk_cmd_draw_indirect_count_khr: dummy_vkCmdDrawIndirectCountKHR,
		}
	}
}
impl Vulkan_KHR_draw_indirect_count {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_draw_indirect_count_khr: {let proc = get_instance_proc_address(instance, "vkCmdDrawIndirectCountKHR"); if proc == null() {dummy_vkCmdDrawIndirectCountKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR` from VK_KHR_shader_subgroup_extended_types
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR.html>
pub type VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;
/// trait for `VK_KHR_shader_subgroup_extended_types`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_subgroup_extended_types.html>
pub trait VK_KHR_shader_subgroup_extended_types: Debug {}
/// struct for `VK_KHR_shader_subgroup_extended_types`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_subgroup_extended_types {}
impl VK_KHR_shader_subgroup_extended_types for Vulkan_KHR_shader_subgroup_extended_types {}
impl Default for Vulkan_KHR_shader_subgroup_extended_types {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_subgroup_extended_types {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDevice8BitStorageFeaturesKHR` from VK_KHR_8bit_storage
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevice8BitStorageFeaturesKHR.html>
pub type VkPhysicalDevice8BitStorageFeaturesKHR = VkPhysicalDevice8BitStorageFeatures;
/// trait for `VK_KHR_8bit_storage`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_8bit_storage.html>
pub trait VK_KHR_8bit_storage: Debug {}
/// struct for `VK_KHR_8bit_storage`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_8bit_storage {}
impl VK_KHR_8bit_storage for Vulkan_KHR_8bit_storage {}
impl Default for Vulkan_KHR_8bit_storage {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_8bit_storage {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceShaderAtomicInt64FeaturesKHR` from VK_KHR_shader_atomic_int64
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.html>
pub type VkPhysicalDeviceShaderAtomicInt64FeaturesKHR = VkPhysicalDeviceShaderAtomicInt64Features;
/// trait for `VK_KHR_shader_atomic_int64`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_atomic_int64.html>
pub trait VK_KHR_shader_atomic_int64: Debug {}
/// struct for `VK_KHR_shader_atomic_int64`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_atomic_int64 {}
impl VK_KHR_shader_atomic_int64 for Vulkan_KHR_shader_atomic_int64 {}
impl Default for Vulkan_KHR_shader_atomic_int64 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_atomic_int64 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceShaderClockFeaturesKHR` from VK_KHR_shader_clock
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderClockFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderClockFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderSubgroupClock: VkBool32,
	pub shaderDeviceClock: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderClockFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderClockFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderSubgroupClock", &self.shaderSubgroupClock)
		.field("shaderDeviceClock", &self.shaderDeviceClock)
		.finish()
	}
}
/// trait for `VK_KHR_shader_clock`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_clock.html>
pub trait VK_KHR_shader_clock: Debug {}
/// struct for `VK_KHR_shader_clock`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_clock {}
impl VK_KHR_shader_clock for Vulkan_KHR_shader_clock {}
impl Default for Vulkan_KHR_shader_clock {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_clock {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkVideoDecodeH265ProfileInfoKHR` from VK_KHR_video_decode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeH265ProfileInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeH265ProfileInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdProfileIdc: StdVideoH265ProfileIdc,
}
impl Debug for VkVideoDecodeH265ProfileInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH265ProfileInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stdProfileIdc", &self.stdProfileIdc)
		.finish()
	}
}
/// struct `VkVideoDecodeH265CapabilitiesKHR` from VK_KHR_video_decode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeH265CapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeH265CapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxLevelIdc: StdVideoH265LevelIdc,
}
impl Debug for VkVideoDecodeH265CapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH265CapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxLevelIdc", &self.maxLevelIdc)
		.finish()
	}
}
/// struct `VkVideoDecodeH265SessionParametersAddInfoKHR` from VK_KHR_video_decode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeH265SessionParametersAddInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeH265SessionParametersAddInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdVPSCount: u32,
	pub pStdVPSs: *const StdVideoH265VideoParameterSet,
	pub stdSPSCount: u32,
	pub pStdSPSs: *const StdVideoH265SequenceParameterSet,
	pub stdPPSCount: u32,
	pub pStdPPSs: *const StdVideoH265PictureParameterSet,
}
impl Debug for VkVideoDecodeH265SessionParametersAddInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH265SessionParametersAddInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stdVPSCount", &self.stdVPSCount)
		.field("pStdVPSs", &self.pStdVPSs)
		.field("stdSPSCount", &self.stdSPSCount)
		.field("pStdSPSs", &self.pStdSPSs)
		.field("stdPPSCount", &self.stdPPSCount)
		.field("pStdPPSs", &self.pStdPPSs)
		.finish()
	}
}
/// struct `VkVideoDecodeH265SessionParametersCreateInfoKHR` from VK_KHR_video_decode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeH265SessionParametersCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeH265SessionParametersCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maxStdVPSCount: u32,
	pub maxStdSPSCount: u32,
	pub maxStdPPSCount: u32,
	pub pParametersAddInfo: *const VkVideoDecodeH265SessionParametersAddInfoKHR,
}
impl Debug for VkVideoDecodeH265SessionParametersCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH265SessionParametersCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxStdVPSCount", &self.maxStdVPSCount)
		.field("maxStdSPSCount", &self.maxStdSPSCount)
		.field("maxStdPPSCount", &self.maxStdPPSCount)
		.field("pParametersAddInfo", &self.pParametersAddInfo)
		.finish()
	}
}
/// struct `VkVideoDecodeH265PictureInfoKHR` from VK_KHR_video_decode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeH265PictureInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeH265PictureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdPictureInfo: *const StdVideoDecodeH265PictureInfo,
	pub sliceSegmentCount: u32,
	pub pSliceSegmentOffsets: *const uint32_t,
}
impl Debug for VkVideoDecodeH265PictureInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH265PictureInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pStdPictureInfo", &self.pStdPictureInfo)
		.field("sliceSegmentCount", &self.sliceSegmentCount)
		.field("pSliceSegmentOffsets", &self.pSliceSegmentOffsets)
		.finish()
	}
}
/// struct `VkVideoDecodeH265DpbSlotInfoKHR` from VK_KHR_video_decode_h265
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeH265DpbSlotInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeH265DpbSlotInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdReferenceInfo: *const StdVideoDecodeH265ReferenceInfo,
}
impl Debug for VkVideoDecodeH265DpbSlotInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH265DpbSlotInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pStdReferenceInfo", &self.pStdReferenceInfo)
		.finish()
	}
}
/// trait for `VK_KHR_video_decode_h265`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_video_decode_h265.html>
pub trait VK_KHR_video_decode_h265: Debug {}
/// struct for `VK_KHR_video_decode_h265`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_decode_h265 {}
impl VK_KHR_video_decode_h265 for Vulkan_KHR_video_decode_h265 {}
impl Default for Vulkan_KHR_video_decode_h265 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_decode_h265 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_API_VERSION_1_0_0` from vulkan_video_codec_h265std_decode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_API_VERSION_1_0_0.html>
pub const VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_API_VERSION_1_0_0: u32 = 0x400000;
/// constant `STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE` from vulkan_video_codec_h265std_decode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE.html>
pub const STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE: u32 = 8u32;
/// struct `StdVideoDecodeH265PictureInfoFlags` from vulkan_video_codec_h265std_decode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoDecodeH265PictureInfoFlags {
	/// Bitfield: IrapPicFlag: u32 in 1 bits
	/// Bitfield: IdrPicFlag: u32 in 1 bits
	/// Bitfield: IsReference: u32 in 1 bits
	/// Bitfield: short_term_ref_pic_set_sps_flag: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoDecodeH265PictureInfoFlags {
	pub fn get_IrapPicFlag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_IrapPicFlag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_IdrPicFlag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_IdrPicFlag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_IsReference(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_IsReference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_short_term_ref_pic_set_sps_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_short_term_ref_pic_set_sps_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
}
impl Debug for StdVideoDecodeH265PictureInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoDecodeH265PictureInfoFlags")
		.field("IrapPicFlag", &self.get_IrapPicFlag())
		.field("IdrPicFlag", &self.get_IdrPicFlag())
		.field("IsReference", &self.get_IsReference())
		.field("short_term_ref_pic_set_sps_flag", &self.get_short_term_ref_pic_set_sps_flag())
		.finish()
	}
}
/// struct `StdVideoDecodeH265PictureInfo` from vulkan_video_codec_h265std_decode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoDecodeH265PictureInfo {
	pub flags: StdVideoDecodeH265PictureInfoFlags,
	pub sps_video_parameter_set_id: u8,
	pub pps_seq_parameter_set_id: u8,
	pub pps_pic_parameter_set_id: u8,
	pub NumDeltaPocsOfRefRpsIdx: u8,
	pub PicOrderCntVal: i32,
	pub NumBitsForSTRefPicSetInSlice: u16,
	pub reserved: u16,
	pub RefPicSetStCurrBefore: [u8; STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE as usize],
	pub RefPicSetStCurrAfter: [u8; STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE as usize],
	pub RefPicSetLtCurr: [u8; STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE as usize],
}
impl Debug for StdVideoDecodeH265PictureInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoDecodeH265PictureInfo")
		.field("flags", &self.flags)
		.field("sps_video_parameter_set_id", &self.sps_video_parameter_set_id)
		.field("pps_seq_parameter_set_id", &self.pps_seq_parameter_set_id)
		.field("pps_pic_parameter_set_id", &self.pps_pic_parameter_set_id)
		.field("NumDeltaPocsOfRefRpsIdx", &self.NumDeltaPocsOfRefRpsIdx)
		.field("PicOrderCntVal", &self.PicOrderCntVal)
		.field("NumBitsForSTRefPicSetInSlice", &self.NumBitsForSTRefPicSetInSlice)
		.field("reserved", &self.reserved)
		.field("RefPicSetStCurrBefore", &self.RefPicSetStCurrBefore)
		.field("RefPicSetStCurrAfter", &self.RefPicSetStCurrAfter)
		.field("RefPicSetLtCurr", &self.RefPicSetLtCurr)
		.finish()
	}
}
/// struct `StdVideoDecodeH265ReferenceInfoFlags` from vulkan_video_codec_h265std_decode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoDecodeH265ReferenceInfoFlags {
	/// Bitfield: used_for_long_term_reference: u32 in 1 bits
	/// Bitfield: unused_for_reference: u32 in 1 bits
	pub bitfield1: u32,
}
impl StdVideoDecodeH265ReferenceInfoFlags {
	pub fn get_used_for_long_term_reference(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_used_for_long_term_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_unused_for_reference(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_unused_for_reference(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
}
impl Debug for StdVideoDecodeH265ReferenceInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoDecodeH265ReferenceInfoFlags")
		.field("used_for_long_term_reference", &self.get_used_for_long_term_reference())
		.field("unused_for_reference", &self.get_unused_for_reference())
		.finish()
	}
}
/// struct `StdVideoDecodeH265ReferenceInfo` from vulkan_video_codec_h265std_decode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoDecodeH265ReferenceInfo {
	pub flags: StdVideoDecodeH265ReferenceInfoFlags,
	pub PicOrderCntVal: i32,
}
impl Debug for StdVideoDecodeH265ReferenceInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoDecodeH265ReferenceInfo")
		.field("flags", &self.flags)
		.field("PicOrderCntVal", &self.PicOrderCntVal)
		.finish()
	}
}
/// trait for `vulkan_video_codec_h265std_decode`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vulkan_video_codec_h265std_decode.html>
pub trait vulkan_video_codec_h265std_decode: Debug {}
/// struct for `vulkan_video_codec_h265std_decode`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_h265std_decode {}
impl vulkan_video_codec_h265std_decode for Vulkan_video_codec_h265std_decode {}
impl Default for Vulkan_video_codec_h265std_decode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_h265std_decode {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `VK_MAX_GLOBAL_PRIORITY_SIZE_KHR` from VK_KHR_global_priority
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_GLOBAL_PRIORITY_SIZE_KHR.html>
pub const VK_MAX_GLOBAL_PRIORITY_SIZE_KHR: u32 = 16u32;
/// type definition `VkQueueGlobalPriorityKHR` from VK_KHR_global_priority
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueGlobalPriorityKHR.html>
pub type VkQueueGlobalPriorityKHR = VkQueueGlobalPriority;
/// type definition `VkDeviceQueueGlobalPriorityCreateInfoKHR` from VK_KHR_global_priority
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceQueueGlobalPriorityCreateInfoKHR.html>
pub type VkDeviceQueueGlobalPriorityCreateInfoKHR = VkDeviceQueueGlobalPriorityCreateInfo;
/// type definition `VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR` from VK_KHR_global_priority
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR.html>
pub type VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR = VkPhysicalDeviceGlobalPriorityQueryFeatures;
/// type definition `VkQueueFamilyGlobalPriorityPropertiesKHR` from VK_KHR_global_priority
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueFamilyGlobalPriorityPropertiesKHR.html>
pub type VkQueueFamilyGlobalPriorityPropertiesKHR = VkQueueFamilyGlobalPriorityProperties;
/// trait for `VK_KHR_global_priority`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_global_priority.html>
pub trait VK_KHR_global_priority: Debug {}
/// struct for `VK_KHR_global_priority`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_global_priority {}
impl VK_KHR_global_priority for Vulkan_KHR_global_priority {}
impl Default for Vulkan_KHR_global_priority {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_global_priority {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `VK_MAX_DRIVER_NAME_SIZE_KHR` from VK_KHR_driver_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_DRIVER_NAME_SIZE_KHR.html>
pub const VK_MAX_DRIVER_NAME_SIZE_KHR: u32 = 256u32;
/// constant `VK_MAX_DRIVER_INFO_SIZE_KHR` from VK_KHR_driver_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_DRIVER_INFO_SIZE_KHR.html>
pub const VK_MAX_DRIVER_INFO_SIZE_KHR: u32 = 256u32;
/// type definition `VkDriverIdKHR` from VK_KHR_driver_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDriverIdKHR.html>
pub type VkDriverIdKHR = VkDriverId;
/// type definition `VkConformanceVersionKHR` from VK_KHR_driver_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkConformanceVersionKHR.html>
pub type VkConformanceVersionKHR = VkConformanceVersion;
/// type definition `VkPhysicalDeviceDriverPropertiesKHR` from VK_KHR_driver_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDriverPropertiesKHR.html>
pub type VkPhysicalDeviceDriverPropertiesKHR = VkPhysicalDeviceDriverProperties;
/// trait for `VK_KHR_driver_properties`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_driver_properties.html>
pub trait VK_KHR_driver_properties: Debug {}
/// struct for `VK_KHR_driver_properties`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_driver_properties {}
impl VK_KHR_driver_properties for Vulkan_KHR_driver_properties {}
impl Default for Vulkan_KHR_driver_properties {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_driver_properties {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkShaderFloatControlsIndependenceKHR` from VK_KHR_shader_float_controls
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderFloatControlsIndependenceKHR.html>
pub type VkShaderFloatControlsIndependenceKHR = VkShaderFloatControlsIndependence;
/// type definition `VkPhysicalDeviceFloatControlsPropertiesKHR` from VK_KHR_shader_float_controls
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFloatControlsPropertiesKHR.html>
pub type VkPhysicalDeviceFloatControlsPropertiesKHR = VkPhysicalDeviceFloatControlsProperties;
/// trait for `VK_KHR_shader_float_controls`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_float_controls.html>
pub trait VK_KHR_shader_float_controls: Debug {}
/// struct for `VK_KHR_shader_float_controls`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_float_controls {}
impl VK_KHR_shader_float_controls for Vulkan_KHR_shader_float_controls {}
impl Default for Vulkan_KHR_shader_float_controls {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_float_controls {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkResolveModeFlagBitsKHR` from VK_KHR_depth_stencil_resolve
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkResolveModeFlagBitsKHR.html>
pub type VkResolveModeFlagBitsKHR = VkResolveModeFlagBits;
/// type definition `VkResolveModeFlagsKHR` from VK_KHR_depth_stencil_resolve
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkResolveModeFlagsKHR.html>
pub type VkResolveModeFlagsKHR = VkResolveModeFlags;
/// type definition `VkSubpassDescriptionDepthStencilResolveKHR` from VK_KHR_depth_stencil_resolve
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassDescriptionDepthStencilResolveKHR.html>
pub type VkSubpassDescriptionDepthStencilResolveKHR = VkSubpassDescriptionDepthStencilResolve;
/// type definition `VkPhysicalDeviceDepthStencilResolvePropertiesKHR` from VK_KHR_depth_stencil_resolve
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDepthStencilResolvePropertiesKHR.html>
pub type VkPhysicalDeviceDepthStencilResolvePropertiesKHR = VkPhysicalDeviceDepthStencilResolveProperties;
/// trait for `VK_KHR_depth_stencil_resolve`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_depth_stencil_resolve.html>
pub trait VK_KHR_depth_stencil_resolve: Debug {}
/// struct for `VK_KHR_depth_stencil_resolve`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_depth_stencil_resolve {}
impl VK_KHR_depth_stencil_resolve for Vulkan_KHR_depth_stencil_resolve {}
impl Default for Vulkan_KHR_depth_stencil_resolve {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_depth_stencil_resolve {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_KHR_swapchain_mutable_format`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_swapchain_mutable_format.html>
pub trait VK_KHR_swapchain_mutable_format: Debug {}
/// struct for `VK_KHR_swapchain_mutable_format`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_swapchain_mutable_format {}
impl VK_KHR_swapchain_mutable_format for Vulkan_KHR_swapchain_mutable_format {}
impl Default for Vulkan_KHR_swapchain_mutable_format {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_swapchain_mutable_format {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkSemaphoreTypeKHR` from VK_KHR_timeline_semaphore
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreTypeKHR.html>
pub type VkSemaphoreTypeKHR = VkSemaphoreType;
/// type definition `VkSemaphoreWaitFlagBitsKHR` from VK_KHR_timeline_semaphore
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreWaitFlagBitsKHR.html>
pub type VkSemaphoreWaitFlagBitsKHR = VkSemaphoreWaitFlagBits;
/// type definition `VkSemaphoreWaitFlagsKHR` from VK_KHR_timeline_semaphore
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreWaitFlagsKHR.html>
pub type VkSemaphoreWaitFlagsKHR = VkSemaphoreWaitFlags;
/// type definition `VkPhysicalDeviceTimelineSemaphoreFeaturesKHR` from VK_KHR_timeline_semaphore
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTimelineSemaphoreFeaturesKHR.html>
pub type VkPhysicalDeviceTimelineSemaphoreFeaturesKHR = VkPhysicalDeviceTimelineSemaphoreFeatures;
/// type definition `VkPhysicalDeviceTimelineSemaphorePropertiesKHR` from VK_KHR_timeline_semaphore
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTimelineSemaphorePropertiesKHR.html>
pub type VkPhysicalDeviceTimelineSemaphorePropertiesKHR = VkPhysicalDeviceTimelineSemaphoreProperties;
/// type definition `VkSemaphoreTypeCreateInfoKHR` from VK_KHR_timeline_semaphore
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreTypeCreateInfoKHR.html>
pub type VkSemaphoreTypeCreateInfoKHR = VkSemaphoreTypeCreateInfo;
/// type definition `VkTimelineSemaphoreSubmitInfoKHR` from VK_KHR_timeline_semaphore
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTimelineSemaphoreSubmitInfoKHR.html>
pub type VkTimelineSemaphoreSubmitInfoKHR = VkTimelineSemaphoreSubmitInfo;
/// type definition `VkSemaphoreWaitInfoKHR` from VK_KHR_timeline_semaphore
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreWaitInfoKHR.html>
pub type VkSemaphoreWaitInfoKHR = VkSemaphoreWaitInfo;
/// type definition `VkSemaphoreSignalInfoKHR` from VK_KHR_timeline_semaphore
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreSignalInfoKHR.html>
pub type VkSemaphoreSignalInfoKHR = VkSemaphoreSignalInfo;
/// function prototype `PFN_vkGetSemaphoreCounterValueKHR` from VK_KHR_timeline_semaphore
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSemaphoreCounterValueKHR.html>
type PFN_vkGetSemaphoreCounterValueKHR = extern "system" fn(device: VkDevice, semaphore: VkSemaphore, pValue: *mut uint64_t) -> VkResult;
/// function prototype `PFN_vkWaitSemaphoresKHR` from VK_KHR_timeline_semaphore
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitSemaphoresKHR.html>
type PFN_vkWaitSemaphoresKHR = extern "system" fn(device: VkDevice, pWaitInfo: *const VkSemaphoreWaitInfo, timeout: u64) -> VkResult;
/// function prototype `PFN_vkSignalSemaphoreKHR` from VK_KHR_timeline_semaphore
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSignalSemaphoreKHR.html>
type PFN_vkSignalSemaphoreKHR = extern "system" fn(device: VkDevice, pSignalInfo: *const VkSemaphoreSignalInfo) -> VkResult;
/// The dummy function for `vkGetSemaphoreCounterValueKHR` from `VK_KHR_timeline_semaphore`
extern "system" fn dummy_vkGetSemaphoreCounterValueKHR(_: VkDevice, _: VkSemaphore, _: *mut uint64_t) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetSemaphoreCounterValueKHR"))
}
/// trait for `VK_KHR_timeline_semaphore`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_timeline_semaphore.html>
pub trait VK_KHR_timeline_semaphore: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSemaphoreCounterValueKHR.html>
	fn vkGetSemaphoreCounterValueKHR(&self, device: VkDevice, semaphore: VkSemaphore, pValue: *mut uint64_t) -> Result<()>;
}
/// struct for `VK_KHR_timeline_semaphore`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_timeline_semaphore {
	vk_get_semaphore_counter_value_khr: PFN_vkGetSemaphoreCounterValueKHR,
}
impl VK_KHR_timeline_semaphore for Vulkan_KHR_timeline_semaphore {
	fn vkGetSemaphoreCounterValueKHR(&self, device: VkDevice, semaphore: VkSemaphore, pValue: *mut uint64_t) -> Result<()> {
		convert_result("vkGetSemaphoreCounterValueKHR", catch_unwind(||((self.vk_get_semaphore_counter_value_khr)(device, semaphore, pValue))))
	}
}
impl Default for Vulkan_KHR_timeline_semaphore {
	fn default() -> Self {
		Self {
			vk_get_semaphore_counter_value_khr: dummy_vkGetSemaphoreCounterValueKHR,
		}
	}
}
impl Vulkan_KHR_timeline_semaphore {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_semaphore_counter_value_khr: {let proc = get_instance_proc_address(instance, "vkGetSemaphoreCounterValueKHR"); if proc == null() {dummy_vkGetSemaphoreCounterValueKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceVulkanMemoryModelFeaturesKHR` from VK_KHR_vulkan_memory_model
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.html>
pub type VkPhysicalDeviceVulkanMemoryModelFeaturesKHR = VkPhysicalDeviceVulkanMemoryModelFeatures;
/// trait for `VK_KHR_vulkan_memory_model`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_vulkan_memory_model.html>
pub trait VK_KHR_vulkan_memory_model: Debug {}
/// struct for `VK_KHR_vulkan_memory_model`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_vulkan_memory_model {}
impl VK_KHR_vulkan_memory_model for Vulkan_KHR_vulkan_memory_model {}
impl Default for Vulkan_KHR_vulkan_memory_model {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_vulkan_memory_model {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR` from VK_KHR_shader_terminate_invocation
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR.html>
pub type VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR = VkPhysicalDeviceShaderTerminateInvocationFeatures;
/// trait for `VK_KHR_shader_terminate_invocation`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_terminate_invocation.html>
pub trait VK_KHR_shader_terminate_invocation: Debug {}
/// struct for `VK_KHR_shader_terminate_invocation`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_terminate_invocation {}
impl VK_KHR_shader_terminate_invocation for Vulkan_KHR_shader_terminate_invocation {}
impl Default for Vulkan_KHR_shader_terminate_invocation {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_terminate_invocation {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkFragmentShadingRateCombinerOpKHR` from VK_KHR_fragment_shading_rate
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFragmentShadingRateCombinerOpKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFragmentShadingRateCombinerOpKHR {
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR = 0,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR = 1,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR = 2,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR = 3,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR = 4,
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_ENUM_KHR = 0x7fffffff,
}
/// struct `VkFragmentShadingRateAttachmentInfoKHR` from VK_KHR_fragment_shading_rate
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFragmentShadingRateAttachmentInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkFragmentShadingRateAttachmentInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pFragmentShadingRateAttachment: *const VkAttachmentReference2,
	pub shadingRateAttachmentTexelSize: VkExtent2D,
}
impl Debug for VkFragmentShadingRateAttachmentInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkFragmentShadingRateAttachmentInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pFragmentShadingRateAttachment", &self.pFragmentShadingRateAttachment)
		.field("shadingRateAttachmentTexelSize", &self.shadingRateAttachmentTexelSize)
		.finish()
	}
}
/// struct `VkPipelineFragmentShadingRateStateCreateInfoKHR` from VK_KHR_fragment_shading_rate
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineFragmentShadingRateStateCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineFragmentShadingRateStateCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub fragmentSize: VkExtent2D,
	pub combinerOps: [VkFragmentShadingRateCombinerOpKHR; 2 as usize],
}
impl Debug for VkPipelineFragmentShadingRateStateCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineFragmentShadingRateStateCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("fragmentSize", &self.fragmentSize)
		.field("combinerOps", &self.combinerOps)
		.finish()
	}
}
/// struct `VkPhysicalDeviceFragmentShadingRateFeaturesKHR` from VK_KHR_fragment_shading_rate
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentShadingRateFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFragmentShadingRateFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineFragmentShadingRate: VkBool32,
	pub primitiveFragmentShadingRate: VkBool32,
	pub attachmentFragmentShadingRate: VkBool32,
}
impl Debug for VkPhysicalDeviceFragmentShadingRateFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentShadingRateFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelineFragmentShadingRate", &self.pipelineFragmentShadingRate)
		.field("primitiveFragmentShadingRate", &self.primitiveFragmentShadingRate)
		.field("attachmentFragmentShadingRate", &self.attachmentFragmentShadingRate)
		.finish()
	}
}
/// struct `VkPhysicalDeviceFragmentShadingRatePropertiesKHR` from VK_KHR_fragment_shading_rate
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentShadingRatePropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFragmentShadingRatePropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minFragmentShadingRateAttachmentTexelSize: VkExtent2D,
	pub maxFragmentShadingRateAttachmentTexelSize: VkExtent2D,
	pub maxFragmentShadingRateAttachmentTexelSizeAspectRatio: u32,
	pub primitiveFragmentShadingRateWithMultipleViewports: VkBool32,
	pub layeredShadingRateAttachments: VkBool32,
	pub fragmentShadingRateNonTrivialCombinerOps: VkBool32,
	pub maxFragmentSize: VkExtent2D,
	pub maxFragmentSizeAspectRatio: u32,
	pub maxFragmentShadingRateCoverageSamples: u32,
	pub maxFragmentShadingRateRasterizationSamples: VkSampleCountFlagBits,
	pub fragmentShadingRateWithShaderDepthStencilWrites: VkBool32,
	pub fragmentShadingRateWithSampleMask: VkBool32,
	pub fragmentShadingRateWithShaderSampleMask: VkBool32,
	pub fragmentShadingRateWithConservativeRasterization: VkBool32,
	pub fragmentShadingRateWithFragmentShaderInterlock: VkBool32,
	pub fragmentShadingRateWithCustomSampleLocations: VkBool32,
	pub fragmentShadingRateStrictMultiplyCombiner: VkBool32,
}
impl Debug for VkPhysicalDeviceFragmentShadingRatePropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentShadingRatePropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("minFragmentShadingRateAttachmentTexelSize", &self.minFragmentShadingRateAttachmentTexelSize)
		.field("maxFragmentShadingRateAttachmentTexelSize", &self.maxFragmentShadingRateAttachmentTexelSize)
		.field("maxFragmentShadingRateAttachmentTexelSizeAspectRatio", &self.maxFragmentShadingRateAttachmentTexelSizeAspectRatio)
		.field("primitiveFragmentShadingRateWithMultipleViewports", &self.primitiveFragmentShadingRateWithMultipleViewports)
		.field("layeredShadingRateAttachments", &self.layeredShadingRateAttachments)
		.field("fragmentShadingRateNonTrivialCombinerOps", &self.fragmentShadingRateNonTrivialCombinerOps)
		.field("maxFragmentSize", &self.maxFragmentSize)
		.field("maxFragmentSizeAspectRatio", &self.maxFragmentSizeAspectRatio)
		.field("maxFragmentShadingRateCoverageSamples", &self.maxFragmentShadingRateCoverageSamples)
		.field("maxFragmentShadingRateRasterizationSamples", &self.maxFragmentShadingRateRasterizationSamples)
		.field("fragmentShadingRateWithShaderDepthStencilWrites", &self.fragmentShadingRateWithShaderDepthStencilWrites)
		.field("fragmentShadingRateWithSampleMask", &self.fragmentShadingRateWithSampleMask)
		.field("fragmentShadingRateWithShaderSampleMask", &self.fragmentShadingRateWithShaderSampleMask)
		.field("fragmentShadingRateWithConservativeRasterization", &self.fragmentShadingRateWithConservativeRasterization)
		.field("fragmentShadingRateWithFragmentShaderInterlock", &self.fragmentShadingRateWithFragmentShaderInterlock)
		.field("fragmentShadingRateWithCustomSampleLocations", &self.fragmentShadingRateWithCustomSampleLocations)
		.field("fragmentShadingRateStrictMultiplyCombiner", &self.fragmentShadingRateStrictMultiplyCombiner)
		.finish()
	}
}
/// struct `VkPhysicalDeviceFragmentShadingRateKHR` from VK_KHR_fragment_shading_rate
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentShadingRateKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFragmentShadingRateKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub sampleCounts: VkSampleCountFlags,
	pub fragmentSize: VkExtent2D,
}
impl Debug for VkPhysicalDeviceFragmentShadingRateKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentShadingRateKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("sampleCounts", &self.sampleCounts)
		.field("fragmentSize", &self.fragmentSize)
		.finish()
	}
}
/// struct `VkRenderingFragmentShadingRateAttachmentInfoKHR` from VK_KHR_fragment_shading_rate
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingFragmentShadingRateAttachmentInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderingFragmentShadingRateAttachmentInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub imageView: VkImageView,
	pub imageLayout: VkImageLayout,
	pub shadingRateAttachmentTexelSize: VkExtent2D,
}
impl Debug for VkRenderingFragmentShadingRateAttachmentInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderingFragmentShadingRateAttachmentInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("imageView", &self.imageView)
		.field("imageLayout", &self.imageLayout)
		.field("shadingRateAttachmentTexelSize", &self.shadingRateAttachmentTexelSize)
		.finish()
	}
}
/// function prototype `PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR` from VK_KHR_fragment_shading_rate
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFragmentShadingRatesKHR.html>
type PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pFragmentShadingRateCount: *mut uint32_t, pFragmentShadingRates: *mut VkPhysicalDeviceFragmentShadingRateKHR) -> VkResult;
/// function prototype `PFN_vkCmdSetFragmentShadingRateKHR` from VK_KHR_fragment_shading_rate
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetFragmentShadingRateKHR.html>
type PFN_vkCmdSetFragmentShadingRateKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pFragmentSize: *const VkExtent2D, combinerOps: &[VkFragmentShadingRateCombinerOpKHR; 2 as usize]);
/// The dummy function for `vkGetPhysicalDeviceFragmentShadingRatesKHR` from `VK_KHR_fragment_shading_rate`
extern "system" fn dummy_vkGetPhysicalDeviceFragmentShadingRatesKHR(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkPhysicalDeviceFragmentShadingRateKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceFragmentShadingRatesKHR"))
}
/// trait for `VK_KHR_fragment_shading_rate`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_fragment_shading_rate.html>
pub trait VK_KHR_fragment_shading_rate: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFragmentShadingRatesKHR.html>
	fn vkGetPhysicalDeviceFragmentShadingRatesKHR(&self, physicalDevice: VkPhysicalDevice, pFragmentShadingRateCount: *mut uint32_t, pFragmentShadingRates: *mut VkPhysicalDeviceFragmentShadingRateKHR) -> Result<()>;
}
/// struct for `VK_KHR_fragment_shading_rate`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_fragment_shading_rate {
	vk_get_physical_device_fragment_shading_rates_khr: PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR,
}
impl VK_KHR_fragment_shading_rate for Vulkan_KHR_fragment_shading_rate {
	fn vkGetPhysicalDeviceFragmentShadingRatesKHR(&self, physicalDevice: VkPhysicalDevice, pFragmentShadingRateCount: *mut uint32_t, pFragmentShadingRates: *mut VkPhysicalDeviceFragmentShadingRateKHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceFragmentShadingRatesKHR", catch_unwind(||((self.vk_get_physical_device_fragment_shading_rates_khr)(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates))))
	}
}
impl Default for Vulkan_KHR_fragment_shading_rate {
	fn default() -> Self {
		Self {
			vk_get_physical_device_fragment_shading_rates_khr: dummy_vkGetPhysicalDeviceFragmentShadingRatesKHR,
		}
	}
}
impl Vulkan_KHR_fragment_shading_rate {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_fragment_shading_rates_khr: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceFragmentShadingRatesKHR"); if proc == null() {dummy_vkGetPhysicalDeviceFragmentShadingRatesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR` from VK_KHR_dynamic_rendering_local_read
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR.html>
pub type VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR = VkPhysicalDeviceDynamicRenderingLocalReadFeatures;
/// type definition `VkRenderingAttachmentLocationInfoKHR` from VK_KHR_dynamic_rendering_local_read
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingAttachmentLocationInfoKHR.html>
pub type VkRenderingAttachmentLocationInfoKHR = VkRenderingAttachmentLocationInfo;
/// type definition `VkRenderingInputAttachmentIndexInfoKHR` from VK_KHR_dynamic_rendering_local_read
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingInputAttachmentIndexInfoKHR.html>
pub type VkRenderingInputAttachmentIndexInfoKHR = VkRenderingInputAttachmentIndexInfo;
/// function prototype `PFN_vkCmdSetRenderingAttachmentLocationsKHR` from VK_KHR_dynamic_rendering_local_read
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRenderingAttachmentLocationsKHR.html>
type PFN_vkCmdSetRenderingAttachmentLocationsKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pLocationInfo: *const VkRenderingAttachmentLocationInfo);
/// function prototype `PFN_vkCmdSetRenderingInputAttachmentIndicesKHR` from VK_KHR_dynamic_rendering_local_read
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRenderingInputAttachmentIndicesKHR.html>
type PFN_vkCmdSetRenderingInputAttachmentIndicesKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pInputAttachmentIndexInfo: *const VkRenderingInputAttachmentIndexInfo);
/// The dummy function for `vkCmdSetRenderingAttachmentLocationsKHR` from `VK_KHR_dynamic_rendering_local_read`
extern "system" fn dummy_vkCmdSetRenderingAttachmentLocationsKHR(_: VkCommandBuffer, _: *const VkRenderingAttachmentLocationInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetRenderingAttachmentLocationsKHR"))
}
/// trait for `VK_KHR_dynamic_rendering_local_read`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_dynamic_rendering_local_read.html>
pub trait VK_KHR_dynamic_rendering_local_read: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRenderingAttachmentLocationsKHR.html>
	fn vkCmdSetRenderingAttachmentLocationsKHR(&self, commandBuffer: VkCommandBuffer, pLocationInfo: *const VkRenderingAttachmentLocationInfo) -> Result<()>;
}
/// struct for `VK_KHR_dynamic_rendering_local_read`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_dynamic_rendering_local_read {
	vk_cmd_set_rendering_attachment_locations_khr: PFN_vkCmdSetRenderingAttachmentLocationsKHR,
}
impl VK_KHR_dynamic_rendering_local_read for Vulkan_KHR_dynamic_rendering_local_read {
	fn vkCmdSetRenderingAttachmentLocationsKHR(&self, commandBuffer: VkCommandBuffer, pLocationInfo: *const VkRenderingAttachmentLocationInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_rendering_attachment_locations_khr)(commandBuffer, pLocationInfo))))
	}
}
impl Default for Vulkan_KHR_dynamic_rendering_local_read {
	fn default() -> Self {
		Self {
			vk_cmd_set_rendering_attachment_locations_khr: dummy_vkCmdSetRenderingAttachmentLocationsKHR,
		}
	}
}
impl Vulkan_KHR_dynamic_rendering_local_read {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_rendering_attachment_locations_khr: {let proc = get_instance_proc_address(instance, "vkCmdSetRenderingAttachmentLocationsKHR"); if proc == null() {dummy_vkCmdSetRenderingAttachmentLocationsKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceShaderQuadControlFeaturesKHR` from VK_KHR_shader_quad_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderQuadControlFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderQuadControlFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderQuadControl: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderQuadControlFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderQuadControlFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderQuadControl", &self.shaderQuadControl)
		.finish()
	}
}
/// trait for `VK_KHR_shader_quad_control`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_quad_control.html>
pub trait VK_KHR_shader_quad_control: Debug {}
/// struct for `VK_KHR_shader_quad_control`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_quad_control {}
impl VK_KHR_shader_quad_control for Vulkan_KHR_shader_quad_control {}
impl Default for Vulkan_KHR_shader_quad_control {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_quad_control {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_KHR_spirv_1_4`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_spirv_1_4.html>
pub trait VK_KHR_spirv_1_4: Debug {}
/// struct for `VK_KHR_spirv_1_4`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_spirv_1_4 {}
impl VK_KHR_spirv_1_4 for Vulkan_KHR_spirv_1_4 {}
impl Default for Vulkan_KHR_spirv_1_4 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_spirv_1_4 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkSurfaceProtectedCapabilitiesKHR` from VK_KHR_surface_protected_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfaceProtectedCapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSurfaceProtectedCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub supportsProtected: VkBool32,
}
impl Debug for VkSurfaceProtectedCapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSurfaceProtectedCapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("supportsProtected", &self.supportsProtected)
		.finish()
	}
}
/// trait for `VK_KHR_surface_protected_capabilities`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_surface_protected_capabilities.html>
pub trait VK_KHR_surface_protected_capabilities: Debug {}
/// struct for `VK_KHR_surface_protected_capabilities`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_surface_protected_capabilities {}
impl VK_KHR_surface_protected_capabilities for Vulkan_KHR_surface_protected_capabilities {}
impl Default for Vulkan_KHR_surface_protected_capabilities {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_surface_protected_capabilities {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR` from VK_KHR_separate_depth_stencil_layouts
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR.html>
pub type VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;
/// type definition `VkAttachmentReferenceStencilLayoutKHR` from VK_KHR_separate_depth_stencil_layouts
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentReferenceStencilLayoutKHR.html>
pub type VkAttachmentReferenceStencilLayoutKHR = VkAttachmentReferenceStencilLayout;
/// type definition `VkAttachmentDescriptionStencilLayoutKHR` from VK_KHR_separate_depth_stencil_layouts
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentDescriptionStencilLayoutKHR.html>
pub type VkAttachmentDescriptionStencilLayoutKHR = VkAttachmentDescriptionStencilLayout;
/// trait for `VK_KHR_separate_depth_stencil_layouts`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_separate_depth_stencil_layouts.html>
pub trait VK_KHR_separate_depth_stencil_layouts: Debug {}
/// struct for `VK_KHR_separate_depth_stencil_layouts`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_separate_depth_stencil_layouts {}
impl VK_KHR_separate_depth_stencil_layouts for Vulkan_KHR_separate_depth_stencil_layouts {}
impl Default for Vulkan_KHR_separate_depth_stencil_layouts {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_separate_depth_stencil_layouts {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDevicePresentWaitFeaturesKHR` from VK_KHR_present_wait
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePresentWaitFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePresentWaitFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentWait: VkBool32,
}
impl Debug for VkPhysicalDevicePresentWaitFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePresentWaitFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentWait", &self.presentWait)
		.finish()
	}
}
/// function prototype `PFN_vkWaitForPresentKHR` from VK_KHR_present_wait
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitForPresentKHR.html>
type PFN_vkWaitForPresentKHR = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, presentId: u64, timeout: u64) -> VkResult;
/// The dummy function for `vkWaitForPresentKHR` from `VK_KHR_present_wait`
extern "system" fn dummy_vkWaitForPresentKHR(_: VkDevice, _: VkSwapchainKHR, _: u64, _: u64) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkWaitForPresentKHR"))
}
/// trait for `VK_KHR_present_wait`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_present_wait.html>
pub trait VK_KHR_present_wait: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitForPresentKHR.html>
	fn vkWaitForPresentKHR(&self, device: VkDevice, swapchain: VkSwapchainKHR, presentId: u64, timeout: u64) -> Result<()>;
}
/// struct for `VK_KHR_present_wait`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_present_wait {
	vk_wait_for_present_khr: PFN_vkWaitForPresentKHR,
}
impl VK_KHR_present_wait for Vulkan_KHR_present_wait {
	fn vkWaitForPresentKHR(&self, device: VkDevice, swapchain: VkSwapchainKHR, presentId: u64, timeout: u64) -> Result<()> {
		convert_result("vkWaitForPresentKHR", catch_unwind(||((self.vk_wait_for_present_khr)(device, swapchain, presentId, timeout))))
	}
}
impl Default for Vulkan_KHR_present_wait {
	fn default() -> Self {
		Self {
			vk_wait_for_present_khr: dummy_vkWaitForPresentKHR,
		}
	}
}
impl Vulkan_KHR_present_wait {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_wait_for_present_khr: {let proc = get_instance_proc_address(instance, "vkWaitForPresentKHR"); if proc == null() {dummy_vkWaitForPresentKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR` from VK_KHR_uniform_buffer_standard_layout
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.html>
pub type VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = VkPhysicalDeviceUniformBufferStandardLayoutFeatures;
/// trait for `VK_KHR_uniform_buffer_standard_layout`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_uniform_buffer_standard_layout.html>
pub trait VK_KHR_uniform_buffer_standard_layout: Debug {}
/// struct for `VK_KHR_uniform_buffer_standard_layout`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_uniform_buffer_standard_layout {}
impl VK_KHR_uniform_buffer_standard_layout for Vulkan_KHR_uniform_buffer_standard_layout {}
impl Default for Vulkan_KHR_uniform_buffer_standard_layout {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_uniform_buffer_standard_layout {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceBufferDeviceAddressFeaturesKHR` from VK_KHR_buffer_device_address
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceBufferDeviceAddressFeaturesKHR.html>
pub type VkPhysicalDeviceBufferDeviceAddressFeaturesKHR = VkPhysicalDeviceBufferDeviceAddressFeatures;
/// type definition `VkBufferDeviceAddressInfoKHR` from VK_KHR_buffer_device_address
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferDeviceAddressInfoKHR.html>
pub type VkBufferDeviceAddressInfoKHR = VkBufferDeviceAddressInfo;
/// type definition `VkBufferOpaqueCaptureAddressCreateInfoKHR` from VK_KHR_buffer_device_address
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferOpaqueCaptureAddressCreateInfoKHR.html>
pub type VkBufferOpaqueCaptureAddressCreateInfoKHR = VkBufferOpaqueCaptureAddressCreateInfo;
/// type definition `VkMemoryOpaqueCaptureAddressAllocateInfoKHR` from VK_KHR_buffer_device_address
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryOpaqueCaptureAddressAllocateInfoKHR.html>
pub type VkMemoryOpaqueCaptureAddressAllocateInfoKHR = VkMemoryOpaqueCaptureAddressAllocateInfo;
/// type definition `VkDeviceMemoryOpaqueCaptureAddressInfoKHR` from VK_KHR_buffer_device_address
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceMemoryOpaqueCaptureAddressInfoKHR.html>
pub type VkDeviceMemoryOpaqueCaptureAddressInfoKHR = VkDeviceMemoryOpaqueCaptureAddressInfo;
/// function prototype `PFN_vkGetBufferDeviceAddressKHR` from VK_KHR_buffer_device_address
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferDeviceAddressKHR.html>
type PFN_vkGetBufferDeviceAddressKHR = extern "system" fn(device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress;
/// function prototype `PFN_vkGetBufferOpaqueCaptureAddressKHR` from VK_KHR_buffer_device_address
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferOpaqueCaptureAddressKHR.html>
type PFN_vkGetBufferOpaqueCaptureAddressKHR = extern "system" fn(device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> u64;
/// function prototype `PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR` from VK_KHR_buffer_device_address
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceMemoryOpaqueCaptureAddressKHR.html>
type PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo) -> u64;
/// The dummy function for `vkGetBufferDeviceAddressKHR` from `VK_KHR_buffer_device_address`
extern "system" fn dummy_vkGetBufferDeviceAddressKHR(_: VkDevice, _: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress {
	panic_any(VkError::NullFunctionPointer("vkGetBufferDeviceAddressKHR"))
}
/// trait for `VK_KHR_buffer_device_address`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_buffer_device_address.html>
pub trait VK_KHR_buffer_device_address: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferDeviceAddressKHR.html>
	fn vkGetBufferDeviceAddressKHR(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> Result<VkDeviceAddress>;
}
/// struct for `VK_KHR_buffer_device_address`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_buffer_device_address {
	vk_get_buffer_device_address_khr: PFN_vkGetBufferDeviceAddressKHR,
}
impl VK_KHR_buffer_device_address for Vulkan_KHR_buffer_device_address {
	fn vkGetBufferDeviceAddressKHR(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> Result<VkDeviceAddress> {
		process_catch(catch_unwind(||((self.vk_get_buffer_device_address_khr)(device, pInfo))))
	}
}
impl Default for Vulkan_KHR_buffer_device_address {
	fn default() -> Self {
		Self {
			vk_get_buffer_device_address_khr: dummy_vkGetBufferDeviceAddressKHR,
		}
	}
}
impl Vulkan_KHR_buffer_device_address {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_buffer_device_address_khr: {let proc = get_instance_proc_address(instance, "vkGetBufferDeviceAddressKHR"); if proc == null() {dummy_vkGetBufferDeviceAddressKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// Non-dispatchable handle `VkDeferredOperationKHR` from VK_KHR_deferred_host_operations
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeferredOperationKHR.html
#[cfg(target_pointer_width = "32")] pub type VkDeferredOperationKHR = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkDeferredOperationKHR_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkDeferredOperationKHR = *const VkDeferredOperationKHR_T;
/// function prototype `PFN_vkCreateDeferredOperationKHR` from VK_KHR_deferred_host_operations
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDeferredOperationKHR.html>
type PFN_vkCreateDeferredOperationKHR = extern "system" fn(device: VkDevice, pAllocator: *const VkAllocationCallbacks, pDeferredOperation: *mut VkDeferredOperationKHR) -> VkResult;
/// function prototype `PFN_vkDestroyDeferredOperationKHR` from VK_KHR_deferred_host_operations
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDeferredOperationKHR.html>
type PFN_vkDestroyDeferredOperationKHR = extern "system" fn(device: VkDevice, operation: VkDeferredOperationKHR, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkGetDeferredOperationMaxConcurrencyKHR` from VK_KHR_deferred_host_operations
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeferredOperationMaxConcurrencyKHR.html>
type PFN_vkGetDeferredOperationMaxConcurrencyKHR = extern "system" fn(device: VkDevice, operation: VkDeferredOperationKHR) -> u32;
/// function prototype `PFN_vkGetDeferredOperationResultKHR` from VK_KHR_deferred_host_operations
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeferredOperationResultKHR.html>
type PFN_vkGetDeferredOperationResultKHR = extern "system" fn(device: VkDevice, operation: VkDeferredOperationKHR) -> VkResult;
/// function prototype `PFN_vkDeferredOperationJoinKHR` from VK_KHR_deferred_host_operations
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDeferredOperationJoinKHR.html>
type PFN_vkDeferredOperationJoinKHR = extern "system" fn(device: VkDevice, operation: VkDeferredOperationKHR) -> VkResult;
/// The dummy function for `vkCreateDeferredOperationKHR` from `VK_KHR_deferred_host_operations`
extern "system" fn dummy_vkCreateDeferredOperationKHR(_: VkDevice, _: *const VkAllocationCallbacks, _: *mut VkDeferredOperationKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateDeferredOperationKHR"))
}
/// trait for `VK_KHR_deferred_host_operations`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_deferred_host_operations.html>
pub trait VK_KHR_deferred_host_operations: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDeferredOperationKHR.html>
	fn vkCreateDeferredOperationKHR(&self, device: VkDevice, pAllocator: *const VkAllocationCallbacks, pDeferredOperation: *mut VkDeferredOperationKHR) -> Result<()>;
}
/// struct for `VK_KHR_deferred_host_operations`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_deferred_host_operations {
	vk_create_deferred_operation_khr: PFN_vkCreateDeferredOperationKHR,
}
impl VK_KHR_deferred_host_operations for Vulkan_KHR_deferred_host_operations {
	fn vkCreateDeferredOperationKHR(&self, device: VkDevice, pAllocator: *const VkAllocationCallbacks, pDeferredOperation: *mut VkDeferredOperationKHR) -> Result<()> {
		convert_result("vkCreateDeferredOperationKHR", catch_unwind(||((self.vk_create_deferred_operation_khr)(device, pAllocator, pDeferredOperation))))
	}
}
impl Default for Vulkan_KHR_deferred_host_operations {
	fn default() -> Self {
		Self {
			vk_create_deferred_operation_khr: dummy_vkCreateDeferredOperationKHR,
		}
	}
}
impl Vulkan_KHR_deferred_host_operations {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_deferred_operation_khr: {let proc = get_instance_proc_address(instance, "vkCreateDeferredOperationKHR"); if proc == null() {dummy_vkCreateDeferredOperationKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// enum `VkPipelineExecutableStatisticFormatKHR` from VK_KHR_pipeline_executable_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineExecutableStatisticFormatKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineExecutableStatisticFormatKHR {
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3,
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR = 0x7fffffff,
}
/// union `VkPipelineExecutableStatisticValueKHR` from VK_KHR_pipeline_executable_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineExecutableStatisticValueKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkPipelineExecutableStatisticValueKHR {
	pub b32: VkBool32,
	pub i64: i64,
	pub u64: u64,
	pub f64: f64,
}
impl Debug for VkPipelineExecutableStatisticValueKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineExecutableStatisticValueKHR")
		.field("b32", unsafe {&self.b32})
		.field("i64", unsafe {&self.i64})
		.field("u64", unsafe {&self.u64})
		.field("f64", unsafe {&self.f64})
		.finish()
	}
}
/// struct `VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR` from VK_KHR_pipeline_executable_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineExecutableInfo: VkBool32,
}
impl Debug for VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelineExecutableInfo", &self.pipelineExecutableInfo)
		.finish()
	}
}
/// struct `VkPipelineInfoKHR` from VK_KHR_pipeline_executable_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pipeline: VkPipeline,
}
impl Debug for VkPipelineInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipeline", &self.pipeline)
		.finish()
	}
}
/// struct `VkPipelineExecutablePropertiesKHR` from VK_KHR_pipeline_executable_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineExecutablePropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineExecutablePropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub stages: VkShaderStageFlags,
	pub name: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub subgroupSize: u32,
}
impl Debug for VkPipelineExecutablePropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineExecutablePropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stages", &self.stages)
		.field("name", &format_args!("{}", maybe_string(&self.name)))
		.field("description", &format_args!("{}", maybe_string(&self.description)))
		.field("subgroupSize", &self.subgroupSize)
		.finish()
	}
}
/// struct `VkPipelineExecutableInfoKHR` from VK_KHR_pipeline_executable_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineExecutableInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineExecutableInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pipeline: VkPipeline,
	pub executableIndex: u32,
}
impl Debug for VkPipelineExecutableInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineExecutableInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipeline", &self.pipeline)
		.field("executableIndex", &self.executableIndex)
		.finish()
	}
}
/// struct `VkPipelineExecutableStatisticKHR` from VK_KHR_pipeline_executable_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineExecutableStatisticKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineExecutableStatisticKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub name: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub format: VkPipelineExecutableStatisticFormatKHR,
	pub value: VkPipelineExecutableStatisticValueKHR,
}
impl Debug for VkPipelineExecutableStatisticKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineExecutableStatisticKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("name", &format_args!("{}", maybe_string(&self.name)))
		.field("description", &format_args!("{}", maybe_string(&self.description)))
		.field("format", &self.format)
		.field("value", &self.value)
		.finish()
	}
}
/// struct `VkPipelineExecutableInternalRepresentationKHR` from VK_KHR_pipeline_executable_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineExecutableInternalRepresentationKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineExecutableInternalRepresentationKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub name: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub isText: VkBool32,
	pub dataSize: usize,
	pub pData: *mut c_void,
}
impl Debug for VkPipelineExecutableInternalRepresentationKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineExecutableInternalRepresentationKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("name", &format_args!("{}", maybe_string(&self.name)))
		.field("description", &format_args!("{}", maybe_string(&self.description)))
		.field("isText", &self.isText)
		.field("dataSize", &self.dataSize)
		.field("pData", &self.pData)
		.finish()
	}
}
/// function prototype `PFN_vkGetPipelineExecutablePropertiesKHR` from VK_KHR_pipeline_executable_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineExecutablePropertiesKHR.html>
type PFN_vkGetPipelineExecutablePropertiesKHR = extern "system" fn(device: VkDevice, pPipelineInfo: *const VkPipelineInfoKHR, pExecutableCount: *mut uint32_t, pProperties: *mut VkPipelineExecutablePropertiesKHR) -> VkResult;
/// function prototype `PFN_vkGetPipelineExecutableStatisticsKHR` from VK_KHR_pipeline_executable_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineExecutableStatisticsKHR.html>
type PFN_vkGetPipelineExecutableStatisticsKHR = extern "system" fn(device: VkDevice, pExecutableInfo: *const VkPipelineExecutableInfoKHR, pStatisticCount: *mut uint32_t, pStatistics: *mut VkPipelineExecutableStatisticKHR) -> VkResult;
/// function prototype `PFN_vkGetPipelineExecutableInternalRepresentationsKHR` from VK_KHR_pipeline_executable_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineExecutableInternalRepresentationsKHR.html>
type PFN_vkGetPipelineExecutableInternalRepresentationsKHR = extern "system" fn(device: VkDevice, pExecutableInfo: *const VkPipelineExecutableInfoKHR, pInternalRepresentationCount: *mut uint32_t, pInternalRepresentations: *mut VkPipelineExecutableInternalRepresentationKHR) -> VkResult;
/// The dummy function for `vkGetPipelineExecutablePropertiesKHR` from `VK_KHR_pipeline_executable_properties`
extern "system" fn dummy_vkGetPipelineExecutablePropertiesKHR(_: VkDevice, _: *const VkPipelineInfoKHR, _: *mut uint32_t, _: *mut VkPipelineExecutablePropertiesKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPipelineExecutablePropertiesKHR"))
}
/// trait for `VK_KHR_pipeline_executable_properties`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_pipeline_executable_properties.html>
pub trait VK_KHR_pipeline_executable_properties: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineExecutablePropertiesKHR.html>
	fn vkGetPipelineExecutablePropertiesKHR(&self, device: VkDevice, pPipelineInfo: *const VkPipelineInfoKHR, pExecutableCount: *mut uint32_t, pProperties: *mut VkPipelineExecutablePropertiesKHR) -> Result<()>;
}
/// struct for `VK_KHR_pipeline_executable_properties`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_pipeline_executable_properties {
	vk_get_pipeline_executable_properties_khr: PFN_vkGetPipelineExecutablePropertiesKHR,
}
impl VK_KHR_pipeline_executable_properties for Vulkan_KHR_pipeline_executable_properties {
	fn vkGetPipelineExecutablePropertiesKHR(&self, device: VkDevice, pPipelineInfo: *const VkPipelineInfoKHR, pExecutableCount: *mut uint32_t, pProperties: *mut VkPipelineExecutablePropertiesKHR) -> Result<()> {
		convert_result("vkGetPipelineExecutablePropertiesKHR", catch_unwind(||((self.vk_get_pipeline_executable_properties_khr)(device, pPipelineInfo, pExecutableCount, pProperties))))
	}
}
impl Default for Vulkan_KHR_pipeline_executable_properties {
	fn default() -> Self {
		Self {
			vk_get_pipeline_executable_properties_khr: dummy_vkGetPipelineExecutablePropertiesKHR,
		}
	}
}
impl Vulkan_KHR_pipeline_executable_properties {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_pipeline_executable_properties_khr: {let proc = get_instance_proc_address(instance, "vkGetPipelineExecutablePropertiesKHR"); if proc == null() {dummy_vkGetPipelineExecutablePropertiesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkMemoryUnmapFlagBitsKHR` from VK_KHR_map_memory2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryUnmapFlagBitsKHR.html>
pub type VkMemoryUnmapFlagBitsKHR = VkMemoryUnmapFlagBits;
/// type definition `VkMemoryUnmapFlagsKHR` from VK_KHR_map_memory2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryUnmapFlagsKHR.html>
pub type VkMemoryUnmapFlagsKHR = VkMemoryUnmapFlags;
/// type definition `VkMemoryMapInfoKHR` from VK_KHR_map_memory2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryMapInfoKHR.html>
pub type VkMemoryMapInfoKHR = VkMemoryMapInfo;
/// type definition `VkMemoryUnmapInfoKHR` from VK_KHR_map_memory2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryUnmapInfoKHR.html>
pub type VkMemoryUnmapInfoKHR = VkMemoryUnmapInfo;
/// function prototype `PFN_vkMapMemory2KHR` from VK_KHR_map_memory2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkMapMemory2KHR.html>
type PFN_vkMapMemory2KHR = extern "system" fn(device: VkDevice, pMemoryMapInfo: *const VkMemoryMapInfo, ppData: *mut *mut c_void) -> VkResult;
/// function prototype `PFN_vkUnmapMemory2KHR` from VK_KHR_map_memory2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkUnmapMemory2KHR.html>
type PFN_vkUnmapMemory2KHR = extern "system" fn(device: VkDevice, pMemoryUnmapInfo: *const VkMemoryUnmapInfo) -> VkResult;
/// The dummy function for `vkMapMemory2KHR` from `VK_KHR_map_memory2`
extern "system" fn dummy_vkMapMemory2KHR(_: VkDevice, _: *const VkMemoryMapInfo, _: *mut *mut c_void) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkMapMemory2KHR"))
}
/// trait for `VK_KHR_map_memory2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_map_memory2.html>
pub trait VK_KHR_map_memory2: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkMapMemory2KHR.html>
	fn vkMapMemory2KHR(&self, device: VkDevice, pMemoryMapInfo: *const VkMemoryMapInfo, ppData: *mut *mut c_void) -> Result<()>;
}
/// struct for `VK_KHR_map_memory2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_map_memory2 {
	vk_map_memory2_khr: PFN_vkMapMemory2KHR,
}
impl VK_KHR_map_memory2 for Vulkan_KHR_map_memory2 {
	fn vkMapMemory2KHR(&self, device: VkDevice, pMemoryMapInfo: *const VkMemoryMapInfo, ppData: *mut *mut c_void) -> Result<()> {
		convert_result("vkMapMemory2KHR", catch_unwind(||((self.vk_map_memory2_khr)(device, pMemoryMapInfo, ppData))))
	}
}
impl Default for Vulkan_KHR_map_memory2 {
	fn default() -> Self {
		Self {
			vk_map_memory2_khr: dummy_vkMapMemory2KHR,
		}
	}
}
impl Vulkan_KHR_map_memory2 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_map_memory2_khr: {let proc = get_instance_proc_address(instance, "vkMapMemory2KHR"); if proc == null() {dummy_vkMapMemory2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR` from VK_KHR_shader_integer_dot_product
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR.html>
pub type VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR = VkPhysicalDeviceShaderIntegerDotProductFeatures;
/// type definition `VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR` from VK_KHR_shader_integer_dot_product
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR.html>
pub type VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR = VkPhysicalDeviceShaderIntegerDotProductProperties;
/// trait for `VK_KHR_shader_integer_dot_product`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_integer_dot_product.html>
pub trait VK_KHR_shader_integer_dot_product: Debug {}
/// struct for `VK_KHR_shader_integer_dot_product`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_integer_dot_product {}
impl VK_KHR_shader_integer_dot_product for Vulkan_KHR_shader_integer_dot_product {}
impl Default for Vulkan_KHR_shader_integer_dot_product {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_integer_dot_product {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPipelineLibraryCreateInfoKHR` from VK_KHR_pipeline_library
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLibraryCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineLibraryCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub libraryCount: u32,
	pub pLibraries: *const VkPipeline,
}
impl Debug for VkPipelineLibraryCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineLibraryCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("libraryCount", &self.libraryCount)
		.field("pLibraries", &self.pLibraries)
		.finish()
	}
}
/// trait for `VK_KHR_pipeline_library`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_pipeline_library.html>
pub trait VK_KHR_pipeline_library: Debug {}
/// struct for `VK_KHR_pipeline_library`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_pipeline_library {}
impl VK_KHR_pipeline_library for Vulkan_KHR_pipeline_library {}
impl Default for Vulkan_KHR_pipeline_library {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_pipeline_library {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_KHR_shader_non_semantic_info`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_non_semantic_info.html>
pub trait VK_KHR_shader_non_semantic_info: Debug {}
/// struct for `VK_KHR_shader_non_semantic_info`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_non_semantic_info {}
impl VK_KHR_shader_non_semantic_info for Vulkan_KHR_shader_non_semantic_info {}
impl Default for Vulkan_KHR_shader_non_semantic_info {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_non_semantic_info {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPresentIdKHR` from VK_KHR_present_id
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentIdKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPresentIdKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount: u32,
	pub pPresentIds: *const uint64_t,
}
impl Debug for VkPresentIdKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPresentIdKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("swapchainCount", &self.swapchainCount)
		.field("pPresentIds", &self.pPresentIds)
		.finish()
	}
}
/// struct `VkPhysicalDevicePresentIdFeaturesKHR` from VK_KHR_present_id
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePresentIdFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePresentIdFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentId: VkBool32,
}
impl Debug for VkPhysicalDevicePresentIdFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePresentIdFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentId", &self.presentId)
		.finish()
	}
}
/// trait for `VK_KHR_present_id`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_present_id.html>
pub trait VK_KHR_present_id: Debug {}
/// struct for `VK_KHR_present_id`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_present_id {}
impl VK_KHR_present_id for Vulkan_KHR_present_id {}
impl Default for Vulkan_KHR_present_id {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_present_id {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkVideoEncodeFlagsKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeFlagsKHR.html>
pub type VkVideoEncodeFlagsKHR = VkFlags;
/// type definition `VkVideoEncodeCapabilityFlagsKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeCapabilityFlagsKHR.html>
pub type VkVideoEncodeCapabilityFlagsKHR = VkFlags;
/// type definition `VkVideoEncodeRateControlModeFlagsKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeRateControlModeFlagsKHR.html>
pub type VkVideoEncodeRateControlModeFlagsKHR = VkFlags;
/// type definition `VkVideoEncodeFeedbackFlagsKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeFeedbackFlagsKHR.html>
pub type VkVideoEncodeFeedbackFlagsKHR = VkFlags;
/// type definition `VkVideoEncodeUsageFlagsKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeUsageFlagsKHR.html>
pub type VkVideoEncodeUsageFlagsKHR = VkFlags;
/// type definition `VkVideoEncodeContentFlagsKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeContentFlagsKHR.html>
pub type VkVideoEncodeContentFlagsKHR = VkFlags;
/// type definition `VkVideoEncodeRateControlFlagsKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeRateControlFlagsKHR.html>
pub type VkVideoEncodeRateControlFlagsKHR = VkFlags;
/// enum `VkVideoEncodeTuningModeKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeTuningModeKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeTuningModeKHR {
	VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR = 1,
	VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR = 2,
	VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR = 3,
	VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR = 4,
	VK_VIDEO_ENCODE_TUNING_MODE_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeFlagBitsKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeFlagBitsKHR {
	VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeCapabilityFlagBitsKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeCapabilityFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeCapabilityFlagBitsKHR {
	VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeRateControlModeFlagBitsKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeRateControlModeFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeRateControlModeFlagBitsKHR {
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_RATE_CONTROL_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeFeedbackFlagBitsKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeFeedbackFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeFeedbackFlagBitsKHR {
	VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_FEEDBACK_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeUsageFlagBitsKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeUsageFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeUsageFlagBitsKHR {
	VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_USAGE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeContentFlagBitsKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeContentFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeContentFlagBitsKHR {
	VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR = 0,
	VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_CONTENT_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// struct `VkVideoEncodeInfoKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoEncodeFlagsKHR,
	pub dstBuffer: VkBuffer,
	pub dstBufferOffset: VkDeviceSize,
	pub dstBufferRange: VkDeviceSize,
	pub srcPictureResource: VkVideoPictureResourceInfoKHR,
	pub pSetupReferenceSlot: *const VkVideoReferenceSlotInfoKHR,
	pub referenceSlotCount: u32,
	pub pReferenceSlots: *const VkVideoReferenceSlotInfoKHR,
	pub precedingExternallyEncodedBytes: u32,
}
impl Debug for VkVideoEncodeInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("dstBuffer", &self.dstBuffer)
		.field("dstBufferOffset", &self.dstBufferOffset)
		.field("dstBufferRange", &self.dstBufferRange)
		.field("srcPictureResource", &self.srcPictureResource)
		.field("pSetupReferenceSlot", &self.pSetupReferenceSlot)
		.field("referenceSlotCount", &self.referenceSlotCount)
		.field("pReferenceSlots", &self.pReferenceSlots)
		.field("precedingExternallyEncodedBytes", &self.precedingExternallyEncodedBytes)
		.finish()
	}
}
/// struct `VkVideoEncodeCapabilitiesKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeCapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkVideoEncodeCapabilityFlagsKHR,
	pub rateControlModes: VkVideoEncodeRateControlModeFlagsKHR,
	pub maxRateControlLayers: u32,
	pub maxBitrate: u64,
	pub maxQualityLevels: u32,
	pub encodeInputPictureGranularity: VkExtent2D,
	pub supportedEncodeFeedbackFlags: VkVideoEncodeFeedbackFlagsKHR,
}
impl Debug for VkVideoEncodeCapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeCapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("rateControlModes", &self.rateControlModes)
		.field("maxRateControlLayers", &self.maxRateControlLayers)
		.field("maxBitrate", &self.maxBitrate)
		.field("maxQualityLevels", &self.maxQualityLevels)
		.field("encodeInputPictureGranularity", &self.encodeInputPictureGranularity)
		.field("supportedEncodeFeedbackFlags", &self.supportedEncodeFeedbackFlags)
		.finish()
	}
}
/// struct `VkQueryPoolVideoEncodeFeedbackCreateInfoKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryPoolVideoEncodeFeedbackCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkQueryPoolVideoEncodeFeedbackCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub encodeFeedbackFlags: VkVideoEncodeFeedbackFlagsKHR,
}
impl Debug for VkQueryPoolVideoEncodeFeedbackCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkQueryPoolVideoEncodeFeedbackCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("encodeFeedbackFlags", &self.encodeFeedbackFlags)
		.finish()
	}
}
/// struct `VkVideoEncodeUsageInfoKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeUsageInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeUsageInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub videoUsageHints: VkVideoEncodeUsageFlagsKHR,
	pub videoContentHints: VkVideoEncodeContentFlagsKHR,
	pub tuningMode: VkVideoEncodeTuningModeKHR,
}
impl Debug for VkVideoEncodeUsageInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeUsageInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("videoUsageHints", &self.videoUsageHints)
		.field("videoContentHints", &self.videoContentHints)
		.field("tuningMode", &self.tuningMode)
		.finish()
	}
}
/// struct `VkVideoEncodeRateControlLayerInfoKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeRateControlLayerInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeRateControlLayerInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub averageBitrate: u64,
	pub maxBitrate: u64,
	pub frameRateNumerator: u32,
	pub frameRateDenominator: u32,
}
impl Debug for VkVideoEncodeRateControlLayerInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeRateControlLayerInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("averageBitrate", &self.averageBitrate)
		.field("maxBitrate", &self.maxBitrate)
		.field("frameRateNumerator", &self.frameRateNumerator)
		.field("frameRateDenominator", &self.frameRateDenominator)
		.finish()
	}
}
/// struct `VkVideoEncodeRateControlInfoKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeRateControlInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeRateControlInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoEncodeRateControlFlagsKHR,
	pub rateControlMode: VkVideoEncodeRateControlModeFlagBitsKHR,
	pub layerCount: u32,
	pub pLayers: *const VkVideoEncodeRateControlLayerInfoKHR,
	pub virtualBufferSizeInMs: u32,
	pub initialVirtualBufferSizeInMs: u32,
}
impl Debug for VkVideoEncodeRateControlInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeRateControlInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("rateControlMode", &self.rateControlMode)
		.field("layerCount", &self.layerCount)
		.field("pLayers", &self.pLayers)
		.field("virtualBufferSizeInMs", &self.virtualBufferSizeInMs)
		.field("initialVirtualBufferSizeInMs", &self.initialVirtualBufferSizeInMs)
		.finish()
	}
}
/// struct `VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pVideoProfile: *const VkVideoProfileInfoKHR,
	pub qualityLevel: u32,
}
impl Debug for VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pVideoProfile", &self.pVideoProfile)
		.field("qualityLevel", &self.qualityLevel)
		.finish()
	}
}
/// struct `VkVideoEncodeQualityLevelPropertiesKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeQualityLevelPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeQualityLevelPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub preferredRateControlMode: VkVideoEncodeRateControlModeFlagBitsKHR,
	pub preferredRateControlLayerCount: u32,
}
impl Debug for VkVideoEncodeQualityLevelPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeQualityLevelPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("preferredRateControlMode", &self.preferredRateControlMode)
		.field("preferredRateControlLayerCount", &self.preferredRateControlLayerCount)
		.finish()
	}
}
/// struct `VkVideoEncodeQualityLevelInfoKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeQualityLevelInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeQualityLevelInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub qualityLevel: u32,
}
impl Debug for VkVideoEncodeQualityLevelInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeQualityLevelInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("qualityLevel", &self.qualityLevel)
		.finish()
	}
}
/// struct `VkVideoEncodeSessionParametersGetInfoKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeSessionParametersGetInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeSessionParametersGetInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub videoSessionParameters: VkVideoSessionParametersKHR,
}
impl Debug for VkVideoEncodeSessionParametersGetInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeSessionParametersGetInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("videoSessionParameters", &self.videoSessionParameters)
		.finish()
	}
}
/// struct `VkVideoEncodeSessionParametersFeedbackInfoKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeSessionParametersFeedbackInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeSessionParametersFeedbackInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub hasOverrides: VkBool32,
}
impl Debug for VkVideoEncodeSessionParametersFeedbackInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeSessionParametersFeedbackInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("hasOverrides", &self.hasOverrides)
		.finish()
	}
}
/// function prototype `PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR.html>
type PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pQualityLevelInfo: *const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, pQualityLevelProperties: *mut VkVideoEncodeQualityLevelPropertiesKHR) -> VkResult;
/// function prototype `PFN_vkGetEncodedVideoSessionParametersKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetEncodedVideoSessionParametersKHR.html>
type PFN_vkGetEncodedVideoSessionParametersKHR = extern "system" fn(device: VkDevice, pVideoSessionParametersInfo: *const VkVideoEncodeSessionParametersGetInfoKHR, pFeedbackInfo: *mut VkVideoEncodeSessionParametersFeedbackInfoKHR, pDataSize: *mut size_t, pData: *mut c_void) -> VkResult;
/// function prototype `PFN_vkCmdEncodeVideoKHR` from VK_KHR_video_encode_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEncodeVideoKHR.html>
type PFN_vkCmdEncodeVideoKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pEncodeInfo: *const VkVideoEncodeInfoKHR);
/// The dummy function for `vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR` from `VK_KHR_video_encode_queue`
extern "system" fn dummy_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(_: VkPhysicalDevice, _: *const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, _: *mut VkVideoEncodeQualityLevelPropertiesKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR"))
}
/// trait for `VK_KHR_video_encode_queue`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_video_encode_queue.html>
pub trait VK_KHR_video_encode_queue: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR.html>
	fn vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pQualityLevelInfo: *const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, pQualityLevelProperties: *mut VkVideoEncodeQualityLevelPropertiesKHR) -> Result<()>;
}
/// struct for `VK_KHR_video_encode_queue`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_encode_queue {
	vk_get_physical_device_video_encode_quality_level_properties_khr: PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR,
}
impl VK_KHR_video_encode_queue for Vulkan_KHR_video_encode_queue {
	fn vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pQualityLevelInfo: *const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, pQualityLevelProperties: *mut VkVideoEncodeQualityLevelPropertiesKHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR", catch_unwind(||((self.vk_get_physical_device_video_encode_quality_level_properties_khr)(physicalDevice, pQualityLevelInfo, pQualityLevelProperties))))
	}
}
impl Default for Vulkan_KHR_video_encode_queue {
	fn default() -> Self {
		Self {
			vk_get_physical_device_video_encode_quality_level_properties_khr: dummy_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR,
		}
	}
}
impl Vulkan_KHR_video_encode_queue {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_video_encode_quality_level_properties_khr: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR"); if proc == null() {dummy_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPipelineStageFlags2KHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineStageFlags2KHR.html>
pub type VkPipelineStageFlags2KHR = VkPipelineStageFlags2;
/// type definition `VkPipelineStageFlagBits2KHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineStageFlagBits2KHR.html>
pub type VkPipelineStageFlagBits2KHR = VkPipelineStageFlagBits2;
/// type definition `VkAccessFlags2KHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccessFlags2KHR.html>
pub type VkAccessFlags2KHR = VkAccessFlags2;
/// type definition `VkAccessFlagBits2KHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccessFlagBits2KHR.html>
pub type VkAccessFlagBits2KHR = VkAccessFlagBits2;
/// type definition `VkSubmitFlagBitsKHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubmitFlagBitsKHR.html>
pub type VkSubmitFlagBitsKHR = VkSubmitFlagBits;
/// type definition `VkSubmitFlagsKHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubmitFlagsKHR.html>
pub type VkSubmitFlagsKHR = VkSubmitFlags;
/// type definition `VkMemoryBarrier2KHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryBarrier2KHR.html>
pub type VkMemoryBarrier2KHR = VkMemoryBarrier2;
/// type definition `VkBufferMemoryBarrier2KHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferMemoryBarrier2KHR.html>
pub type VkBufferMemoryBarrier2KHR = VkBufferMemoryBarrier2;
/// type definition `VkImageMemoryBarrier2KHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageMemoryBarrier2KHR.html>
pub type VkImageMemoryBarrier2KHR = VkImageMemoryBarrier2;
/// type definition `VkDependencyInfoKHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDependencyInfoKHR.html>
pub type VkDependencyInfoKHR = VkDependencyInfo;
/// type definition `VkSubmitInfo2KHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubmitInfo2KHR.html>
pub type VkSubmitInfo2KHR = VkSubmitInfo2;
/// type definition `VkSemaphoreSubmitInfoKHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphoreSubmitInfoKHR.html>
pub type VkSemaphoreSubmitInfoKHR = VkSemaphoreSubmitInfo;
/// type definition `VkCommandBufferSubmitInfoKHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferSubmitInfoKHR.html>
pub type VkCommandBufferSubmitInfoKHR = VkCommandBufferSubmitInfo;
/// type definition `VkPhysicalDeviceSynchronization2FeaturesKHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSynchronization2FeaturesKHR.html>
pub type VkPhysicalDeviceSynchronization2FeaturesKHR = VkPhysicalDeviceSynchronization2Features;
/// function prototype `PFN_vkCmdSetEvent2KHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetEvent2KHR.html>
type PFN_vkCmdSetEvent2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *const VkDependencyInfo);
/// function prototype `PFN_vkCmdResetEvent2KHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResetEvent2KHR.html>
type PFN_vkCmdResetEvent2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2);
/// function prototype `PFN_vkCmdWaitEvents2KHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWaitEvents2KHR.html>
type PFN_vkCmdWaitEvents2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, pDependencyInfos: *const VkDependencyInfo);
/// function prototype `PFN_vkCmdPipelineBarrier2KHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPipelineBarrier2KHR.html>
type PFN_vkCmdPipelineBarrier2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pDependencyInfo: *const VkDependencyInfo);
/// function prototype `PFN_vkCmdWriteTimestamp2KHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteTimestamp2KHR.html>
type PFN_vkCmdWriteTimestamp2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: u32);
/// function prototype `PFN_vkQueueSubmit2KHR` from VK_KHR_synchronization2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueSubmit2KHR.html>
type PFN_vkQueueSubmit2KHR = extern "system" fn(queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo2, fence: VkFence) -> VkResult;
/// The dummy function for `vkCmdSetEvent2KHR` from `VK_KHR_synchronization2`
extern "system" fn dummy_vkCmdSetEvent2KHR(_: VkCommandBuffer, _: VkEvent, _: *const VkDependencyInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetEvent2KHR"))
}
/// trait for `VK_KHR_synchronization2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_synchronization2.html>
pub trait VK_KHR_synchronization2: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetEvent2KHR.html>
	fn vkCmdSetEvent2KHR(&self, commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *const VkDependencyInfo) -> Result<()>;
}
/// struct for `VK_KHR_synchronization2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_synchronization2 {
	vk_cmd_set_event2_khr: PFN_vkCmdSetEvent2KHR,
}
impl VK_KHR_synchronization2 for Vulkan_KHR_synchronization2 {
	fn vkCmdSetEvent2KHR(&self, commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *const VkDependencyInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_event2_khr)(commandBuffer, event, pDependencyInfo))))
	}
}
impl Default for Vulkan_KHR_synchronization2 {
	fn default() -> Self {
		Self {
			vk_cmd_set_event2_khr: dummy_vkCmdSetEvent2KHR,
		}
	}
}
impl Vulkan_KHR_synchronization2 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_event2_khr: {let proc = get_instance_proc_address(instance, "vkCmdSetEvent2KHR"); if proc == null() {dummy_vkCmdSetEvent2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR` from VK_KHR_fragment_shader_barycentric
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub fragmentShaderBarycentric: VkBool32,
}
impl Debug for VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("fragmentShaderBarycentric", &self.fragmentShaderBarycentric)
		.finish()
	}
}
/// struct `VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR` from VK_KHR_fragment_shader_barycentric
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub triStripVertexOrderIndependentOfProvokingVertex: VkBool32,
}
impl Debug for VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("triStripVertexOrderIndependentOfProvokingVertex", &self.triStripVertexOrderIndependentOfProvokingVertex)
		.finish()
	}
}
/// trait for `VK_KHR_fragment_shader_barycentric`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_fragment_shader_barycentric.html>
pub trait VK_KHR_fragment_shader_barycentric: Debug {}
/// struct for `VK_KHR_fragment_shader_barycentric`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_fragment_shader_barycentric {}
impl VK_KHR_fragment_shader_barycentric for Vulkan_KHR_fragment_shader_barycentric {}
impl Default for Vulkan_KHR_fragment_shader_barycentric {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_fragment_shader_barycentric {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR` from VK_KHR_shader_subgroup_uniform_control_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderSubgroupUniformControlFlow: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderSubgroupUniformControlFlow", &self.shaderSubgroupUniformControlFlow)
		.finish()
	}
}
/// trait for `VK_KHR_shader_subgroup_uniform_control_flow`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_subgroup_uniform_control_flow.html>
pub trait VK_KHR_shader_subgroup_uniform_control_flow: Debug {}
/// struct for `VK_KHR_shader_subgroup_uniform_control_flow`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_subgroup_uniform_control_flow {}
impl VK_KHR_shader_subgroup_uniform_control_flow for Vulkan_KHR_shader_subgroup_uniform_control_flow {}
impl Default for Vulkan_KHR_shader_subgroup_uniform_control_flow {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_subgroup_uniform_control_flow {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR` from VK_KHR_zero_initialize_workgroup_memory
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR.html>
pub type VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
/// trait for `VK_KHR_zero_initialize_workgroup_memory`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_zero_initialize_workgroup_memory.html>
pub trait VK_KHR_zero_initialize_workgroup_memory: Debug {}
/// struct for `VK_KHR_zero_initialize_workgroup_memory`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_zero_initialize_workgroup_memory {}
impl VK_KHR_zero_initialize_workgroup_memory for Vulkan_KHR_zero_initialize_workgroup_memory {}
impl Default for Vulkan_KHR_zero_initialize_workgroup_memory {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_zero_initialize_workgroup_memory {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR` from VK_KHR_workgroup_memory_explicit_layout
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub workgroupMemoryExplicitLayout: VkBool32,
	pub workgroupMemoryExplicitLayoutScalarBlockLayout: VkBool32,
	pub workgroupMemoryExplicitLayout8BitAccess: VkBool32,
	pub workgroupMemoryExplicitLayout16BitAccess: VkBool32,
}
impl Debug for VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("workgroupMemoryExplicitLayout", &self.workgroupMemoryExplicitLayout)
		.field("workgroupMemoryExplicitLayoutScalarBlockLayout", &self.workgroupMemoryExplicitLayoutScalarBlockLayout)
		.field("workgroupMemoryExplicitLayout8BitAccess", &self.workgroupMemoryExplicitLayout8BitAccess)
		.field("workgroupMemoryExplicitLayout16BitAccess", &self.workgroupMemoryExplicitLayout16BitAccess)
		.finish()
	}
}
/// trait for `VK_KHR_workgroup_memory_explicit_layout`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_workgroup_memory_explicit_layout.html>
pub trait VK_KHR_workgroup_memory_explicit_layout: Debug {}
/// struct for `VK_KHR_workgroup_memory_explicit_layout`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_workgroup_memory_explicit_layout {}
impl VK_KHR_workgroup_memory_explicit_layout for Vulkan_KHR_workgroup_memory_explicit_layout {}
impl Default for Vulkan_KHR_workgroup_memory_explicit_layout {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_workgroup_memory_explicit_layout {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkCopyBufferInfo2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyBufferInfo2KHR.html>
pub type VkCopyBufferInfo2KHR = VkCopyBufferInfo2;
/// type definition `VkCopyImageInfo2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyImageInfo2KHR.html>
pub type VkCopyImageInfo2KHR = VkCopyImageInfo2;
/// type definition `VkCopyBufferToImageInfo2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyBufferToImageInfo2KHR.html>
pub type VkCopyBufferToImageInfo2KHR = VkCopyBufferToImageInfo2;
/// type definition `VkCopyImageToBufferInfo2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyImageToBufferInfo2KHR.html>
pub type VkCopyImageToBufferInfo2KHR = VkCopyImageToBufferInfo2;
/// type definition `VkBlitImageInfo2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBlitImageInfo2KHR.html>
pub type VkBlitImageInfo2KHR = VkBlitImageInfo2;
/// type definition `VkResolveImageInfo2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkResolveImageInfo2KHR.html>
pub type VkResolveImageInfo2KHR = VkResolveImageInfo2;
/// type definition `VkBufferCopy2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferCopy2KHR.html>
pub type VkBufferCopy2KHR = VkBufferCopy2;
/// type definition `VkImageCopy2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCopy2KHR.html>
pub type VkImageCopy2KHR = VkImageCopy2;
/// type definition `VkImageBlit2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageBlit2KHR.html>
pub type VkImageBlit2KHR = VkImageBlit2;
/// type definition `VkBufferImageCopy2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferImageCopy2KHR.html>
pub type VkBufferImageCopy2KHR = VkBufferImageCopy2;
/// type definition `VkImageResolve2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageResolve2KHR.html>
pub type VkImageResolve2KHR = VkImageResolve2;
/// function prototype `PFN_vkCmdCopyBuffer2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBuffer2KHR.html>
type PFN_vkCmdCopyBuffer2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2);
/// function prototype `PFN_vkCmdCopyImage2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImage2KHR.html>
type PFN_vkCmdCopyImage2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyImageInfo: *const VkCopyImageInfo2);
/// function prototype `PFN_vkCmdCopyBufferToImage2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage2KHR.html>
type PFN_vkCmdCopyBufferToImage2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: *const VkCopyBufferToImageInfo2);
/// function prototype `PFN_vkCmdCopyImageToBuffer2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer2KHR.html>
type PFN_vkCmdCopyImageToBuffer2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: *const VkCopyImageToBufferInfo2);
/// function prototype `PFN_vkCmdBlitImage2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage2KHR.html>
type PFN_vkCmdBlitImage2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pBlitImageInfo: *const VkBlitImageInfo2);
/// function prototype `PFN_vkCmdResolveImage2KHR` from VK_KHR_copy_commands2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResolveImage2KHR.html>
type PFN_vkCmdResolveImage2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pResolveImageInfo: *const VkResolveImageInfo2);
/// The dummy function for `vkCmdCopyBuffer2KHR` from `VK_KHR_copy_commands2`
extern "system" fn dummy_vkCmdCopyBuffer2KHR(_: VkCommandBuffer, _: *const VkCopyBufferInfo2) {
	panic_any(VkError::NullFunctionPointer("vkCmdCopyBuffer2KHR"))
}
/// trait for `VK_KHR_copy_commands2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_copy_commands2.html>
pub trait VK_KHR_copy_commands2: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBuffer2KHR.html>
	fn vkCmdCopyBuffer2KHR(&self, commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2) -> Result<()>;
}
/// struct for `VK_KHR_copy_commands2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_copy_commands2 {
	vk_cmd_copy_buffer2_khr: PFN_vkCmdCopyBuffer2KHR,
}
impl VK_KHR_copy_commands2 for Vulkan_KHR_copy_commands2 {
	fn vkCmdCopyBuffer2KHR(&self, commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_copy_buffer2_khr)(commandBuffer, pCopyBufferInfo))))
	}
}
impl Default for Vulkan_KHR_copy_commands2 {
	fn default() -> Self {
		Self {
			vk_cmd_copy_buffer2_khr: dummy_vkCmdCopyBuffer2KHR,
		}
	}
}
impl Vulkan_KHR_copy_commands2 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_copy_buffer2_khr: {let proc = get_instance_proc_address(instance, "vkCmdCopyBuffer2KHR"); if proc == null() {dummy_vkCmdCopyBuffer2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkFormatFeatureFlags2KHR` from VK_KHR_format_feature_flags2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormatFeatureFlags2KHR.html>
pub type VkFormatFeatureFlags2KHR = VkFormatFeatureFlags2;
/// type definition `VkFormatFeatureFlagBits2KHR` from VK_KHR_format_feature_flags2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormatFeatureFlagBits2KHR.html>
pub type VkFormatFeatureFlagBits2KHR = VkFormatFeatureFlagBits2;
/// type definition `VkFormatProperties3KHR` from VK_KHR_format_feature_flags2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFormatProperties3KHR.html>
pub type VkFormatProperties3KHR = VkFormatProperties3;
/// trait for `VK_KHR_format_feature_flags2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_format_feature_flags2.html>
pub trait VK_KHR_format_feature_flags2: Debug {}
/// struct for `VK_KHR_format_feature_flags2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_format_feature_flags2 {}
impl VK_KHR_format_feature_flags2 for Vulkan_KHR_format_feature_flags2 {}
impl Default for Vulkan_KHR_format_feature_flags2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_format_feature_flags2 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR` from VK_KHR_ray_tracing_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rayTracingMaintenance1: VkBool32,
	pub rayTracingPipelineTraceRaysIndirect2: VkBool32,
}
impl Debug for VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("rayTracingMaintenance1", &self.rayTracingMaintenance1)
		.field("rayTracingPipelineTraceRaysIndirect2", &self.rayTracingPipelineTraceRaysIndirect2)
		.finish()
	}
}
/// struct `VkTraceRaysIndirectCommand2KHR` from VK_KHR_ray_tracing_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTraceRaysIndirectCommand2KHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTraceRaysIndirectCommand2KHR {
	pub raygenShaderRecordAddress: VkDeviceAddress,
	pub raygenShaderRecordSize: VkDeviceSize,
	pub missShaderBindingTableAddress: VkDeviceAddress,
	pub missShaderBindingTableSize: VkDeviceSize,
	pub missShaderBindingTableStride: VkDeviceSize,
	pub hitShaderBindingTableAddress: VkDeviceAddress,
	pub hitShaderBindingTableSize: VkDeviceSize,
	pub hitShaderBindingTableStride: VkDeviceSize,
	pub callableShaderBindingTableAddress: VkDeviceAddress,
	pub callableShaderBindingTableSize: VkDeviceSize,
	pub callableShaderBindingTableStride: VkDeviceSize,
	pub width: u32,
	pub height: u32,
	pub depth: u32,
}
impl Debug for VkTraceRaysIndirectCommand2KHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTraceRaysIndirectCommand2KHR")
		.field("raygenShaderRecordAddress", &self.raygenShaderRecordAddress)
		.field("raygenShaderRecordSize", &self.raygenShaderRecordSize)
		.field("missShaderBindingTableAddress", &self.missShaderBindingTableAddress)
		.field("missShaderBindingTableSize", &self.missShaderBindingTableSize)
		.field("missShaderBindingTableStride", &self.missShaderBindingTableStride)
		.field("hitShaderBindingTableAddress", &self.hitShaderBindingTableAddress)
		.field("hitShaderBindingTableSize", &self.hitShaderBindingTableSize)
		.field("hitShaderBindingTableStride", &self.hitShaderBindingTableStride)
		.field("callableShaderBindingTableAddress", &self.callableShaderBindingTableAddress)
		.field("callableShaderBindingTableSize", &self.callableShaderBindingTableSize)
		.field("callableShaderBindingTableStride", &self.callableShaderBindingTableStride)
		.field("width", &self.width)
		.field("height", &self.height)
		.field("depth", &self.depth)
		.finish()
	}
}
/// function prototype `PFN_vkCmdTraceRaysIndirect2KHR` from VK_KHR_ray_tracing_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdTraceRaysIndirect2KHR.html>
type PFN_vkCmdTraceRaysIndirect2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, indirectDeviceAddress: VkDeviceAddress);
/// The dummy function for `vkCmdTraceRaysIndirect2KHR` from `VK_KHR_ray_tracing_maintenance1`
extern "system" fn dummy_vkCmdTraceRaysIndirect2KHR(_: VkCommandBuffer, _: VkDeviceAddress) {
	panic_any(VkError::NullFunctionPointer("vkCmdTraceRaysIndirect2KHR"))
}
/// trait for `VK_KHR_ray_tracing_maintenance1`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_ray_tracing_maintenance1.html>
pub trait VK_KHR_ray_tracing_maintenance1: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdTraceRaysIndirect2KHR.html>
	fn vkCmdTraceRaysIndirect2KHR(&self, commandBuffer: VkCommandBuffer, indirectDeviceAddress: VkDeviceAddress) -> Result<()>;
}
/// struct for `VK_KHR_ray_tracing_maintenance1`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_ray_tracing_maintenance1 {
	vk_cmd_trace_rays_indirect2_khr: PFN_vkCmdTraceRaysIndirect2KHR,
}
impl VK_KHR_ray_tracing_maintenance1 for Vulkan_KHR_ray_tracing_maintenance1 {
	fn vkCmdTraceRaysIndirect2KHR(&self, commandBuffer: VkCommandBuffer, indirectDeviceAddress: VkDeviceAddress) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_trace_rays_indirect2_khr)(commandBuffer, indirectDeviceAddress))))
	}
}
impl Default for Vulkan_KHR_ray_tracing_maintenance1 {
	fn default() -> Self {
		Self {
			vk_cmd_trace_rays_indirect2_khr: dummy_vkCmdTraceRaysIndirect2KHR,
		}
	}
}
impl Vulkan_KHR_ray_tracing_maintenance1 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_trace_rays_indirect2_khr: {let proc = get_instance_proc_address(instance, "vkCmdTraceRaysIndirect2KHR"); if proc == null() {dummy_vkCmdTraceRaysIndirect2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// trait for `VK_KHR_portability_enumeration`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_portability_enumeration.html>
pub trait VK_KHR_portability_enumeration: Debug {}
/// struct for `VK_KHR_portability_enumeration`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_portability_enumeration {}
impl VK_KHR_portability_enumeration for Vulkan_KHR_portability_enumeration {}
impl Default for Vulkan_KHR_portability_enumeration {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_portability_enumeration {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceMaintenance4FeaturesKHR` from VK_KHR_maintenance4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance4FeaturesKHR.html>
pub type VkPhysicalDeviceMaintenance4FeaturesKHR = VkPhysicalDeviceMaintenance4Features;
/// type definition `VkPhysicalDeviceMaintenance4PropertiesKHR` from VK_KHR_maintenance4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance4PropertiesKHR.html>
pub type VkPhysicalDeviceMaintenance4PropertiesKHR = VkPhysicalDeviceMaintenance4Properties;
/// type definition `VkDeviceBufferMemoryRequirementsKHR` from VK_KHR_maintenance4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceBufferMemoryRequirementsKHR.html>
pub type VkDeviceBufferMemoryRequirementsKHR = VkDeviceBufferMemoryRequirements;
/// type definition `VkDeviceImageMemoryRequirementsKHR` from VK_KHR_maintenance4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceImageMemoryRequirementsKHR.html>
pub type VkDeviceImageMemoryRequirementsKHR = VkDeviceImageMemoryRequirements;
/// function prototype `PFN_vkGetDeviceBufferMemoryRequirementsKHR` from VK_KHR_maintenance4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceBufferMemoryRequirementsKHR.html>
type PFN_vkGetDeviceBufferMemoryRequirementsKHR = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceBufferMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2);
/// function prototype `PFN_vkGetDeviceImageMemoryRequirementsKHR` from VK_KHR_maintenance4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageMemoryRequirementsKHR.html>
type PFN_vkGetDeviceImageMemoryRequirementsKHR = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2);
/// function prototype `PFN_vkGetDeviceImageSparseMemoryRequirementsKHR` from VK_KHR_maintenance4
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSparseMemoryRequirementsKHR.html>
type PFN_vkGetDeviceImageSparseMemoryRequirementsKHR = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2);
/// The dummy function for `vkGetDeviceBufferMemoryRequirementsKHR` from `VK_KHR_maintenance4`
extern "system" fn dummy_vkGetDeviceBufferMemoryRequirementsKHR(_: VkDevice, _: *const VkDeviceBufferMemoryRequirements, _: *mut VkMemoryRequirements2) {
	panic_any(VkError::NullFunctionPointer("vkGetDeviceBufferMemoryRequirementsKHR"))
}
/// trait for `VK_KHR_maintenance4`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_maintenance4.html>
pub trait VK_KHR_maintenance4: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceBufferMemoryRequirementsKHR.html>
	fn vkGetDeviceBufferMemoryRequirementsKHR(&self, device: VkDevice, pInfo: *const VkDeviceBufferMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()>;
}
/// struct for `VK_KHR_maintenance4`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance4 {
	vk_get_device_buffer_memory_requirements_khr: PFN_vkGetDeviceBufferMemoryRequirementsKHR,
}
impl VK_KHR_maintenance4 for Vulkan_KHR_maintenance4 {
	fn vkGetDeviceBufferMemoryRequirementsKHR(&self, device: VkDevice, pInfo: *const VkDeviceBufferMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_device_buffer_memory_requirements_khr)(device, pInfo, pMemoryRequirements))))
	}
}
impl Default for Vulkan_KHR_maintenance4 {
	fn default() -> Self {
		Self {
			vk_get_device_buffer_memory_requirements_khr: dummy_vkGetDeviceBufferMemoryRequirementsKHR,
		}
	}
}
impl Vulkan_KHR_maintenance4 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_device_buffer_memory_requirements_khr: {let proc = get_instance_proc_address(instance, "vkGetDeviceBufferMemoryRequirementsKHR"); if proc == null() {dummy_vkGetDeviceBufferMemoryRequirementsKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR` from VK_KHR_shader_subgroup_rotate
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR.html>
pub type VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR = VkPhysicalDeviceShaderSubgroupRotateFeatures;
/// trait for `VK_KHR_shader_subgroup_rotate`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_subgroup_rotate.html>
pub trait VK_KHR_shader_subgroup_rotate: Debug {}
/// struct for `VK_KHR_shader_subgroup_rotate`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_subgroup_rotate {}
impl VK_KHR_shader_subgroup_rotate for Vulkan_KHR_shader_subgroup_rotate {}
impl Default for Vulkan_KHR_shader_subgroup_rotate {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_subgroup_rotate {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR` from VK_KHR_shader_maximal_reconvergence
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderMaximalReconvergence: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderMaximalReconvergence", &self.shaderMaximalReconvergence)
		.finish()
	}
}
/// trait for `VK_KHR_shader_maximal_reconvergence`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_maximal_reconvergence.html>
pub trait VK_KHR_shader_maximal_reconvergence: Debug {}
/// struct for `VK_KHR_shader_maximal_reconvergence`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_maximal_reconvergence {}
impl VK_KHR_shader_maximal_reconvergence for Vulkan_KHR_shader_maximal_reconvergence {}
impl Default for Vulkan_KHR_shader_maximal_reconvergence {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_maximal_reconvergence {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPipelineCreateFlags2KHR` from VK_KHR_maintenance5
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreateFlags2KHR.html>
pub type VkPipelineCreateFlags2KHR = VkPipelineCreateFlags2;
/// type definition `VkPipelineCreateFlagBits2KHR` from VK_KHR_maintenance5
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreateFlagBits2KHR.html>
pub type VkPipelineCreateFlagBits2KHR = VkPipelineCreateFlagBits2;
/// type definition `VkBufferUsageFlags2KHR` from VK_KHR_maintenance5
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferUsageFlags2KHR.html>
pub type VkBufferUsageFlags2KHR = VkBufferUsageFlags2;
/// type definition `VkBufferUsageFlagBits2KHR` from VK_KHR_maintenance5
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferUsageFlagBits2KHR.html>
pub type VkBufferUsageFlagBits2KHR = VkBufferUsageFlagBits2;
/// type definition `VkPhysicalDeviceMaintenance5FeaturesKHR` from VK_KHR_maintenance5
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance5FeaturesKHR.html>
pub type VkPhysicalDeviceMaintenance5FeaturesKHR = VkPhysicalDeviceMaintenance5Features;
/// type definition `VkPhysicalDeviceMaintenance5PropertiesKHR` from VK_KHR_maintenance5
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance5PropertiesKHR.html>
pub type VkPhysicalDeviceMaintenance5PropertiesKHR = VkPhysicalDeviceMaintenance5Properties;
/// type definition `VkRenderingAreaInfoKHR` from VK_KHR_maintenance5
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingAreaInfoKHR.html>
pub type VkRenderingAreaInfoKHR = VkRenderingAreaInfo;
/// type definition `VkDeviceImageSubresourceInfoKHR` from VK_KHR_maintenance5
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceImageSubresourceInfoKHR.html>
pub type VkDeviceImageSubresourceInfoKHR = VkDeviceImageSubresourceInfo;
/// type definition `VkImageSubresource2KHR` from VK_KHR_maintenance5
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageSubresource2KHR.html>
pub type VkImageSubresource2KHR = VkImageSubresource2;
/// type definition `VkSubresourceLayout2KHR` from VK_KHR_maintenance5
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubresourceLayout2KHR.html>
pub type VkSubresourceLayout2KHR = VkSubresourceLayout2;
/// type definition `VkPipelineCreateFlags2CreateInfoKHR` from VK_KHR_maintenance5
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreateFlags2CreateInfoKHR.html>
pub type VkPipelineCreateFlags2CreateInfoKHR = VkPipelineCreateFlags2CreateInfo;
/// type definition `VkBufferUsageFlags2CreateInfoKHR` from VK_KHR_maintenance5
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferUsageFlags2CreateInfoKHR.html>
pub type VkBufferUsageFlags2CreateInfoKHR = VkBufferUsageFlags2CreateInfo;
/// function prototype `PFN_vkCmdBindIndexBuffer2KHR` from VK_KHR_maintenance5
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindIndexBuffer2KHR.html>
type PFN_vkCmdBindIndexBuffer2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType);
/// function prototype `PFN_vkGetRenderingAreaGranularityKHR` from VK_KHR_maintenance5
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRenderingAreaGranularityKHR.html>
type PFN_vkGetRenderingAreaGranularityKHR = extern "system" fn(device: VkDevice, pRenderingAreaInfo: *const VkRenderingAreaInfo, pGranularity: *mut VkExtent2D);
/// function prototype `PFN_vkGetDeviceImageSubresourceLayoutKHR` from VK_KHR_maintenance5
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSubresourceLayoutKHR.html>
type PFN_vkGetDeviceImageSubresourceLayoutKHR = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceImageSubresourceInfo, pLayout: *mut VkSubresourceLayout2);
/// function prototype `PFN_vkGetImageSubresourceLayout2KHR` from VK_KHR_maintenance5
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout2KHR.html>
type PFN_vkGetImageSubresourceLayout2KHR = extern "system" fn(device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource2, pLayout: *mut VkSubresourceLayout2);
/// The dummy function for `vkCmdBindIndexBuffer2KHR` from `VK_KHR_maintenance5`
extern "system" fn dummy_vkCmdBindIndexBuffer2KHR(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkDeviceSize, _: VkIndexType) {
	panic_any(VkError::NullFunctionPointer("vkCmdBindIndexBuffer2KHR"))
}
/// trait for `VK_KHR_maintenance5`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_maintenance5.html>
pub trait VK_KHR_maintenance5: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindIndexBuffer2KHR.html>
	fn vkCmdBindIndexBuffer2KHR(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType) -> Result<()>;
}
/// struct for `VK_KHR_maintenance5`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance5 {
	vk_cmd_bind_index_buffer2_khr: PFN_vkCmdBindIndexBuffer2KHR,
}
impl VK_KHR_maintenance5 for Vulkan_KHR_maintenance5 {
	fn vkCmdBindIndexBuffer2KHR(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_bind_index_buffer2_khr)(commandBuffer, buffer, offset, size, indexType))))
	}
}
impl Default for Vulkan_KHR_maintenance5 {
	fn default() -> Self {
		Self {
			vk_cmd_bind_index_buffer2_khr: dummy_vkCmdBindIndexBuffer2KHR,
		}
	}
}
impl Vulkan_KHR_maintenance5 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_bind_index_buffer2_khr: {let proc = get_instance_proc_address(instance, "vkCmdBindIndexBuffer2KHR"); if proc == null() {dummy_vkCmdBindIndexBuffer2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkSurfaceCapabilitiesPresentId2KHR` from VK_KHR_present_id2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfaceCapabilitiesPresentId2KHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSurfaceCapabilitiesPresentId2KHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentId2Supported: VkBool32,
}
impl Debug for VkSurfaceCapabilitiesPresentId2KHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSurfaceCapabilitiesPresentId2KHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentId2Supported", &self.presentId2Supported)
		.finish()
	}
}
/// struct `VkPresentId2KHR` from VK_KHR_present_id2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentId2KHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPresentId2KHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount: u32,
	pub pPresentIds: *const uint64_t,
}
impl Debug for VkPresentId2KHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPresentId2KHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("swapchainCount", &self.swapchainCount)
		.field("pPresentIds", &self.pPresentIds)
		.finish()
	}
}
/// struct `VkPhysicalDevicePresentId2FeaturesKHR` from VK_KHR_present_id2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePresentId2FeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePresentId2FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentId2: VkBool32,
}
impl Debug for VkPhysicalDevicePresentId2FeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePresentId2FeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentId2", &self.presentId2)
		.finish()
	}
}
/// trait for `VK_KHR_present_id2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_present_id2.html>
pub trait VK_KHR_present_id2: Debug {}
/// struct for `VK_KHR_present_id2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_present_id2 {}
impl VK_KHR_present_id2 for Vulkan_KHR_present_id2 {}
impl Default for Vulkan_KHR_present_id2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_present_id2 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkSurfaceCapabilitiesPresentWait2KHR` from VK_KHR_present_wait2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfaceCapabilitiesPresentWait2KHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSurfaceCapabilitiesPresentWait2KHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentWait2Supported: VkBool32,
}
impl Debug for VkSurfaceCapabilitiesPresentWait2KHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSurfaceCapabilitiesPresentWait2KHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentWait2Supported", &self.presentWait2Supported)
		.finish()
	}
}
/// struct `VkPhysicalDevicePresentWait2FeaturesKHR` from VK_KHR_present_wait2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePresentWait2FeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePresentWait2FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentWait2: VkBool32,
}
impl Debug for VkPhysicalDevicePresentWait2FeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePresentWait2FeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentWait2", &self.presentWait2)
		.finish()
	}
}
/// struct `VkPresentWait2InfoKHR` from VK_KHR_present_wait2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentWait2InfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPresentWait2InfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub presentId: u64,
	pub timeout: u64,
}
impl Debug for VkPresentWait2InfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPresentWait2InfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentId", &self.presentId)
		.field("timeout", &self.timeout)
		.finish()
	}
}
/// function prototype `PFN_vkWaitForPresent2KHR` from VK_KHR_present_wait2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitForPresent2KHR.html>
type PFN_vkWaitForPresent2KHR = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pPresentWait2Info: *const VkPresentWait2InfoKHR) -> VkResult;
/// The dummy function for `vkWaitForPresent2KHR` from `VK_KHR_present_wait2`
extern "system" fn dummy_vkWaitForPresent2KHR(_: VkDevice, _: VkSwapchainKHR, _: *const VkPresentWait2InfoKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkWaitForPresent2KHR"))
}
/// trait for `VK_KHR_present_wait2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_present_wait2.html>
pub trait VK_KHR_present_wait2: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitForPresent2KHR.html>
	fn vkWaitForPresent2KHR(&self, device: VkDevice, swapchain: VkSwapchainKHR, pPresentWait2Info: *const VkPresentWait2InfoKHR) -> Result<()>;
}
/// struct for `VK_KHR_present_wait2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_present_wait2 {
	vk_wait_for_present2_khr: PFN_vkWaitForPresent2KHR,
}
impl VK_KHR_present_wait2 for Vulkan_KHR_present_wait2 {
	fn vkWaitForPresent2KHR(&self, device: VkDevice, swapchain: VkSwapchainKHR, pPresentWait2Info: *const VkPresentWait2InfoKHR) -> Result<()> {
		convert_result("vkWaitForPresent2KHR", catch_unwind(||((self.vk_wait_for_present2_khr)(device, swapchain, pPresentWait2Info))))
	}
}
impl Default for Vulkan_KHR_present_wait2 {
	fn default() -> Self {
		Self {
			vk_wait_for_present2_khr: dummy_vkWaitForPresent2KHR,
		}
	}
}
impl Vulkan_KHR_present_wait2 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_wait_for_present2_khr: {let proc = get_instance_proc_address(instance, "vkWaitForPresent2KHR"); if proc == null() {dummy_vkWaitForPresent2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR` from VK_KHR_ray_tracing_position_fetch
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rayTracingPositionFetch: VkBool32,
}
impl Debug for VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("rayTracingPositionFetch", &self.rayTracingPositionFetch)
		.finish()
	}
}
/// trait for `VK_KHR_ray_tracing_position_fetch`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_ray_tracing_position_fetch.html>
pub trait VK_KHR_ray_tracing_position_fetch: Debug {}
/// struct for `VK_KHR_ray_tracing_position_fetch`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_ray_tracing_position_fetch {}
impl VK_KHR_ray_tracing_position_fetch for Vulkan_KHR_ray_tracing_position_fetch {}
impl Default for Vulkan_KHR_ray_tracing_position_fetch {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_ray_tracing_position_fetch {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR.html>
pub const VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR: u32 = 32u32;
/// Non-dispatchable handle `VkPipelineBinaryKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineBinaryKHR.html
#[cfg(target_pointer_width = "32")] pub type VkPipelineBinaryKHR = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkPipelineBinaryKHR_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkPipelineBinaryKHR = *const VkPipelineBinaryKHR_T;
/// struct `VkPhysicalDevicePipelineBinaryFeaturesKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePipelineBinaryFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePipelineBinaryFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineBinaries: VkBool32,
}
impl Debug for VkPhysicalDevicePipelineBinaryFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePipelineBinaryFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelineBinaries", &self.pipelineBinaries)
		.finish()
	}
}
/// struct `VkPhysicalDevicePipelineBinaryPropertiesKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePipelineBinaryPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePipelineBinaryPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineBinaryInternalCache: VkBool32,
	pub pipelineBinaryInternalCacheControl: VkBool32,
	pub pipelineBinaryPrefersInternalCache: VkBool32,
	pub pipelineBinaryPrecompiledInternalCache: VkBool32,
	pub pipelineBinaryCompressedData: VkBool32,
}
impl Debug for VkPhysicalDevicePipelineBinaryPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePipelineBinaryPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelineBinaryInternalCache", &self.pipelineBinaryInternalCache)
		.field("pipelineBinaryInternalCacheControl", &self.pipelineBinaryInternalCacheControl)
		.field("pipelineBinaryPrefersInternalCache", &self.pipelineBinaryPrefersInternalCache)
		.field("pipelineBinaryPrecompiledInternalCache", &self.pipelineBinaryPrecompiledInternalCache)
		.field("pipelineBinaryCompressedData", &self.pipelineBinaryCompressedData)
		.finish()
	}
}
/// struct `VkDevicePipelineBinaryInternalCacheControlKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDevicePipelineBinaryInternalCacheControlKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDevicePipelineBinaryInternalCacheControlKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub disableInternalCache: VkBool32,
}
impl Debug for VkDevicePipelineBinaryInternalCacheControlKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDevicePipelineBinaryInternalCacheControlKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("disableInternalCache", &self.disableInternalCache)
		.finish()
	}
}
/// struct `VkPipelineBinaryKeyKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineBinaryKeyKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineBinaryKeyKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub keySize: u32,
	pub key: [u8; VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR as usize],
}
impl Debug for VkPipelineBinaryKeyKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineBinaryKeyKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("keySize", &self.keySize)
		.field("key", &self.key)
		.finish()
	}
}
/// struct `VkPipelineBinaryDataKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineBinaryDataKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineBinaryDataKHR {
	pub dataSize: usize,
	pub pData: *mut c_void,
}
impl Debug for VkPipelineBinaryDataKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineBinaryDataKHR")
		.field("dataSize", &self.dataSize)
		.field("pData", &self.pData)
		.finish()
	}
}
/// struct `VkPipelineBinaryKeysAndDataKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineBinaryKeysAndDataKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineBinaryKeysAndDataKHR {
	pub binaryCount: u32,
	pub pPipelineBinaryKeys: *const VkPipelineBinaryKeyKHR,
	pub pPipelineBinaryData: *const VkPipelineBinaryDataKHR,
}
impl Debug for VkPipelineBinaryKeysAndDataKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineBinaryKeysAndDataKHR")
		.field("binaryCount", &self.binaryCount)
		.field("pPipelineBinaryKeys", &self.pPipelineBinaryKeys)
		.field("pPipelineBinaryData", &self.pPipelineBinaryData)
		.finish()
	}
}
/// struct `VkPipelineCreateInfoKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
}
impl Debug for VkPipelineCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.finish()
	}
}
/// struct `VkPipelineBinaryCreateInfoKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineBinaryCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineBinaryCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pKeysAndDataInfo: *const VkPipelineBinaryKeysAndDataKHR,
	pub pipeline: VkPipeline,
	pub pPipelineCreateInfo: *const VkPipelineCreateInfoKHR,
}
impl Debug for VkPipelineBinaryCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineBinaryCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pKeysAndDataInfo", &self.pKeysAndDataInfo)
		.field("pipeline", &self.pipeline)
		.field("pPipelineCreateInfo", &self.pPipelineCreateInfo)
		.finish()
	}
}
/// struct `VkPipelineBinaryInfoKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineBinaryInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineBinaryInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub binaryCount: u32,
	pub pPipelineBinaries: *const VkPipelineBinaryKHR,
}
impl Debug for VkPipelineBinaryInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineBinaryInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("binaryCount", &self.binaryCount)
		.field("pPipelineBinaries", &self.pPipelineBinaries)
		.finish()
	}
}
/// struct `VkReleaseCapturedPipelineDataInfoKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkReleaseCapturedPipelineDataInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkReleaseCapturedPipelineDataInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipeline: VkPipeline,
}
impl Debug for VkReleaseCapturedPipelineDataInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkReleaseCapturedPipelineDataInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipeline", &self.pipeline)
		.finish()
	}
}
/// struct `VkPipelineBinaryDataInfoKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineBinaryDataInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineBinaryDataInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineBinary: VkPipelineBinaryKHR,
}
impl Debug for VkPipelineBinaryDataInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineBinaryDataInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelineBinary", &self.pipelineBinary)
		.finish()
	}
}
/// struct `VkPipelineBinaryHandlesInfoKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineBinaryHandlesInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineBinaryHandlesInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pipelineBinaryCount: u32,
	pub pPipelineBinaries: *mut VkPipelineBinaryKHR,
}
impl Debug for VkPipelineBinaryHandlesInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineBinaryHandlesInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelineBinaryCount", &self.pipelineBinaryCount)
		.field("pPipelineBinaries", &self.pPipelineBinaries)
		.finish()
	}
}
/// function prototype `PFN_vkCreatePipelineBinariesKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineBinariesKHR.html>
type PFN_vkCreatePipelineBinariesKHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkPipelineBinaryCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pBinaries: *mut VkPipelineBinaryHandlesInfoKHR) -> VkResult;
/// function prototype `PFN_vkDestroyPipelineBinaryKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineBinaryKHR.html>
type PFN_vkDestroyPipelineBinaryKHR = extern "system" fn(device: VkDevice, pipelineBinary: VkPipelineBinaryKHR, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkGetPipelineKeyKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineKeyKHR.html>
type PFN_vkGetPipelineKeyKHR = extern "system" fn(device: VkDevice, pPipelineCreateInfo: *const VkPipelineCreateInfoKHR, pPipelineKey: *mut VkPipelineBinaryKeyKHR) -> VkResult;
/// function prototype `PFN_vkGetPipelineBinaryDataKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineBinaryDataKHR.html>
type PFN_vkGetPipelineBinaryDataKHR = extern "system" fn(device: VkDevice, pInfo: *const VkPipelineBinaryDataInfoKHR, pPipelineBinaryKey: *mut VkPipelineBinaryKeyKHR, pPipelineBinaryDataSize: *mut size_t, pPipelineBinaryData: *mut c_void) -> VkResult;
/// function prototype `PFN_vkReleaseCapturedPipelineDataKHR` from VK_KHR_pipeline_binary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseCapturedPipelineDataKHR.html>
type PFN_vkReleaseCapturedPipelineDataKHR = extern "system" fn(device: VkDevice, pInfo: *const VkReleaseCapturedPipelineDataInfoKHR, pAllocator: *const VkAllocationCallbacks) -> VkResult;
/// The dummy function for `vkCreatePipelineBinariesKHR` from `VK_KHR_pipeline_binary`
extern "system" fn dummy_vkCreatePipelineBinariesKHR(_: VkDevice, _: *const VkPipelineBinaryCreateInfoKHR, _: *const VkAllocationCallbacks, _: *mut VkPipelineBinaryHandlesInfoKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreatePipelineBinariesKHR"))
}
/// trait for `VK_KHR_pipeline_binary`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_pipeline_binary.html>
pub trait VK_KHR_pipeline_binary: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineBinariesKHR.html>
	fn vkCreatePipelineBinariesKHR(&self, device: VkDevice, pCreateInfo: *const VkPipelineBinaryCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pBinaries: *mut VkPipelineBinaryHandlesInfoKHR) -> Result<()>;
}
/// struct for `VK_KHR_pipeline_binary`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_pipeline_binary {
	vk_create_pipeline_binaries_khr: PFN_vkCreatePipelineBinariesKHR,
}
impl VK_KHR_pipeline_binary for Vulkan_KHR_pipeline_binary {
	fn vkCreatePipelineBinariesKHR(&self, device: VkDevice, pCreateInfo: *const VkPipelineBinaryCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pBinaries: *mut VkPipelineBinaryHandlesInfoKHR) -> Result<()> {
		convert_result("vkCreatePipelineBinariesKHR", catch_unwind(||((self.vk_create_pipeline_binaries_khr)(device, pCreateInfo, pAllocator, pBinaries))))
	}
}
impl Default for Vulkan_KHR_pipeline_binary {
	fn default() -> Self {
		Self {
			vk_create_pipeline_binaries_khr: dummy_vkCreatePipelineBinariesKHR,
		}
	}
}
impl Vulkan_KHR_pipeline_binary {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_pipeline_binaries_khr: {let proc = get_instance_proc_address(instance, "vkCreatePipelineBinariesKHR"); if proc == null() {dummy_vkCreatePipelineBinariesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPresentScalingFlagsKHR` from VK_KHR_surface_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentScalingFlagsKHR.html>
pub type VkPresentScalingFlagsKHR = VkFlags;
/// type definition `VkPresentGravityFlagsKHR` from VK_KHR_surface_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentGravityFlagsKHR.html>
pub type VkPresentGravityFlagsKHR = VkFlags;
/// enum `VkPresentScalingFlagBitsKHR` from VK_KHR_surface_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentScalingFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPresentScalingFlagBitsKHR {
	VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR = 0x00000001,
	VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR = 0x00000002,
	VK_PRESENT_SCALING_STRETCH_BIT_KHR = 0x00000004,
	VK_PRESENT_SCALING_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkPresentScalingFlagBitsKHR {
	pub const VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT: VkPresentScalingFlagBitsKHR = VkPresentScalingFlagBitsKHR::VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR;
	pub const VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT: VkPresentScalingFlagBitsKHR = VkPresentScalingFlagBitsKHR::VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR;
	pub const VK_PRESENT_SCALING_STRETCH_BIT_EXT: VkPresentScalingFlagBitsKHR = VkPresentScalingFlagBitsKHR::VK_PRESENT_SCALING_STRETCH_BIT_KHR;
}
/// enum `VkPresentGravityFlagBitsKHR` from VK_KHR_surface_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentGravityFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPresentGravityFlagBitsKHR {
	VK_PRESENT_GRAVITY_MIN_BIT_KHR = 0x00000001,
	VK_PRESENT_GRAVITY_MAX_BIT_KHR = 0x00000002,
	VK_PRESENT_GRAVITY_CENTERED_BIT_KHR = 0x00000004,
	VK_PRESENT_GRAVITY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkPresentGravityFlagBitsKHR {
	pub const VK_PRESENT_GRAVITY_MIN_BIT_EXT: VkPresentGravityFlagBitsKHR = VkPresentGravityFlagBitsKHR::VK_PRESENT_GRAVITY_MIN_BIT_KHR;
	pub const VK_PRESENT_GRAVITY_MAX_BIT_EXT: VkPresentGravityFlagBitsKHR = VkPresentGravityFlagBitsKHR::VK_PRESENT_GRAVITY_MAX_BIT_KHR;
	pub const VK_PRESENT_GRAVITY_CENTERED_BIT_EXT: VkPresentGravityFlagBitsKHR = VkPresentGravityFlagBitsKHR::VK_PRESENT_GRAVITY_CENTERED_BIT_KHR;
}
/// struct `VkSurfacePresentModeKHR` from VK_KHR_surface_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfacePresentModeKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSurfacePresentModeKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentMode: VkPresentModeKHR,
}
impl Debug for VkSurfacePresentModeKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSurfacePresentModeKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentMode", &self.presentMode)
		.finish()
	}
}
/// struct `VkSurfacePresentScalingCapabilitiesKHR` from VK_KHR_surface_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfacePresentScalingCapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSurfacePresentScalingCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub supportedPresentScaling: VkPresentScalingFlagsKHR,
	pub supportedPresentGravityX: VkPresentGravityFlagsKHR,
	pub supportedPresentGravityY: VkPresentGravityFlagsKHR,
	pub minScaledImageExtent: VkExtent2D,
	pub maxScaledImageExtent: VkExtent2D,
}
impl Debug for VkSurfacePresentScalingCapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSurfacePresentScalingCapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("supportedPresentScaling", &self.supportedPresentScaling)
		.field("supportedPresentGravityX", &self.supportedPresentGravityX)
		.field("supportedPresentGravityY", &self.supportedPresentGravityY)
		.field("minScaledImageExtent", &self.minScaledImageExtent)
		.field("maxScaledImageExtent", &self.maxScaledImageExtent)
		.finish()
	}
}
/// struct `VkSurfacePresentModeCompatibilityKHR` from VK_KHR_surface_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfacePresentModeCompatibilityKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSurfacePresentModeCompatibilityKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentModeCount: u32,
	pub pPresentModes: *mut VkPresentModeKHR,
}
impl Debug for VkSurfacePresentModeCompatibilityKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSurfacePresentModeCompatibilityKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentModeCount", &self.presentModeCount)
		.field("pPresentModes", &self.pPresentModes)
		.finish()
	}
}
/// trait for `VK_KHR_surface_maintenance1`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_surface_maintenance1.html>
pub trait VK_KHR_surface_maintenance1: Debug {}
/// struct for `VK_KHR_surface_maintenance1`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_surface_maintenance1 {}
impl VK_KHR_surface_maintenance1 for Vulkan_KHR_surface_maintenance1 {}
impl Default for Vulkan_KHR_surface_maintenance1 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_surface_maintenance1 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR` from VK_KHR_swapchain_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub swapchainMaintenance1: VkBool32,
}
impl Debug for VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("swapchainMaintenance1", &self.swapchainMaintenance1)
		.finish()
	}
}
/// struct `VkSwapchainPresentFenceInfoKHR` from VK_KHR_swapchain_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainPresentFenceInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSwapchainPresentFenceInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount: u32,
	pub pFences: *const VkFence,
}
impl Debug for VkSwapchainPresentFenceInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSwapchainPresentFenceInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("swapchainCount", &self.swapchainCount)
		.field("pFences", &self.pFences)
		.finish()
	}
}
/// struct `VkSwapchainPresentModesCreateInfoKHR` from VK_KHR_swapchain_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainPresentModesCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSwapchainPresentModesCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub presentModeCount: u32,
	pub pPresentModes: *const VkPresentModeKHR,
}
impl Debug for VkSwapchainPresentModesCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSwapchainPresentModesCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentModeCount", &self.presentModeCount)
		.field("pPresentModes", &self.pPresentModes)
		.finish()
	}
}
/// struct `VkSwapchainPresentModeInfoKHR` from VK_KHR_swapchain_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainPresentModeInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSwapchainPresentModeInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount: u32,
	pub pPresentModes: *const VkPresentModeKHR,
}
impl Debug for VkSwapchainPresentModeInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSwapchainPresentModeInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("swapchainCount", &self.swapchainCount)
		.field("pPresentModes", &self.pPresentModes)
		.finish()
	}
}
/// struct `VkSwapchainPresentScalingCreateInfoKHR` from VK_KHR_swapchain_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainPresentScalingCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSwapchainPresentScalingCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub scalingBehavior: VkPresentScalingFlagsKHR,
	pub presentGravityX: VkPresentGravityFlagsKHR,
	pub presentGravityY: VkPresentGravityFlagsKHR,
}
impl Debug for VkSwapchainPresentScalingCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSwapchainPresentScalingCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("scalingBehavior", &self.scalingBehavior)
		.field("presentGravityX", &self.presentGravityX)
		.field("presentGravityY", &self.presentGravityY)
		.finish()
	}
}
/// struct `VkReleaseSwapchainImagesInfoKHR` from VK_KHR_swapchain_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkReleaseSwapchainImagesInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkReleaseSwapchainImagesInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchain: VkSwapchainKHR,
	pub imageIndexCount: u32,
	pub pImageIndices: *const uint32_t,
}
impl Debug for VkReleaseSwapchainImagesInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkReleaseSwapchainImagesInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("swapchain", &self.swapchain)
		.field("imageIndexCount", &self.imageIndexCount)
		.field("pImageIndices", &self.pImageIndices)
		.finish()
	}
}
/// function prototype `PFN_vkReleaseSwapchainImagesKHR` from VK_KHR_swapchain_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseSwapchainImagesKHR.html>
type PFN_vkReleaseSwapchainImagesKHR = extern "system" fn(device: VkDevice, pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR) -> VkResult;
/// The dummy function for `vkReleaseSwapchainImagesKHR` from `VK_KHR_swapchain_maintenance1`
extern "system" fn dummy_vkReleaseSwapchainImagesKHR(_: VkDevice, _: *const VkReleaseSwapchainImagesInfoKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkReleaseSwapchainImagesKHR"))
}
/// trait for `VK_KHR_swapchain_maintenance1`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_swapchain_maintenance1.html>
pub trait VK_KHR_swapchain_maintenance1: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseSwapchainImagesKHR.html>
	fn vkReleaseSwapchainImagesKHR(&self, device: VkDevice, pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR) -> Result<()>;
}
/// struct for `VK_KHR_swapchain_maintenance1`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_swapchain_maintenance1 {
	vk_release_swapchain_images_khr: PFN_vkReleaseSwapchainImagesKHR,
}
impl VK_KHR_swapchain_maintenance1 for Vulkan_KHR_swapchain_maintenance1 {
	fn vkReleaseSwapchainImagesKHR(&self, device: VkDevice, pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR) -> Result<()> {
		convert_result("vkReleaseSwapchainImagesKHR", catch_unwind(||((self.vk_release_swapchain_images_khr)(device, pReleaseInfo))))
	}
}
impl Default for Vulkan_KHR_swapchain_maintenance1 {
	fn default() -> Self {
		Self {
			vk_release_swapchain_images_khr: dummy_vkReleaseSwapchainImagesKHR,
		}
	}
}
impl Vulkan_KHR_swapchain_maintenance1 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_release_swapchain_images_khr: {let proc = get_instance_proc_address(instance, "vkReleaseSwapchainImagesKHR"); if proc == null() {dummy_vkReleaseSwapchainImagesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// enum `VkComponentTypeKHR` from VK_KHR_cooperative_matrix
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkComponentTypeKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkComponentTypeKHR {
	VK_COMPONENT_TYPE_FLOAT16_KHR = 0,
	VK_COMPONENT_TYPE_FLOAT32_KHR = 1,
	VK_COMPONENT_TYPE_FLOAT64_KHR = 2,
	VK_COMPONENT_TYPE_SINT8_KHR = 3,
	VK_COMPONENT_TYPE_SINT16_KHR = 4,
	VK_COMPONENT_TYPE_SINT32_KHR = 5,
	VK_COMPONENT_TYPE_SINT64_KHR = 6,
	VK_COMPONENT_TYPE_UINT8_KHR = 7,
	VK_COMPONENT_TYPE_UINT16_KHR = 8,
	VK_COMPONENT_TYPE_UINT32_KHR = 9,
	VK_COMPONENT_TYPE_UINT64_KHR = 10,
	VK_COMPONENT_TYPE_BFLOAT16_KHR = 1000141000,
	VK_COMPONENT_TYPE_SINT8_PACKED_NV = 1000491000,
	VK_COMPONENT_TYPE_UINT8_PACKED_NV = 1000491001,
	VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT = 1000491002,
	VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT = 1000491003,
	VK_COMPONENT_TYPE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkComponentTypeKHR {
	pub const VK_COMPONENT_TYPE_FLOAT16_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_FLOAT16_KHR;
	pub const VK_COMPONENT_TYPE_FLOAT32_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_FLOAT32_KHR;
	pub const VK_COMPONENT_TYPE_FLOAT64_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_FLOAT64_KHR;
	pub const VK_COMPONENT_TYPE_SINT8_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_SINT8_KHR;
	pub const VK_COMPONENT_TYPE_SINT16_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_SINT16_KHR;
	pub const VK_COMPONENT_TYPE_SINT32_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_SINT32_KHR;
	pub const VK_COMPONENT_TYPE_SINT64_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_SINT64_KHR;
	pub const VK_COMPONENT_TYPE_UINT8_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_UINT8_KHR;
	pub const VK_COMPONENT_TYPE_UINT16_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_UINT16_KHR;
	pub const VK_COMPONENT_TYPE_UINT32_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_UINT32_KHR;
	pub const VK_COMPONENT_TYPE_UINT64_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_UINT64_KHR;
	pub const VK_COMPONENT_TYPE_FLOAT_E4M3_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT;
	pub const VK_COMPONENT_TYPE_FLOAT_E5M2_NV: VkComponentTypeKHR = VkComponentTypeKHR::VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT;
}
/// enum `VkScopeKHR` from VK_KHR_cooperative_matrix
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkScopeKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkScopeKHR {
	VK_SCOPE_DEVICE_KHR = 1,
	VK_SCOPE_WORKGROUP_KHR = 2,
	VK_SCOPE_SUBGROUP_KHR = 3,
	VK_SCOPE_QUEUE_FAMILY_KHR = 5,
	VK_SCOPE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkScopeKHR {
	pub const VK_SCOPE_DEVICE_NV: VkScopeKHR = VkScopeKHR::VK_SCOPE_DEVICE_KHR;
	pub const VK_SCOPE_WORKGROUP_NV: VkScopeKHR = VkScopeKHR::VK_SCOPE_WORKGROUP_KHR;
	pub const VK_SCOPE_SUBGROUP_NV: VkScopeKHR = VkScopeKHR::VK_SCOPE_SUBGROUP_KHR;
	pub const VK_SCOPE_QUEUE_FAMILY_NV: VkScopeKHR = VkScopeKHR::VK_SCOPE_QUEUE_FAMILY_KHR;
}
/// struct `VkCooperativeMatrixPropertiesKHR` from VK_KHR_cooperative_matrix
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCooperativeMatrixPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCooperativeMatrixPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub MSize: u32,
	pub NSize: u32,
	pub KSize: u32,
	pub AType: VkComponentTypeKHR,
	pub BType: VkComponentTypeKHR,
	pub CType: VkComponentTypeKHR,
	pub ResultType: VkComponentTypeKHR,
	pub saturatingAccumulation: VkBool32,
	pub scope: VkScopeKHR,
}
impl Debug for VkCooperativeMatrixPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCooperativeMatrixPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("MSize", &self.MSize)
		.field("NSize", &self.NSize)
		.field("KSize", &self.KSize)
		.field("AType", &self.AType)
		.field("BType", &self.BType)
		.field("CType", &self.CType)
		.field("ResultType", &self.ResultType)
		.field("saturatingAccumulation", &self.saturatingAccumulation)
		.field("scope", &self.scope)
		.finish()
	}
}
/// struct `VkPhysicalDeviceCooperativeMatrixFeaturesKHR` from VK_KHR_cooperative_matrix
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCooperativeMatrixFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCooperativeMatrixFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cooperativeMatrix: VkBool32,
	pub cooperativeMatrixRobustBufferAccess: VkBool32,
}
impl Debug for VkPhysicalDeviceCooperativeMatrixFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCooperativeMatrixFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("cooperativeMatrix", &self.cooperativeMatrix)
		.field("cooperativeMatrixRobustBufferAccess", &self.cooperativeMatrixRobustBufferAccess)
		.finish()
	}
}
/// struct `VkPhysicalDeviceCooperativeMatrixPropertiesKHR` from VK_KHR_cooperative_matrix
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCooperativeMatrixPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCooperativeMatrixPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cooperativeMatrixSupportedStages: VkShaderStageFlags,
}
impl Debug for VkPhysicalDeviceCooperativeMatrixPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCooperativeMatrixPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("cooperativeMatrixSupportedStages", &self.cooperativeMatrixSupportedStages)
		.finish()
	}
}
/// function prototype `PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR` from VK_KHR_cooperative_matrix
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR.html>
type PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixPropertiesKHR) -> VkResult;
/// The dummy function for `vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR` from `VK_KHR_cooperative_matrix`
extern "system" fn dummy_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkCooperativeMatrixPropertiesKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR"))
}
/// trait for `VK_KHR_cooperative_matrix`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_cooperative_matrix.html>
pub trait VK_KHR_cooperative_matrix: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR.html>
	fn vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixPropertiesKHR) -> Result<()>;
}
/// struct for `VK_KHR_cooperative_matrix`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_cooperative_matrix {
	vk_get_physical_device_cooperative_matrix_properties_khr: PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR,
}
impl VK_KHR_cooperative_matrix for Vulkan_KHR_cooperative_matrix {
	fn vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixPropertiesKHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR", catch_unwind(||((self.vk_get_physical_device_cooperative_matrix_properties_khr)(physicalDevice, pPropertyCount, pProperties))))
	}
}
impl Default for Vulkan_KHR_cooperative_matrix {
	fn default() -> Self {
		Self {
			vk_get_physical_device_cooperative_matrix_properties_khr: dummy_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR,
		}
	}
}
impl Vulkan_KHR_cooperative_matrix {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_cooperative_matrix_properties_khr: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR"); if proc == null() {dummy_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR` from VK_KHR_compute_shader_derivatives
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub computeDerivativeGroupQuads: VkBool32,
	pub computeDerivativeGroupLinear: VkBool32,
}
impl Debug for VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("computeDerivativeGroupQuads", &self.computeDerivativeGroupQuads)
		.field("computeDerivativeGroupLinear", &self.computeDerivativeGroupLinear)
		.finish()
	}
}
/// struct `VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR` from VK_KHR_compute_shader_derivatives
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub meshAndTaskShaderDerivatives: VkBool32,
}
impl Debug for VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("meshAndTaskShaderDerivatives", &self.meshAndTaskShaderDerivatives)
		.finish()
	}
}
/// trait for `VK_KHR_compute_shader_derivatives`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_compute_shader_derivatives.html>
pub trait VK_KHR_compute_shader_derivatives: Debug {}
/// struct for `VK_KHR_compute_shader_derivatives`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_compute_shader_derivatives {}
impl VK_KHR_compute_shader_derivatives for Vulkan_KHR_compute_shader_derivatives {}
impl Default for Vulkan_KHR_compute_shader_derivatives {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_compute_shader_derivatives {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR` from VK_KHR_video_decode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR.html>
pub const VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR: u32 = 7u32;
/// struct `VkVideoDecodeAV1ProfileInfoKHR` from VK_KHR_video_decode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeAV1ProfileInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeAV1ProfileInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdProfile: StdVideoAV1Profile,
	pub filmGrainSupport: VkBool32,
}
impl Debug for VkVideoDecodeAV1ProfileInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeAV1ProfileInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stdProfile", &self.stdProfile)
		.field("filmGrainSupport", &self.filmGrainSupport)
		.finish()
	}
}
/// struct `VkVideoDecodeAV1CapabilitiesKHR` from VK_KHR_video_decode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeAV1CapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeAV1CapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxLevel: StdVideoAV1Level,
}
impl Debug for VkVideoDecodeAV1CapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeAV1CapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxLevel", &self.maxLevel)
		.finish()
	}
}
/// struct `VkVideoDecodeAV1SessionParametersCreateInfoKHR` from VK_KHR_video_decode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeAV1SessionParametersCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeAV1SessionParametersCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdSequenceHeader: *const StdVideoAV1SequenceHeader,
}
impl Debug for VkVideoDecodeAV1SessionParametersCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeAV1SessionParametersCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pStdSequenceHeader", &self.pStdSequenceHeader)
		.finish()
	}
}
/// struct `VkVideoDecodeAV1PictureInfoKHR` from VK_KHR_video_decode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeAV1PictureInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeAV1PictureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdPictureInfo: *const StdVideoDecodeAV1PictureInfo,
	pub referenceNameSlotIndices: [i32; VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR as usize],
	pub frameHeaderOffset: u32,
	pub tileCount: u32,
	pub pTileOffsets: *const uint32_t,
	pub pTileSizes: *const uint32_t,
}
impl Debug for VkVideoDecodeAV1PictureInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeAV1PictureInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pStdPictureInfo", &self.pStdPictureInfo)
		.field("referenceNameSlotIndices", &self.referenceNameSlotIndices)
		.field("frameHeaderOffset", &self.frameHeaderOffset)
		.field("tileCount", &self.tileCount)
		.field("pTileOffsets", &self.pTileOffsets)
		.field("pTileSizes", &self.pTileSizes)
		.finish()
	}
}
/// struct `VkVideoDecodeAV1DpbSlotInfoKHR` from VK_KHR_video_decode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeAV1DpbSlotInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeAV1DpbSlotInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdReferenceInfo: *const StdVideoDecodeAV1ReferenceInfo,
}
impl Debug for VkVideoDecodeAV1DpbSlotInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeAV1DpbSlotInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pStdReferenceInfo", &self.pStdReferenceInfo)
		.finish()
	}
}
/// trait for `VK_KHR_video_decode_av1`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_video_decode_av1.html>
pub trait VK_KHR_video_decode_av1: Debug {}
/// struct for `VK_KHR_video_decode_av1`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_decode_av1 {}
impl VK_KHR_video_decode_av1 for Vulkan_KHR_video_decode_av1 {}
impl Default for Vulkan_KHR_video_decode_av1 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_decode_av1 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `STD_VIDEO_AV1_NUM_REF_FRAMES` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_NUM_REF_FRAMES.html>
pub const STD_VIDEO_AV1_NUM_REF_FRAMES: u32 = 8u32;
/// constant `STD_VIDEO_AV1_REFS_PER_FRAME` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_REFS_PER_FRAME.html>
pub const STD_VIDEO_AV1_REFS_PER_FRAME: u32 = 7u32;
/// constant `STD_VIDEO_AV1_TOTAL_REFS_PER_FRAME` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_TOTAL_REFS_PER_FRAME.html>
pub const STD_VIDEO_AV1_TOTAL_REFS_PER_FRAME: u32 = 8u32;
/// constant `STD_VIDEO_AV1_MAX_TILE_COLS` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_MAX_TILE_COLS.html>
pub const STD_VIDEO_AV1_MAX_TILE_COLS: u32 = 64u32;
/// constant `STD_VIDEO_AV1_MAX_TILE_ROWS` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_MAX_TILE_ROWS.html>
pub const STD_VIDEO_AV1_MAX_TILE_ROWS: u32 = 64u32;
/// constant `STD_VIDEO_AV1_MAX_SEGMENTS` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_MAX_SEGMENTS.html>
pub const STD_VIDEO_AV1_MAX_SEGMENTS: u32 = 8u32;
/// constant `STD_VIDEO_AV1_SEG_LVL_MAX` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_SEG_LVL_MAX.html>
pub const STD_VIDEO_AV1_SEG_LVL_MAX: u32 = 8u32;
/// constant `STD_VIDEO_AV1_PRIMARY_REF_NONE` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_PRIMARY_REF_NONE.html>
pub const STD_VIDEO_AV1_PRIMARY_REF_NONE: u32 = 7u32;
/// constant `STD_VIDEO_AV1_SELECT_INTEGER_MV` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_SELECT_INTEGER_MV.html>
pub const STD_VIDEO_AV1_SELECT_INTEGER_MV: u32 = 2u32;
/// constant `STD_VIDEO_AV1_SELECT_SCREEN_CONTENT_TOOLS` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_SELECT_SCREEN_CONTENT_TOOLS.html>
pub const STD_VIDEO_AV1_SELECT_SCREEN_CONTENT_TOOLS: u32 = 2u32;
/// constant `STD_VIDEO_AV1_SKIP_MODE_FRAMES` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_SKIP_MODE_FRAMES.html>
pub const STD_VIDEO_AV1_SKIP_MODE_FRAMES: u32 = 2u32;
/// constant `STD_VIDEO_AV1_MAX_LOOP_FILTER_STRENGTHS` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_MAX_LOOP_FILTER_STRENGTHS.html>
pub const STD_VIDEO_AV1_MAX_LOOP_FILTER_STRENGTHS: u32 = 4u32;
/// constant `STD_VIDEO_AV1_LOOP_FILTER_ADJUSTMENTS` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_LOOP_FILTER_ADJUSTMENTS.html>
pub const STD_VIDEO_AV1_LOOP_FILTER_ADJUSTMENTS: u32 = 2u32;
/// constant `STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS.html>
pub const STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS: u32 = 8u32;
/// constant `STD_VIDEO_AV1_MAX_NUM_PLANES` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_MAX_NUM_PLANES.html>
pub const STD_VIDEO_AV1_MAX_NUM_PLANES: u32 = 3u32;
/// constant `STD_VIDEO_AV1_GLOBAL_MOTION_PARAMS` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_GLOBAL_MOTION_PARAMS.html>
pub const STD_VIDEO_AV1_GLOBAL_MOTION_PARAMS: u32 = 6u32;
/// constant `STD_VIDEO_AV1_MAX_NUM_Y_POINTS` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_MAX_NUM_Y_POINTS.html>
pub const STD_VIDEO_AV1_MAX_NUM_Y_POINTS: u32 = 14u32;
/// constant `STD_VIDEO_AV1_MAX_NUM_CB_POINTS` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_MAX_NUM_CB_POINTS.html>
pub const STD_VIDEO_AV1_MAX_NUM_CB_POINTS: u32 = 10u32;
/// constant `STD_VIDEO_AV1_MAX_NUM_CR_POINTS` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_MAX_NUM_CR_POINTS.html>
pub const STD_VIDEO_AV1_MAX_NUM_CR_POINTS: u32 = 10u32;
/// constant `STD_VIDEO_AV1_MAX_NUM_POS_LUMA` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_MAX_NUM_POS_LUMA.html>
pub const STD_VIDEO_AV1_MAX_NUM_POS_LUMA: u32 = 24u32;
/// constant `STD_VIDEO_AV1_MAX_NUM_POS_CHROMA` from vulkan_video_codec_av1std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_AV1_MAX_NUM_POS_CHROMA.html>
pub const STD_VIDEO_AV1_MAX_NUM_POS_CHROMA: u32 = 25u32;
/// enum `StdVideoAV1Profile` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1Profile {
	STD_VIDEO_AV1_PROFILE_MAIN = 0,
	STD_VIDEO_AV1_PROFILE_HIGH = 1,
	STD_VIDEO_AV1_PROFILE_PROFESSIONAL = 2,
	STD_VIDEO_AV1_PROFILE_INVALID = 0x7fffffff,
}
impl StdVideoAV1Profile {
	pub const STD_VIDEO_AV1_PROFILE_MAX_ENUM: StdVideoAV1Profile = StdVideoAV1Profile::STD_VIDEO_AV1_PROFILE_INVALID;
}
/// enum `StdVideoAV1Level` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1Level {
	STD_VIDEO_AV1_LEVEL_2_0 = 0,
	STD_VIDEO_AV1_LEVEL_2_1 = 1,
	STD_VIDEO_AV1_LEVEL_2_2 = 2,
	STD_VIDEO_AV1_LEVEL_2_3 = 3,
	STD_VIDEO_AV1_LEVEL_3_0 = 4,
	STD_VIDEO_AV1_LEVEL_3_1 = 5,
	STD_VIDEO_AV1_LEVEL_3_2 = 6,
	STD_VIDEO_AV1_LEVEL_3_3 = 7,
	STD_VIDEO_AV1_LEVEL_4_0 = 8,
	STD_VIDEO_AV1_LEVEL_4_1 = 9,
	STD_VIDEO_AV1_LEVEL_4_2 = 10,
	STD_VIDEO_AV1_LEVEL_4_3 = 11,
	STD_VIDEO_AV1_LEVEL_5_0 = 12,
	STD_VIDEO_AV1_LEVEL_5_1 = 13,
	STD_VIDEO_AV1_LEVEL_5_2 = 14,
	STD_VIDEO_AV1_LEVEL_5_3 = 15,
	STD_VIDEO_AV1_LEVEL_6_0 = 16,
	STD_VIDEO_AV1_LEVEL_6_1 = 17,
	STD_VIDEO_AV1_LEVEL_6_2 = 18,
	STD_VIDEO_AV1_LEVEL_6_3 = 19,
	STD_VIDEO_AV1_LEVEL_7_0 = 20,
	STD_VIDEO_AV1_LEVEL_7_1 = 21,
	STD_VIDEO_AV1_LEVEL_7_2 = 22,
	STD_VIDEO_AV1_LEVEL_7_3 = 23,
	STD_VIDEO_AV1_LEVEL_INVALID = 0x7fffffff,
}
impl StdVideoAV1Level {
	pub const STD_VIDEO_AV1_LEVEL_MAX_ENUM: StdVideoAV1Level = StdVideoAV1Level::STD_VIDEO_AV1_LEVEL_INVALID;
}
/// enum `StdVideoAV1FrameType` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1FrameType {
	STD_VIDEO_AV1_FRAME_TYPE_KEY = 0,
	STD_VIDEO_AV1_FRAME_TYPE_INTER = 1,
	STD_VIDEO_AV1_FRAME_TYPE_INTRA_ONLY = 2,
	STD_VIDEO_AV1_FRAME_TYPE_SWITCH = 3,
	STD_VIDEO_AV1_FRAME_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoAV1FrameType {
	pub const STD_VIDEO_AV1_FRAME_TYPE_MAX_ENUM: StdVideoAV1FrameType = StdVideoAV1FrameType::STD_VIDEO_AV1_FRAME_TYPE_INVALID;
}
/// enum `StdVideoAV1ReferenceName` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1ReferenceName {
	STD_VIDEO_AV1_REFERENCE_NAME_INTRA_FRAME = 0,
	STD_VIDEO_AV1_REFERENCE_NAME_LAST_FRAME = 1,
	STD_VIDEO_AV1_REFERENCE_NAME_LAST2_FRAME = 2,
	STD_VIDEO_AV1_REFERENCE_NAME_LAST3_FRAME = 3,
	STD_VIDEO_AV1_REFERENCE_NAME_GOLDEN_FRAME = 4,
	STD_VIDEO_AV1_REFERENCE_NAME_BWDREF_FRAME = 5,
	STD_VIDEO_AV1_REFERENCE_NAME_ALTREF2_FRAME = 6,
	STD_VIDEO_AV1_REFERENCE_NAME_ALTREF_FRAME = 7,
	STD_VIDEO_AV1_REFERENCE_NAME_INVALID = 0x7fffffff,
}
impl StdVideoAV1ReferenceName {
	pub const STD_VIDEO_AV1_REFERENCE_NAME_MAX_ENUM: StdVideoAV1ReferenceName = StdVideoAV1ReferenceName::STD_VIDEO_AV1_REFERENCE_NAME_INVALID;
}
/// enum `StdVideoAV1InterpolationFilter` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1InterpolationFilter {
	STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP = 0,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH = 1,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP_SHARP = 2,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_BILINEAR = 3,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_SWITCHABLE = 4,
	STD_VIDEO_AV1_INTERPOLATION_FILTER_INVALID = 0x7fffffff,
}
impl StdVideoAV1InterpolationFilter {
	pub const STD_VIDEO_AV1_INTERPOLATION_FILTER_MAX_ENUM: StdVideoAV1InterpolationFilter = StdVideoAV1InterpolationFilter::STD_VIDEO_AV1_INTERPOLATION_FILTER_INVALID;
}
/// enum `StdVideoAV1TxMode` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1TxMode {
	STD_VIDEO_AV1_TX_MODE_ONLY_4X4 = 0,
	STD_VIDEO_AV1_TX_MODE_LARGEST = 1,
	STD_VIDEO_AV1_TX_MODE_SELECT = 2,
	STD_VIDEO_AV1_TX_MODE_INVALID = 0x7fffffff,
}
impl StdVideoAV1TxMode {
	pub const STD_VIDEO_AV1_TX_MODE_MAX_ENUM: StdVideoAV1TxMode = StdVideoAV1TxMode::STD_VIDEO_AV1_TX_MODE_INVALID;
}
/// enum `StdVideoAV1FrameRestorationType` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1FrameRestorationType {
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_NONE = 0,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_WIENER = 1,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_SGRPROJ = 2,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_SWITCHABLE = 3,
	STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoAV1FrameRestorationType {
	pub const STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_MAX_ENUM: StdVideoAV1FrameRestorationType = StdVideoAV1FrameRestorationType::STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_INVALID;
}
/// enum `StdVideoAV1ColorPrimaries` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1ColorPrimaries {
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_709 = 1,
	STD_VIDEO_AV1_COLOR_PRIMARIES_UNSPECIFIED = 2,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_470_M = 4,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_470_B_G = 5,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_601 = 6,
	STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_240 = 7,
	STD_VIDEO_AV1_COLOR_PRIMARIES_GENERIC_FILM = 8,
	STD_VIDEO_AV1_COLOR_PRIMARIES_BT_2020 = 9,
	STD_VIDEO_AV1_COLOR_PRIMARIES_XYZ = 10,
	STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_431 = 11,
	STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_432 = 12,
	STD_VIDEO_AV1_COLOR_PRIMARIES_EBU_3213 = 22,
	STD_VIDEO_AV1_COLOR_PRIMARIES_INVALID = 0x7fffffff,
}
impl StdVideoAV1ColorPrimaries {
	pub const STD_VIDEO_AV1_COLOR_PRIMARIES_BT_UNSPECIFIED: StdVideoAV1ColorPrimaries = StdVideoAV1ColorPrimaries::STD_VIDEO_AV1_COLOR_PRIMARIES_UNSPECIFIED;
	pub const STD_VIDEO_AV1_COLOR_PRIMARIES_MAX_ENUM: StdVideoAV1ColorPrimaries = StdVideoAV1ColorPrimaries::STD_VIDEO_AV1_COLOR_PRIMARIES_INVALID;
}
/// enum `StdVideoAV1TransferCharacteristics` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1TransferCharacteristics {
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_RESERVED_0 = 0,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_709 = 1,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_UNSPECIFIED = 2,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_RESERVED_3 = 3,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_470_M = 4,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_470_B_G = 5,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_601 = 6,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_240 = 7,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LINEAR = 8,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LOG_100 = 9,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LOG_100_SQRT10 = 10,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_IEC_61966 = 11,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_1361 = 12,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SRGB = 13,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_2020_10_BIT = 14,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_2020_12_BIT = 15,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_2084 = 16,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_428 = 17,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_HLG = 18,
	STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_INVALID = 0x7fffffff,
}
impl StdVideoAV1TransferCharacteristics {
	pub const STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_MAX_ENUM: StdVideoAV1TransferCharacteristics = StdVideoAV1TransferCharacteristics::STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_INVALID;
}
/// enum `StdVideoAV1MatrixCoefficients` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1MatrixCoefficients {
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_IDENTITY = 0,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_709 = 1,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_UNSPECIFIED = 2,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_RESERVED_3 = 3,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_FCC = 4,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_470_B_G = 5,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_601 = 6,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_240 = 7,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_YCGCO = 8,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_2020_NCL = 9,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_2020_CL = 10,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_2085 = 11,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_CHROMAT_NCL = 12,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_CHROMAT_CL = 13,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_ICTCP = 14,
	STD_VIDEO_AV1_MATRIX_COEFFICIENTS_INVALID = 0x7fffffff,
}
impl StdVideoAV1MatrixCoefficients {
	pub const STD_VIDEO_AV1_MATRIX_COEFFICIENTS_MAX_ENUM: StdVideoAV1MatrixCoefficients = StdVideoAV1MatrixCoefficients::STD_VIDEO_AV1_MATRIX_COEFFICIENTS_INVALID;
}
/// enum `StdVideoAV1ChromaSamplePosition` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoAV1ChromaSamplePosition {
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_UNKNOWN = 0,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_VERTICAL = 1,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_COLOCATED = 2,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_RESERVED = 3,
	STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_INVALID = 0x7fffffff,
}
impl StdVideoAV1ChromaSamplePosition {
	pub const STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_MAX_ENUM: StdVideoAV1ChromaSamplePosition = StdVideoAV1ChromaSamplePosition::STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_INVALID;
}
/// struct `StdVideoAV1ColorConfigFlags` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1ColorConfigFlags {
	/// Bitfield: mono_chrome: u32 in 1 bits
	/// Bitfield: color_range: u32 in 1 bits
	/// Bitfield: separate_uv_delta_q: u32 in 1 bits
	/// Bitfield: color_description_present_flag: u32 in 1 bits
	/// Bitfield: reserved: u32 in 28 bits
	bitfield1: u32,
}
impl StdVideoAV1ColorConfigFlags {
	pub fn get_mono_chrome(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_mono_chrome(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_color_range(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_color_range(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_separate_uv_delta_q(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_separate_uv_delta_q(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_color_description_present_flag(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_color_description_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 4) & 0xfffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0xfffffff) << 4;
	}
}
impl Debug for StdVideoAV1ColorConfigFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1ColorConfigFlags")
		.field("mono_chrome", &self.get_mono_chrome())
		.field("color_range", &self.get_color_range())
		.field("separate_uv_delta_q", &self.get_separate_uv_delta_q())
		.field("color_description_present_flag", &self.get_color_description_present_flag())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoAV1ColorConfig` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1ColorConfig {
	pub flags: StdVideoAV1ColorConfigFlags,
	pub BitDepth: u8,
	pub subsampling_x: u8,
	pub subsampling_y: u8,
	pub reserved1: u8,
	pub color_primaries: StdVideoAV1ColorPrimaries,
	pub transfer_characteristics: StdVideoAV1TransferCharacteristics,
	pub matrix_coefficients: StdVideoAV1MatrixCoefficients,
	pub chroma_sample_position: StdVideoAV1ChromaSamplePosition,
}
impl Debug for StdVideoAV1ColorConfig {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1ColorConfig")
		.field("flags", &self.flags)
		.field("BitDepth", &self.BitDepth)
		.field("subsampling_x", &self.subsampling_x)
		.field("subsampling_y", &self.subsampling_y)
		.field("reserved1", &self.reserved1)
		.field("color_primaries", &self.color_primaries)
		.field("transfer_characteristics", &self.transfer_characteristics)
		.field("matrix_coefficients", &self.matrix_coefficients)
		.field("chroma_sample_position", &self.chroma_sample_position)
		.finish()
	}
}
/// struct `StdVideoAV1TimingInfoFlags` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1TimingInfoFlags {
	/// Bitfield: equal_picture_interval: u32 in 1 bits
	/// Bitfield: reserved: u32 in 31 bits
	bitfield1: u32,
}
impl StdVideoAV1TimingInfoFlags {
	pub fn get_equal_picture_interval(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_equal_picture_interval(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x7fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7fffffff) << 1;
	}
}
impl Debug for StdVideoAV1TimingInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1TimingInfoFlags")
		.field("equal_picture_interval", &self.get_equal_picture_interval())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoAV1TimingInfo` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1TimingInfo {
	pub flags: StdVideoAV1TimingInfoFlags,
	pub num_units_in_display_tick: u32,
	pub time_scale: u32,
	pub num_ticks_per_picture_minus_1: u32,
}
impl Debug for StdVideoAV1TimingInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1TimingInfo")
		.field("flags", &self.flags)
		.field("num_units_in_display_tick", &self.num_units_in_display_tick)
		.field("time_scale", &self.time_scale)
		.field("num_ticks_per_picture_minus_1", &self.num_ticks_per_picture_minus_1)
		.finish()
	}
}
/// struct `StdVideoAV1LoopFilterFlags` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1LoopFilterFlags {
	/// Bitfield: loop_filter_delta_enabled: u32 in 1 bits
	/// Bitfield: loop_filter_delta_update: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoAV1LoopFilterFlags {
	pub fn get_loop_filter_delta_enabled(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_loop_filter_delta_enabled(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_loop_filter_delta_update(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_loop_filter_delta_update(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
impl Debug for StdVideoAV1LoopFilterFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1LoopFilterFlags")
		.field("loop_filter_delta_enabled", &self.get_loop_filter_delta_enabled())
		.field("loop_filter_delta_update", &self.get_loop_filter_delta_update())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoAV1LoopFilter` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1LoopFilter {
	pub flags: StdVideoAV1LoopFilterFlags,
	pub loop_filter_level: [u8; STD_VIDEO_AV1_MAX_LOOP_FILTER_STRENGTHS as usize],
	pub loop_filter_sharpness: u8,
	pub update_ref_delta: u8,
	pub loop_filter_ref_deltas: [i8; STD_VIDEO_AV1_TOTAL_REFS_PER_FRAME as usize],
	pub update_mode_delta: u8,
	pub loop_filter_mode_deltas: [i8; STD_VIDEO_AV1_LOOP_FILTER_ADJUSTMENTS as usize],
}
impl Debug for StdVideoAV1LoopFilter {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1LoopFilter")
		.field("flags", &self.flags)
		.field("loop_filter_level", &self.loop_filter_level)
		.field("loop_filter_sharpness", &self.loop_filter_sharpness)
		.field("update_ref_delta", &self.update_ref_delta)
		.field("loop_filter_ref_deltas", &format_args!("{}", maybe_string(&self.loop_filter_ref_deltas)))
		.field("update_mode_delta", &self.update_mode_delta)
		.field("loop_filter_mode_deltas", &format_args!("{}", maybe_string(&self.loop_filter_mode_deltas)))
		.finish()
	}
}
/// struct `StdVideoAV1QuantizationFlags` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1QuantizationFlags {
	/// Bitfield: using_qmatrix: u32 in 1 bits
	/// Bitfield: diff_uv_delta: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoAV1QuantizationFlags {
	pub fn get_using_qmatrix(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_using_qmatrix(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_diff_uv_delta(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_diff_uv_delta(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
impl Debug for StdVideoAV1QuantizationFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1QuantizationFlags")
		.field("using_qmatrix", &self.get_using_qmatrix())
		.field("diff_uv_delta", &self.get_diff_uv_delta())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoAV1Quantization` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1Quantization {
	pub flags: StdVideoAV1QuantizationFlags,
	pub base_q_idx: u8,
	pub DeltaQYDc: i8,
	pub DeltaQUDc: i8,
	pub DeltaQUAc: i8,
	pub DeltaQVDc: i8,
	pub DeltaQVAc: i8,
	pub qm_y: u8,
	pub qm_u: u8,
	pub qm_v: u8,
}
impl Debug for StdVideoAV1Quantization {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1Quantization")
		.field("flags", &self.flags)
		.field("base_q_idx", &self.base_q_idx)
		.field("DeltaQYDc", &self.DeltaQYDc)
		.field("DeltaQUDc", &self.DeltaQUDc)
		.field("DeltaQUAc", &self.DeltaQUAc)
		.field("DeltaQVDc", &self.DeltaQVDc)
		.field("DeltaQVAc", &self.DeltaQVAc)
		.field("qm_y", &self.qm_y)
		.field("qm_u", &self.qm_u)
		.field("qm_v", &self.qm_v)
		.finish()
	}
}
/// struct `StdVideoAV1Segmentation` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1Segmentation {
	pub FeatureEnabled: [u8; STD_VIDEO_AV1_MAX_SEGMENTS as usize],
	pub FeatureData: [[i16; STD_VIDEO_AV1_SEG_LVL_MAX as usize]; STD_VIDEO_AV1_MAX_SEGMENTS as usize],
}
impl Debug for StdVideoAV1Segmentation {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1Segmentation")
		.field("FeatureEnabled", &self.FeatureEnabled)
		.field("FeatureData", &self.FeatureData)
		.finish()
	}
}
/// struct `StdVideoAV1TileInfoFlags` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1TileInfoFlags {
	/// Bitfield: uniform_tile_spacing_flag: u32 in 1 bits
	/// Bitfield: reserved: u32 in 31 bits
	bitfield1: u32,
}
impl StdVideoAV1TileInfoFlags {
	pub fn get_uniform_tile_spacing_flag(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_uniform_tile_spacing_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x7fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7fffffff) << 1;
	}
}
impl Debug for StdVideoAV1TileInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1TileInfoFlags")
		.field("uniform_tile_spacing_flag", &self.get_uniform_tile_spacing_flag())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoAV1TileInfo` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1TileInfo {
	pub flags: StdVideoAV1TileInfoFlags,
	pub TileCols: u8,
	pub TileRows: u8,
	pub context_update_tile_id: u16,
	pub tile_size_bytes_minus_1: u8,
	pub reserved1: [u8; 7 as usize],
	pub pMiColStarts: *const uint16_t,
	pub pMiRowStarts: *const uint16_t,
	pub pWidthInSbsMinus1: *const uint16_t,
	pub pHeightInSbsMinus1: *const uint16_t,
}
impl Debug for StdVideoAV1TileInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1TileInfo")
		.field("flags", &self.flags)
		.field("TileCols", &self.TileCols)
		.field("TileRows", &self.TileRows)
		.field("context_update_tile_id", &self.context_update_tile_id)
		.field("tile_size_bytes_minus_1", &self.tile_size_bytes_minus_1)
		.field("reserved1", &self.reserved1)
		.field("pMiColStarts", &self.pMiColStarts)
		.field("pMiRowStarts", &self.pMiRowStarts)
		.field("pWidthInSbsMinus1", &self.pWidthInSbsMinus1)
		.field("pHeightInSbsMinus1", &self.pHeightInSbsMinus1)
		.finish()
	}
}
/// struct `StdVideoAV1CDEF` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1CDEF {
	pub cdef_damping_minus_3: u8,
	pub cdef_bits: u8,
	pub cdef_y_pri_strength: [u8; STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS as usize],
	pub cdef_y_sec_strength: [u8; STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS as usize],
	pub cdef_uv_pri_strength: [u8; STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS as usize],
	pub cdef_uv_sec_strength: [u8; STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS as usize],
}
impl Debug for StdVideoAV1CDEF {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1CDEF")
		.field("cdef_damping_minus_3", &self.cdef_damping_minus_3)
		.field("cdef_bits", &self.cdef_bits)
		.field("cdef_y_pri_strength", &self.cdef_y_pri_strength)
		.field("cdef_y_sec_strength", &self.cdef_y_sec_strength)
		.field("cdef_uv_pri_strength", &self.cdef_uv_pri_strength)
		.field("cdef_uv_sec_strength", &self.cdef_uv_sec_strength)
		.finish()
	}
}
/// struct `StdVideoAV1LoopRestoration` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1LoopRestoration {
	pub FrameRestorationType: [StdVideoAV1FrameRestorationType; STD_VIDEO_AV1_MAX_NUM_PLANES as usize],
	pub LoopRestorationSize: [u16; STD_VIDEO_AV1_MAX_NUM_PLANES as usize],
}
impl Debug for StdVideoAV1LoopRestoration {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1LoopRestoration")
		.field("FrameRestorationType", &self.FrameRestorationType)
		.field("LoopRestorationSize", &self.LoopRestorationSize)
		.finish()
	}
}
/// struct `StdVideoAV1GlobalMotion` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1GlobalMotion {
	pub GmType: [u8; STD_VIDEO_AV1_NUM_REF_FRAMES as usize],
	pub gm_params: [[i32; STD_VIDEO_AV1_GLOBAL_MOTION_PARAMS as usize]; STD_VIDEO_AV1_NUM_REF_FRAMES as usize],
}
impl Debug for StdVideoAV1GlobalMotion {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1GlobalMotion")
		.field("GmType", &self.GmType)
		.field("gm_params", &self.gm_params)
		.finish()
	}
}
/// struct `StdVideoAV1FilmGrainFlags` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1FilmGrainFlags {
	/// Bitfield: chroma_scaling_from_luma: u32 in 1 bits
	/// Bitfield: overlap_flag: u32 in 1 bits
	/// Bitfield: clip_to_restricted_range: u32 in 1 bits
	/// Bitfield: update_grain: u32 in 1 bits
	/// Bitfield: reserved: u32 in 28 bits
	bitfield1: u32,
}
impl StdVideoAV1FilmGrainFlags {
	pub fn get_chroma_scaling_from_luma(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_chroma_scaling_from_luma(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_overlap_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_overlap_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_clip_to_restricted_range(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_clip_to_restricted_range(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_update_grain(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_update_grain(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 4) & 0xfffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0xfffffff) << 4;
	}
}
impl Debug for StdVideoAV1FilmGrainFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1FilmGrainFlags")
		.field("chroma_scaling_from_luma", &self.get_chroma_scaling_from_luma())
		.field("overlap_flag", &self.get_overlap_flag())
		.field("clip_to_restricted_range", &self.get_clip_to_restricted_range())
		.field("update_grain", &self.get_update_grain())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoAV1FilmGrain` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1FilmGrain {
	pub flags: StdVideoAV1FilmGrainFlags,
	pub grain_scaling_minus_8: u8,
	pub ar_coeff_lag: u8,
	pub ar_coeff_shift_minus_6: u8,
	pub grain_scale_shift: u8,
	pub grain_seed: u16,
	pub film_grain_params_ref_idx: u8,
	pub num_y_points: u8,
	pub point_y_value: [u8; STD_VIDEO_AV1_MAX_NUM_Y_POINTS as usize],
	pub point_y_scaling: [u8; STD_VIDEO_AV1_MAX_NUM_Y_POINTS as usize],
	pub num_cb_points: u8,
	pub point_cb_value: [u8; STD_VIDEO_AV1_MAX_NUM_CB_POINTS as usize],
	pub point_cb_scaling: [u8; STD_VIDEO_AV1_MAX_NUM_CB_POINTS as usize],
	pub num_cr_points: u8,
	pub point_cr_value: [u8; STD_VIDEO_AV1_MAX_NUM_CR_POINTS as usize],
	pub point_cr_scaling: [u8; STD_VIDEO_AV1_MAX_NUM_CR_POINTS as usize],
	pub ar_coeffs_y_plus_128: [i8; STD_VIDEO_AV1_MAX_NUM_POS_LUMA as usize],
	pub ar_coeffs_cb_plus_128: [i8; STD_VIDEO_AV1_MAX_NUM_POS_CHROMA as usize],
	pub ar_coeffs_cr_plus_128: [i8; STD_VIDEO_AV1_MAX_NUM_POS_CHROMA as usize],
	pub cb_mult: u8,
	pub cb_luma_mult: u8,
	pub cb_offset: u16,
	pub cr_mult: u8,
	pub cr_luma_mult: u8,
	pub cr_offset: u16,
}
impl Debug for StdVideoAV1FilmGrain {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1FilmGrain")
		.field("flags", &self.flags)
		.field("grain_scaling_minus_8", &self.grain_scaling_minus_8)
		.field("ar_coeff_lag", &self.ar_coeff_lag)
		.field("ar_coeff_shift_minus_6", &self.ar_coeff_shift_minus_6)
		.field("grain_scale_shift", &self.grain_scale_shift)
		.field("grain_seed", &self.grain_seed)
		.field("film_grain_params_ref_idx", &self.film_grain_params_ref_idx)
		.field("num_y_points", &self.num_y_points)
		.field("point_y_value", &self.point_y_value)
		.field("point_y_scaling", &self.point_y_scaling)
		.field("num_cb_points", &self.num_cb_points)
		.field("point_cb_value", &self.point_cb_value)
		.field("point_cb_scaling", &self.point_cb_scaling)
		.field("num_cr_points", &self.num_cr_points)
		.field("point_cr_value", &self.point_cr_value)
		.field("point_cr_scaling", &self.point_cr_scaling)
		.field("ar_coeffs_y_plus_128", &format_args!("{}", maybe_string(&self.ar_coeffs_y_plus_128)))
		.field("ar_coeffs_cb_plus_128", &format_args!("{}", maybe_string(&self.ar_coeffs_cb_plus_128)))
		.field("ar_coeffs_cr_plus_128", &format_args!("{}", maybe_string(&self.ar_coeffs_cr_plus_128)))
		.field("cb_mult", &self.cb_mult)
		.field("cb_luma_mult", &self.cb_luma_mult)
		.field("cb_offset", &self.cb_offset)
		.field("cr_mult", &self.cr_mult)
		.field("cr_luma_mult", &self.cr_luma_mult)
		.field("cr_offset", &self.cr_offset)
		.finish()
	}
}
/// struct `StdVideoAV1SequenceHeaderFlags` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1SequenceHeaderFlags {
	/// Bitfield: still_picture: u32 in 1 bits
	/// Bitfield: reduced_still_picture_header: u32 in 1 bits
	/// Bitfield: use_128x128_superblock: u32 in 1 bits
	/// Bitfield: enable_filter_intra: u32 in 1 bits
	/// Bitfield: enable_intra_edge_filter: u32 in 1 bits
	/// Bitfield: enable_interintra_compound: u32 in 1 bits
	/// Bitfield: enable_masked_compound: u32 in 1 bits
	/// Bitfield: enable_warped_motion: u32 in 1 bits
	/// Bitfield: enable_dual_filter: u32 in 1 bits
	/// Bitfield: enable_order_hint: u32 in 1 bits
	/// Bitfield: enable_jnt_comp: u32 in 1 bits
	/// Bitfield: enable_ref_frame_mvs: u32 in 1 bits
	/// Bitfield: frame_id_numbers_present_flag: u32 in 1 bits
	/// Bitfield: enable_superres: u32 in 1 bits
	/// Bitfield: enable_cdef: u32 in 1 bits
	/// Bitfield: enable_restoration: u32 in 1 bits
	/// Bitfield: film_grain_params_present: u32 in 1 bits
	/// Bitfield: timing_info_present_flag: u32 in 1 bits
	/// Bitfield: initial_display_delay_present_flag: u32 in 1 bits
	/// Bitfield: reserved: u32 in 13 bits
	bitfield1: u32,
}
impl StdVideoAV1SequenceHeaderFlags {
	pub fn get_still_picture(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_still_picture(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_reduced_still_picture_header(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_reduced_still_picture_header(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_use_128x128_superblock(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_use_128x128_superblock(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_enable_filter_intra(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_enable_filter_intra(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_enable_intra_edge_filter(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_enable_intra_edge_filter(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_enable_interintra_compound(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_enable_interintra_compound(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_enable_masked_compound(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_enable_masked_compound(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_enable_warped_motion(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_enable_warped_motion(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_enable_dual_filter(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_enable_dual_filter(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_enable_order_hint(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_enable_order_hint(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_enable_jnt_comp(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_enable_jnt_comp(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_enable_ref_frame_mvs(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_enable_ref_frame_mvs(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
	pub fn get_frame_id_numbers_present_flag(&self) -> u32 {
		(self.bitfield1 >> 12) & 0x1
	}
	pub fn set_frame_id_numbers_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 12;
	}
	pub fn get_enable_superres(&self) -> u32 {
		(self.bitfield1 >> 13) & 0x1
	}
	pub fn set_enable_superres(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 13;
	}
	pub fn get_enable_cdef(&self) -> u32 {
		(self.bitfield1 >> 14) & 0x1
	}
	pub fn set_enable_cdef(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 14;
	}
	pub fn get_enable_restoration(&self) -> u32 {
		(self.bitfield1 >> 15) & 0x1
	}
	pub fn set_enable_restoration(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 15;
	}
	pub fn get_film_grain_params_present(&self) -> u32 {
		(self.bitfield1 >> 16) & 0x1
	}
	pub fn set_film_grain_params_present(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 16;
	}
	pub fn get_timing_info_present_flag(&self) -> u32 {
		(self.bitfield1 >> 17) & 0x1
	}
	pub fn set_timing_info_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 17;
	}
	pub fn get_initial_display_delay_present_flag(&self) -> u32 {
		(self.bitfield1 >> 18) & 0x1
	}
	pub fn set_initial_display_delay_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 18;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 19) & 0x1fff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1fff) << 19;
	}
}
impl Debug for StdVideoAV1SequenceHeaderFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1SequenceHeaderFlags")
		.field("still_picture", &self.get_still_picture())
		.field("reduced_still_picture_header", &self.get_reduced_still_picture_header())
		.field("use_128x128_superblock", &self.get_use_128x128_superblock())
		.field("enable_filter_intra", &self.get_enable_filter_intra())
		.field("enable_intra_edge_filter", &self.get_enable_intra_edge_filter())
		.field("enable_interintra_compound", &self.get_enable_interintra_compound())
		.field("enable_masked_compound", &self.get_enable_masked_compound())
		.field("enable_warped_motion", &self.get_enable_warped_motion())
		.field("enable_dual_filter", &self.get_enable_dual_filter())
		.field("enable_order_hint", &self.get_enable_order_hint())
		.field("enable_jnt_comp", &self.get_enable_jnt_comp())
		.field("enable_ref_frame_mvs", &self.get_enable_ref_frame_mvs())
		.field("frame_id_numbers_present_flag", &self.get_frame_id_numbers_present_flag())
		.field("enable_superres", &self.get_enable_superres())
		.field("enable_cdef", &self.get_enable_cdef())
		.field("enable_restoration", &self.get_enable_restoration())
		.field("film_grain_params_present", &self.get_film_grain_params_present())
		.field("timing_info_present_flag", &self.get_timing_info_present_flag())
		.field("initial_display_delay_present_flag", &self.get_initial_display_delay_present_flag())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoAV1SequenceHeader` from vulkan_video_codec_av1std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoAV1SequenceHeader {
	pub flags: StdVideoAV1SequenceHeaderFlags,
	pub seq_profile: StdVideoAV1Profile,
	pub frame_width_bits_minus_1: u8,
	pub frame_height_bits_minus_1: u8,
	pub max_frame_width_minus_1: u16,
	pub max_frame_height_minus_1: u16,
	pub delta_frame_id_length_minus_2: u8,
	pub additional_frame_id_length_minus_1: u8,
	pub order_hint_bits_minus_1: u8,
	pub seq_force_integer_mv: u8,
	pub seq_force_screen_content_tools: u8,
	pub reserved1: [u8; 5 as usize],
	pub pColorConfig: *const StdVideoAV1ColorConfig,
	pub pTimingInfo: *const StdVideoAV1TimingInfo,
}
impl Debug for StdVideoAV1SequenceHeader {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoAV1SequenceHeader")
		.field("flags", &self.flags)
		.field("seq_profile", &self.seq_profile)
		.field("frame_width_bits_minus_1", &self.frame_width_bits_minus_1)
		.field("frame_height_bits_minus_1", &self.frame_height_bits_minus_1)
		.field("max_frame_width_minus_1", &self.max_frame_width_minus_1)
		.field("max_frame_height_minus_1", &self.max_frame_height_minus_1)
		.field("delta_frame_id_length_minus_2", &self.delta_frame_id_length_minus_2)
		.field("additional_frame_id_length_minus_1", &self.additional_frame_id_length_minus_1)
		.field("order_hint_bits_minus_1", &self.order_hint_bits_minus_1)
		.field("seq_force_integer_mv", &self.seq_force_integer_mv)
		.field("seq_force_screen_content_tools", &self.seq_force_screen_content_tools)
		.field("reserved1", &self.reserved1)
		.field("pColorConfig", &self.pColorConfig)
		.field("pTimingInfo", &self.pTimingInfo)
		.finish()
	}
}
/// trait for `vulkan_video_codec_av1std`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vulkan_video_codec_av1std.html>
pub trait vulkan_video_codec_av1std: Debug {}
/// struct for `vulkan_video_codec_av1std`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_av1std {}
impl vulkan_video_codec_av1std for Vulkan_video_codec_av1std {}
impl Default for Vulkan_video_codec_av1std {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_av1std {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_API_VERSION_1_0_0` from vulkan_video_codec_av1std_decode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_API_VERSION_1_0_0.html>
pub const VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_API_VERSION_1_0_0: u32 = 0x400000;
/// struct `StdVideoDecodeAV1PictureInfoFlags` from vulkan_video_codec_av1std_decode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoDecodeAV1PictureInfoFlags {
	/// Bitfield: error_resilient_mode: u32 in 1 bits
	/// Bitfield: disable_cdf_update: u32 in 1 bits
	/// Bitfield: use_superres: u32 in 1 bits
	/// Bitfield: render_and_frame_size_different: u32 in 1 bits
	/// Bitfield: allow_screen_content_tools: u32 in 1 bits
	/// Bitfield: is_filter_switchable: u32 in 1 bits
	/// Bitfield: force_integer_mv: u32 in 1 bits
	/// Bitfield: frame_size_override_flag: u32 in 1 bits
	/// Bitfield: buffer_removal_time_present_flag: u32 in 1 bits
	/// Bitfield: allow_intrabc: u32 in 1 bits
	/// Bitfield: frame_refs_short_signaling: u32 in 1 bits
	/// Bitfield: allow_high_precision_mv: u32 in 1 bits
	/// Bitfield: is_motion_mode_switchable: u32 in 1 bits
	/// Bitfield: use_ref_frame_mvs: u32 in 1 bits
	/// Bitfield: disable_frame_end_update_cdf: u32 in 1 bits
	/// Bitfield: allow_warped_motion: u32 in 1 bits
	/// Bitfield: reduced_tx_set: u32 in 1 bits
	/// Bitfield: reference_select: u32 in 1 bits
	/// Bitfield: skip_mode_present: u32 in 1 bits
	/// Bitfield: delta_q_present: u32 in 1 bits
	/// Bitfield: delta_lf_present: u32 in 1 bits
	/// Bitfield: delta_lf_multi: u32 in 1 bits
	/// Bitfield: segmentation_enabled: u32 in 1 bits
	/// Bitfield: segmentation_update_map: u32 in 1 bits
	/// Bitfield: segmentation_temporal_update: u32 in 1 bits
	/// Bitfield: segmentation_update_data: u32 in 1 bits
	/// Bitfield: UsesLr: u32 in 1 bits
	/// Bitfield: usesChromaLr: u32 in 1 bits
	/// Bitfield: apply_grain: u32 in 1 bits
	/// Bitfield: reserved: u32 in 3 bits
	bitfield1: u32,
}
impl StdVideoDecodeAV1PictureInfoFlags {
	pub fn get_error_resilient_mode(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_error_resilient_mode(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_disable_cdf_update(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_disable_cdf_update(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_use_superres(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_use_superres(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_render_and_frame_size_different(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_render_and_frame_size_different(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_allow_screen_content_tools(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_allow_screen_content_tools(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_is_filter_switchable(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_is_filter_switchable(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_force_integer_mv(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_force_integer_mv(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_frame_size_override_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_frame_size_override_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_buffer_removal_time_present_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_buffer_removal_time_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_allow_intrabc(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_allow_intrabc(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_frame_refs_short_signaling(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_frame_refs_short_signaling(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_allow_high_precision_mv(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_allow_high_precision_mv(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
	pub fn get_is_motion_mode_switchable(&self) -> u32 {
		(self.bitfield1 >> 12) & 0x1
	}
	pub fn set_is_motion_mode_switchable(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 12;
	}
	pub fn get_use_ref_frame_mvs(&self) -> u32 {
		(self.bitfield1 >> 13) & 0x1
	}
	pub fn set_use_ref_frame_mvs(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 13;
	}
	pub fn get_disable_frame_end_update_cdf(&self) -> u32 {
		(self.bitfield1 >> 14) & 0x1
	}
	pub fn set_disable_frame_end_update_cdf(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 14;
	}
	pub fn get_allow_warped_motion(&self) -> u32 {
		(self.bitfield1 >> 15) & 0x1
	}
	pub fn set_allow_warped_motion(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 15;
	}
	pub fn get_reduced_tx_set(&self) -> u32 {
		(self.bitfield1 >> 16) & 0x1
	}
	pub fn set_reduced_tx_set(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 16;
	}
	pub fn get_reference_select(&self) -> u32 {
		(self.bitfield1 >> 17) & 0x1
	}
	pub fn set_reference_select(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 17;
	}
	pub fn get_skip_mode_present(&self) -> u32 {
		(self.bitfield1 >> 18) & 0x1
	}
	pub fn set_skip_mode_present(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 18;
	}
	pub fn get_delta_q_present(&self) -> u32 {
		(self.bitfield1 >> 19) & 0x1
	}
	pub fn set_delta_q_present(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 19;
	}
	pub fn get_delta_lf_present(&self) -> u32 {
		(self.bitfield1 >> 20) & 0x1
	}
	pub fn set_delta_lf_present(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 20;
	}
	pub fn get_delta_lf_multi(&self) -> u32 {
		(self.bitfield1 >> 21) & 0x1
	}
	pub fn set_delta_lf_multi(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 21;
	}
	pub fn get_segmentation_enabled(&self) -> u32 {
		(self.bitfield1 >> 22) & 0x1
	}
	pub fn set_segmentation_enabled(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 22;
	}
	pub fn get_segmentation_update_map(&self) -> u32 {
		(self.bitfield1 >> 23) & 0x1
	}
	pub fn set_segmentation_update_map(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 23;
	}
	pub fn get_segmentation_temporal_update(&self) -> u32 {
		(self.bitfield1 >> 24) & 0x1
	}
	pub fn set_segmentation_temporal_update(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 24;
	}
	pub fn get_segmentation_update_data(&self) -> u32 {
		(self.bitfield1 >> 25) & 0x1
	}
	pub fn set_segmentation_update_data(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 25;
	}
	pub fn get_UsesLr(&self) -> u32 {
		(self.bitfield1 >> 26) & 0x1
	}
	pub fn set_UsesLr(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 26;
	}
	pub fn get_usesChromaLr(&self) -> u32 {
		(self.bitfield1 >> 27) & 0x1
	}
	pub fn set_usesChromaLr(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 27;
	}
	pub fn get_apply_grain(&self) -> u32 {
		(self.bitfield1 >> 28) & 0x1
	}
	pub fn set_apply_grain(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 28;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 29) & 0x7
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7) << 29;
	}
}
impl Debug for StdVideoDecodeAV1PictureInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoDecodeAV1PictureInfoFlags")
		.field("error_resilient_mode", &self.get_error_resilient_mode())
		.field("disable_cdf_update", &self.get_disable_cdf_update())
		.field("use_superres", &self.get_use_superres())
		.field("render_and_frame_size_different", &self.get_render_and_frame_size_different())
		.field("allow_screen_content_tools", &self.get_allow_screen_content_tools())
		.field("is_filter_switchable", &self.get_is_filter_switchable())
		.field("force_integer_mv", &self.get_force_integer_mv())
		.field("frame_size_override_flag", &self.get_frame_size_override_flag())
		.field("buffer_removal_time_present_flag", &self.get_buffer_removal_time_present_flag())
		.field("allow_intrabc", &self.get_allow_intrabc())
		.field("frame_refs_short_signaling", &self.get_frame_refs_short_signaling())
		.field("allow_high_precision_mv", &self.get_allow_high_precision_mv())
		.field("is_motion_mode_switchable", &self.get_is_motion_mode_switchable())
		.field("use_ref_frame_mvs", &self.get_use_ref_frame_mvs())
		.field("disable_frame_end_update_cdf", &self.get_disable_frame_end_update_cdf())
		.field("allow_warped_motion", &self.get_allow_warped_motion())
		.field("reduced_tx_set", &self.get_reduced_tx_set())
		.field("reference_select", &self.get_reference_select())
		.field("skip_mode_present", &self.get_skip_mode_present())
		.field("delta_q_present", &self.get_delta_q_present())
		.field("delta_lf_present", &self.get_delta_lf_present())
		.field("delta_lf_multi", &self.get_delta_lf_multi())
		.field("segmentation_enabled", &self.get_segmentation_enabled())
		.field("segmentation_update_map", &self.get_segmentation_update_map())
		.field("segmentation_temporal_update", &self.get_segmentation_temporal_update())
		.field("segmentation_update_data", &self.get_segmentation_update_data())
		.field("UsesLr", &self.get_UsesLr())
		.field("usesChromaLr", &self.get_usesChromaLr())
		.field("apply_grain", &self.get_apply_grain())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoDecodeAV1PictureInfo` from vulkan_video_codec_av1std_decode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoDecodeAV1PictureInfo {
	pub flags: StdVideoDecodeAV1PictureInfoFlags,
	pub frame_type: StdVideoAV1FrameType,
	pub current_frame_id: u32,
	pub OrderHint: u8,
	pub primary_ref_frame: u8,
	pub refresh_frame_flags: u8,
	pub reserved1: u8,
	pub interpolation_filter: StdVideoAV1InterpolationFilter,
	pub TxMode: StdVideoAV1TxMode,
	pub delta_q_res: u8,
	pub delta_lf_res: u8,
	pub SkipModeFrame: [u8; STD_VIDEO_AV1_SKIP_MODE_FRAMES as usize],
	pub coded_denom: u8,
	pub reserved2: [u8; 3 as usize],
	pub OrderHints: [u8; STD_VIDEO_AV1_NUM_REF_FRAMES as usize],
	pub expectedFrameId: [u32; STD_VIDEO_AV1_NUM_REF_FRAMES as usize],
	pub pTileInfo: *const StdVideoAV1TileInfo,
	pub pQuantization: *const StdVideoAV1Quantization,
	pub pSegmentation: *const StdVideoAV1Segmentation,
	pub pLoopFilter: *const StdVideoAV1LoopFilter,
	pub pCDEF: *const StdVideoAV1CDEF,
	pub pLoopRestoration: *const StdVideoAV1LoopRestoration,
	pub pGlobalMotion: *const StdVideoAV1GlobalMotion,
	pub pFilmGrain: *const StdVideoAV1FilmGrain,
}
impl Debug for StdVideoDecodeAV1PictureInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoDecodeAV1PictureInfo")
		.field("flags", &self.flags)
		.field("frame_type", &self.frame_type)
		.field("current_frame_id", &self.current_frame_id)
		.field("OrderHint", &self.OrderHint)
		.field("primary_ref_frame", &self.primary_ref_frame)
		.field("refresh_frame_flags", &self.refresh_frame_flags)
		.field("reserved1", &self.reserved1)
		.field("interpolation_filter", &self.interpolation_filter)
		.field("TxMode", &self.TxMode)
		.field("delta_q_res", &self.delta_q_res)
		.field("delta_lf_res", &self.delta_lf_res)
		.field("SkipModeFrame", &self.SkipModeFrame)
		.field("coded_denom", &self.coded_denom)
		.field("reserved2", &self.reserved2)
		.field("OrderHints", &self.OrderHints)
		.field("expectedFrameId", &self.expectedFrameId)
		.field("pTileInfo", &self.pTileInfo)
		.field("pQuantization", &self.pQuantization)
		.field("pSegmentation", &self.pSegmentation)
		.field("pLoopFilter", &self.pLoopFilter)
		.field("pCDEF", &self.pCDEF)
		.field("pLoopRestoration", &self.pLoopRestoration)
		.field("pGlobalMotion", &self.pGlobalMotion)
		.field("pFilmGrain", &self.pFilmGrain)
		.finish()
	}
}
/// struct `StdVideoDecodeAV1ReferenceInfoFlags` from vulkan_video_codec_av1std_decode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoDecodeAV1ReferenceInfoFlags {
	/// Bitfield: disable_frame_end_update_cdf: u32 in 1 bits
	/// Bitfield: segmentation_enabled: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoDecodeAV1ReferenceInfoFlags {
	pub fn get_disable_frame_end_update_cdf(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_disable_frame_end_update_cdf(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_segmentation_enabled(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_segmentation_enabled(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
impl Debug for StdVideoDecodeAV1ReferenceInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoDecodeAV1ReferenceInfoFlags")
		.field("disable_frame_end_update_cdf", &self.get_disable_frame_end_update_cdf())
		.field("segmentation_enabled", &self.get_segmentation_enabled())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoDecodeAV1ReferenceInfo` from vulkan_video_codec_av1std_decode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoDecodeAV1ReferenceInfo {
	pub flags: StdVideoDecodeAV1ReferenceInfoFlags,
	pub frame_type: u8,
	pub RefFrameSignBias: u8,
	pub OrderHint: u8,
	pub SavedOrderHints: [u8; STD_VIDEO_AV1_NUM_REF_FRAMES as usize],
}
impl Debug for StdVideoDecodeAV1ReferenceInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoDecodeAV1ReferenceInfo")
		.field("flags", &self.flags)
		.field("frame_type", &self.frame_type)
		.field("RefFrameSignBias", &self.RefFrameSignBias)
		.field("OrderHint", &self.OrderHint)
		.field("SavedOrderHints", &self.SavedOrderHints)
		.finish()
	}
}
/// trait for `vulkan_video_codec_av1std_decode`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vulkan_video_codec_av1std_decode.html>
pub trait vulkan_video_codec_av1std_decode: Debug {}
/// struct for `vulkan_video_codec_av1std_decode`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_av1std_decode {}
impl vulkan_video_codec_av1std_decode for Vulkan_video_codec_av1std_decode {}
impl Default for Vulkan_video_codec_av1std_decode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_av1std_decode {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkVideoEncodeAV1CapabilityFlagsKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1CapabilityFlagsKHR.html>
pub type VkVideoEncodeAV1CapabilityFlagsKHR = VkFlags;
/// type definition `VkVideoEncodeAV1StdFlagsKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1StdFlagsKHR.html>
pub type VkVideoEncodeAV1StdFlagsKHR = VkFlags;
/// type definition `VkVideoEncodeAV1SuperblockSizeFlagsKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1SuperblockSizeFlagsKHR.html>
pub type VkVideoEncodeAV1SuperblockSizeFlagsKHR = VkFlags;
/// type definition `VkVideoEncodeAV1RateControlFlagsKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1RateControlFlagsKHR.html>
pub type VkVideoEncodeAV1RateControlFlagsKHR = VkFlags;
/// enum `VkVideoEncodeAV1PredictionModeKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1PredictionModeKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeAV1PredictionModeKHR {
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR = 0,
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR = 1,
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR = 2,
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR = 3,
	VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeAV1RateControlGroupKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1RateControlGroupKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeAV1RateControlGroupKHR {
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR = 0,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR = 1,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR = 2,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeAV1CapabilityFlagBitsKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1CapabilityFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeAV1CapabilityFlagBitsKHR {
	VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR = 0x00000010,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_COMPOUND_PREDICTION_INTRA_REFRESH_BIT_KHR = 0x00000020,
	VK_VIDEO_ENCODE_AV1_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeAV1StdFlagBitsKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1StdFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeAV1StdFlagBitsKHR {
	VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_AV1_STD_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeAV1SuperblockSizeFlagBitsKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1SuperblockSizeFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeAV1SuperblockSizeFlagBitsKHR {
	VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkVideoEncodeAV1RateControlFlagBitsKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1RateControlFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeAV1RateControlFlagBitsKHR {
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_AV1_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// struct `VkPhysicalDeviceVideoEncodeAV1FeaturesKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVideoEncodeAV1FeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVideoEncodeAV1FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub videoEncodeAV1: VkBool32,
}
impl Debug for VkPhysicalDeviceVideoEncodeAV1FeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVideoEncodeAV1FeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("videoEncodeAV1", &self.videoEncodeAV1)
		.finish()
	}
}
/// struct `VkVideoEncodeAV1CapabilitiesKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1CapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeAV1CapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkVideoEncodeAV1CapabilityFlagsKHR,
	pub maxLevel: StdVideoAV1Level,
	pub codedPictureAlignment: VkExtent2D,
	pub maxTiles: VkExtent2D,
	pub minTileSize: VkExtent2D,
	pub maxTileSize: VkExtent2D,
	pub superblockSizes: VkVideoEncodeAV1SuperblockSizeFlagsKHR,
	pub maxSingleReferenceCount: u32,
	pub singleReferenceNameMask: u32,
	pub maxUnidirectionalCompoundReferenceCount: u32,
	pub maxUnidirectionalCompoundGroup1ReferenceCount: u32,
	pub unidirectionalCompoundReferenceNameMask: u32,
	pub maxBidirectionalCompoundReferenceCount: u32,
	pub maxBidirectionalCompoundGroup1ReferenceCount: u32,
	pub maxBidirectionalCompoundGroup2ReferenceCount: u32,
	pub bidirectionalCompoundReferenceNameMask: u32,
	pub maxTemporalLayerCount: u32,
	pub maxSpatialLayerCount: u32,
	pub maxOperatingPoints: u32,
	pub minQIndex: u32,
	pub maxQIndex: u32,
	pub prefersGopRemainingFrames: VkBool32,
	pub requiresGopRemainingFrames: VkBool32,
	pub stdSyntaxFlags: VkVideoEncodeAV1StdFlagsKHR,
}
impl Debug for VkVideoEncodeAV1CapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeAV1CapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("maxLevel", &self.maxLevel)
		.field("codedPictureAlignment", &self.codedPictureAlignment)
		.field("maxTiles", &self.maxTiles)
		.field("minTileSize", &self.minTileSize)
		.field("maxTileSize", &self.maxTileSize)
		.field("superblockSizes", &self.superblockSizes)
		.field("maxSingleReferenceCount", &self.maxSingleReferenceCount)
		.field("singleReferenceNameMask", &self.singleReferenceNameMask)
		.field("maxUnidirectionalCompoundReferenceCount", &self.maxUnidirectionalCompoundReferenceCount)
		.field("maxUnidirectionalCompoundGroup1ReferenceCount", &self.maxUnidirectionalCompoundGroup1ReferenceCount)
		.field("unidirectionalCompoundReferenceNameMask", &self.unidirectionalCompoundReferenceNameMask)
		.field("maxBidirectionalCompoundReferenceCount", &self.maxBidirectionalCompoundReferenceCount)
		.field("maxBidirectionalCompoundGroup1ReferenceCount", &self.maxBidirectionalCompoundGroup1ReferenceCount)
		.field("maxBidirectionalCompoundGroup2ReferenceCount", &self.maxBidirectionalCompoundGroup2ReferenceCount)
		.field("bidirectionalCompoundReferenceNameMask", &self.bidirectionalCompoundReferenceNameMask)
		.field("maxTemporalLayerCount", &self.maxTemporalLayerCount)
		.field("maxSpatialLayerCount", &self.maxSpatialLayerCount)
		.field("maxOperatingPoints", &self.maxOperatingPoints)
		.field("minQIndex", &self.minQIndex)
		.field("maxQIndex", &self.maxQIndex)
		.field("prefersGopRemainingFrames", &self.prefersGopRemainingFrames)
		.field("requiresGopRemainingFrames", &self.requiresGopRemainingFrames)
		.field("stdSyntaxFlags", &self.stdSyntaxFlags)
		.finish()
	}
}
/// struct `VkVideoEncodeAV1QIndexKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1QIndexKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeAV1QIndexKHR {
	pub intraQIndex: u32,
	pub predictiveQIndex: u32,
	pub bipredictiveQIndex: u32,
}
impl Debug for VkVideoEncodeAV1QIndexKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeAV1QIndexKHR")
		.field("intraQIndex", &self.intraQIndex)
		.field("predictiveQIndex", &self.predictiveQIndex)
		.field("bipredictiveQIndex", &self.bipredictiveQIndex)
		.finish()
	}
}
/// struct `VkVideoEncodeAV1QualityLevelPropertiesKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1QualityLevelPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeAV1QualityLevelPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub preferredRateControlFlags: VkVideoEncodeAV1RateControlFlagsKHR,
	pub preferredGopFrameCount: u32,
	pub preferredKeyFramePeriod: u32,
	pub preferredConsecutiveBipredictiveFrameCount: u32,
	pub preferredTemporalLayerCount: u32,
	pub preferredConstantQIndex: VkVideoEncodeAV1QIndexKHR,
	pub preferredMaxSingleReferenceCount: u32,
	pub preferredSingleReferenceNameMask: u32,
	pub preferredMaxUnidirectionalCompoundReferenceCount: u32,
	pub preferredMaxUnidirectionalCompoundGroup1ReferenceCount: u32,
	pub preferredUnidirectionalCompoundReferenceNameMask: u32,
	pub preferredMaxBidirectionalCompoundReferenceCount: u32,
	pub preferredMaxBidirectionalCompoundGroup1ReferenceCount: u32,
	pub preferredMaxBidirectionalCompoundGroup2ReferenceCount: u32,
	pub preferredBidirectionalCompoundReferenceNameMask: u32,
}
impl Debug for VkVideoEncodeAV1QualityLevelPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeAV1QualityLevelPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("preferredRateControlFlags", &self.preferredRateControlFlags)
		.field("preferredGopFrameCount", &self.preferredGopFrameCount)
		.field("preferredKeyFramePeriod", &self.preferredKeyFramePeriod)
		.field("preferredConsecutiveBipredictiveFrameCount", &self.preferredConsecutiveBipredictiveFrameCount)
		.field("preferredTemporalLayerCount", &self.preferredTemporalLayerCount)
		.field("preferredConstantQIndex", &self.preferredConstantQIndex)
		.field("preferredMaxSingleReferenceCount", &self.preferredMaxSingleReferenceCount)
		.field("preferredSingleReferenceNameMask", &self.preferredSingleReferenceNameMask)
		.field("preferredMaxUnidirectionalCompoundReferenceCount", &self.preferredMaxUnidirectionalCompoundReferenceCount)
		.field("preferredMaxUnidirectionalCompoundGroup1ReferenceCount", &self.preferredMaxUnidirectionalCompoundGroup1ReferenceCount)
		.field("preferredUnidirectionalCompoundReferenceNameMask", &self.preferredUnidirectionalCompoundReferenceNameMask)
		.field("preferredMaxBidirectionalCompoundReferenceCount", &self.preferredMaxBidirectionalCompoundReferenceCount)
		.field("preferredMaxBidirectionalCompoundGroup1ReferenceCount", &self.preferredMaxBidirectionalCompoundGroup1ReferenceCount)
		.field("preferredMaxBidirectionalCompoundGroup2ReferenceCount", &self.preferredMaxBidirectionalCompoundGroup2ReferenceCount)
		.field("preferredBidirectionalCompoundReferenceNameMask", &self.preferredBidirectionalCompoundReferenceNameMask)
		.finish()
	}
}
/// struct `VkVideoEncodeAV1SessionCreateInfoKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1SessionCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeAV1SessionCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useMaxLevel: VkBool32,
	pub maxLevel: StdVideoAV1Level,
}
impl Debug for VkVideoEncodeAV1SessionCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeAV1SessionCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("useMaxLevel", &self.useMaxLevel)
		.field("maxLevel", &self.maxLevel)
		.finish()
	}
}
/// struct `VkVideoEncodeAV1SessionParametersCreateInfoKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1SessionParametersCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeAV1SessionParametersCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdSequenceHeader: *const StdVideoAV1SequenceHeader,
	pub pStdDecoderModelInfo: *const StdVideoEncodeAV1DecoderModelInfo,
	pub stdOperatingPointCount: u32,
	pub pStdOperatingPoints: *const StdVideoEncodeAV1OperatingPointInfo,
}
impl Debug for VkVideoEncodeAV1SessionParametersCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeAV1SessionParametersCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pStdSequenceHeader", &self.pStdSequenceHeader)
		.field("pStdDecoderModelInfo", &self.pStdDecoderModelInfo)
		.field("stdOperatingPointCount", &self.stdOperatingPointCount)
		.field("pStdOperatingPoints", &self.pStdOperatingPoints)
		.finish()
	}
}
/// struct `VkVideoEncodeAV1PictureInfoKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1PictureInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeAV1PictureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub predictionMode: VkVideoEncodeAV1PredictionModeKHR,
	pub rateControlGroup: VkVideoEncodeAV1RateControlGroupKHR,
	pub constantQIndex: u32,
	pub pStdPictureInfo: *const StdVideoEncodeAV1PictureInfo,
	pub referenceNameSlotIndices: [i32; VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR as usize],
	pub primaryReferenceCdfOnly: VkBool32,
	pub generateObuExtensionHeader: VkBool32,
}
impl Debug for VkVideoEncodeAV1PictureInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeAV1PictureInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("predictionMode", &self.predictionMode)
		.field("rateControlGroup", &self.rateControlGroup)
		.field("constantQIndex", &self.constantQIndex)
		.field("pStdPictureInfo", &self.pStdPictureInfo)
		.field("referenceNameSlotIndices", &self.referenceNameSlotIndices)
		.field("primaryReferenceCdfOnly", &self.primaryReferenceCdfOnly)
		.field("generateObuExtensionHeader", &self.generateObuExtensionHeader)
		.finish()
	}
}
/// struct `VkVideoEncodeAV1DpbSlotInfoKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1DpbSlotInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeAV1DpbSlotInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdReferenceInfo: *const StdVideoEncodeAV1ReferenceInfo,
}
impl Debug for VkVideoEncodeAV1DpbSlotInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeAV1DpbSlotInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pStdReferenceInfo", &self.pStdReferenceInfo)
		.finish()
	}
}
/// struct `VkVideoEncodeAV1ProfileInfoKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1ProfileInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeAV1ProfileInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdProfile: StdVideoAV1Profile,
}
impl Debug for VkVideoEncodeAV1ProfileInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeAV1ProfileInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stdProfile", &self.stdProfile)
		.finish()
	}
}
/// struct `VkVideoEncodeAV1FrameSizeKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1FrameSizeKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeAV1FrameSizeKHR {
	pub intraFrameSize: u32,
	pub predictiveFrameSize: u32,
	pub bipredictiveFrameSize: u32,
}
impl Debug for VkVideoEncodeAV1FrameSizeKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeAV1FrameSizeKHR")
		.field("intraFrameSize", &self.intraFrameSize)
		.field("predictiveFrameSize", &self.predictiveFrameSize)
		.field("bipredictiveFrameSize", &self.bipredictiveFrameSize)
		.finish()
	}
}
/// struct `VkVideoEncodeAV1GopRemainingFrameInfoKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1GopRemainingFrameInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeAV1GopRemainingFrameInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useGopRemainingFrames: VkBool32,
	pub gopRemainingIntra: u32,
	pub gopRemainingPredictive: u32,
	pub gopRemainingBipredictive: u32,
}
impl Debug for VkVideoEncodeAV1GopRemainingFrameInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeAV1GopRemainingFrameInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("useGopRemainingFrames", &self.useGopRemainingFrames)
		.field("gopRemainingIntra", &self.gopRemainingIntra)
		.field("gopRemainingPredictive", &self.gopRemainingPredictive)
		.field("gopRemainingBipredictive", &self.gopRemainingBipredictive)
		.finish()
	}
}
/// struct `VkVideoEncodeAV1RateControlInfoKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1RateControlInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeAV1RateControlInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkVideoEncodeAV1RateControlFlagsKHR,
	pub gopFrameCount: u32,
	pub keyFramePeriod: u32,
	pub consecutiveBipredictiveFrameCount: u32,
	pub temporalLayerCount: u32,
}
impl Debug for VkVideoEncodeAV1RateControlInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeAV1RateControlInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("gopFrameCount", &self.gopFrameCount)
		.field("keyFramePeriod", &self.keyFramePeriod)
		.field("consecutiveBipredictiveFrameCount", &self.consecutiveBipredictiveFrameCount)
		.field("temporalLayerCount", &self.temporalLayerCount)
		.finish()
	}
}
/// struct `VkVideoEncodeAV1RateControlLayerInfoKHR` from VK_KHR_video_encode_av1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1RateControlLayerInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeAV1RateControlLayerInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub useMinQIndex: VkBool32,
	pub minQIndex: VkVideoEncodeAV1QIndexKHR,
	pub useMaxQIndex: VkBool32,
	pub maxQIndex: VkVideoEncodeAV1QIndexKHR,
	pub useMaxFrameSize: VkBool32,
	pub maxFrameSize: VkVideoEncodeAV1FrameSizeKHR,
}
impl Debug for VkVideoEncodeAV1RateControlLayerInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeAV1RateControlLayerInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("useMinQIndex", &self.useMinQIndex)
		.field("minQIndex", &self.minQIndex)
		.field("useMaxQIndex", &self.useMaxQIndex)
		.field("maxQIndex", &self.maxQIndex)
		.field("useMaxFrameSize", &self.useMaxFrameSize)
		.field("maxFrameSize", &self.maxFrameSize)
		.finish()
	}
}
/// trait for `VK_KHR_video_encode_av1`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_video_encode_av1.html>
pub trait VK_KHR_video_encode_av1: Debug {}
/// struct for `VK_KHR_video_encode_av1`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_encode_av1 {}
impl VK_KHR_video_encode_av1 for Vulkan_KHR_video_encode_av1 {}
impl Default for Vulkan_KHR_video_encode_av1 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_encode_av1 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_API_VERSION_1_0_0` from vulkan_video_codec_av1std_encode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_API_VERSION_1_0_0.html>
pub const VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_API_VERSION_1_0_0: u32 = 0x400000;
/// struct `StdVideoEncodeAV1DecoderModelInfo` from vulkan_video_codec_av1std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeAV1DecoderModelInfo {
	pub buffer_delay_length_minus_1: u8,
	pub buffer_removal_time_length_minus_1: u8,
	pub frame_presentation_time_length_minus_1: u8,
	pub reserved1: u8,
	pub num_units_in_decoding_tick: u32,
}
impl Debug for StdVideoEncodeAV1DecoderModelInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeAV1DecoderModelInfo")
		.field("buffer_delay_length_minus_1", &self.buffer_delay_length_minus_1)
		.field("buffer_removal_time_length_minus_1", &self.buffer_removal_time_length_minus_1)
		.field("frame_presentation_time_length_minus_1", &self.frame_presentation_time_length_minus_1)
		.field("reserved1", &self.reserved1)
		.field("num_units_in_decoding_tick", &self.num_units_in_decoding_tick)
		.finish()
	}
}
/// struct `StdVideoEncodeAV1ExtensionHeader` from vulkan_video_codec_av1std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeAV1ExtensionHeader {
	pub temporal_id: u8,
	pub spatial_id: u8,
}
impl Debug for StdVideoEncodeAV1ExtensionHeader {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeAV1ExtensionHeader")
		.field("temporal_id", &self.temporal_id)
		.field("spatial_id", &self.spatial_id)
		.finish()
	}
}
/// struct `StdVideoEncodeAV1OperatingPointInfoFlags` from vulkan_video_codec_av1std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeAV1OperatingPointInfoFlags {
	/// Bitfield: decoder_model_present_for_this_op: u32 in 1 bits
	/// Bitfield: low_delay_mode_flag: u32 in 1 bits
	/// Bitfield: initial_display_delay_present_for_this_op: u32 in 1 bits
	/// Bitfield: reserved: u32 in 29 bits
	bitfield1: u32,
}
impl StdVideoEncodeAV1OperatingPointInfoFlags {
	pub fn get_decoder_model_present_for_this_op(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_decoder_model_present_for_this_op(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_low_delay_mode_flag(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_low_delay_mode_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_initial_display_delay_present_for_this_op(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_initial_display_delay_present_for_this_op(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1fffffff) << 3;
	}
}
impl Debug for StdVideoEncodeAV1OperatingPointInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeAV1OperatingPointInfoFlags")
		.field("decoder_model_present_for_this_op", &self.get_decoder_model_present_for_this_op())
		.field("low_delay_mode_flag", &self.get_low_delay_mode_flag())
		.field("initial_display_delay_present_for_this_op", &self.get_initial_display_delay_present_for_this_op())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoEncodeAV1OperatingPointInfo` from vulkan_video_codec_av1std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeAV1OperatingPointInfo {
	pub flags: StdVideoEncodeAV1OperatingPointInfoFlags,
	pub operating_point_idc: u16,
	pub seq_level_idx: u8,
	pub seq_tier: u8,
	pub decoder_buffer_delay: u32,
	pub encoder_buffer_delay: u32,
	pub initial_display_delay_minus_1: u8,
}
impl Debug for StdVideoEncodeAV1OperatingPointInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeAV1OperatingPointInfo")
		.field("flags", &self.flags)
		.field("operating_point_idc", &self.operating_point_idc)
		.field("seq_level_idx", &self.seq_level_idx)
		.field("seq_tier", &self.seq_tier)
		.field("decoder_buffer_delay", &self.decoder_buffer_delay)
		.field("encoder_buffer_delay", &self.encoder_buffer_delay)
		.field("initial_display_delay_minus_1", &self.initial_display_delay_minus_1)
		.finish()
	}
}
/// struct `StdVideoEncodeAV1PictureInfoFlags` from vulkan_video_codec_av1std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeAV1PictureInfoFlags {
	/// Bitfield: error_resilient_mode: u32 in 1 bits
	/// Bitfield: disable_cdf_update: u32 in 1 bits
	/// Bitfield: use_superres: u32 in 1 bits
	/// Bitfield: render_and_frame_size_different: u32 in 1 bits
	/// Bitfield: allow_screen_content_tools: u32 in 1 bits
	/// Bitfield: is_filter_switchable: u32 in 1 bits
	/// Bitfield: force_integer_mv: u32 in 1 bits
	/// Bitfield: frame_size_override_flag: u32 in 1 bits
	/// Bitfield: buffer_removal_time_present_flag: u32 in 1 bits
	/// Bitfield: allow_intrabc: u32 in 1 bits
	/// Bitfield: frame_refs_short_signaling: u32 in 1 bits
	/// Bitfield: allow_high_precision_mv: u32 in 1 bits
	/// Bitfield: is_motion_mode_switchable: u32 in 1 bits
	/// Bitfield: use_ref_frame_mvs: u32 in 1 bits
	/// Bitfield: disable_frame_end_update_cdf: u32 in 1 bits
	/// Bitfield: allow_warped_motion: u32 in 1 bits
	/// Bitfield: reduced_tx_set: u32 in 1 bits
	/// Bitfield: skip_mode_present: u32 in 1 bits
	/// Bitfield: delta_q_present: u32 in 1 bits
	/// Bitfield: delta_lf_present: u32 in 1 bits
	/// Bitfield: delta_lf_multi: u32 in 1 bits
	/// Bitfield: segmentation_enabled: u32 in 1 bits
	/// Bitfield: segmentation_update_map: u32 in 1 bits
	/// Bitfield: segmentation_temporal_update: u32 in 1 bits
	/// Bitfield: segmentation_update_data: u32 in 1 bits
	/// Bitfield: UsesLr: u32 in 1 bits
	/// Bitfield: usesChromaLr: u32 in 1 bits
	/// Bitfield: show_frame: u32 in 1 bits
	/// Bitfield: showable_frame: u32 in 1 bits
	/// Bitfield: reserved: u32 in 3 bits
	bitfield1: u32,
}
impl StdVideoEncodeAV1PictureInfoFlags {
	pub fn get_error_resilient_mode(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_error_resilient_mode(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_disable_cdf_update(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_disable_cdf_update(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_use_superres(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_use_superres(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_render_and_frame_size_different(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_render_and_frame_size_different(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_allow_screen_content_tools(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_allow_screen_content_tools(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_is_filter_switchable(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_is_filter_switchable(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_force_integer_mv(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_force_integer_mv(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_frame_size_override_flag(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_frame_size_override_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_buffer_removal_time_present_flag(&self) -> u32 {
		(self.bitfield1 >> 8) & 0x1
	}
	pub fn set_buffer_removal_time_present_flag(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 8;
	}
	pub fn get_allow_intrabc(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1
	}
	pub fn set_allow_intrabc(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 9;
	}
	pub fn get_frame_refs_short_signaling(&self) -> u32 {
		(self.bitfield1 >> 10) & 0x1
	}
	pub fn set_frame_refs_short_signaling(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 10;
	}
	pub fn get_allow_high_precision_mv(&self) -> u32 {
		(self.bitfield1 >> 11) & 0x1
	}
	pub fn set_allow_high_precision_mv(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 11;
	}
	pub fn get_is_motion_mode_switchable(&self) -> u32 {
		(self.bitfield1 >> 12) & 0x1
	}
	pub fn set_is_motion_mode_switchable(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 12;
	}
	pub fn get_use_ref_frame_mvs(&self) -> u32 {
		(self.bitfield1 >> 13) & 0x1
	}
	pub fn set_use_ref_frame_mvs(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 13;
	}
	pub fn get_disable_frame_end_update_cdf(&self) -> u32 {
		(self.bitfield1 >> 14) & 0x1
	}
	pub fn set_disable_frame_end_update_cdf(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 14;
	}
	pub fn get_allow_warped_motion(&self) -> u32 {
		(self.bitfield1 >> 15) & 0x1
	}
	pub fn set_allow_warped_motion(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 15;
	}
	pub fn get_reduced_tx_set(&self) -> u32 {
		(self.bitfield1 >> 16) & 0x1
	}
	pub fn set_reduced_tx_set(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 16;
	}
	pub fn get_skip_mode_present(&self) -> u32 {
		(self.bitfield1 >> 17) & 0x1
	}
	pub fn set_skip_mode_present(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 17;
	}
	pub fn get_delta_q_present(&self) -> u32 {
		(self.bitfield1 >> 18) & 0x1
	}
	pub fn set_delta_q_present(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 18;
	}
	pub fn get_delta_lf_present(&self) -> u32 {
		(self.bitfield1 >> 19) & 0x1
	}
	pub fn set_delta_lf_present(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 19;
	}
	pub fn get_delta_lf_multi(&self) -> u32 {
		(self.bitfield1 >> 20) & 0x1
	}
	pub fn set_delta_lf_multi(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 20;
	}
	pub fn get_segmentation_enabled(&self) -> u32 {
		(self.bitfield1 >> 21) & 0x1
	}
	pub fn set_segmentation_enabled(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 21;
	}
	pub fn get_segmentation_update_map(&self) -> u32 {
		(self.bitfield1 >> 22) & 0x1
	}
	pub fn set_segmentation_update_map(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 22;
	}
	pub fn get_segmentation_temporal_update(&self) -> u32 {
		(self.bitfield1 >> 23) & 0x1
	}
	pub fn set_segmentation_temporal_update(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 23;
	}
	pub fn get_segmentation_update_data(&self) -> u32 {
		(self.bitfield1 >> 24) & 0x1
	}
	pub fn set_segmentation_update_data(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 24;
	}
	pub fn get_UsesLr(&self) -> u32 {
		(self.bitfield1 >> 25) & 0x1
	}
	pub fn set_UsesLr(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 25;
	}
	pub fn get_usesChromaLr(&self) -> u32 {
		(self.bitfield1 >> 26) & 0x1
	}
	pub fn set_usesChromaLr(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 26;
	}
	pub fn get_show_frame(&self) -> u32 {
		(self.bitfield1 >> 27) & 0x1
	}
	pub fn set_show_frame(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 27;
	}
	pub fn get_showable_frame(&self) -> u32 {
		(self.bitfield1 >> 28) & 0x1
	}
	pub fn set_showable_frame(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 28;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 29) & 0x7
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7) << 29;
	}
}
impl Debug for StdVideoEncodeAV1PictureInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeAV1PictureInfoFlags")
		.field("error_resilient_mode", &self.get_error_resilient_mode())
		.field("disable_cdf_update", &self.get_disable_cdf_update())
		.field("use_superres", &self.get_use_superres())
		.field("render_and_frame_size_different", &self.get_render_and_frame_size_different())
		.field("allow_screen_content_tools", &self.get_allow_screen_content_tools())
		.field("is_filter_switchable", &self.get_is_filter_switchable())
		.field("force_integer_mv", &self.get_force_integer_mv())
		.field("frame_size_override_flag", &self.get_frame_size_override_flag())
		.field("buffer_removal_time_present_flag", &self.get_buffer_removal_time_present_flag())
		.field("allow_intrabc", &self.get_allow_intrabc())
		.field("frame_refs_short_signaling", &self.get_frame_refs_short_signaling())
		.field("allow_high_precision_mv", &self.get_allow_high_precision_mv())
		.field("is_motion_mode_switchable", &self.get_is_motion_mode_switchable())
		.field("use_ref_frame_mvs", &self.get_use_ref_frame_mvs())
		.field("disable_frame_end_update_cdf", &self.get_disable_frame_end_update_cdf())
		.field("allow_warped_motion", &self.get_allow_warped_motion())
		.field("reduced_tx_set", &self.get_reduced_tx_set())
		.field("skip_mode_present", &self.get_skip_mode_present())
		.field("delta_q_present", &self.get_delta_q_present())
		.field("delta_lf_present", &self.get_delta_lf_present())
		.field("delta_lf_multi", &self.get_delta_lf_multi())
		.field("segmentation_enabled", &self.get_segmentation_enabled())
		.field("segmentation_update_map", &self.get_segmentation_update_map())
		.field("segmentation_temporal_update", &self.get_segmentation_temporal_update())
		.field("segmentation_update_data", &self.get_segmentation_update_data())
		.field("UsesLr", &self.get_UsesLr())
		.field("usesChromaLr", &self.get_usesChromaLr())
		.field("show_frame", &self.get_show_frame())
		.field("showable_frame", &self.get_showable_frame())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoEncodeAV1PictureInfo` from vulkan_video_codec_av1std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeAV1PictureInfo {
	pub flags: StdVideoEncodeAV1PictureInfoFlags,
	pub frame_type: StdVideoAV1FrameType,
	pub frame_presentation_time: u32,
	pub current_frame_id: u32,
	pub order_hint: u8,
	pub primary_ref_frame: u8,
	pub refresh_frame_flags: u8,
	pub coded_denom: u8,
	pub render_width_minus_1: u16,
	pub render_height_minus_1: u16,
	pub interpolation_filter: StdVideoAV1InterpolationFilter,
	pub TxMode: StdVideoAV1TxMode,
	pub delta_q_res: u8,
	pub delta_lf_res: u8,
	pub ref_order_hint: [u8; STD_VIDEO_AV1_NUM_REF_FRAMES as usize],
	pub ref_frame_idx: [i8; STD_VIDEO_AV1_REFS_PER_FRAME as usize],
	pub reserved1: [u8; 3 as usize],
	pub delta_frame_id_minus_1: [u32; STD_VIDEO_AV1_REFS_PER_FRAME as usize],
	pub pTileInfo: *const StdVideoAV1TileInfo,
	pub pQuantization: *const StdVideoAV1Quantization,
	pub pSegmentation: *const StdVideoAV1Segmentation,
	pub pLoopFilter: *const StdVideoAV1LoopFilter,
	pub pCDEF: *const StdVideoAV1CDEF,
	pub pLoopRestoration: *const StdVideoAV1LoopRestoration,
	pub pGlobalMotion: *const StdVideoAV1GlobalMotion,
	pub pExtensionHeader: *const StdVideoEncodeAV1ExtensionHeader,
	pub pBufferRemovalTimes: *const uint32_t,
}
impl Debug for StdVideoEncodeAV1PictureInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeAV1PictureInfo")
		.field("flags", &self.flags)
		.field("frame_type", &self.frame_type)
		.field("frame_presentation_time", &self.frame_presentation_time)
		.field("current_frame_id", &self.current_frame_id)
		.field("order_hint", &self.order_hint)
		.field("primary_ref_frame", &self.primary_ref_frame)
		.field("refresh_frame_flags", &self.refresh_frame_flags)
		.field("coded_denom", &self.coded_denom)
		.field("render_width_minus_1", &self.render_width_minus_1)
		.field("render_height_minus_1", &self.render_height_minus_1)
		.field("interpolation_filter", &self.interpolation_filter)
		.field("TxMode", &self.TxMode)
		.field("delta_q_res", &self.delta_q_res)
		.field("delta_lf_res", &self.delta_lf_res)
		.field("ref_order_hint", &self.ref_order_hint)
		.field("ref_frame_idx", &format_args!("{}", maybe_string(&self.ref_frame_idx)))
		.field("reserved1", &self.reserved1)
		.field("delta_frame_id_minus_1", &self.delta_frame_id_minus_1)
		.field("pTileInfo", &self.pTileInfo)
		.field("pQuantization", &self.pQuantization)
		.field("pSegmentation", &self.pSegmentation)
		.field("pLoopFilter", &self.pLoopFilter)
		.field("pCDEF", &self.pCDEF)
		.field("pLoopRestoration", &self.pLoopRestoration)
		.field("pGlobalMotion", &self.pGlobalMotion)
		.field("pExtensionHeader", &self.pExtensionHeader)
		.field("pBufferRemovalTimes", &self.pBufferRemovalTimes)
		.finish()
	}
}
/// struct `StdVideoEncodeAV1ReferenceInfoFlags` from vulkan_video_codec_av1std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeAV1ReferenceInfoFlags {
	/// Bitfield: disable_frame_end_update_cdf: u32 in 1 bits
	/// Bitfield: segmentation_enabled: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoEncodeAV1ReferenceInfoFlags {
	pub fn get_disable_frame_end_update_cdf(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_disable_frame_end_update_cdf(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_segmentation_enabled(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_segmentation_enabled(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
impl Debug for StdVideoEncodeAV1ReferenceInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeAV1ReferenceInfoFlags")
		.field("disable_frame_end_update_cdf", &self.get_disable_frame_end_update_cdf())
		.field("segmentation_enabled", &self.get_segmentation_enabled())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoEncodeAV1ReferenceInfo` from vulkan_video_codec_av1std_encode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoEncodeAV1ReferenceInfo {
	pub flags: StdVideoEncodeAV1ReferenceInfoFlags,
	pub RefFrameId: u32,
	pub frame_type: StdVideoAV1FrameType,
	pub OrderHint: u8,
	pub reserved1: [u8; 3 as usize],
	pub pExtensionHeader: *const StdVideoEncodeAV1ExtensionHeader,
}
impl Debug for StdVideoEncodeAV1ReferenceInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoEncodeAV1ReferenceInfo")
		.field("flags", &self.flags)
		.field("RefFrameId", &self.RefFrameId)
		.field("frame_type", &self.frame_type)
		.field("OrderHint", &self.OrderHint)
		.field("reserved1", &self.reserved1)
		.field("pExtensionHeader", &self.pExtensionHeader)
		.finish()
	}
}
/// trait for `vulkan_video_codec_av1std_encode`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vulkan_video_codec_av1std_encode.html>
pub trait vulkan_video_codec_av1std_encode: Debug {}
/// struct for `vulkan_video_codec_av1std_encode`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_av1std_encode {}
impl vulkan_video_codec_av1std_encode for Vulkan_video_codec_av1std_encode {}
impl Default for Vulkan_video_codec_av1std_encode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_av1std_encode {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR` from VK_KHR_video_decode_vp9
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR.html>
pub const VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR: u32 = 3u32;
/// struct `VkPhysicalDeviceVideoDecodeVP9FeaturesKHR` from VK_KHR_video_decode_vp9
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVideoDecodeVP9FeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVideoDecodeVP9FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub videoDecodeVP9: VkBool32,
}
impl Debug for VkPhysicalDeviceVideoDecodeVP9FeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVideoDecodeVP9FeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("videoDecodeVP9", &self.videoDecodeVP9)
		.finish()
	}
}
/// struct `VkVideoDecodeVP9ProfileInfoKHR` from VK_KHR_video_decode_vp9
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeVP9ProfileInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeVP9ProfileInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stdProfile: StdVideoVP9Profile,
}
impl Debug for VkVideoDecodeVP9ProfileInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeVP9ProfileInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stdProfile", &self.stdProfile)
		.finish()
	}
}
/// struct `VkVideoDecodeVP9CapabilitiesKHR` from VK_KHR_video_decode_vp9
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeVP9CapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeVP9CapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxLevel: StdVideoVP9Level,
}
impl Debug for VkVideoDecodeVP9CapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeVP9CapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxLevel", &self.maxLevel)
		.finish()
	}
}
/// struct `VkVideoDecodeVP9PictureInfoKHR` from VK_KHR_video_decode_vp9
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeVP9PictureInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeVP9PictureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdPictureInfo: *const StdVideoDecodeVP9PictureInfo,
	pub referenceNameSlotIndices: [i32; VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR as usize],
	pub uncompressedHeaderOffset: u32,
	pub compressedHeaderOffset: u32,
	pub tilesOffset: u32,
}
impl Debug for VkVideoDecodeVP9PictureInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeVP9PictureInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pStdPictureInfo", &self.pStdPictureInfo)
		.field("referenceNameSlotIndices", &self.referenceNameSlotIndices)
		.field("uncompressedHeaderOffset", &self.uncompressedHeaderOffset)
		.field("compressedHeaderOffset", &self.compressedHeaderOffset)
		.field("tilesOffset", &self.tilesOffset)
		.finish()
	}
}
/// trait for `VK_KHR_video_decode_vp9`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_video_decode_vp9.html>
pub trait VK_KHR_video_decode_vp9: Debug {}
/// struct for `VK_KHR_video_decode_vp9`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_decode_vp9 {}
impl VK_KHR_video_decode_vp9 for Vulkan_KHR_video_decode_vp9 {}
impl Default for Vulkan_KHR_video_decode_vp9 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_decode_vp9 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `STD_VIDEO_VP9_NUM_REF_FRAMES` from vulkan_video_codec_vp9std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_VP9_NUM_REF_FRAMES.html>
pub const STD_VIDEO_VP9_NUM_REF_FRAMES: u32 = 8u32;
/// constant `STD_VIDEO_VP9_REFS_PER_FRAME` from vulkan_video_codec_vp9std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_VP9_REFS_PER_FRAME.html>
pub const STD_VIDEO_VP9_REFS_PER_FRAME: u32 = 3u32;
/// constant `STD_VIDEO_VP9_MAX_REF_FRAMES` from vulkan_video_codec_vp9std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_VP9_MAX_REF_FRAMES.html>
pub const STD_VIDEO_VP9_MAX_REF_FRAMES: u32 = 4u32;
/// constant `STD_VIDEO_VP9_LOOP_FILTER_ADJUSTMENTS` from vulkan_video_codec_vp9std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_VP9_LOOP_FILTER_ADJUSTMENTS.html>
pub const STD_VIDEO_VP9_LOOP_FILTER_ADJUSTMENTS: u32 = 2u32;
/// constant `STD_VIDEO_VP9_MAX_SEGMENTS` from vulkan_video_codec_vp9std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_VP9_MAX_SEGMENTS.html>
pub const STD_VIDEO_VP9_MAX_SEGMENTS: u32 = 8u32;
/// constant `STD_VIDEO_VP9_SEG_LVL_MAX` from vulkan_video_codec_vp9std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_VP9_SEG_LVL_MAX.html>
pub const STD_VIDEO_VP9_SEG_LVL_MAX: u32 = 4u32;
/// constant `STD_VIDEO_VP9_MAX_SEGMENTATION_TREE_PROBS` from vulkan_video_codec_vp9std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_VP9_MAX_SEGMENTATION_TREE_PROBS.html>
pub const STD_VIDEO_VP9_MAX_SEGMENTATION_TREE_PROBS: u32 = 7u32;
/// constant `STD_VIDEO_VP9_MAX_SEGMENTATION_PRED_PROB` from vulkan_video_codec_vp9std
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/STD_VIDEO_VP9_MAX_SEGMENTATION_PRED_PROB.html>
pub const STD_VIDEO_VP9_MAX_SEGMENTATION_PRED_PROB: u32 = 3u32;
/// enum `StdVideoVP9Profile` from vulkan_video_codec_vp9std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoVP9Profile {
	STD_VIDEO_VP9_PROFILE_0 = 0,
	STD_VIDEO_VP9_PROFILE_1 = 1,
	STD_VIDEO_VP9_PROFILE_2 = 2,
	STD_VIDEO_VP9_PROFILE_3 = 3,
	STD_VIDEO_VP9_PROFILE_INVALID = 0x7fffffff,
}
impl StdVideoVP9Profile {
	pub const STD_VIDEO_VP9_PROFILE_MAX_ENUM: StdVideoVP9Profile = StdVideoVP9Profile::STD_VIDEO_VP9_PROFILE_INVALID;
}
/// enum `StdVideoVP9Level` from vulkan_video_codec_vp9std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoVP9Level {
	STD_VIDEO_VP9_LEVEL_1_0 = 0,
	STD_VIDEO_VP9_LEVEL_1_1 = 1,
	STD_VIDEO_VP9_LEVEL_2_0 = 2,
	STD_VIDEO_VP9_LEVEL_2_1 = 3,
	STD_VIDEO_VP9_LEVEL_3_0 = 4,
	STD_VIDEO_VP9_LEVEL_3_1 = 5,
	STD_VIDEO_VP9_LEVEL_4_0 = 6,
	STD_VIDEO_VP9_LEVEL_4_1 = 7,
	STD_VIDEO_VP9_LEVEL_5_0 = 8,
	STD_VIDEO_VP9_LEVEL_5_1 = 9,
	STD_VIDEO_VP9_LEVEL_5_2 = 10,
	STD_VIDEO_VP9_LEVEL_6_0 = 11,
	STD_VIDEO_VP9_LEVEL_6_1 = 12,
	STD_VIDEO_VP9_LEVEL_6_2 = 13,
	STD_VIDEO_VP9_LEVEL_INVALID = 0x7fffffff,
}
impl StdVideoVP9Level {
	pub const STD_VIDEO_VP9_LEVEL_MAX_ENUM: StdVideoVP9Level = StdVideoVP9Level::STD_VIDEO_VP9_LEVEL_INVALID;
}
/// enum `StdVideoVP9FrameType` from vulkan_video_codec_vp9std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoVP9FrameType {
	STD_VIDEO_VP9_FRAME_TYPE_KEY = 0,
	STD_VIDEO_VP9_FRAME_TYPE_NON_KEY = 1,
	STD_VIDEO_VP9_FRAME_TYPE_INVALID = 0x7fffffff,
}
impl StdVideoVP9FrameType {
	pub const STD_VIDEO_VP9_FRAME_TYPE_MAX_ENUM: StdVideoVP9FrameType = StdVideoVP9FrameType::STD_VIDEO_VP9_FRAME_TYPE_INVALID;
}
/// enum `StdVideoVP9ReferenceName` from vulkan_video_codec_vp9std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoVP9ReferenceName {
	STD_VIDEO_VP9_REFERENCE_NAME_INTRA_FRAME = 0,
	STD_VIDEO_VP9_REFERENCE_NAME_LAST_FRAME = 1,
	STD_VIDEO_VP9_REFERENCE_NAME_GOLDEN_FRAME = 2,
	STD_VIDEO_VP9_REFERENCE_NAME_ALTREF_FRAME = 3,
	STD_VIDEO_VP9_REFERENCE_NAME_INVALID = 0x7fffffff,
}
impl StdVideoVP9ReferenceName {
	pub const STD_VIDEO_VP9_REFERENCE_NAME_MAX_ENUM: StdVideoVP9ReferenceName = StdVideoVP9ReferenceName::STD_VIDEO_VP9_REFERENCE_NAME_INVALID;
}
/// enum `StdVideoVP9InterpolationFilter` from vulkan_video_codec_vp9std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoVP9InterpolationFilter {
	STD_VIDEO_VP9_INTERPOLATION_FILTER_EIGHTTAP = 0,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH = 1,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_EIGHTTAP_SHARP = 2,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_BILINEAR = 3,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_SWITCHABLE = 4,
	STD_VIDEO_VP9_INTERPOLATION_FILTER_INVALID = 0x7fffffff,
}
impl StdVideoVP9InterpolationFilter {
	pub const STD_VIDEO_VP9_INTERPOLATION_FILTER_MAX_ENUM: StdVideoVP9InterpolationFilter = StdVideoVP9InterpolationFilter::STD_VIDEO_VP9_INTERPOLATION_FILTER_INVALID;
}
/// enum `StdVideoVP9ColorSpace` from vulkan_video_codec_vp9std
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum StdVideoVP9ColorSpace {
	STD_VIDEO_VP9_COLOR_SPACE_UNKNOWN = 0,
	STD_VIDEO_VP9_COLOR_SPACE_BT_601 = 1,
	STD_VIDEO_VP9_COLOR_SPACE_BT_709 = 2,
	STD_VIDEO_VP9_COLOR_SPACE_SMPTE_170 = 3,
	STD_VIDEO_VP9_COLOR_SPACE_SMPTE_240 = 4,
	STD_VIDEO_VP9_COLOR_SPACE_BT_2020 = 5,
	STD_VIDEO_VP9_COLOR_SPACE_RESERVED = 6,
	STD_VIDEO_VP9_COLOR_SPACE_RGB = 7,
	STD_VIDEO_VP9_COLOR_SPACE_INVALID = 0x7fffffff,
}
impl StdVideoVP9ColorSpace {
	pub const STD_VIDEO_VP9_COLOR_SPACE_MAX_ENUM: StdVideoVP9ColorSpace = StdVideoVP9ColorSpace::STD_VIDEO_VP9_COLOR_SPACE_INVALID;
}
/// struct `StdVideoVP9ColorConfigFlags` from vulkan_video_codec_vp9std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoVP9ColorConfigFlags {
	/// Bitfield: color_range: u32 in 1 bits
	/// Bitfield: reserved: u32 in 31 bits
	bitfield1: u32,
}
impl StdVideoVP9ColorConfigFlags {
	pub fn get_color_range(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_color_range(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x7fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7fffffff) << 1;
	}
}
impl Debug for StdVideoVP9ColorConfigFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoVP9ColorConfigFlags")
		.field("color_range", &self.get_color_range())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoVP9ColorConfig` from vulkan_video_codec_vp9std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoVP9ColorConfig {
	pub flags: StdVideoVP9ColorConfigFlags,
	pub BitDepth: u8,
	pub subsampling_x: u8,
	pub subsampling_y: u8,
	pub reserved1: u8,
	pub color_space: StdVideoVP9ColorSpace,
}
impl Debug for StdVideoVP9ColorConfig {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoVP9ColorConfig")
		.field("flags", &self.flags)
		.field("BitDepth", &self.BitDepth)
		.field("subsampling_x", &self.subsampling_x)
		.field("subsampling_y", &self.subsampling_y)
		.field("reserved1", &self.reserved1)
		.field("color_space", &self.color_space)
		.finish()
	}
}
/// struct `StdVideoVP9LoopFilterFlags` from vulkan_video_codec_vp9std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoVP9LoopFilterFlags {
	/// Bitfield: loop_filter_delta_enabled: u32 in 1 bits
	/// Bitfield: loop_filter_delta_update: u32 in 1 bits
	/// Bitfield: reserved: u32 in 30 bits
	bitfield1: u32,
}
impl StdVideoVP9LoopFilterFlags {
	pub fn get_loop_filter_delta_enabled(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_loop_filter_delta_enabled(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_loop_filter_delta_update(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_loop_filter_delta_update(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x3fffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3fffffff) << 2;
	}
}
impl Debug for StdVideoVP9LoopFilterFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoVP9LoopFilterFlags")
		.field("loop_filter_delta_enabled", &self.get_loop_filter_delta_enabled())
		.field("loop_filter_delta_update", &self.get_loop_filter_delta_update())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoVP9LoopFilter` from vulkan_video_codec_vp9std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoVP9LoopFilter {
	pub flags: StdVideoVP9LoopFilterFlags,
	pub loop_filter_level: u8,
	pub loop_filter_sharpness: u8,
	pub update_ref_delta: u8,
	pub loop_filter_ref_deltas: [i8; STD_VIDEO_VP9_MAX_REF_FRAMES as usize],
	pub update_mode_delta: u8,
	pub loop_filter_mode_deltas: [i8; STD_VIDEO_VP9_LOOP_FILTER_ADJUSTMENTS as usize],
}
impl Debug for StdVideoVP9LoopFilter {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoVP9LoopFilter")
		.field("flags", &self.flags)
		.field("loop_filter_level", &self.loop_filter_level)
		.field("loop_filter_sharpness", &self.loop_filter_sharpness)
		.field("update_ref_delta", &self.update_ref_delta)
		.field("loop_filter_ref_deltas", &format_args!("{}", maybe_string(&self.loop_filter_ref_deltas)))
		.field("update_mode_delta", &self.update_mode_delta)
		.field("loop_filter_mode_deltas", &format_args!("{}", maybe_string(&self.loop_filter_mode_deltas)))
		.finish()
	}
}
/// struct `StdVideoVP9SegmentationFlags` from vulkan_video_codec_vp9std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoVP9SegmentationFlags {
	/// Bitfield: segmentation_update_map: u32 in 1 bits
	/// Bitfield: segmentation_temporal_update: u32 in 1 bits
	/// Bitfield: segmentation_update_data: u32 in 1 bits
	/// Bitfield: segmentation_abs_or_delta_update: u32 in 1 bits
	/// Bitfield: reserved: u32 in 28 bits
	bitfield1: u32,
}
impl StdVideoVP9SegmentationFlags {
	pub fn get_segmentation_update_map(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_segmentation_update_map(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_segmentation_temporal_update(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_segmentation_temporal_update(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_segmentation_update_data(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_segmentation_update_data(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_segmentation_abs_or_delta_update(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_segmentation_abs_or_delta_update(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 4) & 0xfffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0xfffffff) << 4;
	}
}
impl Debug for StdVideoVP9SegmentationFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoVP9SegmentationFlags")
		.field("segmentation_update_map", &self.get_segmentation_update_map())
		.field("segmentation_temporal_update", &self.get_segmentation_temporal_update())
		.field("segmentation_update_data", &self.get_segmentation_update_data())
		.field("segmentation_abs_or_delta_update", &self.get_segmentation_abs_or_delta_update())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoVP9Segmentation` from vulkan_video_codec_vp9std
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoVP9Segmentation {
	pub flags: StdVideoVP9SegmentationFlags,
	pub segmentation_tree_probs: [u8; STD_VIDEO_VP9_MAX_SEGMENTATION_TREE_PROBS as usize],
	pub segmentation_pred_prob: [u8; STD_VIDEO_VP9_MAX_SEGMENTATION_PRED_PROB as usize],
	pub FeatureEnabled: [u8; STD_VIDEO_VP9_MAX_SEGMENTS as usize],
	pub FeatureData: [[i16; STD_VIDEO_VP9_SEG_LVL_MAX as usize]; STD_VIDEO_VP9_MAX_SEGMENTS as usize],
}
impl Debug for StdVideoVP9Segmentation {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoVP9Segmentation")
		.field("flags", &self.flags)
		.field("segmentation_tree_probs", &self.segmentation_tree_probs)
		.field("segmentation_pred_prob", &self.segmentation_pred_prob)
		.field("FeatureEnabled", &self.FeatureEnabled)
		.field("FeatureData", &self.FeatureData)
		.finish()
	}
}
/// trait for `vulkan_video_codec_vp9std`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vulkan_video_codec_vp9std.html>
pub trait vulkan_video_codec_vp9std: Debug {}
/// struct for `vulkan_video_codec_vp9std`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_vp9std {}
impl vulkan_video_codec_vp9std for Vulkan_video_codec_vp9std {}
impl Default for Vulkan_video_codec_vp9std {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_vp9std {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_API_VERSION_1_0_0` from vulkan_video_codec_vp9std_decode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_API_VERSION_1_0_0.html>
pub const VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_API_VERSION_1_0_0: u32 = 0x400000;
/// struct `StdVideoDecodeVP9PictureInfoFlags` from vulkan_video_codec_vp9std_decode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoDecodeVP9PictureInfoFlags {
	/// Bitfield: error_resilient_mode: u32 in 1 bits
	/// Bitfield: intra_only: u32 in 1 bits
	/// Bitfield: allow_high_precision_mv: u32 in 1 bits
	/// Bitfield: refresh_frame_context: u32 in 1 bits
	/// Bitfield: frame_parallel_decoding_mode: u32 in 1 bits
	/// Bitfield: segmentation_enabled: u32 in 1 bits
	/// Bitfield: show_frame: u32 in 1 bits
	/// Bitfield: UsePrevFrameMvs: u32 in 1 bits
	/// Bitfield: reserved: u32 in 24 bits
	bitfield1: u32,
}
impl StdVideoDecodeVP9PictureInfoFlags {
	pub fn get_error_resilient_mode(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1
	}
	pub fn set_error_resilient_mode(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 0;
	}
	pub fn get_intra_only(&self) -> u32 {
		(self.bitfield1 >> 1) & 0x1
	}
	pub fn set_intra_only(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 1;
	}
	pub fn get_allow_high_precision_mv(&self) -> u32 {
		(self.bitfield1 >> 2) & 0x1
	}
	pub fn set_allow_high_precision_mv(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 2;
	}
	pub fn get_refresh_frame_context(&self) -> u32 {
		(self.bitfield1 >> 3) & 0x1
	}
	pub fn set_refresh_frame_context(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 3;
	}
	pub fn get_frame_parallel_decoding_mode(&self) -> u32 {
		(self.bitfield1 >> 4) & 0x1
	}
	pub fn set_frame_parallel_decoding_mode(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 4;
	}
	pub fn get_segmentation_enabled(&self) -> u32 {
		(self.bitfield1 >> 5) & 0x1
	}
	pub fn set_segmentation_enabled(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 5;
	}
	pub fn get_show_frame(&self) -> u32 {
		(self.bitfield1 >> 6) & 0x1
	}
	pub fn set_show_frame(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 6;
	}
	pub fn get_UsePrevFrameMvs(&self) -> u32 {
		(self.bitfield1 >> 7) & 0x1
	}
	pub fn set_UsePrevFrameMvs(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1) << 7;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 8) & 0xffffff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0xffffff) << 8;
	}
}
impl Debug for StdVideoDecodeVP9PictureInfoFlags {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoDecodeVP9PictureInfoFlags")
		.field("error_resilient_mode", &self.get_error_resilient_mode())
		.field("intra_only", &self.get_intra_only())
		.field("allow_high_precision_mv", &self.get_allow_high_precision_mv())
		.field("refresh_frame_context", &self.get_refresh_frame_context())
		.field("frame_parallel_decoding_mode", &self.get_frame_parallel_decoding_mode())
		.field("segmentation_enabled", &self.get_segmentation_enabled())
		.field("show_frame", &self.get_show_frame())
		.field("UsePrevFrameMvs", &self.get_UsePrevFrameMvs())
		.field("reserved", &self.get_reserved())
		.finish()
	}
}
/// struct `StdVideoDecodeVP9PictureInfo` from vulkan_video_codec_vp9std_decode
#[repr(C)]
#[derive(Clone, Copy)]
pub struct StdVideoDecodeVP9PictureInfo {
	pub flags: StdVideoDecodeVP9PictureInfoFlags,
	pub profile: StdVideoVP9Profile,
	pub frame_type: StdVideoVP9FrameType,
	pub frame_context_idx: u8,
	pub reset_frame_context: u8,
	pub refresh_frame_flags: u8,
	pub ref_frame_sign_bias_mask: u8,
	pub interpolation_filter: StdVideoVP9InterpolationFilter,
	pub base_q_idx: u8,
	pub delta_q_y_dc: i8,
	pub delta_q_uv_dc: i8,
	pub delta_q_uv_ac: i8,
	pub tile_cols_log2: u8,
	pub tile_rows_log2: u8,
	pub reserved1: [u16; 3 as usize],
	pub pColorConfig: *const StdVideoVP9ColorConfig,
	pub pLoopFilter: *const StdVideoVP9LoopFilter,
	pub pSegmentation: *const StdVideoVP9Segmentation,
}
impl Debug for StdVideoDecodeVP9PictureInfo {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("StdVideoDecodeVP9PictureInfo")
		.field("flags", &self.flags)
		.field("profile", &self.profile)
		.field("frame_type", &self.frame_type)
		.field("frame_context_idx", &self.frame_context_idx)
		.field("reset_frame_context", &self.reset_frame_context)
		.field("refresh_frame_flags", &self.refresh_frame_flags)
		.field("ref_frame_sign_bias_mask", &self.ref_frame_sign_bias_mask)
		.field("interpolation_filter", &self.interpolation_filter)
		.field("base_q_idx", &self.base_q_idx)
		.field("delta_q_y_dc", &self.delta_q_y_dc)
		.field("delta_q_uv_dc", &self.delta_q_uv_dc)
		.field("delta_q_uv_ac", &self.delta_q_uv_ac)
		.field("tile_cols_log2", &self.tile_cols_log2)
		.field("tile_rows_log2", &self.tile_rows_log2)
		.field("reserved1", &self.reserved1)
		.field("pColorConfig", &self.pColorConfig)
		.field("pLoopFilter", &self.pLoopFilter)
		.field("pSegmentation", &self.pSegmentation)
		.finish()
	}
}
/// trait for `vulkan_video_codec_vp9std_decode`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vulkan_video_codec_vp9std_decode.html>
pub trait vulkan_video_codec_vp9std_decode: Debug {}
/// struct for `vulkan_video_codec_vp9std_decode`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_video_codec_vp9std_decode {}
impl vulkan_video_codec_vp9std_decode for Vulkan_video_codec_vp9std_decode {}
impl Default for Vulkan_video_codec_vp9std_decode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_video_codec_vp9std_decode {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceVideoMaintenance1FeaturesKHR` from VK_KHR_video_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVideoMaintenance1FeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVideoMaintenance1FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub videoMaintenance1: VkBool32,
}
impl Debug for VkPhysicalDeviceVideoMaintenance1FeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVideoMaintenance1FeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("videoMaintenance1", &self.videoMaintenance1)
		.finish()
	}
}
/// struct `VkVideoInlineQueryInfoKHR` from VK_KHR_video_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoInlineQueryInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoInlineQueryInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub queryPool: VkQueryPool,
	pub firstQuery: u32,
	pub queryCount: u32,
}
impl Debug for VkVideoInlineQueryInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoInlineQueryInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("queryPool", &self.queryPool)
		.field("firstQuery", &self.firstQuery)
		.field("queryCount", &self.queryCount)
		.finish()
	}
}
/// trait for `VK_KHR_video_maintenance1`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_video_maintenance1.html>
pub trait VK_KHR_video_maintenance1: Debug {}
/// struct for `VK_KHR_video_maintenance1`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_maintenance1 {}
impl VK_KHR_video_maintenance1 for Vulkan_KHR_video_maintenance1 {}
impl Default for Vulkan_KHR_video_maintenance1 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_maintenance1 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR` from VK_KHR_vertex_attribute_divisor
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR.html>
pub type VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR = VkPhysicalDeviceVertexAttributeDivisorProperties;
/// type definition `VkVertexInputBindingDivisorDescriptionKHR` from VK_KHR_vertex_attribute_divisor
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVertexInputBindingDivisorDescriptionKHR.html>
pub type VkVertexInputBindingDivisorDescriptionKHR = VkVertexInputBindingDivisorDescription;
/// type definition `VkPipelineVertexInputDivisorStateCreateInfoKHR` from VK_KHR_vertex_attribute_divisor
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineVertexInputDivisorStateCreateInfoKHR.html>
pub type VkPipelineVertexInputDivisorStateCreateInfoKHR = VkPipelineVertexInputDivisorStateCreateInfo;
/// type definition `VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR` from VK_KHR_vertex_attribute_divisor
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR.html>
pub type VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR = VkPhysicalDeviceVertexAttributeDivisorFeatures;
/// trait for `VK_KHR_vertex_attribute_divisor`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_vertex_attribute_divisor.html>
pub trait VK_KHR_vertex_attribute_divisor: Debug {}
/// struct for `VK_KHR_vertex_attribute_divisor`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_vertex_attribute_divisor {}
impl VK_KHR_vertex_attribute_divisor for Vulkan_KHR_vertex_attribute_divisor {}
impl Default for Vulkan_KHR_vertex_attribute_divisor {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_vertex_attribute_divisor {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_KHR_load_store_op_none`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_load_store_op_none.html>
pub trait VK_KHR_load_store_op_none: Debug {}
/// struct for `VK_KHR_load_store_op_none`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_load_store_op_none {}
impl VK_KHR_load_store_op_none for Vulkan_KHR_load_store_op_none {}
impl Default for Vulkan_KHR_load_store_op_none {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_load_store_op_none {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR` from VK_KHR_unified_image_layouts
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub unifiedImageLayouts: VkBool32,
	pub unifiedImageLayoutsVideo: VkBool32,
}
impl Debug for VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("unifiedImageLayouts", &self.unifiedImageLayouts)
		.field("unifiedImageLayoutsVideo", &self.unifiedImageLayoutsVideo)
		.finish()
	}
}
/// struct `VkAttachmentFeedbackLoopInfoEXT` from VK_KHR_unified_image_layouts
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentFeedbackLoopInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAttachmentFeedbackLoopInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub feedbackLoopEnable: VkBool32,
}
impl Debug for VkAttachmentFeedbackLoopInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAttachmentFeedbackLoopInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("feedbackLoopEnable", &self.feedbackLoopEnable)
		.finish()
	}
}
/// trait for `VK_KHR_unified_image_layouts`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_unified_image_layouts.html>
pub trait VK_KHR_unified_image_layouts: Debug {}
/// struct for `VK_KHR_unified_image_layouts`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_unified_image_layouts {}
impl VK_KHR_unified_image_layouts for Vulkan_KHR_unified_image_layouts {}
impl Default for Vulkan_KHR_unified_image_layouts {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_unified_image_layouts {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceShaderFloatControls2FeaturesKHR` from VK_KHR_shader_float_controls2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderFloatControls2FeaturesKHR.html>
pub type VkPhysicalDeviceShaderFloatControls2FeaturesKHR = VkPhysicalDeviceShaderFloatControls2Features;
/// trait for `VK_KHR_shader_float_controls2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_float_controls2.html>
pub trait VK_KHR_shader_float_controls2: Debug {}
/// struct for `VK_KHR_shader_float_controls2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_float_controls2 {}
impl VK_KHR_shader_float_controls2 for Vulkan_KHR_shader_float_controls2 {}
impl Default for Vulkan_KHR_shader_float_controls2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_float_controls2 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceIndexTypeUint8FeaturesKHR` from VK_KHR_index_type_uint8
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceIndexTypeUint8FeaturesKHR.html>
pub type VkPhysicalDeviceIndexTypeUint8FeaturesKHR = VkPhysicalDeviceIndexTypeUint8Features;
/// trait for `VK_KHR_index_type_uint8`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_index_type_uint8.html>
pub trait VK_KHR_index_type_uint8: Debug {}
/// struct for `VK_KHR_index_type_uint8`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_index_type_uint8 {}
impl VK_KHR_index_type_uint8 for Vulkan_KHR_index_type_uint8 {}
impl Default for Vulkan_KHR_index_type_uint8 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_index_type_uint8 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkLineRasterizationModeKHR` from VK_KHR_line_rasterization
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkLineRasterizationModeKHR.html>
pub type VkLineRasterizationModeKHR = VkLineRasterizationMode;
/// type definition `VkPhysicalDeviceLineRasterizationFeaturesKHR` from VK_KHR_line_rasterization
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLineRasterizationFeaturesKHR.html>
pub type VkPhysicalDeviceLineRasterizationFeaturesKHR = VkPhysicalDeviceLineRasterizationFeatures;
/// type definition `VkPhysicalDeviceLineRasterizationPropertiesKHR` from VK_KHR_line_rasterization
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLineRasterizationPropertiesKHR.html>
pub type VkPhysicalDeviceLineRasterizationPropertiesKHR = VkPhysicalDeviceLineRasterizationProperties;
/// type definition `VkPipelineRasterizationLineStateCreateInfoKHR` from VK_KHR_line_rasterization
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRasterizationLineStateCreateInfoKHR.html>
pub type VkPipelineRasterizationLineStateCreateInfoKHR = VkPipelineRasterizationLineStateCreateInfo;
/// function prototype `PFN_vkCmdSetLineStippleKHR` from VK_KHR_line_rasterization
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLineStippleKHR.html>
type PFN_vkCmdSetLineStippleKHR = extern "system" fn(commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16);
/// The dummy function for `vkCmdSetLineStippleKHR` from `VK_KHR_line_rasterization`
extern "system" fn dummy_vkCmdSetLineStippleKHR(_: VkCommandBuffer, _: u32, _: u16) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetLineStippleKHR"))
}
/// trait for `VK_KHR_line_rasterization`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_line_rasterization.html>
pub trait VK_KHR_line_rasterization: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLineStippleKHR.html>
	fn vkCmdSetLineStippleKHR(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) -> Result<()>;
}
/// struct for `VK_KHR_line_rasterization`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_line_rasterization {
	vk_cmd_set_line_stipple_khr: PFN_vkCmdSetLineStippleKHR,
}
impl VK_KHR_line_rasterization for Vulkan_KHR_line_rasterization {
	fn vkCmdSetLineStippleKHR(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_line_stipple_khr)(commandBuffer, lineStippleFactor, lineStipplePattern))))
	}
}
impl Default for Vulkan_KHR_line_rasterization {
	fn default() -> Self {
		Self {
			vk_cmd_set_line_stipple_khr: dummy_vkCmdSetLineStippleKHR,
		}
	}
}
impl Vulkan_KHR_line_rasterization {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_line_stipple_khr: {let proc = get_instance_proc_address(instance, "vkCmdSetLineStippleKHR"); if proc == null() {dummy_vkCmdSetLineStippleKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// enum `VkTimeDomainKHR` from VK_KHR_calibrated_timestamps
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTimeDomainKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkTimeDomainKHR {
	VK_TIME_DOMAIN_DEVICE_KHR = 0,
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR = 1,
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR = 2,
	VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR = 3,
	VK_TIME_DOMAIN_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkTimeDomainKHR {
	pub const VK_TIME_DOMAIN_DEVICE_EXT: VkTimeDomainKHR = VkTimeDomainKHR::VK_TIME_DOMAIN_DEVICE_KHR;
	pub const VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT: VkTimeDomainKHR = VkTimeDomainKHR::VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR;
	pub const VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT: VkTimeDomainKHR = VkTimeDomainKHR::VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR;
	pub const VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT: VkTimeDomainKHR = VkTimeDomainKHR::VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR;
}
/// struct `VkCalibratedTimestampInfoKHR` from VK_KHR_calibrated_timestamps
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCalibratedTimestampInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCalibratedTimestampInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub timeDomain: VkTimeDomainKHR,
}
impl Debug for VkCalibratedTimestampInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCalibratedTimestampInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("timeDomain", &self.timeDomain)
		.finish()
	}
}
/// function prototype `PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR` from VK_KHR_calibrated_timestamps
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsKHR.html>
type PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR = extern "system" fn(physicalDevice: VkPhysicalDevice, pTimeDomainCount: *mut uint32_t, pTimeDomains: *mut VkTimeDomainKHR) -> VkResult;
/// function prototype `PFN_vkGetCalibratedTimestampsKHR` from VK_KHR_calibrated_timestamps
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetCalibratedTimestampsKHR.html>
type PFN_vkGetCalibratedTimestampsKHR = extern "system" fn(device: VkDevice, timestampCount: u32, pTimestampInfos: *const VkCalibratedTimestampInfoKHR, pTimestamps: *mut uint64_t, pMaxDeviation: *mut uint64_t) -> VkResult;
/// The dummy function for `vkGetPhysicalDeviceCalibrateableTimeDomainsKHR` from `VK_KHR_calibrated_timestamps`
extern "system" fn dummy_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkTimeDomainKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceCalibrateableTimeDomainsKHR"))
}
/// trait for `VK_KHR_calibrated_timestamps`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_calibrated_timestamps.html>
pub trait VK_KHR_calibrated_timestamps: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsKHR.html>
	fn vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(&self, physicalDevice: VkPhysicalDevice, pTimeDomainCount: *mut uint32_t, pTimeDomains: *mut VkTimeDomainKHR) -> Result<()>;
}
/// struct for `VK_KHR_calibrated_timestamps`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_calibrated_timestamps {
	vk_get_physical_device_calibrateable_time_domains_khr: PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR,
}
impl VK_KHR_calibrated_timestamps for Vulkan_KHR_calibrated_timestamps {
	fn vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(&self, physicalDevice: VkPhysicalDevice, pTimeDomainCount: *mut uint32_t, pTimeDomains: *mut VkTimeDomainKHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceCalibrateableTimeDomainsKHR", catch_unwind(||((self.vk_get_physical_device_calibrateable_time_domains_khr)(physicalDevice, pTimeDomainCount, pTimeDomains))))
	}
}
impl Default for Vulkan_KHR_calibrated_timestamps {
	fn default() -> Self {
		Self {
			vk_get_physical_device_calibrateable_time_domains_khr: dummy_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR,
		}
	}
}
impl Vulkan_KHR_calibrated_timestamps {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_calibrateable_time_domains_khr: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceCalibrateableTimeDomainsKHR"); if proc == null() {dummy_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceShaderExpectAssumeFeaturesKHR` from VK_KHR_shader_expect_assume
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderExpectAssumeFeaturesKHR.html>
pub type VkPhysicalDeviceShaderExpectAssumeFeaturesKHR = VkPhysicalDeviceShaderExpectAssumeFeatures;
/// trait for `VK_KHR_shader_expect_assume`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_expect_assume.html>
pub trait VK_KHR_shader_expect_assume: Debug {}
/// struct for `VK_KHR_shader_expect_assume`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_expect_assume {}
impl VK_KHR_shader_expect_assume for Vulkan_KHR_shader_expect_assume {}
impl Default for Vulkan_KHR_shader_expect_assume {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_expect_assume {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceMaintenance6FeaturesKHR` from VK_KHR_maintenance6
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance6FeaturesKHR.html>
pub type VkPhysicalDeviceMaintenance6FeaturesKHR = VkPhysicalDeviceMaintenance6Features;
/// type definition `VkPhysicalDeviceMaintenance6PropertiesKHR` from VK_KHR_maintenance6
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance6PropertiesKHR.html>
pub type VkPhysicalDeviceMaintenance6PropertiesKHR = VkPhysicalDeviceMaintenance6Properties;
/// type definition `VkBindMemoryStatusKHR` from VK_KHR_maintenance6
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindMemoryStatusKHR.html>
pub type VkBindMemoryStatusKHR = VkBindMemoryStatus;
/// type definition `VkBindDescriptorSetsInfoKHR` from VK_KHR_maintenance6
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindDescriptorSetsInfoKHR.html>
pub type VkBindDescriptorSetsInfoKHR = VkBindDescriptorSetsInfo;
/// type definition `VkPushConstantsInfoKHR` from VK_KHR_maintenance6
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPushConstantsInfoKHR.html>
pub type VkPushConstantsInfoKHR = VkPushConstantsInfo;
/// type definition `VkPushDescriptorSetInfoKHR` from VK_KHR_maintenance6
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPushDescriptorSetInfoKHR.html>
pub type VkPushDescriptorSetInfoKHR = VkPushDescriptorSetInfo;
/// type definition `VkPushDescriptorSetWithTemplateInfoKHR` from VK_KHR_maintenance6
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPushDescriptorSetWithTemplateInfoKHR.html>
pub type VkPushDescriptorSetWithTemplateInfoKHR = VkPushDescriptorSetWithTemplateInfo;
/// struct `VkSetDescriptorBufferOffsetsInfoEXT` from VK_KHR_maintenance6
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSetDescriptorBufferOffsetsInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSetDescriptorBufferOffsetsInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stageFlags: VkShaderStageFlags,
	pub layout: VkPipelineLayout,
	pub firstSet: u32,
	pub setCount: u32,
	pub pBufferIndices: *const uint32_t,
	pub pOffsets: *const VkDeviceSize,
}
impl Debug for VkSetDescriptorBufferOffsetsInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSetDescriptorBufferOffsetsInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stageFlags", &self.stageFlags)
		.field("layout", &self.layout)
		.field("firstSet", &self.firstSet)
		.field("setCount", &self.setCount)
		.field("pBufferIndices", &self.pBufferIndices)
		.field("pOffsets", &self.pOffsets)
		.finish()
	}
}
/// struct `VkBindDescriptorBufferEmbeddedSamplersInfoEXT` from VK_KHR_maintenance6
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindDescriptorBufferEmbeddedSamplersInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindDescriptorBufferEmbeddedSamplersInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stageFlags: VkShaderStageFlags,
	pub layout: VkPipelineLayout,
	pub set: u32,
}
impl Debug for VkBindDescriptorBufferEmbeddedSamplersInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindDescriptorBufferEmbeddedSamplersInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stageFlags", &self.stageFlags)
		.field("layout", &self.layout)
		.field("set", &self.set)
		.finish()
	}
}
/// function prototype `PFN_vkCmdBindDescriptorSets2KHR` from VK_KHR_maintenance6
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorSets2KHR.html>
type PFN_vkCmdBindDescriptorSets2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo);
/// function prototype `PFN_vkCmdPushConstants2KHR` from VK_KHR_maintenance6
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushConstants2KHR.html>
type PFN_vkCmdPushConstants2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pPushConstantsInfo: *const VkPushConstantsInfo);
/// function prototype `PFN_vkCmdPushDescriptorSet2KHR` from VK_KHR_maintenance6
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSet2KHR.html>
type PFN_vkCmdPushDescriptorSet2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pPushDescriptorSetInfo: *const VkPushDescriptorSetInfo);
/// function prototype `PFN_vkCmdPushDescriptorSetWithTemplate2KHR` from VK_KHR_maintenance6
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetWithTemplate2KHR.html>
type PFN_vkCmdPushDescriptorSetWithTemplate2KHR = extern "system" fn(commandBuffer: VkCommandBuffer, pPushDescriptorSetWithTemplateInfo: *const VkPushDescriptorSetWithTemplateInfo);
/// function prototype `PFN_vkCmdSetDescriptorBufferOffsets2EXT` from VK_KHR_maintenance6
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDescriptorBufferOffsets2EXT.html>
type PFN_vkCmdSetDescriptorBufferOffsets2EXT = extern "system" fn(commandBuffer: VkCommandBuffer, pSetDescriptorBufferOffsetsInfo: *const VkSetDescriptorBufferOffsetsInfoEXT);
/// function prototype `PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT` from VK_KHR_maintenance6
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorBufferEmbeddedSamplers2EXT.html>
type PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT = extern "system" fn(commandBuffer: VkCommandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo: *const VkBindDescriptorBufferEmbeddedSamplersInfoEXT);
/// The dummy function for `vkCmdBindDescriptorSets2KHR` from `VK_KHR_maintenance6`
extern "system" fn dummy_vkCmdBindDescriptorSets2KHR(_: VkCommandBuffer, _: *const VkBindDescriptorSetsInfo) {
	panic_any(VkError::NullFunctionPointer("vkCmdBindDescriptorSets2KHR"))
}
/// trait for `VK_KHR_maintenance6`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_maintenance6.html>
pub trait VK_KHR_maintenance6: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorSets2KHR.html>
	fn vkCmdBindDescriptorSets2KHR(&self, commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo) -> Result<()>;
}
/// struct for `VK_KHR_maintenance6`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance6 {
	vk_cmd_bind_descriptor_sets2_khr: PFN_vkCmdBindDescriptorSets2KHR,
}
impl VK_KHR_maintenance6 for Vulkan_KHR_maintenance6 {
	fn vkCmdBindDescriptorSets2KHR(&self, commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_bind_descriptor_sets2_khr)(commandBuffer, pBindDescriptorSetsInfo))))
	}
}
impl Default for Vulkan_KHR_maintenance6 {
	fn default() -> Self {
		Self {
			vk_cmd_bind_descriptor_sets2_khr: dummy_vkCmdBindDescriptorSets2KHR,
		}
	}
}
impl Vulkan_KHR_maintenance6 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_bind_descriptor_sets2_khr: {let proc = get_instance_proc_address(instance, "vkCmdBindDescriptorSets2KHR"); if proc == null() {dummy_vkCmdBindDescriptorSets2KHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkVideoEncodeIntraRefreshModeFlagsKHR` from VK_KHR_video_encode_intra_refresh
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeIntraRefreshModeFlagsKHR.html>
pub type VkVideoEncodeIntraRefreshModeFlagsKHR = VkFlags;
/// enum `VkVideoEncodeIntraRefreshModeFlagBitsKHR` from VK_KHR_video_encode_intra_refresh
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeIntraRefreshModeFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkVideoEncodeIntraRefreshModeFlagBitsKHR {
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_NONE_KHR = 0,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_PER_PICTURE_PARTITION_BIT_KHR = 0x00000001,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_BASED_BIT_KHR = 0x00000002,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_ROW_BASED_BIT_KHR = 0x00000004,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_COLUMN_BASED_BIT_KHR = 0x00000008,
	VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// struct `VkVideoEncodeIntraRefreshCapabilitiesKHR` from VK_KHR_video_encode_intra_refresh
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeIntraRefreshCapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeIntraRefreshCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub intraRefreshModes: VkVideoEncodeIntraRefreshModeFlagsKHR,
	pub maxIntraRefreshCycleDuration: u32,
	pub maxIntraRefreshActiveReferencePictures: u32,
	pub partitionIndependentIntraRefreshRegions: VkBool32,
	pub nonRectangularIntraRefreshRegions: VkBool32,
}
impl Debug for VkVideoEncodeIntraRefreshCapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeIntraRefreshCapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("intraRefreshModes", &self.intraRefreshModes)
		.field("maxIntraRefreshCycleDuration", &self.maxIntraRefreshCycleDuration)
		.field("maxIntraRefreshActiveReferencePictures", &self.maxIntraRefreshActiveReferencePictures)
		.field("partitionIndependentIntraRefreshRegions", &self.partitionIndependentIntraRefreshRegions)
		.field("nonRectangularIntraRefreshRegions", &self.nonRectangularIntraRefreshRegions)
		.finish()
	}
}
/// struct `VkVideoEncodeSessionIntraRefreshCreateInfoKHR` from VK_KHR_video_encode_intra_refresh
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeSessionIntraRefreshCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeSessionIntraRefreshCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub intraRefreshMode: VkVideoEncodeIntraRefreshModeFlagBitsKHR,
}
impl Debug for VkVideoEncodeSessionIntraRefreshCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeSessionIntraRefreshCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("intraRefreshMode", &self.intraRefreshMode)
		.finish()
	}
}
/// struct `VkVideoEncodeIntraRefreshInfoKHR` from VK_KHR_video_encode_intra_refresh
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeIntraRefreshInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeIntraRefreshInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub intraRefreshCycleDuration: u32,
	pub intraRefreshIndex: u32,
}
impl Debug for VkVideoEncodeIntraRefreshInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeIntraRefreshInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("intraRefreshCycleDuration", &self.intraRefreshCycleDuration)
		.field("intraRefreshIndex", &self.intraRefreshIndex)
		.finish()
	}
}
/// struct `VkVideoReferenceIntraRefreshInfoKHR` from VK_KHR_video_encode_intra_refresh
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoReferenceIntraRefreshInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoReferenceIntraRefreshInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dirtyIntraRefreshRegions: u32,
}
impl Debug for VkVideoReferenceIntraRefreshInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoReferenceIntraRefreshInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dirtyIntraRefreshRegions", &self.dirtyIntraRefreshRegions)
		.finish()
	}
}
/// struct `VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR` from VK_KHR_video_encode_intra_refresh
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub videoEncodeIntraRefresh: VkBool32,
}
impl Debug for VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("videoEncodeIntraRefresh", &self.videoEncodeIntraRefresh)
		.finish()
	}
}
/// trait for `VK_KHR_video_encode_intra_refresh`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_video_encode_intra_refresh.html>
pub trait VK_KHR_video_encode_intra_refresh: Debug {}
/// struct for `VK_KHR_video_encode_intra_refresh`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_encode_intra_refresh {}
impl VK_KHR_video_encode_intra_refresh for Vulkan_KHR_video_encode_intra_refresh {}
impl Default for Vulkan_KHR_video_encode_intra_refresh {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_encode_intra_refresh {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkVideoEncodeQuantizationMapCapabilitiesKHR` from VK_KHR_video_encode_quantization_map
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeQuantizationMapCapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeQuantizationMapCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxQuantizationMapExtent: VkExtent2D,
}
impl Debug for VkVideoEncodeQuantizationMapCapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeQuantizationMapCapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxQuantizationMapExtent", &self.maxQuantizationMapExtent)
		.finish()
	}
}
/// struct `VkVideoFormatQuantizationMapPropertiesKHR` from VK_KHR_video_encode_quantization_map
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoFormatQuantizationMapPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoFormatQuantizationMapPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub quantizationMapTexelSize: VkExtent2D,
}
impl Debug for VkVideoFormatQuantizationMapPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoFormatQuantizationMapPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("quantizationMapTexelSize", &self.quantizationMapTexelSize)
		.finish()
	}
}
/// struct `VkVideoEncodeQuantizationMapInfoKHR` from VK_KHR_video_encode_quantization_map
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeQuantizationMapInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeQuantizationMapInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub quantizationMap: VkImageView,
	pub quantizationMapExtent: VkExtent2D,
}
impl Debug for VkVideoEncodeQuantizationMapInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeQuantizationMapInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("quantizationMap", &self.quantizationMap)
		.field("quantizationMapExtent", &self.quantizationMapExtent)
		.finish()
	}
}
/// struct `VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR` from VK_KHR_video_encode_quantization_map
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub quantizationMapTexelSize: VkExtent2D,
}
impl Debug for VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("quantizationMapTexelSize", &self.quantizationMapTexelSize)
		.finish()
	}
}
/// struct `VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR` from VK_KHR_video_encode_quantization_map
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub videoEncodeQuantizationMap: VkBool32,
}
impl Debug for VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("videoEncodeQuantizationMap", &self.videoEncodeQuantizationMap)
		.finish()
	}
}
/// struct `VkVideoEncodeH264QuantizationMapCapabilitiesKHR` from VK_KHR_video_encode_quantization_map
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH264QuantizationMapCapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH264QuantizationMapCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minQpDelta: i32,
	pub maxQpDelta: i32,
}
impl Debug for VkVideoEncodeH264QuantizationMapCapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH264QuantizationMapCapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("minQpDelta", &self.minQpDelta)
		.field("maxQpDelta", &self.maxQpDelta)
		.finish()
	}
}
/// struct `VkVideoEncodeH265QuantizationMapCapabilitiesKHR` from VK_KHR_video_encode_quantization_map
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeH265QuantizationMapCapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeH265QuantizationMapCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minQpDelta: i32,
	pub maxQpDelta: i32,
}
impl Debug for VkVideoEncodeH265QuantizationMapCapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeH265QuantizationMapCapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("minQpDelta", &self.minQpDelta)
		.field("maxQpDelta", &self.maxQpDelta)
		.finish()
	}
}
/// struct `VkVideoFormatH265QuantizationMapPropertiesKHR` from VK_KHR_video_encode_quantization_map
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoFormatH265QuantizationMapPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoFormatH265QuantizationMapPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub compatibleCtbSizes: VkVideoEncodeH265CtbSizeFlagsKHR,
}
impl Debug for VkVideoFormatH265QuantizationMapPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoFormatH265QuantizationMapPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("compatibleCtbSizes", &self.compatibleCtbSizes)
		.finish()
	}
}
/// struct `VkVideoEncodeAV1QuantizationMapCapabilitiesKHR` from VK_KHR_video_encode_quantization_map
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoEncodeAV1QuantizationMapCapabilitiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoEncodeAV1QuantizationMapCapabilitiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minQIndexDelta: i32,
	pub maxQIndexDelta: i32,
}
impl Debug for VkVideoEncodeAV1QuantizationMapCapabilitiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoEncodeAV1QuantizationMapCapabilitiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("minQIndexDelta", &self.minQIndexDelta)
		.field("maxQIndexDelta", &self.maxQIndexDelta)
		.finish()
	}
}
/// struct `VkVideoFormatAV1QuantizationMapPropertiesKHR` from VK_KHR_video_encode_quantization_map
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoFormatAV1QuantizationMapPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoFormatAV1QuantizationMapPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub compatibleSuperblockSizes: VkVideoEncodeAV1SuperblockSizeFlagsKHR,
}
impl Debug for VkVideoFormatAV1QuantizationMapPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoFormatAV1QuantizationMapPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("compatibleSuperblockSizes", &self.compatibleSuperblockSizes)
		.finish()
	}
}
/// trait for `VK_KHR_video_encode_quantization_map`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_video_encode_quantization_map.html>
pub trait VK_KHR_video_encode_quantization_map: Debug {}
/// struct for `VK_KHR_video_encode_quantization_map`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_encode_quantization_map {}
impl VK_KHR_video_encode_quantization_map for Vulkan_KHR_video_encode_quantization_map {}
impl Default for Vulkan_KHR_video_encode_quantization_map {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_encode_quantization_map {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR` from VK_KHR_shader_relaxed_extended_instruction
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderRelaxedExtendedInstruction: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderRelaxedExtendedInstruction", &self.shaderRelaxedExtendedInstruction)
		.finish()
	}
}
/// trait for `VK_KHR_shader_relaxed_extended_instruction`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_shader_relaxed_extended_instruction.html>
pub trait VK_KHR_shader_relaxed_extended_instruction: Debug {}
/// struct for `VK_KHR_shader_relaxed_extended_instruction`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_shader_relaxed_extended_instruction {}
impl VK_KHR_shader_relaxed_extended_instruction for Vulkan_KHR_shader_relaxed_extended_instruction {}
impl Default for Vulkan_KHR_shader_relaxed_extended_instruction {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_shader_relaxed_extended_instruction {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkPhysicalDeviceLayeredApiKHR` from VK_KHR_maintenance7
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLayeredApiKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPhysicalDeviceLayeredApiKHR {
	VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR = 0,
	VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR = 1,
	VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR = 2,
	VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR = 3,
	VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR = 4,
	VK_PHYSICAL_DEVICE_LAYERED_API_MAX_ENUM_KHR = 0x7fffffff,
}
/// struct `VkPhysicalDeviceMaintenance7FeaturesKHR` from VK_KHR_maintenance7
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance7FeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance7FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maintenance7: VkBool32,
}
impl Debug for VkPhysicalDeviceMaintenance7FeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMaintenance7FeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maintenance7", &self.maintenance7)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMaintenance7PropertiesKHR` from VK_KHR_maintenance7
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance7PropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance7PropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub robustFragmentShadingRateAttachmentAccess: VkBool32,
	pub separateDepthStencilAttachmentAccess: VkBool32,
	pub maxDescriptorSetTotalUniformBuffersDynamic: u32,
	pub maxDescriptorSetTotalStorageBuffersDynamic: u32,
	pub maxDescriptorSetTotalBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic: u32,
	pub maxDescriptorSetUpdateAfterBindTotalBuffersDynamic: u32,
}
impl Debug for VkPhysicalDeviceMaintenance7PropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMaintenance7PropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("robustFragmentShadingRateAttachmentAccess", &self.robustFragmentShadingRateAttachmentAccess)
		.field("separateDepthStencilAttachmentAccess", &self.separateDepthStencilAttachmentAccess)
		.field("maxDescriptorSetTotalUniformBuffersDynamic", &self.maxDescriptorSetTotalUniformBuffersDynamic)
		.field("maxDescriptorSetTotalStorageBuffersDynamic", &self.maxDescriptorSetTotalStorageBuffersDynamic)
		.field("maxDescriptorSetTotalBuffersDynamic", &self.maxDescriptorSetTotalBuffersDynamic)
		.field("maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic", &self.maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic)
		.field("maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic", &self.maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic)
		.field("maxDescriptorSetUpdateAfterBindTotalBuffersDynamic", &self.maxDescriptorSetUpdateAfterBindTotalBuffersDynamic)
		.finish()
	}
}
/// struct `VkPhysicalDeviceLayeredApiPropertiesKHR` from VK_KHR_maintenance7
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLayeredApiPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceLayeredApiPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub vendorID: u32,
	pub deviceID: u32,
	pub layeredAPI: VkPhysicalDeviceLayeredApiKHR,
	pub deviceName: [i8; VK_MAX_PHYSICAL_DEVICE_NAME_SIZE as usize],
}
impl Debug for VkPhysicalDeviceLayeredApiPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceLayeredApiPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("vendorID", &self.vendorID)
		.field("deviceID", &self.deviceID)
		.field("layeredAPI", &self.layeredAPI)
		.field("deviceName", &format_args!("{}", maybe_string(&self.deviceName)))
		.finish()
	}
}
/// struct `VkPhysicalDeviceLayeredApiPropertiesListKHR` from VK_KHR_maintenance7
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLayeredApiPropertiesListKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceLayeredApiPropertiesListKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub layeredApiCount: u32,
	pub pLayeredApis: *mut VkPhysicalDeviceLayeredApiPropertiesKHR,
}
impl Debug for VkPhysicalDeviceLayeredApiPropertiesListKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceLayeredApiPropertiesListKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("layeredApiCount", &self.layeredApiCount)
		.field("pLayeredApis", &self.pLayeredApis)
		.finish()
	}
}
/// struct `VkPhysicalDeviceLayeredApiVulkanPropertiesKHR` from VK_KHR_maintenance7
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLayeredApiVulkanPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceLayeredApiVulkanPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub properties: VkPhysicalDeviceProperties2,
}
impl Debug for VkPhysicalDeviceLayeredApiVulkanPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceLayeredApiVulkanPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("properties", &self.properties)
		.finish()
	}
}
/// trait for `VK_KHR_maintenance7`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_maintenance7.html>
pub trait VK_KHR_maintenance7: Debug {}
/// struct for `VK_KHR_maintenance7`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance7 {}
impl VK_KHR_maintenance7 for Vulkan_KHR_maintenance7 {}
impl Default for Vulkan_KHR_maintenance7 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_maintenance7 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkAccessFlags3KHR` from VK_KHR_maintenance8
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccessFlags3KHR.html>
pub type VkAccessFlags3KHR = VkFlags64;
/// type definition `VkAccessFlagBits3KHR` from VK_KHR_maintenance8
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccessFlagBits3KHR.html>
pub type VkAccessFlagBits3KHR = VkFlags64;
/// struct `VkMemoryBarrierAccessFlags3KHR` from VK_KHR_maintenance8
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryBarrierAccessFlags3KHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryBarrierAccessFlags3KHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcAccessMask3: VkAccessFlags3KHR,
	pub dstAccessMask3: VkAccessFlags3KHR,
}
impl Debug for VkMemoryBarrierAccessFlags3KHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryBarrierAccessFlags3KHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcAccessMask3", &self.srcAccessMask3)
		.field("dstAccessMask3", &self.dstAccessMask3)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMaintenance8FeaturesKHR` from VK_KHR_maintenance8
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance8FeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance8FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maintenance8: VkBool32,
}
impl Debug for VkPhysicalDeviceMaintenance8FeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMaintenance8FeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maintenance8", &self.maintenance8)
		.finish()
	}
}
/// trait for `VK_KHR_maintenance8`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_maintenance8.html>
pub trait VK_KHR_maintenance8: Debug {}
/// struct for `VK_KHR_maintenance8`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance8 {}
impl VK_KHR_maintenance8 for Vulkan_KHR_maintenance8 {}
impl Default for Vulkan_KHR_maintenance8 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_maintenance8 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkDefaultVertexAttributeValueKHR` from VK_KHR_maintenance9
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDefaultVertexAttributeValueKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDefaultVertexAttributeValueKHR {
	VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR = 0,
	VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR = 1,
	VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_MAX_ENUM_KHR = 0x7fffffff,
}
/// struct `VkPhysicalDeviceMaintenance9FeaturesKHR` from VK_KHR_maintenance9
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance9FeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance9FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maintenance9: VkBool32,
}
impl Debug for VkPhysicalDeviceMaintenance9FeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMaintenance9FeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maintenance9", &self.maintenance9)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMaintenance9PropertiesKHR` from VK_KHR_maintenance9
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMaintenance9PropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMaintenance9PropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub image2DViewOf3DSparse: VkBool32,
	pub defaultVertexAttributeValue: VkDefaultVertexAttributeValueKHR,
}
impl Debug for VkPhysicalDeviceMaintenance9PropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMaintenance9PropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("image2DViewOf3DSparse", &self.image2DViewOf3DSparse)
		.field("defaultVertexAttributeValue", &self.defaultVertexAttributeValue)
		.finish()
	}
}
/// struct `VkQueueFamilyOwnershipTransferPropertiesKHR` from VK_KHR_maintenance9
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueFamilyOwnershipTransferPropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkQueueFamilyOwnershipTransferPropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub optimalImageTransferToQueueFamilies: u32,
}
impl Debug for VkQueueFamilyOwnershipTransferPropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkQueueFamilyOwnershipTransferPropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("optimalImageTransferToQueueFamilies", &self.optimalImageTransferToQueueFamilies)
		.finish()
	}
}
/// trait for `VK_KHR_maintenance9`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_maintenance9.html>
pub trait VK_KHR_maintenance9: Debug {}
/// struct for `VK_KHR_maintenance9`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_maintenance9 {}
impl VK_KHR_maintenance9 for Vulkan_KHR_maintenance9 {}
impl Default for Vulkan_KHR_maintenance9 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_maintenance9 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceVideoMaintenance2FeaturesKHR` from VK_KHR_video_maintenance2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVideoMaintenance2FeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVideoMaintenance2FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub videoMaintenance2: VkBool32,
}
impl Debug for VkPhysicalDeviceVideoMaintenance2FeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVideoMaintenance2FeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("videoMaintenance2", &self.videoMaintenance2)
		.finish()
	}
}
/// struct `VkVideoDecodeH264InlineSessionParametersInfoKHR` from VK_KHR_video_maintenance2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeH264InlineSessionParametersInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeH264InlineSessionParametersInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdSPS: *const StdVideoH264SequenceParameterSet,
	pub pStdPPS: *const StdVideoH264PictureParameterSet,
}
impl Debug for VkVideoDecodeH264InlineSessionParametersInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH264InlineSessionParametersInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pStdSPS", &self.pStdSPS)
		.field("pStdPPS", &self.pStdPPS)
		.finish()
	}
}
/// struct `VkVideoDecodeH265InlineSessionParametersInfoKHR` from VK_KHR_video_maintenance2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeH265InlineSessionParametersInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeH265InlineSessionParametersInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdVPS: *const StdVideoH265VideoParameterSet,
	pub pStdSPS: *const StdVideoH265SequenceParameterSet,
	pub pStdPPS: *const StdVideoH265PictureParameterSet,
}
impl Debug for VkVideoDecodeH265InlineSessionParametersInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeH265InlineSessionParametersInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pStdVPS", &self.pStdVPS)
		.field("pStdSPS", &self.pStdSPS)
		.field("pStdPPS", &self.pStdPPS)
		.finish()
	}
}
/// struct `VkVideoDecodeAV1InlineSessionParametersInfoKHR` from VK_KHR_video_maintenance2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoDecodeAV1InlineSessionParametersInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVideoDecodeAV1InlineSessionParametersInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pStdSequenceHeader: *const StdVideoAV1SequenceHeader,
}
impl Debug for VkVideoDecodeAV1InlineSessionParametersInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVideoDecodeAV1InlineSessionParametersInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pStdSequenceHeader", &self.pStdSequenceHeader)
		.finish()
	}
}
/// trait for `VK_KHR_video_maintenance2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_video_maintenance2.html>
pub trait VK_KHR_video_maintenance2: Debug {}
/// struct for `VK_KHR_video_maintenance2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_video_maintenance2 {}
impl VK_KHR_video_maintenance2 for Vulkan_KHR_video_maintenance2 {}
impl Default for Vulkan_KHR_video_maintenance2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_video_maintenance2 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceDepthClampZeroOneFeaturesKHR` from VK_KHR_depth_clamp_zero_one
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDepthClampZeroOneFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDepthClampZeroOneFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub depthClampZeroOne: VkBool32,
}
impl Debug for VkPhysicalDeviceDepthClampZeroOneFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDepthClampZeroOneFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("depthClampZeroOne", &self.depthClampZeroOne)
		.finish()
	}
}
/// trait for `VK_KHR_depth_clamp_zero_one`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_depth_clamp_zero_one.html>
pub trait VK_KHR_depth_clamp_zero_one: Debug {}
/// struct for `VK_KHR_depth_clamp_zero_one`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_depth_clamp_zero_one {}
impl VK_KHR_depth_clamp_zero_one for Vulkan_KHR_depth_clamp_zero_one {}
impl Default for Vulkan_KHR_depth_clamp_zero_one {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_depth_clamp_zero_one {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceRobustness2FeaturesKHR` from VK_KHR_robustness2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRobustness2FeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRobustness2FeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub robustBufferAccess2: VkBool32,
	pub robustImageAccess2: VkBool32,
	pub nullDescriptor: VkBool32,
}
impl Debug for VkPhysicalDeviceRobustness2FeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRobustness2FeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("robustBufferAccess2", &self.robustBufferAccess2)
		.field("robustImageAccess2", &self.robustImageAccess2)
		.field("nullDescriptor", &self.nullDescriptor)
		.finish()
	}
}
/// struct `VkPhysicalDeviceRobustness2PropertiesKHR` from VK_KHR_robustness2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRobustness2PropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRobustness2PropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub robustStorageBufferAccessSizeAlignment: VkDeviceSize,
	pub robustUniformBufferAccessSizeAlignment: VkDeviceSize,
}
impl Debug for VkPhysicalDeviceRobustness2PropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRobustness2PropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("robustStorageBufferAccessSizeAlignment", &self.robustStorageBufferAccessSizeAlignment)
		.field("robustUniformBufferAccessSizeAlignment", &self.robustUniformBufferAccessSizeAlignment)
		.finish()
	}
}
/// trait for `VK_KHR_robustness2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_robustness2.html>
pub trait VK_KHR_robustness2: Debug {}
/// struct for `VK_KHR_robustness2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_robustness2 {}
impl VK_KHR_robustness2 for Vulkan_KHR_robustness2 {}
impl Default for Vulkan_KHR_robustness2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_robustness2 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR` from VK_KHR_present_mode_fifo_latest_ready
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentModeFifoLatestReady: VkBool32,
}
impl Debug for VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentModeFifoLatestReady", &self.presentModeFifoLatestReady)
		.finish()
	}
}
/// trait for `VK_KHR_present_mode_fifo_latest_ready`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_present_mode_fifo_latest_ready.html>
pub trait VK_KHR_present_mode_fifo_latest_ready: Debug {}
/// struct for `VK_KHR_present_mode_fifo_latest_ready`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_present_mode_fifo_latest_ready {}
impl VK_KHR_present_mode_fifo_latest_ready for Vulkan_KHR_present_mode_fifo_latest_ready {}
impl Default for Vulkan_KHR_present_mode_fifo_latest_ready {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_present_mode_fifo_latest_ready {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkDebugReportFlagsEXT` from VK_EXT_debug_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugReportFlagsEXT.html>
pub type VkDebugReportFlagsEXT = VkFlags;
/// Non-dispatchable handle `VkDebugReportCallbackEXT` from VK_EXT_debug_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugReportCallbackEXT.html
#[cfg(target_pointer_width = "32")] pub type VkDebugReportCallbackEXT = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkDebugReportCallbackEXT_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkDebugReportCallbackEXT = *const VkDebugReportCallbackEXT_T;
/// enum `VkDebugReportObjectTypeEXT` from VK_EXT_debug_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugReportObjectTypeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDebugReportObjectTypeEXT {
	VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
	VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
	VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
	VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
	VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
	VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
	VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
	VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
	VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
	VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
	VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
	VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
	VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
	VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT = 1000029000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT = 1000029001,
	VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT = 1000150000,
	VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT = 1000307000,
	VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT = 1000307001,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT = 1000366000,
	VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
impl VkDebugReportObjectTypeEXT {
	pub const VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT: VkDebugReportObjectTypeEXT = VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT;
	pub const VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT: VkDebugReportObjectTypeEXT = VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT;
	pub const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT: VkDebugReportObjectTypeEXT = VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT;
	pub const VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT: VkDebugReportObjectTypeEXT = VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT;
}
/// enum `VkDebugReportFlagBitsEXT` from VK_EXT_debug_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugReportFlagBitsEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDebugReportFlagBitsEXT {
	VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001,
	VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002,
	VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
	VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008,
	VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010,
	VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkDebugReportCallbackCreateInfoEXT` from VK_EXT_debug_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugReportCallbackCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDebugReportCallbackCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDebugReportFlagsEXT,
	pub pfnCallback: PFN_vkDebugReportCallbackEXT,
	pub pUserData: *mut c_void,
}
impl Debug for VkDebugReportCallbackCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDebugReportCallbackCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("pfnCallback", &self.pfnCallback)
		.field("pUserData", &self.pUserData)
		.finish()
	}
}
/// function prototype `PFN_vkDebugReportCallbackEXT` from VK_EXT_debug_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDebugReportCallbackEXT.html>
type PFN_vkDebugReportCallbackEXT = extern "system" fn(flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT, object: u64, location: usize, messageCode: i32, pLayerPrefix: *const i8, pMessage: *const i8, pUserData: *mut c_void) -> VkBool32;
/// function prototype `PFN_vkCreateDebugReportCallbackEXT` from VK_EXT_debug_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDebugReportCallbackEXT.html>
type PFN_vkCreateDebugReportCallbackEXT = extern "system" fn(instance: VkInstance, pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pCallback: *mut VkDebugReportCallbackEXT) -> VkResult;
/// function prototype `PFN_vkDestroyDebugReportCallbackEXT` from VK_EXT_debug_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDebugReportCallbackEXT.html>
type PFN_vkDestroyDebugReportCallbackEXT = extern "system" fn(instance: VkInstance, callback: VkDebugReportCallbackEXT, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkDebugReportMessageEXT` from VK_EXT_debug_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDebugReportMessageEXT.html>
type PFN_vkDebugReportMessageEXT = extern "system" fn(instance: VkInstance, flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT, object: u64, location: usize, messageCode: i32, pLayerPrefix: *const i8, pMessage: *const i8);
/// The dummy function for `vkCreateDebugReportCallbackEXT` from `VK_EXT_debug_report`
extern "system" fn dummy_vkCreateDebugReportCallbackEXT(_: VkInstance, _: *const VkDebugReportCallbackCreateInfoEXT, _: *const VkAllocationCallbacks, _: *mut VkDebugReportCallbackEXT) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateDebugReportCallbackEXT"))
}
/// trait for `VK_EXT_debug_report`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_debug_report.html>
pub trait VK_EXT_debug_report: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDebugReportCallbackEXT.html>
	fn vkCreateDebugReportCallbackEXT(&self, instance: VkInstance, pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pCallback: *mut VkDebugReportCallbackEXT) -> Result<()>;
}
/// struct for `VK_EXT_debug_report`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_debug_report {
	vk_create_debug_report_callback_ext: PFN_vkCreateDebugReportCallbackEXT,
}
impl VK_EXT_debug_report for Vulkan_EXT_debug_report {
	fn vkCreateDebugReportCallbackEXT(&self, instance: VkInstance, pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pCallback: *mut VkDebugReportCallbackEXT) -> Result<()> {
		convert_result("vkCreateDebugReportCallbackEXT", catch_unwind(||((self.vk_create_debug_report_callback_ext)(instance, pCreateInfo, pAllocator, pCallback))))
	}
}
impl Default for Vulkan_EXT_debug_report {
	fn default() -> Self {
		Self {
			vk_create_debug_report_callback_ext: dummy_vkCreateDebugReportCallbackEXT,
		}
	}
}
impl Vulkan_EXT_debug_report {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_debug_report_callback_ext: {let proc = get_instance_proc_address(instance, "vkCreateDebugReportCallbackEXT"); if proc == null() {dummy_vkCreateDebugReportCallbackEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// trait for `VK_NV_glsl_shader`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_glsl_shader.html>
pub trait VK_NV_glsl_shader: Debug {}
/// struct for `VK_NV_glsl_shader`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_glsl_shader {}
impl VK_NV_glsl_shader for Vulkan_NV_glsl_shader {}
impl Default for Vulkan_NV_glsl_shader {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_glsl_shader {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_EXT_depth_range_unrestricted`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_depth_range_unrestricted.html>
pub trait VK_EXT_depth_range_unrestricted: Debug {}
/// struct for `VK_EXT_depth_range_unrestricted`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_depth_range_unrestricted {}
impl VK_EXT_depth_range_unrestricted for Vulkan_EXT_depth_range_unrestricted {}
impl Default for Vulkan_EXT_depth_range_unrestricted {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_depth_range_unrestricted {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_IMG_filter_cubic`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_IMG_filter_cubic.html>
pub trait VK_IMG_filter_cubic: Debug {}
/// struct for `VK_IMG_filter_cubic`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_IMG_filter_cubic {}
impl VK_IMG_filter_cubic for Vulkan_IMG_filter_cubic {}
impl Default for Vulkan_IMG_filter_cubic {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_IMG_filter_cubic {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkRasterizationOrderAMD` from VK_AMD_rasterization_order
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRasterizationOrderAMD.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkRasterizationOrderAMD {
	VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
	VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
	VK_RASTERIZATION_ORDER_MAX_ENUM_AMD = 0x7fffffff,
}
/// struct `VkPipelineRasterizationStateRasterizationOrderAMD` from VK_AMD_rasterization_order
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRasterizationStateRasterizationOrderAMD.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineRasterizationStateRasterizationOrderAMD {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub rasterizationOrder: VkRasterizationOrderAMD,
}
impl Debug for VkPipelineRasterizationStateRasterizationOrderAMD {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineRasterizationStateRasterizationOrderAMD")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("rasterizationOrder", &self.rasterizationOrder)
		.finish()
	}
}
/// trait for `VK_AMD_rasterization_order`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_rasterization_order.html>
pub trait VK_AMD_rasterization_order: Debug {}
/// struct for `VK_AMD_rasterization_order`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_rasterization_order {}
impl VK_AMD_rasterization_order for Vulkan_AMD_rasterization_order {}
impl Default for Vulkan_AMD_rasterization_order {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_rasterization_order {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_AMD_shader_trinary_minmax`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_shader_trinary_minmax.html>
pub trait VK_AMD_shader_trinary_minmax: Debug {}
/// struct for `VK_AMD_shader_trinary_minmax`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_trinary_minmax {}
impl VK_AMD_shader_trinary_minmax for Vulkan_AMD_shader_trinary_minmax {}
impl Default for Vulkan_AMD_shader_trinary_minmax {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_shader_trinary_minmax {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_AMD_shader_explicit_vertex_parameter`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_shader_explicit_vertex_parameter.html>
pub trait VK_AMD_shader_explicit_vertex_parameter: Debug {}
/// struct for `VK_AMD_shader_explicit_vertex_parameter`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_explicit_vertex_parameter {}
impl VK_AMD_shader_explicit_vertex_parameter for Vulkan_AMD_shader_explicit_vertex_parameter {}
impl Default for Vulkan_AMD_shader_explicit_vertex_parameter {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_shader_explicit_vertex_parameter {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkDebugMarkerObjectNameInfoEXT` from VK_EXT_debug_marker
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugMarkerObjectNameInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDebugMarkerObjectNameInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub objectType: VkDebugReportObjectTypeEXT,
	pub object: u64,
	pub pObjectName: *const i8,
}
impl Debug for VkDebugMarkerObjectNameInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDebugMarkerObjectNameInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("objectType", &self.objectType)
		.field("object", &self.object)
		.field("pObjectName", &self.pObjectName)
		.finish()
	}
}
/// struct `VkDebugMarkerObjectTagInfoEXT` from VK_EXT_debug_marker
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugMarkerObjectTagInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDebugMarkerObjectTagInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub objectType: VkDebugReportObjectTypeEXT,
	pub object: u64,
	pub tagName: u64,
	pub tagSize: usize,
	pub pTag: *const c_void,
}
impl Debug for VkDebugMarkerObjectTagInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDebugMarkerObjectTagInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("objectType", &self.objectType)
		.field("object", &self.object)
		.field("tagName", &self.tagName)
		.field("tagSize", &self.tagSize)
		.field("pTag", &self.pTag)
		.finish()
	}
}
/// struct `VkDebugMarkerMarkerInfoEXT` from VK_EXT_debug_marker
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugMarkerMarkerInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDebugMarkerMarkerInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pMarkerName: *const i8,
	pub color: [f32; 4 as usize],
}
impl Debug for VkDebugMarkerMarkerInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDebugMarkerMarkerInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pMarkerName", &self.pMarkerName)
		.field("color", &self.color)
		.finish()
	}
}
/// function prototype `PFN_vkDebugMarkerSetObjectTagEXT` from VK_EXT_debug_marker
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDebugMarkerSetObjectTagEXT.html>
type PFN_vkDebugMarkerSetObjectTagEXT = extern "system" fn(device: VkDevice, pTagInfo: *const VkDebugMarkerObjectTagInfoEXT) -> VkResult;
/// function prototype `PFN_vkDebugMarkerSetObjectNameEXT` from VK_EXT_debug_marker
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDebugMarkerSetObjectNameEXT.html>
type PFN_vkDebugMarkerSetObjectNameEXT = extern "system" fn(device: VkDevice, pNameInfo: *const VkDebugMarkerObjectNameInfoEXT) -> VkResult;
/// function prototype `PFN_vkCmdDebugMarkerBeginEXT` from VK_EXT_debug_marker
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDebugMarkerBeginEXT.html>
type PFN_vkCmdDebugMarkerBeginEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pMarkerInfo: *const VkDebugMarkerMarkerInfoEXT);
/// function prototype `PFN_vkCmdDebugMarkerEndEXT` from VK_EXT_debug_marker
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDebugMarkerEndEXT.html>
type PFN_vkCmdDebugMarkerEndEXT = extern "system" fn(commandBuffer: VkCommandBuffer);
/// function prototype `PFN_vkCmdDebugMarkerInsertEXT` from VK_EXT_debug_marker
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDebugMarkerInsertEXT.html>
type PFN_vkCmdDebugMarkerInsertEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pMarkerInfo: *const VkDebugMarkerMarkerInfoEXT);
/// The dummy function for `vkDebugMarkerSetObjectTagEXT` from `VK_EXT_debug_marker`
extern "system" fn dummy_vkDebugMarkerSetObjectTagEXT(_: VkDevice, _: *const VkDebugMarkerObjectTagInfoEXT) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkDebugMarkerSetObjectTagEXT"))
}
/// trait for `VK_EXT_debug_marker`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_debug_marker.html>
pub trait VK_EXT_debug_marker: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDebugMarkerSetObjectTagEXT.html>
	fn vkDebugMarkerSetObjectTagEXT(&self, device: VkDevice, pTagInfo: *const VkDebugMarkerObjectTagInfoEXT) -> Result<()>;
}
/// struct for `VK_EXT_debug_marker`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_debug_marker {
	vk_debug_marker_set_object_tag_ext: PFN_vkDebugMarkerSetObjectTagEXT,
}
impl VK_EXT_debug_marker for Vulkan_EXT_debug_marker {
	fn vkDebugMarkerSetObjectTagEXT(&self, device: VkDevice, pTagInfo: *const VkDebugMarkerObjectTagInfoEXT) -> Result<()> {
		convert_result("vkDebugMarkerSetObjectTagEXT", catch_unwind(||((self.vk_debug_marker_set_object_tag_ext)(device, pTagInfo))))
	}
}
impl Default for Vulkan_EXT_debug_marker {
	fn default() -> Self {
		Self {
			vk_debug_marker_set_object_tag_ext: dummy_vkDebugMarkerSetObjectTagEXT,
		}
	}
}
impl Vulkan_EXT_debug_marker {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_debug_marker_set_object_tag_ext: {let proc = get_instance_proc_address(instance, "vkDebugMarkerSetObjectTagEXT"); if proc == null() {dummy_vkDebugMarkerSetObjectTagEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// trait for `VK_AMD_gcn_shader`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_gcn_shader.html>
pub trait VK_AMD_gcn_shader: Debug {}
/// struct for `VK_AMD_gcn_shader`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_gcn_shader {}
impl VK_AMD_gcn_shader for Vulkan_AMD_gcn_shader {}
impl Default for Vulkan_AMD_gcn_shader {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_gcn_shader {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkDedicatedAllocationImageCreateInfoNV` from VK_NV_dedicated_allocation
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDedicatedAllocationImageCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDedicatedAllocationImageCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dedicatedAllocation: VkBool32,
}
impl Debug for VkDedicatedAllocationImageCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDedicatedAllocationImageCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dedicatedAllocation", &self.dedicatedAllocation)
		.finish()
	}
}
/// struct `VkDedicatedAllocationBufferCreateInfoNV` from VK_NV_dedicated_allocation
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDedicatedAllocationBufferCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDedicatedAllocationBufferCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dedicatedAllocation: VkBool32,
}
impl Debug for VkDedicatedAllocationBufferCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDedicatedAllocationBufferCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dedicatedAllocation", &self.dedicatedAllocation)
		.finish()
	}
}
/// struct `VkDedicatedAllocationMemoryAllocateInfoNV` from VK_NV_dedicated_allocation
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDedicatedAllocationMemoryAllocateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDedicatedAllocationMemoryAllocateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub image: VkImage,
	pub buffer: VkBuffer,
}
impl Debug for VkDedicatedAllocationMemoryAllocateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDedicatedAllocationMemoryAllocateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("image", &self.image)
		.field("buffer", &self.buffer)
		.finish()
	}
}
/// trait for `VK_NV_dedicated_allocation`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_dedicated_allocation.html>
pub trait VK_NV_dedicated_allocation: Debug {}
/// struct for `VK_NV_dedicated_allocation`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_dedicated_allocation {}
impl VK_NV_dedicated_allocation for Vulkan_NV_dedicated_allocation {}
impl Default for Vulkan_NV_dedicated_allocation {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_dedicated_allocation {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPipelineRasterizationStateStreamCreateFlagsEXT` from VK_EXT_transform_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRasterizationStateStreamCreateFlagsEXT.html>
pub type VkPipelineRasterizationStateStreamCreateFlagsEXT = VkFlags;
/// struct `VkPhysicalDeviceTransformFeedbackFeaturesEXT` from VK_EXT_transform_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTransformFeedbackFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceTransformFeedbackFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub transformFeedback: VkBool32,
	pub geometryStreams: VkBool32,
}
impl Debug for VkPhysicalDeviceTransformFeedbackFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceTransformFeedbackFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("transformFeedback", &self.transformFeedback)
		.field("geometryStreams", &self.geometryStreams)
		.finish()
	}
}
/// struct `VkPhysicalDeviceTransformFeedbackPropertiesEXT` from VK_EXT_transform_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTransformFeedbackPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceTransformFeedbackPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxTransformFeedbackStreams: u32,
	pub maxTransformFeedbackBuffers: u32,
	pub maxTransformFeedbackBufferSize: VkDeviceSize,
	pub maxTransformFeedbackStreamDataSize: u32,
	pub maxTransformFeedbackBufferDataSize: u32,
	pub maxTransformFeedbackBufferDataStride: u32,
	pub transformFeedbackQueries: VkBool32,
	pub transformFeedbackStreamsLinesTriangles: VkBool32,
	pub transformFeedbackRasterizationStreamSelect: VkBool32,
	pub transformFeedbackDraw: VkBool32,
}
impl Debug for VkPhysicalDeviceTransformFeedbackPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceTransformFeedbackPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxTransformFeedbackStreams", &self.maxTransformFeedbackStreams)
		.field("maxTransformFeedbackBuffers", &self.maxTransformFeedbackBuffers)
		.field("maxTransformFeedbackBufferSize", &self.maxTransformFeedbackBufferSize)
		.field("maxTransformFeedbackStreamDataSize", &self.maxTransformFeedbackStreamDataSize)
		.field("maxTransformFeedbackBufferDataSize", &self.maxTransformFeedbackBufferDataSize)
		.field("maxTransformFeedbackBufferDataStride", &self.maxTransformFeedbackBufferDataStride)
		.field("transformFeedbackQueries", &self.transformFeedbackQueries)
		.field("transformFeedbackStreamsLinesTriangles", &self.transformFeedbackStreamsLinesTriangles)
		.field("transformFeedbackRasterizationStreamSelect", &self.transformFeedbackRasterizationStreamSelect)
		.field("transformFeedbackDraw", &self.transformFeedbackDraw)
		.finish()
	}
}
/// struct `VkPipelineRasterizationStateStreamCreateInfoEXT` from VK_EXT_transform_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRasterizationStateStreamCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineRasterizationStateStreamCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineRasterizationStateStreamCreateFlagsEXT,
	pub rasterizationStream: u32,
}
impl Debug for VkPipelineRasterizationStateStreamCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineRasterizationStateStreamCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("rasterizationStream", &self.rasterizationStream)
		.finish()
	}
}
/// function prototype `PFN_vkCmdBindTransformFeedbackBuffersEXT` from VK_EXT_transform_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindTransformFeedbackBuffersEXT.html>
type PFN_vkCmdBindTransformFeedbackBuffersEXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize);
/// function prototype `PFN_vkCmdBeginTransformFeedbackEXT` from VK_EXT_transform_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginTransformFeedbackEXT.html>
type PFN_vkCmdBeginTransformFeedbackEXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *const VkBuffer, pCounterBufferOffsets: *const VkDeviceSize);
/// function prototype `PFN_vkCmdEndTransformFeedbackEXT` from VK_EXT_transform_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndTransformFeedbackEXT.html>
type PFN_vkCmdEndTransformFeedbackEXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *const VkBuffer, pCounterBufferOffsets: *const VkDeviceSize);
/// function prototype `PFN_vkCmdBeginQueryIndexedEXT` from VK_EXT_transform_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginQueryIndexedEXT.html>
type PFN_vkCmdBeginQueryIndexedEXT = extern "system" fn(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags, index: u32);
/// function prototype `PFN_vkCmdEndQueryIndexedEXT` from VK_EXT_transform_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndQueryIndexedEXT.html>
type PFN_vkCmdEndQueryIndexedEXT = extern "system" fn(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, index: u32);
/// function prototype `PFN_vkCmdDrawIndirectByteCountEXT` from VK_EXT_transform_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndirectByteCountEXT.html>
type PFN_vkCmdDrawIndirectByteCountEXT = extern "system" fn(commandBuffer: VkCommandBuffer, instanceCount: u32, firstInstance: u32, counterBuffer: VkBuffer, counterBufferOffset: VkDeviceSize, counterOffset: u32, vertexStride: u32);
/// The dummy function for `vkCmdBindTransformFeedbackBuffersEXT` from `VK_EXT_transform_feedback`
extern "system" fn dummy_vkCmdBindTransformFeedbackBuffersEXT(_: VkCommandBuffer, _: u32, _: u32, _: *const VkBuffer, _: *const VkDeviceSize, _: *const VkDeviceSize) {
	panic_any(VkError::NullFunctionPointer("vkCmdBindTransformFeedbackBuffersEXT"))
}
/// trait for `VK_EXT_transform_feedback`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_transform_feedback.html>
pub trait VK_EXT_transform_feedback: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindTransformFeedbackBuffersEXT.html>
	fn vkCmdBindTransformFeedbackBuffersEXT(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize) -> Result<()>;
}
/// struct for `VK_EXT_transform_feedback`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_transform_feedback {
	vk_cmd_bind_transform_feedback_buffers_ext: PFN_vkCmdBindTransformFeedbackBuffersEXT,
}
impl VK_EXT_transform_feedback for Vulkan_EXT_transform_feedback {
	fn vkCmdBindTransformFeedbackBuffersEXT(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_bind_transform_feedback_buffers_ext)(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes))))
	}
}
impl Default for Vulkan_EXT_transform_feedback {
	fn default() -> Self {
		Self {
			vk_cmd_bind_transform_feedback_buffers_ext: dummy_vkCmdBindTransformFeedbackBuffersEXT,
		}
	}
}
impl Vulkan_EXT_transform_feedback {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_bind_transform_feedback_buffers_ext: {let proc = get_instance_proc_address(instance, "vkCmdBindTransformFeedbackBuffersEXT"); if proc == null() {dummy_vkCmdBindTransformFeedbackBuffersEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// Non-dispatchable handle `VkCuModuleNVX` from VK_NVX_binary_import
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCuModuleNVX.html
#[cfg(target_pointer_width = "32")] pub type VkCuModuleNVX = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkCuModuleNVX_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkCuModuleNVX = *const VkCuModuleNVX_T;
/// Non-dispatchable handle `VkCuFunctionNVX` from VK_NVX_binary_import
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCuFunctionNVX.html
#[cfg(target_pointer_width = "32")] pub type VkCuFunctionNVX = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkCuFunctionNVX_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkCuFunctionNVX = *const VkCuFunctionNVX_T;
/// struct `VkCuModuleCreateInfoNVX` from VK_NVX_binary_import
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCuModuleCreateInfoNVX.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCuModuleCreateInfoNVX {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dataSize: usize,
	pub pData: *const c_void,
}
impl Debug for VkCuModuleCreateInfoNVX {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCuModuleCreateInfoNVX")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dataSize", &self.dataSize)
		.field("pData", &self.pData)
		.finish()
	}
}
/// struct `VkCuModuleTexturingModeCreateInfoNVX` from VK_NVX_binary_import
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCuModuleTexturingModeCreateInfoNVX.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCuModuleTexturingModeCreateInfoNVX {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub use64bitTexturing: VkBool32,
}
impl Debug for VkCuModuleTexturingModeCreateInfoNVX {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCuModuleTexturingModeCreateInfoNVX")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("use64bitTexturing", &self.use64bitTexturing)
		.finish()
	}
}
/// struct `VkCuFunctionCreateInfoNVX` from VK_NVX_binary_import
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCuFunctionCreateInfoNVX.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCuFunctionCreateInfoNVX {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub module: VkCuModuleNVX,
	pub pName: *const i8,
}
impl Debug for VkCuFunctionCreateInfoNVX {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCuFunctionCreateInfoNVX")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("module", &self.module)
		.field("pName", &self.pName)
		.finish()
	}
}
/// struct `VkCuLaunchInfoNVX` from VK_NVX_binary_import
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCuLaunchInfoNVX.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCuLaunchInfoNVX {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub function: VkCuFunctionNVX,
	pub gridDimX: u32,
	pub gridDimY: u32,
	pub gridDimZ: u32,
	pub blockDimX: u32,
	pub blockDimY: u32,
	pub blockDimZ: u32,
	pub sharedMemBytes: u32,
	pub paramCount: usize,
	pub pParams: *const *const c_void,
	pub extraCount: usize,
	pub pExtras: *const *const c_void,
}
impl Debug for VkCuLaunchInfoNVX {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCuLaunchInfoNVX")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("function", &self.function)
		.field("gridDimX", &self.gridDimX)
		.field("gridDimY", &self.gridDimY)
		.field("gridDimZ", &self.gridDimZ)
		.field("blockDimX", &self.blockDimX)
		.field("blockDimY", &self.blockDimY)
		.field("blockDimZ", &self.blockDimZ)
		.field("sharedMemBytes", &self.sharedMemBytes)
		.field("paramCount", &self.paramCount)
		.field("pParams", &self.pParams)
		.field("extraCount", &self.extraCount)
		.field("pExtras", &self.pExtras)
		.finish()
	}
}
/// function prototype `PFN_vkCreateCuModuleNVX` from VK_NVX_binary_import
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCuModuleNVX.html>
type PFN_vkCreateCuModuleNVX = extern "system" fn(device: VkDevice, pCreateInfo: *const VkCuModuleCreateInfoNVX, pAllocator: *const VkAllocationCallbacks, pModule: *mut VkCuModuleNVX) -> VkResult;
/// function prototype `PFN_vkCreateCuFunctionNVX` from VK_NVX_binary_import
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCuFunctionNVX.html>
type PFN_vkCreateCuFunctionNVX = extern "system" fn(device: VkDevice, pCreateInfo: *const VkCuFunctionCreateInfoNVX, pAllocator: *const VkAllocationCallbacks, pFunction: *mut VkCuFunctionNVX) -> VkResult;
/// function prototype `PFN_vkDestroyCuModuleNVX` from VK_NVX_binary_import
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCuModuleNVX.html>
type PFN_vkDestroyCuModuleNVX = extern "system" fn(device: VkDevice, module: VkCuModuleNVX, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkDestroyCuFunctionNVX` from VK_NVX_binary_import
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCuFunctionNVX.html>
type PFN_vkDestroyCuFunctionNVX = extern "system" fn(device: VkDevice, function: VkCuFunctionNVX, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCmdCuLaunchKernelNVX` from VK_NVX_binary_import
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCuLaunchKernelNVX.html>
type PFN_vkCmdCuLaunchKernelNVX = extern "system" fn(commandBuffer: VkCommandBuffer, pLaunchInfo: *const VkCuLaunchInfoNVX);
/// The dummy function for `vkCreateCuModuleNVX` from `VK_NVX_binary_import`
extern "system" fn dummy_vkCreateCuModuleNVX(_: VkDevice, _: *const VkCuModuleCreateInfoNVX, _: *const VkAllocationCallbacks, _: *mut VkCuModuleNVX) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateCuModuleNVX"))
}
/// trait for `VK_NVX_binary_import`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NVX_binary_import.html>
pub trait VK_NVX_binary_import: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCuModuleNVX.html>
	fn vkCreateCuModuleNVX(&self, device: VkDevice, pCreateInfo: *const VkCuModuleCreateInfoNVX, pAllocator: *const VkAllocationCallbacks, pModule: *mut VkCuModuleNVX) -> Result<()>;
}
/// struct for `VK_NVX_binary_import`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NVX_binary_import {
	vk_create_cu_module_nvx: PFN_vkCreateCuModuleNVX,
}
impl VK_NVX_binary_import for Vulkan_NVX_binary_import {
	fn vkCreateCuModuleNVX(&self, device: VkDevice, pCreateInfo: *const VkCuModuleCreateInfoNVX, pAllocator: *const VkAllocationCallbacks, pModule: *mut VkCuModuleNVX) -> Result<()> {
		convert_result("vkCreateCuModuleNVX", catch_unwind(||((self.vk_create_cu_module_nvx)(device, pCreateInfo, pAllocator, pModule))))
	}
}
impl Default for Vulkan_NVX_binary_import {
	fn default() -> Self {
		Self {
			vk_create_cu_module_nvx: dummy_vkCreateCuModuleNVX,
		}
	}
}
impl Vulkan_NVX_binary_import {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_cu_module_nvx: {let proc = get_instance_proc_address(instance, "vkCreateCuModuleNVX"); if proc == null() {dummy_vkCreateCuModuleNVX} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkImageViewHandleInfoNVX` from VK_NVX_image_view_handle
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageViewHandleInfoNVX.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageViewHandleInfoNVX {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub imageView: VkImageView,
	pub descriptorType: VkDescriptorType,
	pub sampler: VkSampler,
}
impl Debug for VkImageViewHandleInfoNVX {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageViewHandleInfoNVX")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("imageView", &self.imageView)
		.field("descriptorType", &self.descriptorType)
		.field("sampler", &self.sampler)
		.finish()
	}
}
/// struct `VkImageViewAddressPropertiesNVX` from VK_NVX_image_view_handle
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageViewAddressPropertiesNVX.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageViewAddressPropertiesNVX {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceAddress: VkDeviceAddress,
	pub size: VkDeviceSize,
}
impl Debug for VkImageViewAddressPropertiesNVX {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageViewAddressPropertiesNVX")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceAddress", &self.deviceAddress)
		.field("size", &self.size)
		.finish()
	}
}
/// function prototype `PFN_vkGetImageViewHandleNVX` from VK_NVX_image_view_handle
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageViewHandleNVX.html>
type PFN_vkGetImageViewHandleNVX = extern "system" fn(device: VkDevice, pInfo: *const VkImageViewHandleInfoNVX) -> u32;
/// function prototype `PFN_vkGetImageViewHandle64NVX` from VK_NVX_image_view_handle
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageViewHandle64NVX.html>
type PFN_vkGetImageViewHandle64NVX = extern "system" fn(device: VkDevice, pInfo: *const VkImageViewHandleInfoNVX) -> u64;
/// function prototype `PFN_vkGetImageViewAddressNVX` from VK_NVX_image_view_handle
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageViewAddressNVX.html>
type PFN_vkGetImageViewAddressNVX = extern "system" fn(device: VkDevice, imageView: VkImageView, pProperties: *mut VkImageViewAddressPropertiesNVX) -> VkResult;
/// The dummy function for `vkGetImageViewHandleNVX` from `VK_NVX_image_view_handle`
extern "system" fn dummy_vkGetImageViewHandleNVX(_: VkDevice, _: *const VkImageViewHandleInfoNVX) -> u32 {
	panic_any(VkError::NullFunctionPointer("vkGetImageViewHandleNVX"))
}
/// trait for `VK_NVX_image_view_handle`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NVX_image_view_handle.html>
pub trait VK_NVX_image_view_handle: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageViewHandleNVX.html>
	fn vkGetImageViewHandleNVX(&self, device: VkDevice, pInfo: *const VkImageViewHandleInfoNVX) -> Result<u32>;
}
/// struct for `VK_NVX_image_view_handle`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NVX_image_view_handle {
	vk_get_image_view_handle_nvx: PFN_vkGetImageViewHandleNVX,
}
impl VK_NVX_image_view_handle for Vulkan_NVX_image_view_handle {
	fn vkGetImageViewHandleNVX(&self, device: VkDevice, pInfo: *const VkImageViewHandleInfoNVX) -> Result<u32> {
		process_catch(catch_unwind(||((self.vk_get_image_view_handle_nvx)(device, pInfo))))
	}
}
impl Default for Vulkan_NVX_image_view_handle {
	fn default() -> Self {
		Self {
			vk_get_image_view_handle_nvx: dummy_vkGetImageViewHandleNVX,
		}
	}
}
impl Vulkan_NVX_image_view_handle {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_image_view_handle_nvx: {let proc = get_instance_proc_address(instance, "vkGetImageViewHandleNVX"); if proc == null() {dummy_vkGetImageViewHandleNVX} else {unsafe {transmute(proc)}}},
		}
	}
}
/// function prototype `PFN_vkCmdDrawIndirectCountAMD` from VK_AMD_draw_indirect_count
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndirectCountAMD.html>
type PFN_vkCmdDrawIndirectCountAMD = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
/// function prototype `PFN_vkCmdDrawIndexedIndirectCountAMD` from VK_AMD_draw_indirect_count
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexedIndirectCountAMD.html>
type PFN_vkCmdDrawIndexedIndirectCountAMD = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
/// The dummy function for `vkCmdDrawIndirectCountAMD` from `VK_AMD_draw_indirect_count`
extern "system" fn dummy_vkCmdDrawIndirectCountAMD(_: VkCommandBuffer, _: VkBuffer, _: VkDeviceSize, _: VkBuffer, _: VkDeviceSize, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdDrawIndirectCountAMD"))
}
/// trait for `VK_AMD_draw_indirect_count`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_draw_indirect_count.html>
pub trait VK_AMD_draw_indirect_count: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndirectCountAMD.html>
	fn vkCmdDrawIndirectCountAMD(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> Result<()>;
}
/// struct for `VK_AMD_draw_indirect_count`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_draw_indirect_count {
	vk_cmd_draw_indirect_count_amd: PFN_vkCmdDrawIndirectCountAMD,
}
impl VK_AMD_draw_indirect_count for Vulkan_AMD_draw_indirect_count {
	fn vkCmdDrawIndirectCountAMD(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_draw_indirect_count_amd)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride))))
	}
}
impl Default for Vulkan_AMD_draw_indirect_count {
	fn default() -> Self {
		Self {
			vk_cmd_draw_indirect_count_amd: dummy_vkCmdDrawIndirectCountAMD,
		}
	}
}
impl Vulkan_AMD_draw_indirect_count {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_draw_indirect_count_amd: {let proc = get_instance_proc_address(instance, "vkCmdDrawIndirectCountAMD"); if proc == null() {dummy_vkCmdDrawIndirectCountAMD} else {unsafe {transmute(proc)}}},
		}
	}
}
/// trait for `VK_AMD_negative_viewport_height`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_negative_viewport_height.html>
pub trait VK_AMD_negative_viewport_height: Debug {}
/// struct for `VK_AMD_negative_viewport_height`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_negative_viewport_height {}
impl VK_AMD_negative_viewport_height for Vulkan_AMD_negative_viewport_height {}
impl Default for Vulkan_AMD_negative_viewport_height {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_negative_viewport_height {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_AMD_gpu_shader_half_float`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_gpu_shader_half_float.html>
pub trait VK_AMD_gpu_shader_half_float: Debug {}
/// struct for `VK_AMD_gpu_shader_half_float`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_gpu_shader_half_float {}
impl VK_AMD_gpu_shader_half_float for Vulkan_AMD_gpu_shader_half_float {}
impl Default for Vulkan_AMD_gpu_shader_half_float {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_gpu_shader_half_float {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_AMD_shader_ballot`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_shader_ballot.html>
pub trait VK_AMD_shader_ballot: Debug {}
/// struct for `VK_AMD_shader_ballot`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_ballot {}
impl VK_AMD_shader_ballot for Vulkan_AMD_shader_ballot {}
impl Default for Vulkan_AMD_shader_ballot {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_shader_ballot {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkTextureLODGatherFormatPropertiesAMD` from VK_AMD_texture_gather_bias_lod
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTextureLODGatherFormatPropertiesAMD.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTextureLODGatherFormatPropertiesAMD {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub supportsTextureGatherLODBiasAMD: VkBool32,
}
impl Debug for VkTextureLODGatherFormatPropertiesAMD {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTextureLODGatherFormatPropertiesAMD")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("supportsTextureGatherLODBiasAMD", &self.supportsTextureGatherLODBiasAMD)
		.finish()
	}
}
/// trait for `VK_AMD_texture_gather_bias_lod`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_texture_gather_bias_lod.html>
pub trait VK_AMD_texture_gather_bias_lod: Debug {}
/// struct for `VK_AMD_texture_gather_bias_lod`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_texture_gather_bias_lod {}
impl VK_AMD_texture_gather_bias_lod for Vulkan_AMD_texture_gather_bias_lod {}
impl Default for Vulkan_AMD_texture_gather_bias_lod {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_texture_gather_bias_lod {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkShaderInfoTypeAMD` from VK_AMD_shader_info
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderInfoTypeAMD.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkShaderInfoTypeAMD {
	VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0,
	VK_SHADER_INFO_TYPE_BINARY_AMD = 1,
	VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2,
	VK_SHADER_INFO_TYPE_MAX_ENUM_AMD = 0x7fffffff,
}
/// struct `VkShaderResourceUsageAMD` from VK_AMD_shader_info
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderResourceUsageAMD.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkShaderResourceUsageAMD {
	pub numUsedVgprs: u32,
	pub numUsedSgprs: u32,
	pub ldsSizePerLocalWorkGroup: u32,
	pub ldsUsageSizeInBytes: usize,
	pub scratchMemUsageInBytes: usize,
}
impl Debug for VkShaderResourceUsageAMD {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkShaderResourceUsageAMD")
		.field("numUsedVgprs", &self.numUsedVgprs)
		.field("numUsedSgprs", &self.numUsedSgprs)
		.field("ldsSizePerLocalWorkGroup", &self.ldsSizePerLocalWorkGroup)
		.field("ldsUsageSizeInBytes", &self.ldsUsageSizeInBytes)
		.field("scratchMemUsageInBytes", &self.scratchMemUsageInBytes)
		.finish()
	}
}
/// struct `VkShaderStatisticsInfoAMD` from VK_AMD_shader_info
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderStatisticsInfoAMD.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkShaderStatisticsInfoAMD {
	pub shaderStageMask: VkShaderStageFlags,
	pub resourceUsage: VkShaderResourceUsageAMD,
	pub numPhysicalVgprs: u32,
	pub numPhysicalSgprs: u32,
	pub numAvailableVgprs: u32,
	pub numAvailableSgprs: u32,
	pub computeWorkGroupSize: [u32; 3 as usize],
}
impl Debug for VkShaderStatisticsInfoAMD {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkShaderStatisticsInfoAMD")
		.field("shaderStageMask", &self.shaderStageMask)
		.field("resourceUsage", &self.resourceUsage)
		.field("numPhysicalVgprs", &self.numPhysicalVgprs)
		.field("numPhysicalSgprs", &self.numPhysicalSgprs)
		.field("numAvailableVgprs", &self.numAvailableVgprs)
		.field("numAvailableSgprs", &self.numAvailableSgprs)
		.field("computeWorkGroupSize", &self.computeWorkGroupSize)
		.finish()
	}
}
/// function prototype `PFN_vkGetShaderInfoAMD` from VK_AMD_shader_info
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetShaderInfoAMD.html>
type PFN_vkGetShaderInfoAMD = extern "system" fn(device: VkDevice, pipeline: VkPipeline, shaderStage: VkShaderStageFlagBits, infoType: VkShaderInfoTypeAMD, pInfoSize: *mut size_t, pInfo: *mut c_void) -> VkResult;
/// The dummy function for `vkGetShaderInfoAMD` from `VK_AMD_shader_info`
extern "system" fn dummy_vkGetShaderInfoAMD(_: VkDevice, _: VkPipeline, _: VkShaderStageFlagBits, _: VkShaderInfoTypeAMD, _: *mut size_t, _: *mut c_void) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetShaderInfoAMD"))
}
/// trait for `VK_AMD_shader_info`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_shader_info.html>
pub trait VK_AMD_shader_info: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetShaderInfoAMD.html>
	fn vkGetShaderInfoAMD(&self, device: VkDevice, pipeline: VkPipeline, shaderStage: VkShaderStageFlagBits, infoType: VkShaderInfoTypeAMD, pInfoSize: *mut size_t, pInfo: *mut c_void) -> Result<()>;
}
/// struct for `VK_AMD_shader_info`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_info {
	vk_get_shader_info_amd: PFN_vkGetShaderInfoAMD,
}
impl VK_AMD_shader_info for Vulkan_AMD_shader_info {
	fn vkGetShaderInfoAMD(&self, device: VkDevice, pipeline: VkPipeline, shaderStage: VkShaderStageFlagBits, infoType: VkShaderInfoTypeAMD, pInfoSize: *mut size_t, pInfo: *mut c_void) -> Result<()> {
		convert_result("vkGetShaderInfoAMD", catch_unwind(||((self.vk_get_shader_info_amd)(device, pipeline, shaderStage, infoType, pInfoSize, pInfo))))
	}
}
impl Default for Vulkan_AMD_shader_info {
	fn default() -> Self {
		Self {
			vk_get_shader_info_amd: dummy_vkGetShaderInfoAMD,
		}
	}
}
impl Vulkan_AMD_shader_info {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_shader_info_amd: {let proc = get_instance_proc_address(instance, "vkGetShaderInfoAMD"); if proc == null() {dummy_vkGetShaderInfoAMD} else {unsafe {transmute(proc)}}},
		}
	}
}
/// trait for `VK_AMD_shader_image_load_store_lod`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_shader_image_load_store_lod.html>
pub trait VK_AMD_shader_image_load_store_lod: Debug {}
/// struct for `VK_AMD_shader_image_load_store_lod`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_image_load_store_lod {}
impl VK_AMD_shader_image_load_store_lod for Vulkan_AMD_shader_image_load_store_lod {}
impl Default for Vulkan_AMD_shader_image_load_store_lod {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_shader_image_load_store_lod {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceCornerSampledImageFeaturesNV` from VK_NV_corner_sampled_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCornerSampledImageFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCornerSampledImageFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cornerSampledImage: VkBool32,
}
impl Debug for VkPhysicalDeviceCornerSampledImageFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCornerSampledImageFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("cornerSampledImage", &self.cornerSampledImage)
		.finish()
	}
}
/// trait for `VK_NV_corner_sampled_image`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_corner_sampled_image.html>
pub trait VK_NV_corner_sampled_image: Debug {}
/// struct for `VK_NV_corner_sampled_image`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_corner_sampled_image {}
impl VK_NV_corner_sampled_image for Vulkan_NV_corner_sampled_image {}
impl Default for Vulkan_NV_corner_sampled_image {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_corner_sampled_image {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_IMG_format_pvrtc`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_IMG_format_pvrtc.html>
pub trait VK_IMG_format_pvrtc: Debug {}
/// struct for `VK_IMG_format_pvrtc`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_IMG_format_pvrtc {}
impl VK_IMG_format_pvrtc for Vulkan_IMG_format_pvrtc {}
impl Default for Vulkan_IMG_format_pvrtc {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_IMG_format_pvrtc {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkExternalMemoryHandleTypeFlagsNV` from VK_NV_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryHandleTypeFlagsNV.html>
pub type VkExternalMemoryHandleTypeFlagsNV = VkFlags;
/// type definition `VkExternalMemoryFeatureFlagsNV` from VK_NV_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryFeatureFlagsNV.html>
pub type VkExternalMemoryFeatureFlagsNV = VkFlags;
/// enum `VkExternalMemoryHandleTypeFlagBitsNV` from VK_NV_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryHandleTypeFlagBitsNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkExternalMemoryHandleTypeFlagBitsNV {
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x00000001,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x00000004,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x00000008,
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkExternalMemoryFeatureFlagBitsNV` from VK_NV_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryFeatureFlagBitsNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkExternalMemoryFeatureFlagBitsNV {
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x00000001,
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x00000002,
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x00000004,
	VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
/// struct `VkExternalImageFormatPropertiesNV` from VK_NV_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalImageFormatPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExternalImageFormatPropertiesNV {
	pub imageFormatProperties: VkImageFormatProperties,
	pub externalMemoryFeatures: VkExternalMemoryFeatureFlagsNV,
	pub exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagsNV,
	pub compatibleHandleTypes: VkExternalMemoryHandleTypeFlagsNV,
}
impl Debug for VkExternalImageFormatPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExternalImageFormatPropertiesNV")
		.field("imageFormatProperties", &self.imageFormatProperties)
		.field("externalMemoryFeatures", &self.externalMemoryFeatures)
		.field("exportFromImportedHandleTypes", &self.exportFromImportedHandleTypes)
		.field("compatibleHandleTypes", &self.compatibleHandleTypes)
		.finish()
	}
}
/// function prototype `PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV` from VK_NV_external_memory_capabilities
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalImageFormatPropertiesNV.html>
type PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = extern "system" fn(physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, externalHandleType: VkExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *mut VkExternalImageFormatPropertiesNV) -> VkResult;
/// The dummy function for `vkGetPhysicalDeviceExternalImageFormatPropertiesNV` from `VK_NV_external_memory_capabilities`
extern "system" fn dummy_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(_: VkPhysicalDevice, _: VkFormat, _: VkImageType, _: VkImageTiling, _: VkImageUsageFlags, _: VkImageCreateFlags, _: VkExternalMemoryHandleTypeFlagsNV, _: *mut VkExternalImageFormatPropertiesNV) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceExternalImageFormatPropertiesNV"))
}
/// trait for `VK_NV_external_memory_capabilities`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_external_memory_capabilities.html>
pub trait VK_NV_external_memory_capabilities: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalImageFormatPropertiesNV.html>
	fn vkGetPhysicalDeviceExternalImageFormatPropertiesNV(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, externalHandleType: VkExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *mut VkExternalImageFormatPropertiesNV) -> Result<()>;
}
/// struct for `VK_NV_external_memory_capabilities`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_external_memory_capabilities {
	vk_get_physical_device_external_image_format_properties_nv: PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV,
}
impl VK_NV_external_memory_capabilities for Vulkan_NV_external_memory_capabilities {
	fn vkGetPhysicalDeviceExternalImageFormatPropertiesNV(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, externalHandleType: VkExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *mut VkExternalImageFormatPropertiesNV) -> Result<()> {
		convert_result("vkGetPhysicalDeviceExternalImageFormatPropertiesNV", catch_unwind(||((self.vk_get_physical_device_external_image_format_properties_nv)(physicalDevice, format, type_, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties))))
	}
}
impl Default for Vulkan_NV_external_memory_capabilities {
	fn default() -> Self {
		Self {
			vk_get_physical_device_external_image_format_properties_nv: dummy_vkGetPhysicalDeviceExternalImageFormatPropertiesNV,
		}
	}
}
impl Vulkan_NV_external_memory_capabilities {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_external_image_format_properties_nv: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV"); if proc == null() {dummy_vkGetPhysicalDeviceExternalImageFormatPropertiesNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkExternalMemoryImageCreateInfoNV` from VK_NV_external_memory
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryImageCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExternalMemoryImageCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes: VkExternalMemoryHandleTypeFlagsNV,
}
impl Debug for VkExternalMemoryImageCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExternalMemoryImageCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("handleTypes", &self.handleTypes)
		.finish()
	}
}
/// struct `VkExportMemoryAllocateInfoNV` from VK_NV_external_memory
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExportMemoryAllocateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExportMemoryAllocateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes: VkExternalMemoryHandleTypeFlagsNV,
}
impl Debug for VkExportMemoryAllocateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExportMemoryAllocateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("handleTypes", &self.handleTypes)
		.finish()
	}
}
/// trait for `VK_NV_external_memory`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_external_memory.html>
pub trait VK_NV_external_memory: Debug {}
/// struct for `VK_NV_external_memory`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_external_memory {}
impl VK_NV_external_memory for Vulkan_NV_external_memory {}
impl Default for Vulkan_NV_external_memory {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_external_memory {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkValidationCheckEXT` from VK_EXT_validation_flags
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkValidationCheckEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkValidationCheckEXT {
	VK_VALIDATION_CHECK_ALL_EXT = 0,
	VK_VALIDATION_CHECK_SHADERS_EXT = 1,
	VK_VALIDATION_CHECK_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkValidationFlagsEXT` from VK_EXT_validation_flags
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkValidationFlagsEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkValidationFlagsEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub disabledValidationCheckCount: u32,
	pub pDisabledValidationChecks: *const VkValidationCheckEXT,
}
impl Debug for VkValidationFlagsEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkValidationFlagsEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("disabledValidationCheckCount", &self.disabledValidationCheckCount)
		.field("pDisabledValidationChecks", &self.pDisabledValidationChecks)
		.finish()
	}
}
/// trait for `VK_EXT_validation_flags`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_validation_flags.html>
pub trait VK_EXT_validation_flags: Debug {}
/// struct for `VK_EXT_validation_flags`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_validation_flags {}
impl VK_EXT_validation_flags for Vulkan_EXT_validation_flags {}
impl Default for Vulkan_EXT_validation_flags {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_validation_flags {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_EXT_shader_subgroup_ballot`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_shader_subgroup_ballot.html>
pub trait VK_EXT_shader_subgroup_ballot: Debug {}
/// struct for `VK_EXT_shader_subgroup_ballot`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_subgroup_ballot {}
impl VK_EXT_shader_subgroup_ballot for Vulkan_EXT_shader_subgroup_ballot {}
impl Default for Vulkan_EXT_shader_subgroup_ballot {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_subgroup_ballot {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_EXT_shader_subgroup_vote`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_shader_subgroup_vote.html>
pub trait VK_EXT_shader_subgroup_vote: Debug {}
/// struct for `VK_EXT_shader_subgroup_vote`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_subgroup_vote {}
impl VK_EXT_shader_subgroup_vote for Vulkan_EXT_shader_subgroup_vote {}
impl Default for Vulkan_EXT_shader_subgroup_vote {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_subgroup_vote {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT` from VK_EXT_texture_compression_astc_hdr
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT.html>
pub type VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = VkPhysicalDeviceTextureCompressionASTCHDRFeatures;
/// trait for `VK_EXT_texture_compression_astc_hdr`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_texture_compression_astc_hdr.html>
pub trait VK_EXT_texture_compression_astc_hdr: Debug {}
/// struct for `VK_EXT_texture_compression_astc_hdr`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_texture_compression_astc_hdr {}
impl VK_EXT_texture_compression_astc_hdr for Vulkan_EXT_texture_compression_astc_hdr {}
impl Default for Vulkan_EXT_texture_compression_astc_hdr {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_texture_compression_astc_hdr {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkImageViewASTCDecodeModeEXT` from VK_EXT_astc_decode_mode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageViewASTCDecodeModeEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageViewASTCDecodeModeEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub decodeMode: VkFormat,
}
impl Debug for VkImageViewASTCDecodeModeEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageViewASTCDecodeModeEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("decodeMode", &self.decodeMode)
		.finish()
	}
}
/// struct `VkPhysicalDeviceASTCDecodeFeaturesEXT` from VK_EXT_astc_decode_mode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceASTCDecodeFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceASTCDecodeFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub decodeModeSharedExponent: VkBool32,
}
impl Debug for VkPhysicalDeviceASTCDecodeFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceASTCDecodeFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("decodeModeSharedExponent", &self.decodeModeSharedExponent)
		.finish()
	}
}
/// trait for `VK_EXT_astc_decode_mode`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_astc_decode_mode.html>
pub trait VK_EXT_astc_decode_mode: Debug {}
/// struct for `VK_EXT_astc_decode_mode`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_astc_decode_mode {}
impl VK_EXT_astc_decode_mode for Vulkan_EXT_astc_decode_mode {}
impl Default for Vulkan_EXT_astc_decode_mode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_astc_decode_mode {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPipelineRobustnessBufferBehaviorEXT` from VK_EXT_pipeline_robustness
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRobustnessBufferBehaviorEXT.html>
pub type VkPipelineRobustnessBufferBehaviorEXT = VkPipelineRobustnessBufferBehavior;
/// type definition `VkPipelineRobustnessImageBehaviorEXT` from VK_EXT_pipeline_robustness
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRobustnessImageBehaviorEXT.html>
pub type VkPipelineRobustnessImageBehaviorEXT = VkPipelineRobustnessImageBehavior;
/// type definition `VkPhysicalDevicePipelineRobustnessFeaturesEXT` from VK_EXT_pipeline_robustness
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePipelineRobustnessFeaturesEXT.html>
pub type VkPhysicalDevicePipelineRobustnessFeaturesEXT = VkPhysicalDevicePipelineRobustnessFeatures;
/// type definition `VkPhysicalDevicePipelineRobustnessPropertiesEXT` from VK_EXT_pipeline_robustness
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePipelineRobustnessPropertiesEXT.html>
pub type VkPhysicalDevicePipelineRobustnessPropertiesEXT = VkPhysicalDevicePipelineRobustnessProperties;
/// type definition `VkPipelineRobustnessCreateInfoEXT` from VK_EXT_pipeline_robustness
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRobustnessCreateInfoEXT.html>
pub type VkPipelineRobustnessCreateInfoEXT = VkPipelineRobustnessCreateInfo;
/// trait for `VK_EXT_pipeline_robustness`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_pipeline_robustness.html>
pub trait VK_EXT_pipeline_robustness: Debug {}
/// struct for `VK_EXT_pipeline_robustness`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_pipeline_robustness {}
impl VK_EXT_pipeline_robustness for Vulkan_EXT_pipeline_robustness {}
impl Default for Vulkan_EXT_pipeline_robustness {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_pipeline_robustness {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkConditionalRenderingFlagsEXT` from VK_EXT_conditional_rendering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkConditionalRenderingFlagsEXT.html>
pub type VkConditionalRenderingFlagsEXT = VkFlags;
/// enum `VkConditionalRenderingFlagBitsEXT` from VK_EXT_conditional_rendering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkConditionalRenderingFlagBitsEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkConditionalRenderingFlagBitsEXT {
	VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 0x00000001,
	VK_CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkConditionalRenderingBeginInfoEXT` from VK_EXT_conditional_rendering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkConditionalRenderingBeginInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkConditionalRenderingBeginInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub buffer: VkBuffer,
	pub offset: VkDeviceSize,
	pub flags: VkConditionalRenderingFlagsEXT,
}
impl Debug for VkConditionalRenderingBeginInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkConditionalRenderingBeginInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("buffer", &self.buffer)
		.field("offset", &self.offset)
		.field("flags", &self.flags)
		.finish()
	}
}
/// struct `VkPhysicalDeviceConditionalRenderingFeaturesEXT` from VK_EXT_conditional_rendering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceConditionalRenderingFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceConditionalRenderingFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub conditionalRendering: VkBool32,
	pub inheritedConditionalRendering: VkBool32,
}
impl Debug for VkPhysicalDeviceConditionalRenderingFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceConditionalRenderingFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("conditionalRendering", &self.conditionalRendering)
		.field("inheritedConditionalRendering", &self.inheritedConditionalRendering)
		.finish()
	}
}
/// struct `VkCommandBufferInheritanceConditionalRenderingInfoEXT` from VK_EXT_conditional_rendering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferInheritanceConditionalRenderingInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCommandBufferInheritanceConditionalRenderingInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub conditionalRenderingEnable: VkBool32,
}
impl Debug for VkCommandBufferInheritanceConditionalRenderingInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCommandBufferInheritanceConditionalRenderingInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("conditionalRenderingEnable", &self.conditionalRenderingEnable)
		.finish()
	}
}
/// function prototype `PFN_vkCmdBeginConditionalRenderingEXT` from VK_EXT_conditional_rendering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginConditionalRenderingEXT.html>
type PFN_vkCmdBeginConditionalRenderingEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pConditionalRenderingBegin: *const VkConditionalRenderingBeginInfoEXT);
/// function prototype `PFN_vkCmdEndConditionalRenderingEXT` from VK_EXT_conditional_rendering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndConditionalRenderingEXT.html>
type PFN_vkCmdEndConditionalRenderingEXT = extern "system" fn(commandBuffer: VkCommandBuffer);
/// The dummy function for `vkCmdBeginConditionalRenderingEXT` from `VK_EXT_conditional_rendering`
extern "system" fn dummy_vkCmdBeginConditionalRenderingEXT(_: VkCommandBuffer, _: *const VkConditionalRenderingBeginInfoEXT) {
	panic_any(VkError::NullFunctionPointer("vkCmdBeginConditionalRenderingEXT"))
}
/// trait for `VK_EXT_conditional_rendering`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_conditional_rendering.html>
pub trait VK_EXT_conditional_rendering: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginConditionalRenderingEXT.html>
	fn vkCmdBeginConditionalRenderingEXT(&self, commandBuffer: VkCommandBuffer, pConditionalRenderingBegin: *const VkConditionalRenderingBeginInfoEXT) -> Result<()>;
}
/// struct for `VK_EXT_conditional_rendering`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_conditional_rendering {
	vk_cmd_begin_conditional_rendering_ext: PFN_vkCmdBeginConditionalRenderingEXT,
}
impl VK_EXT_conditional_rendering for Vulkan_EXT_conditional_rendering {
	fn vkCmdBeginConditionalRenderingEXT(&self, commandBuffer: VkCommandBuffer, pConditionalRenderingBegin: *const VkConditionalRenderingBeginInfoEXT) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_begin_conditional_rendering_ext)(commandBuffer, pConditionalRenderingBegin))))
	}
}
impl Default for Vulkan_EXT_conditional_rendering {
	fn default() -> Self {
		Self {
			vk_cmd_begin_conditional_rendering_ext: dummy_vkCmdBeginConditionalRenderingEXT,
		}
	}
}
impl Vulkan_EXT_conditional_rendering {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_begin_conditional_rendering_ext: {let proc = get_instance_proc_address(instance, "vkCmdBeginConditionalRenderingEXT"); if proc == null() {dummy_vkCmdBeginConditionalRenderingEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkViewportWScalingNV` from VK_NV_clip_space_w_scaling
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkViewportWScalingNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkViewportWScalingNV {
	pub xcoeff: f32,
	pub ycoeff: f32,
}
impl Debug for VkViewportWScalingNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkViewportWScalingNV")
		.field("xcoeff", &self.xcoeff)
		.field("ycoeff", &self.ycoeff)
		.finish()
	}
}
/// struct `VkPipelineViewportWScalingStateCreateInfoNV` from VK_NV_clip_space_w_scaling
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineViewportWScalingStateCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineViewportWScalingStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub viewportWScalingEnable: VkBool32,
	pub viewportCount: u32,
	pub pViewportWScalings: *const VkViewportWScalingNV,
}
impl Debug for VkPipelineViewportWScalingStateCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineViewportWScalingStateCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("viewportWScalingEnable", &self.viewportWScalingEnable)
		.field("viewportCount", &self.viewportCount)
		.field("pViewportWScalings", &self.pViewportWScalings)
		.finish()
	}
}
/// function prototype `PFN_vkCmdSetViewportWScalingNV` from VK_NV_clip_space_w_scaling
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportWScalingNV.html>
type PFN_vkCmdSetViewportWScalingNV = extern "system" fn(commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportWScalings: *const VkViewportWScalingNV);
/// The dummy function for `vkCmdSetViewportWScalingNV` from `VK_NV_clip_space_w_scaling`
extern "system" fn dummy_vkCmdSetViewportWScalingNV(_: VkCommandBuffer, _: u32, _: u32, _: *const VkViewportWScalingNV) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetViewportWScalingNV"))
}
/// trait for `VK_NV_clip_space_w_scaling`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_clip_space_w_scaling.html>
pub trait VK_NV_clip_space_w_scaling: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportWScalingNV.html>
	fn vkCmdSetViewportWScalingNV(&self, commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportWScalings: *const VkViewportWScalingNV) -> Result<()>;
}
/// struct for `VK_NV_clip_space_w_scaling`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_clip_space_w_scaling {
	vk_cmd_set_viewport_wscaling_nv: PFN_vkCmdSetViewportWScalingNV,
}
impl VK_NV_clip_space_w_scaling for Vulkan_NV_clip_space_w_scaling {
	fn vkCmdSetViewportWScalingNV(&self, commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportWScalings: *const VkViewportWScalingNV) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_viewport_wscaling_nv)(commandBuffer, firstViewport, viewportCount, pViewportWScalings))))
	}
}
impl Default for Vulkan_NV_clip_space_w_scaling {
	fn default() -> Self {
		Self {
			vk_cmd_set_viewport_wscaling_nv: dummy_vkCmdSetViewportWScalingNV,
		}
	}
}
impl Vulkan_NV_clip_space_w_scaling {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_viewport_wscaling_nv: {let proc = get_instance_proc_address(instance, "vkCmdSetViewportWScalingNV"); if proc == null() {dummy_vkCmdSetViewportWScalingNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// function prototype `PFN_vkReleaseDisplayEXT` from VK_EXT_direct_mode_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseDisplayEXT.html>
type PFN_vkReleaseDisplayEXT = extern "system" fn(physicalDevice: VkPhysicalDevice, display: VkDisplayKHR) -> VkResult;
/// The dummy function for `vkReleaseDisplayEXT` from `VK_EXT_direct_mode_display`
extern "system" fn dummy_vkReleaseDisplayEXT(_: VkPhysicalDevice, _: VkDisplayKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkReleaseDisplayEXT"))
}
/// trait for `VK_EXT_direct_mode_display`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_direct_mode_display.html>
pub trait VK_EXT_direct_mode_display: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseDisplayEXT.html>
	fn vkReleaseDisplayEXT(&self, physicalDevice: VkPhysicalDevice, display: VkDisplayKHR) -> Result<()>;
}
/// struct for `VK_EXT_direct_mode_display`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_direct_mode_display {
	vk_release_display_ext: PFN_vkReleaseDisplayEXT,
}
impl VK_EXT_direct_mode_display for Vulkan_EXT_direct_mode_display {
	fn vkReleaseDisplayEXT(&self, physicalDevice: VkPhysicalDevice, display: VkDisplayKHR) -> Result<()> {
		convert_result("vkReleaseDisplayEXT", catch_unwind(||((self.vk_release_display_ext)(physicalDevice, display))))
	}
}
impl Default for Vulkan_EXT_direct_mode_display {
	fn default() -> Self {
		Self {
			vk_release_display_ext: dummy_vkReleaseDisplayEXT,
		}
	}
}
impl Vulkan_EXT_direct_mode_display {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_release_display_ext: {let proc = get_instance_proc_address(instance, "vkReleaseDisplayEXT"); if proc == null() {dummy_vkReleaseDisplayEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkSurfaceCounterFlagsEXT` from VK_EXT_display_surface_counter
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfaceCounterFlagsEXT.html>
pub type VkSurfaceCounterFlagsEXT = VkFlags;
/// enum `VkSurfaceCounterFlagBitsEXT` from VK_EXT_display_surface_counter
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfaceCounterFlagBitsEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSurfaceCounterFlagBitsEXT {
	VK_SURFACE_COUNTER_VBLANK_BIT_EXT = 0x00000001,
	VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
impl VkSurfaceCounterFlagBitsEXT {
	pub const VK_SURFACE_COUNTER_VBLANK_EXT: VkSurfaceCounterFlagBitsEXT = VkSurfaceCounterFlagBitsEXT::VK_SURFACE_COUNTER_VBLANK_BIT_EXT;
}
/// struct `VkSurfaceCapabilities2EXT` from VK_EXT_display_surface_counter
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfaceCapabilities2EXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSurfaceCapabilities2EXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minImageCount: u32,
	pub maxImageCount: u32,
	pub currentExtent: VkExtent2D,
	pub minImageExtent: VkExtent2D,
	pub maxImageExtent: VkExtent2D,
	pub maxImageArrayLayers: u32,
	pub supportedTransforms: VkSurfaceTransformFlagsKHR,
	pub currentTransform: VkSurfaceTransformFlagBitsKHR,
	pub supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
	pub supportedUsageFlags: VkImageUsageFlags,
	pub supportedSurfaceCounters: VkSurfaceCounterFlagsEXT,
}
impl Debug for VkSurfaceCapabilities2EXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSurfaceCapabilities2EXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("minImageCount", &self.minImageCount)
		.field("maxImageCount", &self.maxImageCount)
		.field("currentExtent", &self.currentExtent)
		.field("minImageExtent", &self.minImageExtent)
		.field("maxImageExtent", &self.maxImageExtent)
		.field("maxImageArrayLayers", &self.maxImageArrayLayers)
		.field("supportedTransforms", &self.supportedTransforms)
		.field("currentTransform", &self.currentTransform)
		.field("supportedCompositeAlpha", &self.supportedCompositeAlpha)
		.field("supportedUsageFlags", &self.supportedUsageFlags)
		.field("supportedSurfaceCounters", &self.supportedSurfaceCounters)
		.finish()
	}
}
/// function prototype `PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT` from VK_EXT_display_surface_counter
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceCapabilities2EXT.html>
type PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT = extern "system" fn(physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2EXT) -> VkResult;
/// The dummy function for `vkGetPhysicalDeviceSurfaceCapabilities2EXT` from `VK_EXT_display_surface_counter`
extern "system" fn dummy_vkGetPhysicalDeviceSurfaceCapabilities2EXT(_: VkPhysicalDevice, _: VkSurfaceKHR, _: *mut VkSurfaceCapabilities2EXT) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceSurfaceCapabilities2EXT"))
}
/// trait for `VK_EXT_display_surface_counter`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_display_surface_counter.html>
pub trait VK_EXT_display_surface_counter: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceCapabilities2EXT.html>
	fn vkGetPhysicalDeviceSurfaceCapabilities2EXT(&self, physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2EXT) -> Result<()>;
}
/// struct for `VK_EXT_display_surface_counter`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_display_surface_counter {
	vk_get_physical_device_surface_capabilities2_ext: PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT,
}
impl VK_EXT_display_surface_counter for Vulkan_EXT_display_surface_counter {
	fn vkGetPhysicalDeviceSurfaceCapabilities2EXT(&self, physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2EXT) -> Result<()> {
		convert_result("vkGetPhysicalDeviceSurfaceCapabilities2EXT", catch_unwind(||((self.vk_get_physical_device_surface_capabilities2_ext)(physicalDevice, surface, pSurfaceCapabilities))))
	}
}
impl Default for Vulkan_EXT_display_surface_counter {
	fn default() -> Self {
		Self {
			vk_get_physical_device_surface_capabilities2_ext: dummy_vkGetPhysicalDeviceSurfaceCapabilities2EXT,
		}
	}
}
impl Vulkan_EXT_display_surface_counter {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_surface_capabilities2_ext: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceSurfaceCapabilities2EXT"); if proc == null() {dummy_vkGetPhysicalDeviceSurfaceCapabilities2EXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// enum `VkDisplayPowerStateEXT` from VK_EXT_display_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayPowerStateEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDisplayPowerStateEXT {
	VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
	VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
	VK_DISPLAY_POWER_STATE_ON_EXT = 2,
	VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkDeviceEventTypeEXT` from VK_EXT_display_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceEventTypeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceEventTypeEXT {
	VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,
	VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkDisplayEventTypeEXT` from VK_EXT_display_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayEventTypeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDisplayEventTypeEXT {
	VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,
	VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkDisplayPowerInfoEXT` from VK_EXT_display_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayPowerInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplayPowerInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub powerState: VkDisplayPowerStateEXT,
}
impl Debug for VkDisplayPowerInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayPowerInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("powerState", &self.powerState)
		.finish()
	}
}
/// struct `VkDeviceEventInfoEXT` from VK_EXT_display_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceEventInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceEventInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub deviceEvent: VkDeviceEventTypeEXT,
}
impl Debug for VkDeviceEventInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceEventInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceEvent", &self.deviceEvent)
		.finish()
	}
}
/// struct `VkDisplayEventInfoEXT` from VK_EXT_display_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayEventInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplayEventInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub displayEvent: VkDisplayEventTypeEXT,
}
impl Debug for VkDisplayEventInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayEventInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("displayEvent", &self.displayEvent)
		.finish()
	}
}
/// struct `VkSwapchainCounterCreateInfoEXT` from VK_EXT_display_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainCounterCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSwapchainCounterCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub surfaceCounters: VkSurfaceCounterFlagsEXT,
}
impl Debug for VkSwapchainCounterCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSwapchainCounterCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("surfaceCounters", &self.surfaceCounters)
		.finish()
	}
}
/// function prototype `PFN_vkDisplayPowerControlEXT` from VK_EXT_display_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDisplayPowerControlEXT.html>
type PFN_vkDisplayPowerControlEXT = extern "system" fn(device: VkDevice, display: VkDisplayKHR, pDisplayPowerInfo: *const VkDisplayPowerInfoEXT) -> VkResult;
/// function prototype `PFN_vkRegisterDeviceEventEXT` from VK_EXT_display_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkRegisterDeviceEventEXT.html>
type PFN_vkRegisterDeviceEventEXT = extern "system" fn(device: VkDevice, pDeviceEventInfo: *const VkDeviceEventInfoEXT, pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence) -> VkResult;
/// function prototype `PFN_vkRegisterDisplayEventEXT` from VK_EXT_display_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkRegisterDisplayEventEXT.html>
type PFN_vkRegisterDisplayEventEXT = extern "system" fn(device: VkDevice, display: VkDisplayKHR, pDisplayEventInfo: *const VkDisplayEventInfoEXT, pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence) -> VkResult;
/// function prototype `PFN_vkGetSwapchainCounterEXT` from VK_EXT_display_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSwapchainCounterEXT.html>
type PFN_vkGetSwapchainCounterEXT = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, counter: VkSurfaceCounterFlagBitsEXT, pCounterValue: *mut uint64_t) -> VkResult;
/// The dummy function for `vkDisplayPowerControlEXT` from `VK_EXT_display_control`
extern "system" fn dummy_vkDisplayPowerControlEXT(_: VkDevice, _: VkDisplayKHR, _: *const VkDisplayPowerInfoEXT) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkDisplayPowerControlEXT"))
}
/// trait for `VK_EXT_display_control`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_display_control.html>
pub trait VK_EXT_display_control: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDisplayPowerControlEXT.html>
	fn vkDisplayPowerControlEXT(&self, device: VkDevice, display: VkDisplayKHR, pDisplayPowerInfo: *const VkDisplayPowerInfoEXT) -> Result<()>;
}
/// struct for `VK_EXT_display_control`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_display_control {
	vk_display_power_control_ext: PFN_vkDisplayPowerControlEXT,
}
impl VK_EXT_display_control for Vulkan_EXT_display_control {
	fn vkDisplayPowerControlEXT(&self, device: VkDevice, display: VkDisplayKHR, pDisplayPowerInfo: *const VkDisplayPowerInfoEXT) -> Result<()> {
		convert_result("vkDisplayPowerControlEXT", catch_unwind(||((self.vk_display_power_control_ext)(device, display, pDisplayPowerInfo))))
	}
}
impl Default for Vulkan_EXT_display_control {
	fn default() -> Self {
		Self {
			vk_display_power_control_ext: dummy_vkDisplayPowerControlEXT,
		}
	}
}
impl Vulkan_EXT_display_control {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_display_power_control_ext: {let proc = get_instance_proc_address(instance, "vkDisplayPowerControlEXT"); if proc == null() {dummy_vkDisplayPowerControlEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkRefreshCycleDurationGOOGLE` from VK_GOOGLE_display_timing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRefreshCycleDurationGOOGLE.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRefreshCycleDurationGOOGLE {
	pub refreshDuration: u64,
}
impl Debug for VkRefreshCycleDurationGOOGLE {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRefreshCycleDurationGOOGLE")
		.field("refreshDuration", &self.refreshDuration)
		.finish()
	}
}
/// struct `VkPastPresentationTimingGOOGLE` from VK_GOOGLE_display_timing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPastPresentationTimingGOOGLE.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPastPresentationTimingGOOGLE {
	pub presentID: u32,
	pub desiredPresentTime: u64,
	pub actualPresentTime: u64,
	pub earliestPresentTime: u64,
	pub presentMargin: u64,
}
impl Debug for VkPastPresentationTimingGOOGLE {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPastPresentationTimingGOOGLE")
		.field("presentID", &self.presentID)
		.field("desiredPresentTime", &self.desiredPresentTime)
		.field("actualPresentTime", &self.actualPresentTime)
		.field("earliestPresentTime", &self.earliestPresentTime)
		.field("presentMargin", &self.presentMargin)
		.finish()
	}
}
/// struct `VkPresentTimeGOOGLE` from VK_GOOGLE_display_timing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentTimeGOOGLE.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPresentTimeGOOGLE {
	pub presentID: u32,
	pub desiredPresentTime: u64,
}
impl Debug for VkPresentTimeGOOGLE {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPresentTimeGOOGLE")
		.field("presentID", &self.presentID)
		.field("desiredPresentTime", &self.desiredPresentTime)
		.finish()
	}
}
/// struct `VkPresentTimesInfoGOOGLE` from VK_GOOGLE_display_timing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentTimesInfoGOOGLE.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPresentTimesInfoGOOGLE {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount: u32,
	pub pTimes: *const VkPresentTimeGOOGLE,
}
impl Debug for VkPresentTimesInfoGOOGLE {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPresentTimesInfoGOOGLE")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("swapchainCount", &self.swapchainCount)
		.field("pTimes", &self.pTimes)
		.finish()
	}
}
/// function prototype `PFN_vkGetRefreshCycleDurationGOOGLE` from VK_GOOGLE_display_timing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRefreshCycleDurationGOOGLE.html>
type PFN_vkGetRefreshCycleDurationGOOGLE = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pDisplayTimingProperties: *mut VkRefreshCycleDurationGOOGLE) -> VkResult;
/// function prototype `PFN_vkGetPastPresentationTimingGOOGLE` from VK_GOOGLE_display_timing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPastPresentationTimingGOOGLE.html>
type PFN_vkGetPastPresentationTimingGOOGLE = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pPresentationTimingCount: *mut uint32_t, pPresentationTimings: *mut VkPastPresentationTimingGOOGLE) -> VkResult;
/// The dummy function for `vkGetRefreshCycleDurationGOOGLE` from `VK_GOOGLE_display_timing`
extern "system" fn dummy_vkGetRefreshCycleDurationGOOGLE(_: VkDevice, _: VkSwapchainKHR, _: *mut VkRefreshCycleDurationGOOGLE) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetRefreshCycleDurationGOOGLE"))
}
/// trait for `VK_GOOGLE_display_timing`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_GOOGLE_display_timing.html>
pub trait VK_GOOGLE_display_timing: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRefreshCycleDurationGOOGLE.html>
	fn vkGetRefreshCycleDurationGOOGLE(&self, device: VkDevice, swapchain: VkSwapchainKHR, pDisplayTimingProperties: *mut VkRefreshCycleDurationGOOGLE) -> Result<()>;
}
/// struct for `VK_GOOGLE_display_timing`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_GOOGLE_display_timing {
	vk_get_refresh_cycle_duration_google: PFN_vkGetRefreshCycleDurationGOOGLE,
}
impl VK_GOOGLE_display_timing for Vulkan_GOOGLE_display_timing {
	fn vkGetRefreshCycleDurationGOOGLE(&self, device: VkDevice, swapchain: VkSwapchainKHR, pDisplayTimingProperties: *mut VkRefreshCycleDurationGOOGLE) -> Result<()> {
		convert_result("vkGetRefreshCycleDurationGOOGLE", catch_unwind(||((self.vk_get_refresh_cycle_duration_google)(device, swapchain, pDisplayTimingProperties))))
	}
}
impl Default for Vulkan_GOOGLE_display_timing {
	fn default() -> Self {
		Self {
			vk_get_refresh_cycle_duration_google: dummy_vkGetRefreshCycleDurationGOOGLE,
		}
	}
}
impl Vulkan_GOOGLE_display_timing {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_refresh_cycle_duration_google: {let proc = get_instance_proc_address(instance, "vkGetRefreshCycleDurationGOOGLE"); if proc == null() {dummy_vkGetRefreshCycleDurationGOOGLE} else {unsafe {transmute(proc)}}},
		}
	}
}
/// trait for `VK_NV_sample_mask_override_coverage`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_sample_mask_override_coverage.html>
pub trait VK_NV_sample_mask_override_coverage: Debug {}
/// struct for `VK_NV_sample_mask_override_coverage`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_sample_mask_override_coverage {}
impl VK_NV_sample_mask_override_coverage for Vulkan_NV_sample_mask_override_coverage {}
impl Default for Vulkan_NV_sample_mask_override_coverage {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_sample_mask_override_coverage {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_NV_geometry_shader_passthrough`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_geometry_shader_passthrough.html>
pub trait VK_NV_geometry_shader_passthrough: Debug {}
/// struct for `VK_NV_geometry_shader_passthrough`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_geometry_shader_passthrough {}
impl VK_NV_geometry_shader_passthrough for Vulkan_NV_geometry_shader_passthrough {}
impl Default for Vulkan_NV_geometry_shader_passthrough {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_geometry_shader_passthrough {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_NV_viewport_array2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_viewport_array2.html>
pub trait VK_NV_viewport_array2: Debug {}
/// struct for `VK_NV_viewport_array2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_viewport_array2 {}
impl VK_NV_viewport_array2 for Vulkan_NV_viewport_array2 {}
impl Default for Vulkan_NV_viewport_array2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_viewport_array2 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX` from VK_NVX_multiview_per_view_attributes
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub perViewPositionAllComponents: VkBool32,
}
impl Debug for VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("perViewPositionAllComponents", &self.perViewPositionAllComponents)
		.finish()
	}
}
/// struct `VkMultiviewPerViewAttributesInfoNVX` from VK_NVX_multiview_per_view_attributes
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMultiviewPerViewAttributesInfoNVX.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMultiviewPerViewAttributesInfoNVX {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub perViewAttributes: VkBool32,
	pub perViewAttributesPositionXOnly: VkBool32,
}
impl Debug for VkMultiviewPerViewAttributesInfoNVX {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMultiviewPerViewAttributesInfoNVX")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("perViewAttributes", &self.perViewAttributes)
		.field("perViewAttributesPositionXOnly", &self.perViewAttributesPositionXOnly)
		.finish()
	}
}
/// trait for `VK_NVX_multiview_per_view_attributes`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NVX_multiview_per_view_attributes.html>
pub trait VK_NVX_multiview_per_view_attributes: Debug {}
/// struct for `VK_NVX_multiview_per_view_attributes`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NVX_multiview_per_view_attributes {}
impl VK_NVX_multiview_per_view_attributes for Vulkan_NVX_multiview_per_view_attributes {}
impl Default for Vulkan_NVX_multiview_per_view_attributes {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NVX_multiview_per_view_attributes {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPipelineViewportSwizzleStateCreateFlagsNV` from VK_NV_viewport_swizzle
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineViewportSwizzleStateCreateFlagsNV.html>
pub type VkPipelineViewportSwizzleStateCreateFlagsNV = VkFlags;
/// enum `VkViewportCoordinateSwizzleNV` from VK_NV_viewport_swizzle
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkViewportCoordinateSwizzleNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkViewportCoordinateSwizzleNV {
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7,
	VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV = 0x7fffffff,
}
/// struct `VkViewportSwizzleNV` from VK_NV_viewport_swizzle
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkViewportSwizzleNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkViewportSwizzleNV {
	pub x: VkViewportCoordinateSwizzleNV,
	pub y: VkViewportCoordinateSwizzleNV,
	pub z: VkViewportCoordinateSwizzleNV,
	pub w: VkViewportCoordinateSwizzleNV,
}
impl Debug for VkViewportSwizzleNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkViewportSwizzleNV")
		.field("x", &self.x)
		.field("y", &self.y)
		.field("z", &self.z)
		.field("w", &self.w)
		.finish()
	}
}
/// struct `VkPipelineViewportSwizzleStateCreateInfoNV` from VK_NV_viewport_swizzle
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineViewportSwizzleStateCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineViewportSwizzleStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineViewportSwizzleStateCreateFlagsNV,
	pub viewportCount: u32,
	pub pViewportSwizzles: *const VkViewportSwizzleNV,
}
impl Debug for VkPipelineViewportSwizzleStateCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineViewportSwizzleStateCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("viewportCount", &self.viewportCount)
		.field("pViewportSwizzles", &self.pViewportSwizzles)
		.finish()
	}
}
/// trait for `VK_NV_viewport_swizzle`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_viewport_swizzle.html>
pub trait VK_NV_viewport_swizzle: Debug {}
/// struct for `VK_NV_viewport_swizzle`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_viewport_swizzle {}
impl VK_NV_viewport_swizzle for Vulkan_NV_viewport_swizzle {}
impl Default for Vulkan_NV_viewport_swizzle {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_viewport_swizzle {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPipelineDiscardRectangleStateCreateFlagsEXT` from VK_EXT_discard_rectangles
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineDiscardRectangleStateCreateFlagsEXT.html>
pub type VkPipelineDiscardRectangleStateCreateFlagsEXT = VkFlags;
/// enum `VkDiscardRectangleModeEXT` from VK_EXT_discard_rectangles
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDiscardRectangleModeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDiscardRectangleModeEXT {
	VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
	VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,
	VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkPhysicalDeviceDiscardRectanglePropertiesEXT` from VK_EXT_discard_rectangles
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDiscardRectanglePropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDiscardRectanglePropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxDiscardRectangles: u32,
}
impl Debug for VkPhysicalDeviceDiscardRectanglePropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDiscardRectanglePropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxDiscardRectangles", &self.maxDiscardRectangles)
		.finish()
	}
}
/// struct `VkPipelineDiscardRectangleStateCreateInfoEXT` from VK_EXT_discard_rectangles
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineDiscardRectangleStateCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineDiscardRectangleStateCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineDiscardRectangleStateCreateFlagsEXT,
	pub discardRectangleMode: VkDiscardRectangleModeEXT,
	pub discardRectangleCount: u32,
	pub pDiscardRectangles: *const VkRect2D,
}
impl Debug for VkPipelineDiscardRectangleStateCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineDiscardRectangleStateCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("discardRectangleMode", &self.discardRectangleMode)
		.field("discardRectangleCount", &self.discardRectangleCount)
		.field("pDiscardRectangles", &self.pDiscardRectangles)
		.finish()
	}
}
/// function prototype `PFN_vkCmdSetDiscardRectangleEXT` from VK_EXT_discard_rectangles
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDiscardRectangleEXT.html>
type PFN_vkCmdSetDiscardRectangleEXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstDiscardRectangle: u32, discardRectangleCount: u32, pDiscardRectangles: *const VkRect2D);
/// function prototype `PFN_vkCmdSetDiscardRectangleEnableEXT` from VK_EXT_discard_rectangles
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDiscardRectangleEnableEXT.html>
type PFN_vkCmdSetDiscardRectangleEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, discardRectangleEnable: VkBool32);
/// function prototype `PFN_vkCmdSetDiscardRectangleModeEXT` from VK_EXT_discard_rectangles
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDiscardRectangleModeEXT.html>
type PFN_vkCmdSetDiscardRectangleModeEXT = extern "system" fn(commandBuffer: VkCommandBuffer, discardRectangleMode: VkDiscardRectangleModeEXT);
/// The dummy function for `vkCmdSetDiscardRectangleEXT` from `VK_EXT_discard_rectangles`
extern "system" fn dummy_vkCmdSetDiscardRectangleEXT(_: VkCommandBuffer, _: u32, _: u32, _: *const VkRect2D) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetDiscardRectangleEXT"))
}
/// trait for `VK_EXT_discard_rectangles`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_discard_rectangles.html>
pub trait VK_EXT_discard_rectangles: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDiscardRectangleEXT.html>
	fn vkCmdSetDiscardRectangleEXT(&self, commandBuffer: VkCommandBuffer, firstDiscardRectangle: u32, discardRectangleCount: u32, pDiscardRectangles: *const VkRect2D) -> Result<()>;
}
/// struct for `VK_EXT_discard_rectangles`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_discard_rectangles {
	vk_cmd_set_discard_rectangle_ext: PFN_vkCmdSetDiscardRectangleEXT,
}
impl VK_EXT_discard_rectangles for Vulkan_EXT_discard_rectangles {
	fn vkCmdSetDiscardRectangleEXT(&self, commandBuffer: VkCommandBuffer, firstDiscardRectangle: u32, discardRectangleCount: u32, pDiscardRectangles: *const VkRect2D) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_discard_rectangle_ext)(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles))))
	}
}
impl Default for Vulkan_EXT_discard_rectangles {
	fn default() -> Self {
		Self {
			vk_cmd_set_discard_rectangle_ext: dummy_vkCmdSetDiscardRectangleEXT,
		}
	}
}
impl Vulkan_EXT_discard_rectangles {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_discard_rectangle_ext: {let proc = get_instance_proc_address(instance, "vkCmdSetDiscardRectangleEXT"); if proc == null() {dummy_vkCmdSetDiscardRectangleEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPipelineRasterizationConservativeStateCreateFlagsEXT` from VK_EXT_conservative_rasterization
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRasterizationConservativeStateCreateFlagsEXT.html>
pub type VkPipelineRasterizationConservativeStateCreateFlagsEXT = VkFlags;
/// enum `VkConservativeRasterizationModeEXT` from VK_EXT_conservative_rasterization
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkConservativeRasterizationModeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkConservativeRasterizationModeEXT {
	VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0,
	VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1,
	VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2,
	VK_CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkPhysicalDeviceConservativeRasterizationPropertiesEXT` from VK_EXT_conservative_rasterization
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceConservativeRasterizationPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub primitiveOverestimationSize: f32,
	pub maxExtraPrimitiveOverestimationSize: f32,
	pub extraPrimitiveOverestimationSizeGranularity: f32,
	pub primitiveUnderestimation: VkBool32,
	pub conservativePointAndLineRasterization: VkBool32,
	pub degenerateTrianglesRasterized: VkBool32,
	pub degenerateLinesRasterized: VkBool32,
	pub fullyCoveredFragmentShaderInputVariable: VkBool32,
	pub conservativeRasterizationPostDepthCoverage: VkBool32,
}
impl Debug for VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceConservativeRasterizationPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("primitiveOverestimationSize", &self.primitiveOverestimationSize)
		.field("maxExtraPrimitiveOverestimationSize", &self.maxExtraPrimitiveOverestimationSize)
		.field("extraPrimitiveOverestimationSizeGranularity", &self.extraPrimitiveOverestimationSizeGranularity)
		.field("primitiveUnderestimation", &self.primitiveUnderestimation)
		.field("conservativePointAndLineRasterization", &self.conservativePointAndLineRasterization)
		.field("degenerateTrianglesRasterized", &self.degenerateTrianglesRasterized)
		.field("degenerateLinesRasterized", &self.degenerateLinesRasterized)
		.field("fullyCoveredFragmentShaderInputVariable", &self.fullyCoveredFragmentShaderInputVariable)
		.field("conservativeRasterizationPostDepthCoverage", &self.conservativeRasterizationPostDepthCoverage)
		.finish()
	}
}
/// struct `VkPipelineRasterizationConservativeStateCreateInfoEXT` from VK_EXT_conservative_rasterization
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRasterizationConservativeStateCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineRasterizationConservativeStateCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineRasterizationConservativeStateCreateFlagsEXT,
	pub conservativeRasterizationMode: VkConservativeRasterizationModeEXT,
	pub extraPrimitiveOverestimationSize: f32,
}
impl Debug for VkPipelineRasterizationConservativeStateCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineRasterizationConservativeStateCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("conservativeRasterizationMode", &self.conservativeRasterizationMode)
		.field("extraPrimitiveOverestimationSize", &self.extraPrimitiveOverestimationSize)
		.finish()
	}
}
/// trait for `VK_EXT_conservative_rasterization`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_conservative_rasterization.html>
pub trait VK_EXT_conservative_rasterization: Debug {}
/// struct for `VK_EXT_conservative_rasterization`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_conservative_rasterization {}
impl VK_EXT_conservative_rasterization for Vulkan_EXT_conservative_rasterization {}
impl Default for Vulkan_EXT_conservative_rasterization {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_conservative_rasterization {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPipelineRasterizationDepthClipStateCreateFlagsEXT` from VK_EXT_depth_clip_enable
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRasterizationDepthClipStateCreateFlagsEXT.html>
pub type VkPipelineRasterizationDepthClipStateCreateFlagsEXT = VkFlags;
/// struct `VkPhysicalDeviceDepthClipEnableFeaturesEXT` from VK_EXT_depth_clip_enable
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDepthClipEnableFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDepthClipEnableFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub depthClipEnable: VkBool32,
}
impl Debug for VkPhysicalDeviceDepthClipEnableFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDepthClipEnableFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("depthClipEnable", &self.depthClipEnable)
		.finish()
	}
}
/// struct `VkPipelineRasterizationDepthClipStateCreateInfoEXT` from VK_EXT_depth_clip_enable
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRasterizationDepthClipStateCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineRasterizationDepthClipStateCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineRasterizationDepthClipStateCreateFlagsEXT,
	pub depthClipEnable: VkBool32,
}
impl Debug for VkPipelineRasterizationDepthClipStateCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineRasterizationDepthClipStateCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("depthClipEnable", &self.depthClipEnable)
		.finish()
	}
}
/// trait for `VK_EXT_depth_clip_enable`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_depth_clip_enable.html>
pub trait VK_EXT_depth_clip_enable: Debug {}
/// struct for `VK_EXT_depth_clip_enable`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_depth_clip_enable {}
impl VK_EXT_depth_clip_enable for Vulkan_EXT_depth_clip_enable {}
impl Default for Vulkan_EXT_depth_clip_enable {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_depth_clip_enable {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_EXT_swapchain_colorspace`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_swapchain_colorspace.html>
pub trait VK_EXT_swapchain_colorspace: Debug {}
/// struct for `VK_EXT_swapchain_colorspace`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_swapchain_colorspace {}
impl VK_EXT_swapchain_colorspace for Vulkan_EXT_swapchain_colorspace {}
impl Default for Vulkan_EXT_swapchain_colorspace {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_swapchain_colorspace {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkXYColorEXT` from VK_EXT_hdr_metadata
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkXYColorEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkXYColorEXT {
	pub x: f32,
	pub y: f32,
}
impl Debug for VkXYColorEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkXYColorEXT")
		.field("x", &self.x)
		.field("y", &self.y)
		.finish()
	}
}
/// struct `VkHdrMetadataEXT` from VK_EXT_hdr_metadata
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkHdrMetadataEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkHdrMetadataEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub displayPrimaryRed: VkXYColorEXT,
	pub displayPrimaryGreen: VkXYColorEXT,
	pub displayPrimaryBlue: VkXYColorEXT,
	pub whitePoint: VkXYColorEXT,
	pub maxLuminance: f32,
	pub minLuminance: f32,
	pub maxContentLightLevel: f32,
	pub maxFrameAverageLightLevel: f32,
}
impl Debug for VkHdrMetadataEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkHdrMetadataEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("displayPrimaryRed", &self.displayPrimaryRed)
		.field("displayPrimaryGreen", &self.displayPrimaryGreen)
		.field("displayPrimaryBlue", &self.displayPrimaryBlue)
		.field("whitePoint", &self.whitePoint)
		.field("maxLuminance", &self.maxLuminance)
		.field("minLuminance", &self.minLuminance)
		.field("maxContentLightLevel", &self.maxContentLightLevel)
		.field("maxFrameAverageLightLevel", &self.maxFrameAverageLightLevel)
		.finish()
	}
}
/// function prototype `PFN_vkSetHdrMetadataEXT` from VK_EXT_hdr_metadata
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetHdrMetadataEXT.html>
type PFN_vkSetHdrMetadataEXT = extern "system" fn(device: VkDevice, swapchainCount: u32, pSwapchains: *const VkSwapchainKHR, pMetadata: *const VkHdrMetadataEXT);
/// The dummy function for `vkSetHdrMetadataEXT` from `VK_EXT_hdr_metadata`
extern "system" fn dummy_vkSetHdrMetadataEXT(_: VkDevice, _: u32, _: *const VkSwapchainKHR, _: *const VkHdrMetadataEXT) {
	panic_any(VkError::NullFunctionPointer("vkSetHdrMetadataEXT"))
}
/// trait for `VK_EXT_hdr_metadata`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_hdr_metadata.html>
pub trait VK_EXT_hdr_metadata: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetHdrMetadataEXT.html>
	fn vkSetHdrMetadataEXT(&self, device: VkDevice, swapchainCount: u32, pSwapchains: *const VkSwapchainKHR, pMetadata: *const VkHdrMetadataEXT) -> Result<()>;
}
/// struct for `VK_EXT_hdr_metadata`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_hdr_metadata {
	vk_set_hdr_metadata_ext: PFN_vkSetHdrMetadataEXT,
}
impl VK_EXT_hdr_metadata for Vulkan_EXT_hdr_metadata {
	fn vkSetHdrMetadataEXT(&self, device: VkDevice, swapchainCount: u32, pSwapchains: *const VkSwapchainKHR, pMetadata: *const VkHdrMetadataEXT) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_set_hdr_metadata_ext)(device, swapchainCount, pSwapchains, pMetadata))))
	}
}
impl Default for Vulkan_EXT_hdr_metadata {
	fn default() -> Self {
		Self {
			vk_set_hdr_metadata_ext: dummy_vkSetHdrMetadataEXT,
		}
	}
}
impl Vulkan_EXT_hdr_metadata {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_set_hdr_metadata_ext: {let proc = get_instance_proc_address(instance, "vkSetHdrMetadataEXT"); if proc == null() {dummy_vkSetHdrMetadataEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG` from VK_IMG_relaxed_line_rasterization
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub relaxedLineRasterization: VkBool32,
}
impl Debug for VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("relaxedLineRasterization", &self.relaxedLineRasterization)
		.finish()
	}
}
/// trait for `VK_IMG_relaxed_line_rasterization`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_IMG_relaxed_line_rasterization.html>
pub trait VK_IMG_relaxed_line_rasterization: Debug {}
/// struct for `VK_IMG_relaxed_line_rasterization`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_IMG_relaxed_line_rasterization {}
impl VK_IMG_relaxed_line_rasterization for Vulkan_IMG_relaxed_line_rasterization {}
impl Default for Vulkan_IMG_relaxed_line_rasterization {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_IMG_relaxed_line_rasterization {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_EXT_external_memory_dma_buf`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_external_memory_dma_buf.html>
pub trait VK_EXT_external_memory_dma_buf: Debug {}
/// struct for `VK_EXT_external_memory_dma_buf`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_external_memory_dma_buf {}
impl VK_EXT_external_memory_dma_buf for Vulkan_EXT_external_memory_dma_buf {}
impl Default for Vulkan_EXT_external_memory_dma_buf {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_external_memory_dma_buf {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `VK_QUEUE_FAMILY_FOREIGN_EXT` from VK_EXT_queue_family_foreign
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QUEUE_FAMILY_FOREIGN_EXT.html>
pub const VK_QUEUE_FAMILY_FOREIGN_EXT: u32 = !2u32;
/// trait for `VK_EXT_queue_family_foreign`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_queue_family_foreign.html>
pub trait VK_EXT_queue_family_foreign: Debug {}
/// struct for `VK_EXT_queue_family_foreign`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_queue_family_foreign {}
impl VK_EXT_queue_family_foreign for Vulkan_EXT_queue_family_foreign {}
impl Default for Vulkan_EXT_queue_family_foreign {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_queue_family_foreign {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkDebugUtilsMessengerCallbackDataFlagsEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugUtilsMessengerCallbackDataFlagsEXT.html>
pub type VkDebugUtilsMessengerCallbackDataFlagsEXT = VkFlags;
/// type definition `VkDebugUtilsMessageTypeFlagsEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugUtilsMessageTypeFlagsEXT.html>
pub type VkDebugUtilsMessageTypeFlagsEXT = VkFlags;
/// type definition `VkDebugUtilsMessageSeverityFlagsEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugUtilsMessageSeverityFlagsEXT.html>
pub type VkDebugUtilsMessageSeverityFlagsEXT = VkFlags;
/// type definition `VkDebugUtilsMessengerCreateFlagsEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugUtilsMessengerCreateFlagsEXT.html>
pub type VkDebugUtilsMessengerCreateFlagsEXT = VkFlags;
/// Non-dispatchable handle `VkDebugUtilsMessengerEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugUtilsMessengerEXT.html
#[cfg(target_pointer_width = "32")] pub type VkDebugUtilsMessengerEXT = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkDebugUtilsMessengerEXT_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkDebugUtilsMessengerEXT = *const VkDebugUtilsMessengerEXT_T;
/// enum `VkDebugUtilsMessageSeverityFlagBitsEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugUtilsMessageSeverityFlagBitsEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDebugUtilsMessageSeverityFlagBitsEXT {
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 0x00000001,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 0x00000010,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 0x00000100,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 0x00001000,
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkDebugUtilsMessageTypeFlagBitsEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugUtilsMessageTypeFlagBitsEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDebugUtilsMessageTypeFlagBitsEXT {
	VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 0x00000001,
	VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 0x00000002,
	VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 0x00000004,
	VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT = 0x00000008,
	VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkDebugUtilsLabelEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugUtilsLabelEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDebugUtilsLabelEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pLabelName: *const i8,
	pub color: [f32; 4 as usize],
}
impl Debug for VkDebugUtilsLabelEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDebugUtilsLabelEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pLabelName", &self.pLabelName)
		.field("color", &self.color)
		.finish()
	}
}
/// struct `VkDebugUtilsObjectNameInfoEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugUtilsObjectNameInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDebugUtilsObjectNameInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub objectType: VkObjectType,
	pub objectHandle: u64,
	pub pObjectName: *const i8,
}
impl Debug for VkDebugUtilsObjectNameInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDebugUtilsObjectNameInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("objectType", &self.objectType)
		.field("objectHandle", &self.objectHandle)
		.field("pObjectName", &self.pObjectName)
		.finish()
	}
}
/// struct `VkDebugUtilsMessengerCallbackDataEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugUtilsMessengerCallbackDataEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDebugUtilsMessengerCallbackDataEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDebugUtilsMessengerCallbackDataFlagsEXT,
	pub pMessageIdName: *const i8,
	pub messageIdNumber: i32,
	pub pMessage: *const i8,
	pub queueLabelCount: u32,
	pub pQueueLabels: *const VkDebugUtilsLabelEXT,
	pub cmdBufLabelCount: u32,
	pub pCmdBufLabels: *const VkDebugUtilsLabelEXT,
	pub objectCount: u32,
	pub pObjects: *const VkDebugUtilsObjectNameInfoEXT,
}
impl Debug for VkDebugUtilsMessengerCallbackDataEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDebugUtilsMessengerCallbackDataEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("pMessageIdName", &self.pMessageIdName)
		.field("messageIdNumber", &self.messageIdNumber)
		.field("pMessage", &self.pMessage)
		.field("queueLabelCount", &self.queueLabelCount)
		.field("pQueueLabels", &self.pQueueLabels)
		.field("cmdBufLabelCount", &self.cmdBufLabelCount)
		.field("pCmdBufLabels", &self.pCmdBufLabels)
		.field("objectCount", &self.objectCount)
		.field("pObjects", &self.pObjects)
		.finish()
	}
}
/// struct `VkDebugUtilsMessengerCreateInfoEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugUtilsMessengerCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDebugUtilsMessengerCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDebugUtilsMessengerCreateFlagsEXT,
	pub messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT,
	pub messageType: VkDebugUtilsMessageTypeFlagsEXT,
	pub pfnUserCallback: PFN_vkDebugUtilsMessengerCallbackEXT,
	pub pUserData: *mut c_void,
}
impl Debug for VkDebugUtilsMessengerCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDebugUtilsMessengerCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("messageSeverity", &self.messageSeverity)
		.field("messageType", &self.messageType)
		.field("pfnUserCallback", &self.pfnUserCallback)
		.field("pUserData", &self.pUserData)
		.finish()
	}
}
/// struct `VkDebugUtilsObjectTagInfoEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugUtilsObjectTagInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDebugUtilsObjectTagInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub objectType: VkObjectType,
	pub objectHandle: u64,
	pub tagName: u64,
	pub tagSize: usize,
	pub pTag: *const c_void,
}
impl Debug for VkDebugUtilsObjectTagInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDebugUtilsObjectTagInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("objectType", &self.objectType)
		.field("objectHandle", &self.objectHandle)
		.field("tagName", &self.tagName)
		.field("tagSize", &self.tagSize)
		.field("pTag", &self.pTag)
		.finish()
	}
}
/// function prototype `PFN_vkDebugUtilsMessengerCallbackEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDebugUtilsMessengerCallbackEXT.html>
type PFN_vkDebugUtilsMessengerCallbackEXT = extern "system" fn(messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT, messageTypes: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: *const VkDebugUtilsMessengerCallbackDataEXT, pUserData: *mut c_void) -> VkBool32;
/// function prototype `PFN_vkSetDebugUtilsObjectNameEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetDebugUtilsObjectNameEXT.html>
type PFN_vkSetDebugUtilsObjectNameEXT = extern "system" fn(device: VkDevice, pNameInfo: *const VkDebugUtilsObjectNameInfoEXT) -> VkResult;
/// function prototype `PFN_vkSetDebugUtilsObjectTagEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetDebugUtilsObjectTagEXT.html>
type PFN_vkSetDebugUtilsObjectTagEXT = extern "system" fn(device: VkDevice, pTagInfo: *const VkDebugUtilsObjectTagInfoEXT) -> VkResult;
/// function prototype `PFN_vkQueueBeginDebugUtilsLabelEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueBeginDebugUtilsLabelEXT.html>
type PFN_vkQueueBeginDebugUtilsLabelEXT = extern "system" fn(queue: VkQueue, pLabelInfo: *const VkDebugUtilsLabelEXT);
/// function prototype `PFN_vkQueueEndDebugUtilsLabelEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueEndDebugUtilsLabelEXT.html>
type PFN_vkQueueEndDebugUtilsLabelEXT = extern "system" fn(queue: VkQueue);
/// function prototype `PFN_vkQueueInsertDebugUtilsLabelEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueInsertDebugUtilsLabelEXT.html>
type PFN_vkQueueInsertDebugUtilsLabelEXT = extern "system" fn(queue: VkQueue, pLabelInfo: *const VkDebugUtilsLabelEXT);
/// function prototype `PFN_vkCmdBeginDebugUtilsLabelEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginDebugUtilsLabelEXT.html>
type PFN_vkCmdBeginDebugUtilsLabelEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pLabelInfo: *const VkDebugUtilsLabelEXT);
/// function prototype `PFN_vkCmdEndDebugUtilsLabelEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndDebugUtilsLabelEXT.html>
type PFN_vkCmdEndDebugUtilsLabelEXT = extern "system" fn(commandBuffer: VkCommandBuffer);
/// function prototype `PFN_vkCmdInsertDebugUtilsLabelEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdInsertDebugUtilsLabelEXT.html>
type PFN_vkCmdInsertDebugUtilsLabelEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pLabelInfo: *const VkDebugUtilsLabelEXT);
/// function prototype `PFN_vkCreateDebugUtilsMessengerEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDebugUtilsMessengerEXT.html>
type PFN_vkCreateDebugUtilsMessengerEXT = extern "system" fn(instance: VkInstance, pCreateInfo: *const VkDebugUtilsMessengerCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pMessenger: *mut VkDebugUtilsMessengerEXT) -> VkResult;
/// function prototype `PFN_vkDestroyDebugUtilsMessengerEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDebugUtilsMessengerEXT.html>
type PFN_vkDestroyDebugUtilsMessengerEXT = extern "system" fn(instance: VkInstance, messenger: VkDebugUtilsMessengerEXT, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkSubmitDebugUtilsMessageEXT` from VK_EXT_debug_utils
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSubmitDebugUtilsMessageEXT.html>
type PFN_vkSubmitDebugUtilsMessageEXT = extern "system" fn(instance: VkInstance, messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT, messageTypes: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: *const VkDebugUtilsMessengerCallbackDataEXT);
/// The dummy function for `vkSetDebugUtilsObjectNameEXT` from `VK_EXT_debug_utils`
extern "system" fn dummy_vkSetDebugUtilsObjectNameEXT(_: VkDevice, _: *const VkDebugUtilsObjectNameInfoEXT) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkSetDebugUtilsObjectNameEXT"))
}
/// trait for `VK_EXT_debug_utils`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_debug_utils.html>
pub trait VK_EXT_debug_utils: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetDebugUtilsObjectNameEXT.html>
	fn vkSetDebugUtilsObjectNameEXT(&self, device: VkDevice, pNameInfo: *const VkDebugUtilsObjectNameInfoEXT) -> Result<()>;
}
/// struct for `VK_EXT_debug_utils`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_debug_utils {
	vk_set_debug_utils_object_name_ext: PFN_vkSetDebugUtilsObjectNameEXT,
}
impl VK_EXT_debug_utils for Vulkan_EXT_debug_utils {
	fn vkSetDebugUtilsObjectNameEXT(&self, device: VkDevice, pNameInfo: *const VkDebugUtilsObjectNameInfoEXT) -> Result<()> {
		convert_result("vkSetDebugUtilsObjectNameEXT", catch_unwind(||((self.vk_set_debug_utils_object_name_ext)(device, pNameInfo))))
	}
}
impl Default for Vulkan_EXT_debug_utils {
	fn default() -> Self {
		Self {
			vk_set_debug_utils_object_name_ext: dummy_vkSetDebugUtilsObjectNameEXT,
		}
	}
}
impl Vulkan_EXT_debug_utils {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_set_debug_utils_object_name_ext: {let proc = get_instance_proc_address(instance, "vkSetDebugUtilsObjectNameEXT"); if proc == null() {dummy_vkSetDebugUtilsObjectNameEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkSamplerReductionModeEXT` from VK_EXT_sampler_filter_minmax
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerReductionModeEXT.html>
pub type VkSamplerReductionModeEXT = VkSamplerReductionMode;
/// type definition `VkSamplerReductionModeCreateInfoEXT` from VK_EXT_sampler_filter_minmax
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerReductionModeCreateInfoEXT.html>
pub type VkSamplerReductionModeCreateInfoEXT = VkSamplerReductionModeCreateInfo;
/// type definition `VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT` from VK_EXT_sampler_filter_minmax
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.html>
pub type VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT = VkPhysicalDeviceSamplerFilterMinmaxProperties;
/// trait for `VK_EXT_sampler_filter_minmax`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_sampler_filter_minmax.html>
pub trait VK_EXT_sampler_filter_minmax: Debug {}
/// struct for `VK_EXT_sampler_filter_minmax`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_sampler_filter_minmax {}
impl VK_EXT_sampler_filter_minmax for Vulkan_EXT_sampler_filter_minmax {}
impl Default for Vulkan_EXT_sampler_filter_minmax {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_sampler_filter_minmax {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_AMD_gpu_shader_int16`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_gpu_shader_int16.html>
pub trait VK_AMD_gpu_shader_int16: Debug {}
/// struct for `VK_AMD_gpu_shader_int16`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_gpu_shader_int16 {}
impl VK_AMD_gpu_shader_int16 for Vulkan_AMD_gpu_shader_int16 {}
impl Default for Vulkan_AMD_gpu_shader_int16 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_gpu_shader_int16 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkAttachmentSampleCountInfoAMD` from VK_AMD_mixed_attachment_samples
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentSampleCountInfoAMD.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAttachmentSampleCountInfoAMD {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub colorAttachmentCount: u32,
	pub pColorAttachmentSamples: *const VkSampleCountFlagBits,
	pub depthStencilAttachmentSamples: VkSampleCountFlagBits,
}
impl Debug for VkAttachmentSampleCountInfoAMD {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAttachmentSampleCountInfoAMD")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("colorAttachmentCount", &self.colorAttachmentCount)
		.field("pColorAttachmentSamples", &self.pColorAttachmentSamples)
		.field("depthStencilAttachmentSamples", &self.depthStencilAttachmentSamples)
		.finish()
	}
}
/// trait for `VK_AMD_mixed_attachment_samples`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_mixed_attachment_samples.html>
pub trait VK_AMD_mixed_attachment_samples: Debug {}
/// struct for `VK_AMD_mixed_attachment_samples`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_mixed_attachment_samples {}
impl VK_AMD_mixed_attachment_samples for Vulkan_AMD_mixed_attachment_samples {}
impl Default for Vulkan_AMD_mixed_attachment_samples {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_mixed_attachment_samples {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_AMD_shader_fragment_mask`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_shader_fragment_mask.html>
pub trait VK_AMD_shader_fragment_mask: Debug {}
/// struct for `VK_AMD_shader_fragment_mask`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_fragment_mask {}
impl VK_AMD_shader_fragment_mask for Vulkan_AMD_shader_fragment_mask {}
impl Default for Vulkan_AMD_shader_fragment_mask {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_shader_fragment_mask {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceInlineUniformBlockFeaturesEXT` from VK_EXT_inline_uniform_block
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceInlineUniformBlockFeaturesEXT.html>
pub type VkPhysicalDeviceInlineUniformBlockFeaturesEXT = VkPhysicalDeviceInlineUniformBlockFeatures;
/// type definition `VkPhysicalDeviceInlineUniformBlockPropertiesEXT` from VK_EXT_inline_uniform_block
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceInlineUniformBlockPropertiesEXT.html>
pub type VkPhysicalDeviceInlineUniformBlockPropertiesEXT = VkPhysicalDeviceInlineUniformBlockProperties;
/// type definition `VkWriteDescriptorSetInlineUniformBlockEXT` from VK_EXT_inline_uniform_block
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetInlineUniformBlockEXT.html>
pub type VkWriteDescriptorSetInlineUniformBlockEXT = VkWriteDescriptorSetInlineUniformBlock;
/// type definition `VkDescriptorPoolInlineUniformBlockCreateInfoEXT` from VK_EXT_inline_uniform_block
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPoolInlineUniformBlockCreateInfoEXT.html>
pub type VkDescriptorPoolInlineUniformBlockCreateInfoEXT = VkDescriptorPoolInlineUniformBlockCreateInfo;
/// trait for `VK_EXT_inline_uniform_block`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_inline_uniform_block.html>
pub trait VK_EXT_inline_uniform_block: Debug {}
/// struct for `VK_EXT_inline_uniform_block`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_inline_uniform_block {}
impl VK_EXT_inline_uniform_block for Vulkan_EXT_inline_uniform_block {}
impl Default for Vulkan_EXT_inline_uniform_block {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_inline_uniform_block {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_EXT_shader_stencil_export`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_shader_stencil_export.html>
pub trait VK_EXT_shader_stencil_export: Debug {}
/// struct for `VK_EXT_shader_stencil_export`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_stencil_export {}
impl VK_EXT_shader_stencil_export for Vulkan_EXT_shader_stencil_export {}
impl Default for Vulkan_EXT_shader_stencil_export {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_stencil_export {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkSampleLocationEXT` from VK_EXT_sample_locations
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSampleLocationEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSampleLocationEXT {
	pub x: f32,
	pub y: f32,
}
impl Debug for VkSampleLocationEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSampleLocationEXT")
		.field("x", &self.x)
		.field("y", &self.y)
		.finish()
	}
}
/// struct `VkSampleLocationsInfoEXT` from VK_EXT_sample_locations
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSampleLocationsInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSampleLocationsInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub sampleLocationsPerPixel: VkSampleCountFlagBits,
	pub sampleLocationGridSize: VkExtent2D,
	pub sampleLocationsCount: u32,
	pub pSampleLocations: *const VkSampleLocationEXT,
}
impl Debug for VkSampleLocationsInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSampleLocationsInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("sampleLocationsPerPixel", &self.sampleLocationsPerPixel)
		.field("sampleLocationGridSize", &self.sampleLocationGridSize)
		.field("sampleLocationsCount", &self.sampleLocationsCount)
		.field("pSampleLocations", &self.pSampleLocations)
		.finish()
	}
}
/// struct `VkAttachmentSampleLocationsEXT` from VK_EXT_sample_locations
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentSampleLocationsEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAttachmentSampleLocationsEXT {
	pub attachmentIndex: u32,
	pub sampleLocationsInfo: VkSampleLocationsInfoEXT,
}
impl Debug for VkAttachmentSampleLocationsEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAttachmentSampleLocationsEXT")
		.field("attachmentIndex", &self.attachmentIndex)
		.field("sampleLocationsInfo", &self.sampleLocationsInfo)
		.finish()
	}
}
/// struct `VkSubpassSampleLocationsEXT` from VK_EXT_sample_locations
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassSampleLocationsEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSubpassSampleLocationsEXT {
	pub subpassIndex: u32,
	pub sampleLocationsInfo: VkSampleLocationsInfoEXT,
}
impl Debug for VkSubpassSampleLocationsEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSubpassSampleLocationsEXT")
		.field("subpassIndex", &self.subpassIndex)
		.field("sampleLocationsInfo", &self.sampleLocationsInfo)
		.finish()
	}
}
/// struct `VkRenderPassSampleLocationsBeginInfoEXT` from VK_EXT_sample_locations
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassSampleLocationsBeginInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassSampleLocationsBeginInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub attachmentInitialSampleLocationsCount: u32,
	pub pAttachmentInitialSampleLocations: *const VkAttachmentSampleLocationsEXT,
	pub postSubpassSampleLocationsCount: u32,
	pub pPostSubpassSampleLocations: *const VkSubpassSampleLocationsEXT,
}
impl Debug for VkRenderPassSampleLocationsBeginInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassSampleLocationsBeginInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("attachmentInitialSampleLocationsCount", &self.attachmentInitialSampleLocationsCount)
		.field("pAttachmentInitialSampleLocations", &self.pAttachmentInitialSampleLocations)
		.field("postSubpassSampleLocationsCount", &self.postSubpassSampleLocationsCount)
		.field("pPostSubpassSampleLocations", &self.pPostSubpassSampleLocations)
		.finish()
	}
}
/// struct `VkPipelineSampleLocationsStateCreateInfoEXT` from VK_EXT_sample_locations
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineSampleLocationsStateCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineSampleLocationsStateCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub sampleLocationsEnable: VkBool32,
	pub sampleLocationsInfo: VkSampleLocationsInfoEXT,
}
impl Debug for VkPipelineSampleLocationsStateCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineSampleLocationsStateCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("sampleLocationsEnable", &self.sampleLocationsEnable)
		.field("sampleLocationsInfo", &self.sampleLocationsInfo)
		.finish()
	}
}
/// struct `VkPhysicalDeviceSampleLocationsPropertiesEXT` from VK_EXT_sample_locations
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSampleLocationsPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSampleLocationsPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub sampleLocationSampleCounts: VkSampleCountFlags,
	pub maxSampleLocationGridSize: VkExtent2D,
	pub sampleLocationCoordinateRange: [f32; 2 as usize],
	pub sampleLocationSubPixelBits: u32,
	pub variableSampleLocations: VkBool32,
}
impl Debug for VkPhysicalDeviceSampleLocationsPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSampleLocationsPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("sampleLocationSampleCounts", &self.sampleLocationSampleCounts)
		.field("maxSampleLocationGridSize", &self.maxSampleLocationGridSize)
		.field("sampleLocationCoordinateRange", &self.sampleLocationCoordinateRange)
		.field("sampleLocationSubPixelBits", &self.sampleLocationSubPixelBits)
		.field("variableSampleLocations", &self.variableSampleLocations)
		.finish()
	}
}
/// struct `VkMultisamplePropertiesEXT` from VK_EXT_sample_locations
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMultisamplePropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMultisamplePropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxSampleLocationGridSize: VkExtent2D,
}
impl Debug for VkMultisamplePropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMultisamplePropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxSampleLocationGridSize", &self.maxSampleLocationGridSize)
		.finish()
	}
}
/// function prototype `PFN_vkCmdSetSampleLocationsEXT` from VK_EXT_sample_locations
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetSampleLocationsEXT.html>
type PFN_vkCmdSetSampleLocationsEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pSampleLocationsInfo: *const VkSampleLocationsInfoEXT);
/// function prototype `PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT` from VK_EXT_sample_locations
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMultisamplePropertiesEXT.html>
type PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT = extern "system" fn(physicalDevice: VkPhysicalDevice, samples: VkSampleCountFlagBits, pMultisampleProperties: *mut VkMultisamplePropertiesEXT);
/// The dummy function for `vkCmdSetSampleLocationsEXT` from `VK_EXT_sample_locations`
extern "system" fn dummy_vkCmdSetSampleLocationsEXT(_: VkCommandBuffer, _: *const VkSampleLocationsInfoEXT) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetSampleLocationsEXT"))
}
/// trait for `VK_EXT_sample_locations`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_sample_locations.html>
pub trait VK_EXT_sample_locations: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetSampleLocationsEXT.html>
	fn vkCmdSetSampleLocationsEXT(&self, commandBuffer: VkCommandBuffer, pSampleLocationsInfo: *const VkSampleLocationsInfoEXT) -> Result<()>;
}
/// struct for `VK_EXT_sample_locations`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_sample_locations {
	vk_cmd_set_sample_locations_ext: PFN_vkCmdSetSampleLocationsEXT,
}
impl VK_EXT_sample_locations for Vulkan_EXT_sample_locations {
	fn vkCmdSetSampleLocationsEXT(&self, commandBuffer: VkCommandBuffer, pSampleLocationsInfo: *const VkSampleLocationsInfoEXT) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_sample_locations_ext)(commandBuffer, pSampleLocationsInfo))))
	}
}
impl Default for Vulkan_EXT_sample_locations {
	fn default() -> Self {
		Self {
			vk_cmd_set_sample_locations_ext: dummy_vkCmdSetSampleLocationsEXT,
		}
	}
}
impl Vulkan_EXT_sample_locations {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_sample_locations_ext: {let proc = get_instance_proc_address(instance, "vkCmdSetSampleLocationsEXT"); if proc == null() {dummy_vkCmdSetSampleLocationsEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// enum `VkBlendOverlapEXT` from VK_EXT_blend_operation_advanced
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBlendOverlapEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBlendOverlapEXT {
	VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0,
	VK_BLEND_OVERLAP_DISJOINT_EXT = 1,
	VK_BLEND_OVERLAP_CONJOINT_EXT = 2,
	VK_BLEND_OVERLAP_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT` from VK_EXT_blend_operation_advanced
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub advancedBlendCoherentOperations: VkBool32,
}
impl Debug for VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("advancedBlendCoherentOperations", &self.advancedBlendCoherentOperations)
		.finish()
	}
}
/// struct `VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT` from VK_EXT_blend_operation_advanced
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub advancedBlendMaxColorAttachments: u32,
	pub advancedBlendIndependentBlend: VkBool32,
	pub advancedBlendNonPremultipliedSrcColor: VkBool32,
	pub advancedBlendNonPremultipliedDstColor: VkBool32,
	pub advancedBlendCorrelatedOverlap: VkBool32,
	pub advancedBlendAllOperations: VkBool32,
}
impl Debug for VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("advancedBlendMaxColorAttachments", &self.advancedBlendMaxColorAttachments)
		.field("advancedBlendIndependentBlend", &self.advancedBlendIndependentBlend)
		.field("advancedBlendNonPremultipliedSrcColor", &self.advancedBlendNonPremultipliedSrcColor)
		.field("advancedBlendNonPremultipliedDstColor", &self.advancedBlendNonPremultipliedDstColor)
		.field("advancedBlendCorrelatedOverlap", &self.advancedBlendCorrelatedOverlap)
		.field("advancedBlendAllOperations", &self.advancedBlendAllOperations)
		.finish()
	}
}
/// struct `VkPipelineColorBlendAdvancedStateCreateInfoEXT` from VK_EXT_blend_operation_advanced
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineColorBlendAdvancedStateCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineColorBlendAdvancedStateCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcPremultiplied: VkBool32,
	pub dstPremultiplied: VkBool32,
	pub blendOverlap: VkBlendOverlapEXT,
}
impl Debug for VkPipelineColorBlendAdvancedStateCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineColorBlendAdvancedStateCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcPremultiplied", &self.srcPremultiplied)
		.field("dstPremultiplied", &self.dstPremultiplied)
		.field("blendOverlap", &self.blendOverlap)
		.finish()
	}
}
/// trait for `VK_EXT_blend_operation_advanced`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_blend_operation_advanced.html>
pub trait VK_EXT_blend_operation_advanced: Debug {}
/// struct for `VK_EXT_blend_operation_advanced`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_blend_operation_advanced {}
impl VK_EXT_blend_operation_advanced for Vulkan_EXT_blend_operation_advanced {}
impl Default for Vulkan_EXT_blend_operation_advanced {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_blend_operation_advanced {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPipelineCoverageToColorStateCreateFlagsNV` from VK_NV_fragment_coverage_to_color
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCoverageToColorStateCreateFlagsNV.html>
pub type VkPipelineCoverageToColorStateCreateFlagsNV = VkFlags;
/// struct `VkPipelineCoverageToColorStateCreateInfoNV` from VK_NV_fragment_coverage_to_color
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCoverageToColorStateCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineCoverageToColorStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCoverageToColorStateCreateFlagsNV,
	pub coverageToColorEnable: VkBool32,
	pub coverageToColorLocation: u32,
}
impl Debug for VkPipelineCoverageToColorStateCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineCoverageToColorStateCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("coverageToColorEnable", &self.coverageToColorEnable)
		.field("coverageToColorLocation", &self.coverageToColorLocation)
		.finish()
	}
}
/// trait for `VK_NV_fragment_coverage_to_color`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_fragment_coverage_to_color.html>
pub trait VK_NV_fragment_coverage_to_color: Debug {}
/// struct for `VK_NV_fragment_coverage_to_color`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_fragment_coverage_to_color {}
impl VK_NV_fragment_coverage_to_color for Vulkan_NV_fragment_coverage_to_color {}
impl Default for Vulkan_NV_fragment_coverage_to_color {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_fragment_coverage_to_color {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPipelineCoverageModulationStateCreateFlagsNV` from VK_NV_framebuffer_mixed_samples
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCoverageModulationStateCreateFlagsNV.html>
pub type VkPipelineCoverageModulationStateCreateFlagsNV = VkFlags;
/// type definition `VkAttachmentSampleCountInfoNV` from VK_NV_framebuffer_mixed_samples
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAttachmentSampleCountInfoNV.html>
pub type VkAttachmentSampleCountInfoNV = VkAttachmentSampleCountInfoAMD;
/// enum `VkCoverageModulationModeNV` from VK_NV_framebuffer_mixed_samples
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCoverageModulationModeNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCoverageModulationModeNV {
	VK_COVERAGE_MODULATION_MODE_NONE_NV = 0,
	VK_COVERAGE_MODULATION_MODE_RGB_NV = 1,
	VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 2,
	VK_COVERAGE_MODULATION_MODE_RGBA_NV = 3,
	VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV = 0x7fffffff,
}
/// struct `VkPipelineCoverageModulationStateCreateInfoNV` from VK_NV_framebuffer_mixed_samples
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCoverageModulationStateCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineCoverageModulationStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCoverageModulationStateCreateFlagsNV,
	pub coverageModulationMode: VkCoverageModulationModeNV,
	pub coverageModulationTableEnable: VkBool32,
	pub coverageModulationTableCount: u32,
	pub pCoverageModulationTable: *const float,
}
impl Debug for VkPipelineCoverageModulationStateCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineCoverageModulationStateCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("coverageModulationMode", &self.coverageModulationMode)
		.field("coverageModulationTableEnable", &self.coverageModulationTableEnable)
		.field("coverageModulationTableCount", &self.coverageModulationTableCount)
		.field("pCoverageModulationTable", &self.pCoverageModulationTable)
		.finish()
	}
}
/// trait for `VK_NV_framebuffer_mixed_samples`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_framebuffer_mixed_samples.html>
pub trait VK_NV_framebuffer_mixed_samples: Debug {}
/// struct for `VK_NV_framebuffer_mixed_samples`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_framebuffer_mixed_samples {}
impl VK_NV_framebuffer_mixed_samples for Vulkan_NV_framebuffer_mixed_samples {}
impl Default for Vulkan_NV_framebuffer_mixed_samples {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_framebuffer_mixed_samples {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_NV_fill_rectangle`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_fill_rectangle.html>
pub trait VK_NV_fill_rectangle: Debug {}
/// struct for `VK_NV_fill_rectangle`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_fill_rectangle {}
impl VK_NV_fill_rectangle for Vulkan_NV_fill_rectangle {}
impl Default for Vulkan_NV_fill_rectangle {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_fill_rectangle {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceShaderSMBuiltinsPropertiesNV` from VK_NV_shader_sm_builtins
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderSMBuiltinsPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderSMCount: u32,
	pub shaderWarpsPerSM: u32,
}
impl Debug for VkPhysicalDeviceShaderSMBuiltinsPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderSMBuiltinsPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderSMCount", &self.shaderSMCount)
		.field("shaderWarpsPerSM", &self.shaderWarpsPerSM)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShaderSMBuiltinsFeaturesNV` from VK_NV_shader_sm_builtins
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderSMBuiltinsFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderSMBuiltins: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderSMBuiltinsFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderSMBuiltinsFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderSMBuiltins", &self.shaderSMBuiltins)
		.finish()
	}
}
/// trait for `VK_NV_shader_sm_builtins`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_shader_sm_builtins.html>
pub trait VK_NV_shader_sm_builtins: Debug {}
/// struct for `VK_NV_shader_sm_builtins`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_shader_sm_builtins {}
impl VK_NV_shader_sm_builtins for Vulkan_NV_shader_sm_builtins {}
impl Default for Vulkan_NV_shader_sm_builtins {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_shader_sm_builtins {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_EXT_post_depth_coverage`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_post_depth_coverage.html>
pub trait VK_EXT_post_depth_coverage: Debug {}
/// struct for `VK_EXT_post_depth_coverage`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_post_depth_coverage {}
impl VK_EXT_post_depth_coverage for Vulkan_EXT_post_depth_coverage {}
impl Default for Vulkan_EXT_post_depth_coverage {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_post_depth_coverage {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkDrmFormatModifierPropertiesEXT` from VK_EXT_image_drm_format_modifier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDrmFormatModifierPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDrmFormatModifierPropertiesEXT {
	pub drmFormatModifier: u64,
	pub drmFormatModifierPlaneCount: u32,
	pub drmFormatModifierTilingFeatures: VkFormatFeatureFlags,
}
impl Debug for VkDrmFormatModifierPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDrmFormatModifierPropertiesEXT")
		.field("drmFormatModifier", &self.drmFormatModifier)
		.field("drmFormatModifierPlaneCount", &self.drmFormatModifierPlaneCount)
		.field("drmFormatModifierTilingFeatures", &self.drmFormatModifierTilingFeatures)
		.finish()
	}
}
/// struct `VkDrmFormatModifierPropertiesListEXT` from VK_EXT_image_drm_format_modifier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDrmFormatModifierPropertiesListEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDrmFormatModifierPropertiesListEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub drmFormatModifierCount: u32,
	pub pDrmFormatModifierProperties: *mut VkDrmFormatModifierPropertiesEXT,
}
impl Debug for VkDrmFormatModifierPropertiesListEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDrmFormatModifierPropertiesListEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("drmFormatModifierCount", &self.drmFormatModifierCount)
		.field("pDrmFormatModifierProperties", &self.pDrmFormatModifierProperties)
		.finish()
	}
}
/// struct `VkPhysicalDeviceImageDrmFormatModifierInfoEXT` from VK_EXT_image_drm_format_modifier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImageDrmFormatModifierInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub drmFormatModifier: u64,
	pub sharingMode: VkSharingMode,
	pub queueFamilyIndexCount: u32,
	pub pQueueFamilyIndices: *const uint32_t,
}
impl Debug for VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceImageDrmFormatModifierInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("drmFormatModifier", &self.drmFormatModifier)
		.field("sharingMode", &self.sharingMode)
		.field("queueFamilyIndexCount", &self.queueFamilyIndexCount)
		.field("pQueueFamilyIndices", &self.pQueueFamilyIndices)
		.finish()
	}
}
/// struct `VkImageDrmFormatModifierListCreateInfoEXT` from VK_EXT_image_drm_format_modifier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageDrmFormatModifierListCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageDrmFormatModifierListCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub drmFormatModifierCount: u32,
	pub pDrmFormatModifiers: *const uint64_t,
}
impl Debug for VkImageDrmFormatModifierListCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageDrmFormatModifierListCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("drmFormatModifierCount", &self.drmFormatModifierCount)
		.field("pDrmFormatModifiers", &self.pDrmFormatModifiers)
		.finish()
	}
}
/// struct `VkImageDrmFormatModifierExplicitCreateInfoEXT` from VK_EXT_image_drm_format_modifier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageDrmFormatModifierExplicitCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageDrmFormatModifierExplicitCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub drmFormatModifier: u64,
	pub drmFormatModifierPlaneCount: u32,
	pub pPlaneLayouts: *const VkSubresourceLayout,
}
impl Debug for VkImageDrmFormatModifierExplicitCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageDrmFormatModifierExplicitCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("drmFormatModifier", &self.drmFormatModifier)
		.field("drmFormatModifierPlaneCount", &self.drmFormatModifierPlaneCount)
		.field("pPlaneLayouts", &self.pPlaneLayouts)
		.finish()
	}
}
/// struct `VkImageDrmFormatModifierPropertiesEXT` from VK_EXT_image_drm_format_modifier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageDrmFormatModifierPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageDrmFormatModifierPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub drmFormatModifier: u64,
}
impl Debug for VkImageDrmFormatModifierPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageDrmFormatModifierPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("drmFormatModifier", &self.drmFormatModifier)
		.finish()
	}
}
/// struct `VkDrmFormatModifierProperties2EXT` from VK_EXT_image_drm_format_modifier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDrmFormatModifierProperties2EXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDrmFormatModifierProperties2EXT {
	pub drmFormatModifier: u64,
	pub drmFormatModifierPlaneCount: u32,
	pub drmFormatModifierTilingFeatures: VkFormatFeatureFlags2,
}
impl Debug for VkDrmFormatModifierProperties2EXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDrmFormatModifierProperties2EXT")
		.field("drmFormatModifier", &self.drmFormatModifier)
		.field("drmFormatModifierPlaneCount", &self.drmFormatModifierPlaneCount)
		.field("drmFormatModifierTilingFeatures", &self.drmFormatModifierTilingFeatures)
		.finish()
	}
}
/// struct `VkDrmFormatModifierPropertiesList2EXT` from VK_EXT_image_drm_format_modifier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDrmFormatModifierPropertiesList2EXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDrmFormatModifierPropertiesList2EXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub drmFormatModifierCount: u32,
	pub pDrmFormatModifierProperties: *mut VkDrmFormatModifierProperties2EXT,
}
impl Debug for VkDrmFormatModifierPropertiesList2EXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDrmFormatModifierPropertiesList2EXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("drmFormatModifierCount", &self.drmFormatModifierCount)
		.field("pDrmFormatModifierProperties", &self.pDrmFormatModifierProperties)
		.finish()
	}
}
/// function prototype `PFN_vkGetImageDrmFormatModifierPropertiesEXT` from VK_EXT_image_drm_format_modifier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageDrmFormatModifierPropertiesEXT.html>
type PFN_vkGetImageDrmFormatModifierPropertiesEXT = extern "system" fn(device: VkDevice, image: VkImage, pProperties: *mut VkImageDrmFormatModifierPropertiesEXT) -> VkResult;
/// The dummy function for `vkGetImageDrmFormatModifierPropertiesEXT` from `VK_EXT_image_drm_format_modifier`
extern "system" fn dummy_vkGetImageDrmFormatModifierPropertiesEXT(_: VkDevice, _: VkImage, _: *mut VkImageDrmFormatModifierPropertiesEXT) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetImageDrmFormatModifierPropertiesEXT"))
}
/// trait for `VK_EXT_image_drm_format_modifier`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_image_drm_format_modifier.html>
pub trait VK_EXT_image_drm_format_modifier: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageDrmFormatModifierPropertiesEXT.html>
	fn vkGetImageDrmFormatModifierPropertiesEXT(&self, device: VkDevice, image: VkImage, pProperties: *mut VkImageDrmFormatModifierPropertiesEXT) -> Result<()>;
}
/// struct for `VK_EXT_image_drm_format_modifier`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_image_drm_format_modifier {
	vk_get_image_drm_format_modifier_properties_ext: PFN_vkGetImageDrmFormatModifierPropertiesEXT,
}
impl VK_EXT_image_drm_format_modifier for Vulkan_EXT_image_drm_format_modifier {
	fn vkGetImageDrmFormatModifierPropertiesEXT(&self, device: VkDevice, image: VkImage, pProperties: *mut VkImageDrmFormatModifierPropertiesEXT) -> Result<()> {
		convert_result("vkGetImageDrmFormatModifierPropertiesEXT", catch_unwind(||((self.vk_get_image_drm_format_modifier_properties_ext)(device, image, pProperties))))
	}
}
impl Default for Vulkan_EXT_image_drm_format_modifier {
	fn default() -> Self {
		Self {
			vk_get_image_drm_format_modifier_properties_ext: dummy_vkGetImageDrmFormatModifierPropertiesEXT,
		}
	}
}
impl Vulkan_EXT_image_drm_format_modifier {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_image_drm_format_modifier_properties_ext: {let proc = get_instance_proc_address(instance, "vkGetImageDrmFormatModifierPropertiesEXT"); if proc == null() {dummy_vkGetImageDrmFormatModifierPropertiesEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkValidationCacheCreateFlagsEXT` from VK_EXT_validation_cache
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkValidationCacheCreateFlagsEXT.html>
pub type VkValidationCacheCreateFlagsEXT = VkFlags;
/// Non-dispatchable handle `VkValidationCacheEXT` from VK_EXT_validation_cache
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkValidationCacheEXT.html
#[cfg(target_pointer_width = "32")] pub type VkValidationCacheEXT = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkValidationCacheEXT_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkValidationCacheEXT = *const VkValidationCacheEXT_T;
/// enum `VkValidationCacheHeaderVersionEXT` from VK_EXT_validation_cache
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkValidationCacheHeaderVersionEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkValidationCacheHeaderVersionEXT {
	VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1,
	VK_VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkValidationCacheCreateInfoEXT` from VK_EXT_validation_cache
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkValidationCacheCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkValidationCacheCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkValidationCacheCreateFlagsEXT,
	pub initialDataSize: usize,
	pub pInitialData: *const c_void,
}
impl Debug for VkValidationCacheCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkValidationCacheCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("initialDataSize", &self.initialDataSize)
		.field("pInitialData", &self.pInitialData)
		.finish()
	}
}
/// struct `VkShaderModuleValidationCacheCreateInfoEXT` from VK_EXT_validation_cache
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderModuleValidationCacheCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkShaderModuleValidationCacheCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub validationCache: VkValidationCacheEXT,
}
impl Debug for VkShaderModuleValidationCacheCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkShaderModuleValidationCacheCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("validationCache", &self.validationCache)
		.finish()
	}
}
/// function prototype `PFN_vkCreateValidationCacheEXT` from VK_EXT_validation_cache
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateValidationCacheEXT.html>
type PFN_vkCreateValidationCacheEXT = extern "system" fn(device: VkDevice, pCreateInfo: *const VkValidationCacheCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pValidationCache: *mut VkValidationCacheEXT) -> VkResult;
/// function prototype `PFN_vkDestroyValidationCacheEXT` from VK_EXT_validation_cache
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyValidationCacheEXT.html>
type PFN_vkDestroyValidationCacheEXT = extern "system" fn(device: VkDevice, validationCache: VkValidationCacheEXT, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkMergeValidationCachesEXT` from VK_EXT_validation_cache
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkMergeValidationCachesEXT.html>
type PFN_vkMergeValidationCachesEXT = extern "system" fn(device: VkDevice, dstCache: VkValidationCacheEXT, srcCacheCount: u32, pSrcCaches: *const VkValidationCacheEXT) -> VkResult;
/// function prototype `PFN_vkGetValidationCacheDataEXT` from VK_EXT_validation_cache
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetValidationCacheDataEXT.html>
type PFN_vkGetValidationCacheDataEXT = extern "system" fn(device: VkDevice, validationCache: VkValidationCacheEXT, pDataSize: *mut size_t, pData: *mut c_void) -> VkResult;
/// The dummy function for `vkCreateValidationCacheEXT` from `VK_EXT_validation_cache`
extern "system" fn dummy_vkCreateValidationCacheEXT(_: VkDevice, _: *const VkValidationCacheCreateInfoEXT, _: *const VkAllocationCallbacks, _: *mut VkValidationCacheEXT) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateValidationCacheEXT"))
}
/// trait for `VK_EXT_validation_cache`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_validation_cache.html>
pub trait VK_EXT_validation_cache: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateValidationCacheEXT.html>
	fn vkCreateValidationCacheEXT(&self, device: VkDevice, pCreateInfo: *const VkValidationCacheCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pValidationCache: *mut VkValidationCacheEXT) -> Result<()>;
}
/// struct for `VK_EXT_validation_cache`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_validation_cache {
	vk_create_validation_cache_ext: PFN_vkCreateValidationCacheEXT,
}
impl VK_EXT_validation_cache for Vulkan_EXT_validation_cache {
	fn vkCreateValidationCacheEXT(&self, device: VkDevice, pCreateInfo: *const VkValidationCacheCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pValidationCache: *mut VkValidationCacheEXT) -> Result<()> {
		convert_result("vkCreateValidationCacheEXT", catch_unwind(||((self.vk_create_validation_cache_ext)(device, pCreateInfo, pAllocator, pValidationCache))))
	}
}
impl Default for Vulkan_EXT_validation_cache {
	fn default() -> Self {
		Self {
			vk_create_validation_cache_ext: dummy_vkCreateValidationCacheEXT,
		}
	}
}
impl Vulkan_EXT_validation_cache {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_validation_cache_ext: {let proc = get_instance_proc_address(instance, "vkCreateValidationCacheEXT"); if proc == null() {dummy_vkCreateValidationCacheEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkDescriptorBindingFlagBitsEXT` from VK_EXT_descriptor_indexing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorBindingFlagBitsEXT.html>
pub type VkDescriptorBindingFlagBitsEXT = VkDescriptorBindingFlagBits;
/// type definition `VkDescriptorBindingFlagsEXT` from VK_EXT_descriptor_indexing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorBindingFlagsEXT.html>
pub type VkDescriptorBindingFlagsEXT = VkDescriptorBindingFlags;
/// type definition `VkDescriptorSetLayoutBindingFlagsCreateInfoEXT` from VK_EXT_descriptor_indexing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.html>
pub type VkDescriptorSetLayoutBindingFlagsCreateInfoEXT = VkDescriptorSetLayoutBindingFlagsCreateInfo;
/// type definition `VkPhysicalDeviceDescriptorIndexingFeaturesEXT` from VK_EXT_descriptor_indexing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDescriptorIndexingFeaturesEXT.html>
pub type VkPhysicalDeviceDescriptorIndexingFeaturesEXT = VkPhysicalDeviceDescriptorIndexingFeatures;
/// type definition `VkPhysicalDeviceDescriptorIndexingPropertiesEXT` from VK_EXT_descriptor_indexing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDescriptorIndexingPropertiesEXT.html>
pub type VkPhysicalDeviceDescriptorIndexingPropertiesEXT = VkPhysicalDeviceDescriptorIndexingProperties;
/// type definition `VkDescriptorSetVariableDescriptorCountAllocateInfoEXT` from VK_EXT_descriptor_indexing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.html>
pub type VkDescriptorSetVariableDescriptorCountAllocateInfoEXT = VkDescriptorSetVariableDescriptorCountAllocateInfo;
/// type definition `VkDescriptorSetVariableDescriptorCountLayoutSupportEXT` from VK_EXT_descriptor_indexing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.html>
pub type VkDescriptorSetVariableDescriptorCountLayoutSupportEXT = VkDescriptorSetVariableDescriptorCountLayoutSupport;
/// trait for `VK_EXT_descriptor_indexing`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_descriptor_indexing.html>
pub trait VK_EXT_descriptor_indexing: Debug {}
/// struct for `VK_EXT_descriptor_indexing`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_descriptor_indexing {}
impl VK_EXT_descriptor_indexing for Vulkan_EXT_descriptor_indexing {}
impl Default for Vulkan_EXT_descriptor_indexing {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_descriptor_indexing {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_EXT_shader_viewport_index_layer`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_shader_viewport_index_layer.html>
pub trait VK_EXT_shader_viewport_index_layer: Debug {}
/// struct for `VK_EXT_shader_viewport_index_layer`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_viewport_index_layer {}
impl VK_EXT_shader_viewport_index_layer for Vulkan_EXT_shader_viewport_index_layer {}
impl Default for Vulkan_EXT_shader_viewport_index_layer {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_viewport_index_layer {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkShadingRatePaletteEntryNV` from VK_NV_shading_rate_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShadingRatePaletteEntryNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkShadingRatePaletteEntryNV {
	VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0,
	VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 1,
	VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 2,
	VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 3,
	VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 4,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 5,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 6,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 7,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 8,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 10,
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 11,
	VK_SHADING_RATE_PALETTE_ENTRY_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkCoarseSampleOrderTypeNV` from VK_NV_shading_rate_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCoarseSampleOrderTypeNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCoarseSampleOrderTypeNV {
	VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0,
	VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 1,
	VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 2,
	VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 3,
	VK_COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
/// struct `VkShadingRatePaletteNV` from VK_NV_shading_rate_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShadingRatePaletteNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkShadingRatePaletteNV {
	pub shadingRatePaletteEntryCount: u32,
	pub pShadingRatePaletteEntries: *const VkShadingRatePaletteEntryNV,
}
impl Debug for VkShadingRatePaletteNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkShadingRatePaletteNV")
		.field("shadingRatePaletteEntryCount", &self.shadingRatePaletteEntryCount)
		.field("pShadingRatePaletteEntries", &self.pShadingRatePaletteEntries)
		.finish()
	}
}
/// struct `VkPipelineViewportShadingRateImageStateCreateInfoNV` from VK_NV_shading_rate_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineViewportShadingRateImageStateCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineViewportShadingRateImageStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub shadingRateImageEnable: VkBool32,
	pub viewportCount: u32,
	pub pShadingRatePalettes: *const VkShadingRatePaletteNV,
}
impl Debug for VkPipelineViewportShadingRateImageStateCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineViewportShadingRateImageStateCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shadingRateImageEnable", &self.shadingRateImageEnable)
		.field("viewportCount", &self.viewportCount)
		.field("pShadingRatePalettes", &self.pShadingRatePalettes)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShadingRateImageFeaturesNV` from VK_NV_shading_rate_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShadingRateImageFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShadingRateImageFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shadingRateImage: VkBool32,
	pub shadingRateCoarseSampleOrder: VkBool32,
}
impl Debug for VkPhysicalDeviceShadingRateImageFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShadingRateImageFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shadingRateImage", &self.shadingRateImage)
		.field("shadingRateCoarseSampleOrder", &self.shadingRateCoarseSampleOrder)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShadingRateImagePropertiesNV` from VK_NV_shading_rate_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShadingRateImagePropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShadingRateImagePropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shadingRateTexelSize: VkExtent2D,
	pub shadingRatePaletteSize: u32,
	pub shadingRateMaxCoarseSamples: u32,
}
impl Debug for VkPhysicalDeviceShadingRateImagePropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShadingRateImagePropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shadingRateTexelSize", &self.shadingRateTexelSize)
		.field("shadingRatePaletteSize", &self.shadingRatePaletteSize)
		.field("shadingRateMaxCoarseSamples", &self.shadingRateMaxCoarseSamples)
		.finish()
	}
}
/// struct `VkCoarseSampleLocationNV` from VK_NV_shading_rate_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCoarseSampleLocationNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCoarseSampleLocationNV {
	pub pixelX: u32,
	pub pixelY: u32,
	pub sample: u32,
}
impl Debug for VkCoarseSampleLocationNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCoarseSampleLocationNV")
		.field("pixelX", &self.pixelX)
		.field("pixelY", &self.pixelY)
		.field("sample", &self.sample)
		.finish()
	}
}
/// struct `VkCoarseSampleOrderCustomNV` from VK_NV_shading_rate_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCoarseSampleOrderCustomNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCoarseSampleOrderCustomNV {
	pub shadingRate: VkShadingRatePaletteEntryNV,
	pub sampleCount: u32,
	pub sampleLocationCount: u32,
	pub pSampleLocations: *const VkCoarseSampleLocationNV,
}
impl Debug for VkCoarseSampleOrderCustomNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCoarseSampleOrderCustomNV")
		.field("shadingRate", &self.shadingRate)
		.field("sampleCount", &self.sampleCount)
		.field("sampleLocationCount", &self.sampleLocationCount)
		.field("pSampleLocations", &self.pSampleLocations)
		.finish()
	}
}
/// struct `VkPipelineViewportCoarseSampleOrderStateCreateInfoNV` from VK_NV_shading_rate_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub sampleOrderType: VkCoarseSampleOrderTypeNV,
	pub customSampleOrderCount: u32,
	pub pCustomSampleOrders: *const VkCoarseSampleOrderCustomNV,
}
impl Debug for VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineViewportCoarseSampleOrderStateCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("sampleOrderType", &self.sampleOrderType)
		.field("customSampleOrderCount", &self.customSampleOrderCount)
		.field("pCustomSampleOrders", &self.pCustomSampleOrders)
		.finish()
	}
}
/// function prototype `PFN_vkCmdBindShadingRateImageNV` from VK_NV_shading_rate_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindShadingRateImageNV.html>
type PFN_vkCmdBindShadingRateImageNV = extern "system" fn(commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout);
/// function prototype `PFN_vkCmdSetViewportShadingRatePaletteNV` from VK_NV_shading_rate_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportShadingRatePaletteNV.html>
type PFN_vkCmdSetViewportShadingRatePaletteNV = extern "system" fn(commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pShadingRatePalettes: *const VkShadingRatePaletteNV);
/// function prototype `PFN_vkCmdSetCoarseSampleOrderNV` from VK_NV_shading_rate_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCoarseSampleOrderNV.html>
type PFN_vkCmdSetCoarseSampleOrderNV = extern "system" fn(commandBuffer: VkCommandBuffer, sampleOrderType: VkCoarseSampleOrderTypeNV, customSampleOrderCount: u32, pCustomSampleOrders: *const VkCoarseSampleOrderCustomNV);
/// The dummy function for `vkCmdBindShadingRateImageNV` from `VK_NV_shading_rate_image`
extern "system" fn dummy_vkCmdBindShadingRateImageNV(_: VkCommandBuffer, _: VkImageView, _: VkImageLayout) {
	panic_any(VkError::NullFunctionPointer("vkCmdBindShadingRateImageNV"))
}
/// trait for `VK_NV_shading_rate_image`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_shading_rate_image.html>
pub trait VK_NV_shading_rate_image: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindShadingRateImageNV.html>
	fn vkCmdBindShadingRateImageNV(&self, commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) -> Result<()>;
}
/// struct for `VK_NV_shading_rate_image`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_shading_rate_image {
	vk_cmd_bind_shading_rate_image_nv: PFN_vkCmdBindShadingRateImageNV,
}
impl VK_NV_shading_rate_image for Vulkan_NV_shading_rate_image {
	fn vkCmdBindShadingRateImageNV(&self, commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_bind_shading_rate_image_nv)(commandBuffer, imageView, imageLayout))))
	}
}
impl Default for Vulkan_NV_shading_rate_image {
	fn default() -> Self {
		Self {
			vk_cmd_bind_shading_rate_image_nv: dummy_vkCmdBindShadingRateImageNV,
		}
	}
}
impl Vulkan_NV_shading_rate_image {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_bind_shading_rate_image_nv: {let proc = get_instance_proc_address(instance, "vkCmdBindShadingRateImageNV"); if proc == null() {dummy_vkCmdBindShadingRateImageNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// constant `VK_SHADER_UNUSED_KHR` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_SHADER_UNUSED_KHR.html>
pub const VK_SHADER_UNUSED_KHR: u32 = !0u32;
/// constant `VK_SHADER_UNUSED_NV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_SHADER_UNUSED_NV.html>
pub const VK_SHADER_UNUSED_NV: u32 = !0u32;
/// type definition `VkRayTracingShaderGroupTypeNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRayTracingShaderGroupTypeNV.html>
pub type VkRayTracingShaderGroupTypeNV = VkRayTracingShaderGroupTypeKHR;
/// type definition `VkGeometryTypeNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeometryTypeNV.html>
pub type VkGeometryTypeNV = VkGeometryTypeKHR;
/// type definition `VkAccelerationStructureTypeNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureTypeNV.html>
pub type VkAccelerationStructureTypeNV = VkAccelerationStructureTypeKHR;
/// type definition `VkCopyAccelerationStructureModeNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyAccelerationStructureModeNV.html>
pub type VkCopyAccelerationStructureModeNV = VkCopyAccelerationStructureModeKHR;
/// type definition `VkGeometryFlagsKHR` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeometryFlagsKHR.html>
pub type VkGeometryFlagsKHR = VkFlags;
/// type definition `VkGeometryFlagsNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeometryFlagsNV.html>
pub type VkGeometryFlagsNV = VkGeometryFlagsKHR;
/// type definition `VkGeometryFlagBitsNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeometryFlagBitsNV.html>
pub type VkGeometryFlagBitsNV = VkGeometryFlagBitsKHR;
/// type definition `VkGeometryInstanceFlagsKHR` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeometryInstanceFlagsKHR.html>
pub type VkGeometryInstanceFlagsKHR = VkFlags;
/// type definition `VkGeometryInstanceFlagsNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeometryInstanceFlagsNV.html>
pub type VkGeometryInstanceFlagsNV = VkGeometryInstanceFlagsKHR;
/// type definition `VkGeometryInstanceFlagBitsNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeometryInstanceFlagBitsNV.html>
pub type VkGeometryInstanceFlagBitsNV = VkGeometryInstanceFlagBitsKHR;
/// type definition `VkBuildAccelerationStructureFlagsKHR` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBuildAccelerationStructureFlagsKHR.html>
pub type VkBuildAccelerationStructureFlagsKHR = VkFlags;
/// type definition `VkBuildAccelerationStructureFlagsNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBuildAccelerationStructureFlagsNV.html>
pub type VkBuildAccelerationStructureFlagsNV = VkBuildAccelerationStructureFlagsKHR;
/// type definition `VkBuildAccelerationStructureFlagBitsNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBuildAccelerationStructureFlagBitsNV.html>
pub type VkBuildAccelerationStructureFlagBitsNV = VkBuildAccelerationStructureFlagBitsKHR;
/// type definition `VkTransformMatrixNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTransformMatrixNV.html>
pub type VkTransformMatrixNV = VkTransformMatrixKHR;
/// type definition `VkAabbPositionsNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAabbPositionsNV.html>
pub type VkAabbPositionsNV = VkAabbPositionsKHR;
/// type definition `VkAccelerationStructureInstanceNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureInstanceNV.html>
pub type VkAccelerationStructureInstanceNV = VkAccelerationStructureInstanceKHR;
/// Non-dispatchable handle `VkAccelerationStructureNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureNV.html
#[cfg(target_pointer_width = "32")] pub type VkAccelerationStructureNV = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkAccelerationStructureNV_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkAccelerationStructureNV = *const VkAccelerationStructureNV_T;
/// enum `VkRayTracingShaderGroupTypeKHR` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRayTracingShaderGroupTypeKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkRayTracingShaderGroupTypeKHR {
	VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR = 0,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR = 1,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR = 2,
	VK_RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkRayTracingShaderGroupTypeKHR {
	pub const VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV: VkRayTracingShaderGroupTypeKHR = VkRayTracingShaderGroupTypeKHR::VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR;
	pub const VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV: VkRayTracingShaderGroupTypeKHR = VkRayTracingShaderGroupTypeKHR::VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR;
	pub const VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV: VkRayTracingShaderGroupTypeKHR = VkRayTracingShaderGroupTypeKHR::VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR;
}
/// enum `VkGeometryTypeKHR` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeometryTypeKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkGeometryTypeKHR {
	VK_GEOMETRY_TYPE_TRIANGLES_KHR = 0,
	VK_GEOMETRY_TYPE_AABBS_KHR = 1,
	VK_GEOMETRY_TYPE_INSTANCES_KHR = 2,
	VK_GEOMETRY_TYPE_SPHERES_NV = 1000429004,
	VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV = 1000429005,
	VK_GEOMETRY_TYPE_DENSE_GEOMETRY_FORMAT_TRIANGLES_AMDX = 1000478000,
	VK_GEOMETRY_TYPE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkGeometryTypeKHR {
	pub const VK_GEOMETRY_TYPE_TRIANGLES_NV: VkGeometryTypeKHR = VkGeometryTypeKHR::VK_GEOMETRY_TYPE_TRIANGLES_KHR;
	pub const VK_GEOMETRY_TYPE_AABBS_NV: VkGeometryTypeKHR = VkGeometryTypeKHR::VK_GEOMETRY_TYPE_AABBS_KHR;
}
/// enum `VkAccelerationStructureTypeKHR` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureTypeKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAccelerationStructureTypeKHR {
	VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR = 0,
	VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR = 1,
	VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR = 2,
	VK_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkAccelerationStructureTypeKHR {
	pub const VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV: VkAccelerationStructureTypeKHR = VkAccelerationStructureTypeKHR::VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;
	pub const VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV: VkAccelerationStructureTypeKHR = VkAccelerationStructureTypeKHR::VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;
}
/// enum `VkCopyAccelerationStructureModeKHR` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyAccelerationStructureModeKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCopyAccelerationStructureModeKHR {
	VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR = 0,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR = 1,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR = 2,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR = 3,
	VK_COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkCopyAccelerationStructureModeKHR {
	pub const VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV: VkCopyAccelerationStructureModeKHR = VkCopyAccelerationStructureModeKHR::VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR;
	pub const VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV: VkCopyAccelerationStructureModeKHR = VkCopyAccelerationStructureModeKHR::VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR;
}
/// enum `VkAccelerationStructureMemoryRequirementsTypeNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureMemoryRequirementsTypeNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAccelerationStructureMemoryRequirementsTypeNV {
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0,
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1,
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2,
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkGeometryFlagBitsKHR` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeometryFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkGeometryFlagBitsKHR {
	VK_GEOMETRY_OPAQUE_BIT_KHR = 0x00000001,
	VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR = 0x00000002,
	VK_GEOMETRY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkGeometryFlagBitsKHR {
	pub const VK_GEOMETRY_OPAQUE_BIT_NV: VkGeometryFlagBitsKHR = VkGeometryFlagBitsKHR::VK_GEOMETRY_OPAQUE_BIT_KHR;
	pub const VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV: VkGeometryFlagBitsKHR = VkGeometryFlagBitsKHR::VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR;
}
/// enum `VkGeometryInstanceFlagBitsKHR` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeometryInstanceFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkGeometryInstanceFlagBitsKHR {
	VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR = 0x00000001,
	VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR = 0x00000002,
	VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR = 0x00000004,
	VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR = 0x00000008,
	VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT = 0x00000010,
	VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT = 0x00000020,
	VK_GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkGeometryInstanceFlagBitsKHR {
	pub const VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR: VkGeometryInstanceFlagBitsKHR = VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR;
	pub const VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV: VkGeometryInstanceFlagBitsKHR = VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR;
	pub const VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV: VkGeometryInstanceFlagBitsKHR = VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR;
	pub const VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV: VkGeometryInstanceFlagBitsKHR = VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR;
	pub const VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV: VkGeometryInstanceFlagBitsKHR = VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR;
	pub const VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT: VkGeometryInstanceFlagBitsKHR = VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT;
	pub const VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT: VkGeometryInstanceFlagBitsKHR = VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT;
}
/// enum `VkBuildAccelerationStructureFlagBitsKHR` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBuildAccelerationStructureFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBuildAccelerationStructureFlagBitsKHR {
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR = 0x00000001,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR = 0x00000002,
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR = 0x00000004,
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR = 0x00000008,
	VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR = 0x00000010,
	VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV = 0x00000020,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT = 0x00000040,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT = 0x00000080,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT = 0x00000100,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_BIT_NV = 0x00000200,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR = 0x00000800,
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_CLUSTER_OPACITY_MICROMAPS_BIT_NV = 0x00001000,
	VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
impl VkBuildAccelerationStructureFlagBitsKHR {
	pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_BIT_NV;
	pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR: VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR;
}
/// struct `VkRayTracingShaderGroupCreateInfoNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRayTracingShaderGroupCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRayTracingShaderGroupCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkRayTracingShaderGroupTypeKHR,
	pub generalShader: u32,
	pub closestHitShader: u32,
	pub anyHitShader: u32,
	pub intersectionShader: u32,
}
impl Debug for VkRayTracingShaderGroupCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRayTracingShaderGroupCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("type_", &self.type_)
		.field("generalShader", &self.generalShader)
		.field("closestHitShader", &self.closestHitShader)
		.field("anyHitShader", &self.anyHitShader)
		.field("intersectionShader", &self.intersectionShader)
		.finish()
	}
}
/// struct `VkRayTracingPipelineCreateInfoNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRayTracingPipelineCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRayTracingPipelineCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCreateFlags,
	pub stageCount: u32,
	pub pStages: *const VkPipelineShaderStageCreateInfo,
	pub groupCount: u32,
	pub pGroups: *const VkRayTracingShaderGroupCreateInfoNV,
	pub maxRecursionDepth: u32,
	pub layout: VkPipelineLayout,
	pub basePipelineHandle: VkPipeline,
	pub basePipelineIndex: i32,
}
impl Debug for VkRayTracingPipelineCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRayTracingPipelineCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("stageCount", &self.stageCount)
		.field("pStages", &self.pStages)
		.field("groupCount", &self.groupCount)
		.field("pGroups", &self.pGroups)
		.field("maxRecursionDepth", &self.maxRecursionDepth)
		.field("layout", &self.layout)
		.field("basePipelineHandle", &self.basePipelineHandle)
		.field("basePipelineIndex", &self.basePipelineIndex)
		.finish()
	}
}
/// struct `VkGeometryTrianglesNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeometryTrianglesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkGeometryTrianglesNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub vertexData: VkBuffer,
	pub vertexOffset: VkDeviceSize,
	pub vertexCount: u32,
	pub vertexStride: VkDeviceSize,
	pub vertexFormat: VkFormat,
	pub indexData: VkBuffer,
	pub indexOffset: VkDeviceSize,
	pub indexCount: u32,
	pub indexType: VkIndexType,
	pub transformData: VkBuffer,
	pub transformOffset: VkDeviceSize,
}
impl Debug for VkGeometryTrianglesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkGeometryTrianglesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("vertexData", &self.vertexData)
		.field("vertexOffset", &self.vertexOffset)
		.field("vertexCount", &self.vertexCount)
		.field("vertexStride", &self.vertexStride)
		.field("vertexFormat", &self.vertexFormat)
		.field("indexData", &self.indexData)
		.field("indexOffset", &self.indexOffset)
		.field("indexCount", &self.indexCount)
		.field("indexType", &self.indexType)
		.field("transformData", &self.transformData)
		.field("transformOffset", &self.transformOffset)
		.finish()
	}
}
/// struct `VkGeometryAABBNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeometryAABBNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkGeometryAABBNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub aabbData: VkBuffer,
	pub numAABBs: u32,
	pub stride: u32,
	pub offset: VkDeviceSize,
}
impl Debug for VkGeometryAABBNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkGeometryAABBNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("aabbData", &self.aabbData)
		.field("numAABBs", &self.numAABBs)
		.field("stride", &self.stride)
		.field("offset", &self.offset)
		.finish()
	}
}
/// struct `VkGeometryDataNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeometryDataNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkGeometryDataNV {
	pub triangles: VkGeometryTrianglesNV,
	pub aabbs: VkGeometryAABBNV,
}
impl Debug for VkGeometryDataNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkGeometryDataNV")
		.field("triangles", &self.triangles)
		.field("aabbs", &self.aabbs)
		.finish()
	}
}
/// struct `VkGeometryNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeometryNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkGeometryNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub geometryType: VkGeometryTypeKHR,
	pub geometry: VkGeometryDataNV,
	pub flags: VkGeometryFlagsKHR,
}
impl Debug for VkGeometryNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkGeometryNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("geometryType", &self.geometryType)
		.field("geometry", &self.geometry)
		.field("flags", &self.flags)
		.finish()
	}
}
/// struct `VkAccelerationStructureInfoNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkAccelerationStructureTypeNV,
	pub flags: VkBuildAccelerationStructureFlagsNV,
	pub instanceCount: u32,
	pub geometryCount: u32,
	pub pGeometries: *const VkGeometryNV,
}
impl Debug for VkAccelerationStructureInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("type_", &self.type_)
		.field("flags", &self.flags)
		.field("instanceCount", &self.instanceCount)
		.field("geometryCount", &self.geometryCount)
		.field("pGeometries", &self.pGeometries)
		.finish()
	}
}
/// struct `VkAccelerationStructureCreateInfoNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub compactedSize: VkDeviceSize,
	pub info: VkAccelerationStructureInfoNV,
}
impl Debug for VkAccelerationStructureCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("compactedSize", &self.compactedSize)
		.field("info", &self.info)
		.finish()
	}
}
/// struct `VkBindAccelerationStructureMemoryInfoNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindAccelerationStructureMemoryInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindAccelerationStructureMemoryInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub accelerationStructure: VkAccelerationStructureNV,
	pub memory: VkDeviceMemory,
	pub memoryOffset: VkDeviceSize,
	pub deviceIndexCount: u32,
	pub pDeviceIndices: *const uint32_t,
}
impl Debug for VkBindAccelerationStructureMemoryInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindAccelerationStructureMemoryInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("accelerationStructure", &self.accelerationStructure)
		.field("memory", &self.memory)
		.field("memoryOffset", &self.memoryOffset)
		.field("deviceIndexCount", &self.deviceIndexCount)
		.field("pDeviceIndices", &self.pDeviceIndices)
		.finish()
	}
}
/// struct `VkWriteDescriptorSetAccelerationStructureNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetAccelerationStructureNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkWriteDescriptorSetAccelerationStructureNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub accelerationStructureCount: u32,
	pub pAccelerationStructures: *const VkAccelerationStructureNV,
}
impl Debug for VkWriteDescriptorSetAccelerationStructureNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkWriteDescriptorSetAccelerationStructureNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("accelerationStructureCount", &self.accelerationStructureCount)
		.field("pAccelerationStructures", &self.pAccelerationStructures)
		.finish()
	}
}
/// struct `VkAccelerationStructureMemoryRequirementsInfoNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureMemoryRequirementsInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureMemoryRequirementsInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkAccelerationStructureMemoryRequirementsTypeNV,
	pub accelerationStructure: VkAccelerationStructureNV,
}
impl Debug for VkAccelerationStructureMemoryRequirementsInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureMemoryRequirementsInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("type_", &self.type_)
		.field("accelerationStructure", &self.accelerationStructure)
		.finish()
	}
}
/// struct `VkPhysicalDeviceRayTracingPropertiesNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRayTracingPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderGroupHandleSize: u32,
	pub maxRecursionDepth: u32,
	pub maxShaderGroupStride: u32,
	pub shaderGroupBaseAlignment: u32,
	pub maxGeometryCount: u64,
	pub maxInstanceCount: u64,
	pub maxTriangleCount: u64,
	pub maxDescriptorSetAccelerationStructures: u32,
}
impl Debug for VkPhysicalDeviceRayTracingPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRayTracingPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderGroupHandleSize", &self.shaderGroupHandleSize)
		.field("maxRecursionDepth", &self.maxRecursionDepth)
		.field("maxShaderGroupStride", &self.maxShaderGroupStride)
		.field("shaderGroupBaseAlignment", &self.shaderGroupBaseAlignment)
		.field("maxGeometryCount", &self.maxGeometryCount)
		.field("maxInstanceCount", &self.maxInstanceCount)
		.field("maxTriangleCount", &self.maxTriangleCount)
		.field("maxDescriptorSetAccelerationStructures", &self.maxDescriptorSetAccelerationStructures)
		.finish()
	}
}
/// struct `VkTransformMatrixKHR` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTransformMatrixKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTransformMatrixKHR {
	pub matrix: [[f32; 4 as usize]; 3 as usize],
}
impl Debug for VkTransformMatrixKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTransformMatrixKHR")
		.field("matrix", &self.matrix)
		.finish()
	}
}
/// struct `VkAabbPositionsKHR` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAabbPositionsKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAabbPositionsKHR {
	pub minX: f32,
	pub minY: f32,
	pub minZ: f32,
	pub maxX: f32,
	pub maxY: f32,
	pub maxZ: f32,
}
impl Debug for VkAabbPositionsKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAabbPositionsKHR")
		.field("minX", &self.minX)
		.field("minY", &self.minY)
		.field("minZ", &self.minZ)
		.field("maxX", &self.maxX)
		.field("maxY", &self.maxY)
		.field("maxZ", &self.maxZ)
		.finish()
	}
}
/// struct `VkAccelerationStructureInstanceKHR` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureInstanceKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureInstanceKHR {
	pub transform: VkTransformMatrixKHR,
	/// Bitfield: instanceCustomIndex: u32 in 24 bits
	/// Bitfield: mask: u32 in 8 bits
	bitfield1: u32,
	/// Bitfield: instanceShaderBindingTableRecordOffset: u32 in 24 bits
	/// Bitfield: flags: VkGeometryInstanceFlagsKHR in 8 bits
	bitfield2: u32,
	pub accelerationStructureReference: u64,
}
impl VkAccelerationStructureInstanceKHR {
	pub fn get_instanceCustomIndex(&self) -> u32 {
		(self.bitfield1 >> 0) & 0xffffff
	}
	pub fn set_instanceCustomIndex(&mut self, value: u32) {
		self.bitfield1 = (value & 0xffffff) << 0;
	}
	pub fn get_mask(&self) -> u32 {
		(self.bitfield1 >> 24) & 0xff
	}
	pub fn set_mask(&mut self, value: u32) {
		self.bitfield1 = (value & 0xff) << 24;
	}
	pub fn get_instanceShaderBindingTableRecordOffset(&self) -> u32 {
		(self.bitfield2 >> 0) & 0xffffff
	}
	pub fn set_instanceShaderBindingTableRecordOffset(&mut self, value: u32) {
		self.bitfield2 = (value & 0xffffff) << 0;
	}
	pub fn get_flags(&self) -> u32 {
		(self.bitfield2 >> 24) & 0xff
	}
	pub fn set_flags(&mut self, value: u32) {
		self.bitfield2 = (value & 0xff) << 24;
	}
}
impl Debug for VkAccelerationStructureInstanceKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureInstanceKHR")
		.field("transform", &self.transform)
		.field("instanceCustomIndex", &self.get_instanceCustomIndex())
		.field("mask", &self.get_mask())
		.field("instanceShaderBindingTableRecordOffset", &self.get_instanceShaderBindingTableRecordOffset())
		.field("flags", &self.get_flags())
		.field("accelerationStructureReference", &self.accelerationStructureReference)
		.finish()
	}
}
/// function prototype `PFN_vkCreateAccelerationStructureNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAccelerationStructureNV.html>
type PFN_vkCreateAccelerationStructureNV = extern "system" fn(device: VkDevice, pCreateInfo: *const VkAccelerationStructureCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pAccelerationStructure: *mut VkAccelerationStructureNV) -> VkResult;
/// function prototype `PFN_vkDestroyAccelerationStructureNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyAccelerationStructureNV.html>
type PFN_vkDestroyAccelerationStructureNV = extern "system" fn(device: VkDevice, accelerationStructure: VkAccelerationStructureNV, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkGetAccelerationStructureMemoryRequirementsNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureMemoryRequirementsNV.html>
type PFN_vkGetAccelerationStructureMemoryRequirementsNV = extern "system" fn(device: VkDevice, pInfo: *const VkAccelerationStructureMemoryRequirementsInfoNV, pMemoryRequirements: *mut VkMemoryRequirements2KHR);
/// function prototype `PFN_vkBindAccelerationStructureMemoryNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindAccelerationStructureMemoryNV.html>
type PFN_vkBindAccelerationStructureMemoryNV = extern "system" fn(device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindAccelerationStructureMemoryInfoNV) -> VkResult;
/// function prototype `PFN_vkCmdBuildAccelerationStructureNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildAccelerationStructureNV.html>
type PFN_vkCmdBuildAccelerationStructureNV = extern "system" fn(commandBuffer: VkCommandBuffer, pInfo: *const VkAccelerationStructureInfoNV, instanceData: VkBuffer, instanceOffset: VkDeviceSize, update: VkBool32, dst: VkAccelerationStructureNV, src: VkAccelerationStructureNV, scratch: VkBuffer, scratchOffset: VkDeviceSize);
/// function prototype `PFN_vkCmdCopyAccelerationStructureNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyAccelerationStructureNV.html>
type PFN_vkCmdCopyAccelerationStructureNV = extern "system" fn(commandBuffer: VkCommandBuffer, dst: VkAccelerationStructureNV, src: VkAccelerationStructureNV, mode: VkCopyAccelerationStructureModeKHR);
/// function prototype `PFN_vkCmdTraceRaysNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdTraceRaysNV.html>
type PFN_vkCmdTraceRaysNV = extern "system" fn(commandBuffer: VkCommandBuffer, raygenShaderBindingTableBuffer: VkBuffer, raygenShaderBindingOffset: VkDeviceSize, missShaderBindingTableBuffer: VkBuffer, missShaderBindingOffset: VkDeviceSize, missShaderBindingStride: VkDeviceSize, hitShaderBindingTableBuffer: VkBuffer, hitShaderBindingOffset: VkDeviceSize, hitShaderBindingStride: VkDeviceSize, callableShaderBindingTableBuffer: VkBuffer, callableShaderBindingOffset: VkDeviceSize, callableShaderBindingStride: VkDeviceSize, width: u32, height: u32, depth: u32);
/// function prototype `PFN_vkCreateRayTracingPipelinesNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesNV.html>
type PFN_vkCreateRayTracingPipelinesNV = extern "system" fn(device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkRayTracingPipelineCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult;
/// function prototype `PFN_vkGetRayTracingShaderGroupHandlesKHR` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingShaderGroupHandlesKHR.html>
type PFN_vkGetRayTracingShaderGroupHandlesKHR = extern "system" fn(device: VkDevice, pipeline: VkPipeline, firstGroup: u32, groupCount: u32, dataSize: usize, pData: *mut c_void) -> VkResult;
/// function prototype `PFN_vkGetRayTracingShaderGroupHandlesNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingShaderGroupHandlesNV.html>
type PFN_vkGetRayTracingShaderGroupHandlesNV = extern "system" fn(device: VkDevice, pipeline: VkPipeline, firstGroup: u32, groupCount: u32, dataSize: usize, pData: *mut c_void) -> VkResult;
/// function prototype `PFN_vkGetAccelerationStructureHandleNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureHandleNV.html>
type PFN_vkGetAccelerationStructureHandleNV = extern "system" fn(device: VkDevice, accelerationStructure: VkAccelerationStructureNV, dataSize: usize, pData: *mut c_void) -> VkResult;
/// function prototype `PFN_vkCmdWriteAccelerationStructuresPropertiesNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteAccelerationStructuresPropertiesNV.html>
type PFN_vkCmdWriteAccelerationStructuresPropertiesNV = extern "system" fn(commandBuffer: VkCommandBuffer, accelerationStructureCount: u32, pAccelerationStructures: *const VkAccelerationStructureNV, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: u32);
/// function prototype `PFN_vkCompileDeferredNV` from VK_NV_ray_tracing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCompileDeferredNV.html>
type PFN_vkCompileDeferredNV = extern "system" fn(device: VkDevice, pipeline: VkPipeline, shader: u32) -> VkResult;
/// The dummy function for `vkCreateAccelerationStructureNV` from `VK_NV_ray_tracing`
extern "system" fn dummy_vkCreateAccelerationStructureNV(_: VkDevice, _: *const VkAccelerationStructureCreateInfoNV, _: *const VkAllocationCallbacks, _: *mut VkAccelerationStructureNV) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateAccelerationStructureNV"))
}
/// trait for `VK_NV_ray_tracing`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_ray_tracing.html>
pub trait VK_NV_ray_tracing: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAccelerationStructureNV.html>
	fn vkCreateAccelerationStructureNV(&self, device: VkDevice, pCreateInfo: *const VkAccelerationStructureCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pAccelerationStructure: *mut VkAccelerationStructureNV) -> Result<()>;
}
/// struct for `VK_NV_ray_tracing`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_ray_tracing {
	vk_create_acceleration_structure_nv: PFN_vkCreateAccelerationStructureNV,
}
impl VK_NV_ray_tracing for Vulkan_NV_ray_tracing {
	fn vkCreateAccelerationStructureNV(&self, device: VkDevice, pCreateInfo: *const VkAccelerationStructureCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pAccelerationStructure: *mut VkAccelerationStructureNV) -> Result<()> {
		convert_result("vkCreateAccelerationStructureNV", catch_unwind(||((self.vk_create_acceleration_structure_nv)(device, pCreateInfo, pAllocator, pAccelerationStructure))))
	}
}
impl Default for Vulkan_NV_ray_tracing {
	fn default() -> Self {
		Self {
			vk_create_acceleration_structure_nv: dummy_vkCreateAccelerationStructureNV,
		}
	}
}
impl Vulkan_NV_ray_tracing {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_acceleration_structure_nv: {let proc = get_instance_proc_address(instance, "vkCreateAccelerationStructureNV"); if proc == null() {dummy_vkCreateAccelerationStructureNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV` from VK_NV_representative_fragment_test
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub representativeFragmentTest: VkBool32,
}
impl Debug for VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("representativeFragmentTest", &self.representativeFragmentTest)
		.finish()
	}
}
/// struct `VkPipelineRepresentativeFragmentTestStateCreateInfoNV` from VK_NV_representative_fragment_test
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRepresentativeFragmentTestStateCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub representativeFragmentTestEnable: VkBool32,
}
impl Debug for VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineRepresentativeFragmentTestStateCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("representativeFragmentTestEnable", &self.representativeFragmentTestEnable)
		.finish()
	}
}
/// trait for `VK_NV_representative_fragment_test`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_representative_fragment_test.html>
pub trait VK_NV_representative_fragment_test: Debug {}
/// struct for `VK_NV_representative_fragment_test`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_representative_fragment_test {}
impl VK_NV_representative_fragment_test for Vulkan_NV_representative_fragment_test {}
impl Default for Vulkan_NV_representative_fragment_test {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_representative_fragment_test {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceImageViewImageFormatInfoEXT` from VK_EXT_filter_cubic
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImageViewImageFormatInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceImageViewImageFormatInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageViewType: VkImageViewType,
}
impl Debug for VkPhysicalDeviceImageViewImageFormatInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceImageViewImageFormatInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("imageViewType", &self.imageViewType)
		.finish()
	}
}
/// struct `VkFilterCubicImageViewImageFormatPropertiesEXT` from VK_EXT_filter_cubic
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFilterCubicImageViewImageFormatPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkFilterCubicImageViewImageFormatPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub filterCubic: VkBool32,
	pub filterCubicMinmax: VkBool32,
}
impl Debug for VkFilterCubicImageViewImageFormatPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkFilterCubicImageViewImageFormatPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("filterCubic", &self.filterCubic)
		.field("filterCubicMinmax", &self.filterCubicMinmax)
		.finish()
	}
}
/// trait for `VK_EXT_filter_cubic`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_filter_cubic.html>
pub trait VK_EXT_filter_cubic: Debug {}
/// struct for `VK_EXT_filter_cubic`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_filter_cubic {}
impl VK_EXT_filter_cubic for Vulkan_EXT_filter_cubic {}
impl Default for Vulkan_EXT_filter_cubic {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_filter_cubic {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_QCOM_render_pass_shader_resolve`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QCOM_render_pass_shader_resolve.html>
pub trait VK_QCOM_render_pass_shader_resolve: Debug {}
/// struct for `VK_QCOM_render_pass_shader_resolve`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_render_pass_shader_resolve {}
impl VK_QCOM_render_pass_shader_resolve for Vulkan_QCOM_render_pass_shader_resolve {}
impl Default for Vulkan_QCOM_render_pass_shader_resolve {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_render_pass_shader_resolve {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkQueueGlobalPriorityEXT` from VK_EXT_global_priority
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueGlobalPriorityEXT.html>
pub type VkQueueGlobalPriorityEXT = VkQueueGlobalPriority;
/// type definition `VkDeviceQueueGlobalPriorityCreateInfoEXT` from VK_EXT_global_priority
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceQueueGlobalPriorityCreateInfoEXT.html>
pub type VkDeviceQueueGlobalPriorityCreateInfoEXT = VkDeviceQueueGlobalPriorityCreateInfo;
/// trait for `VK_EXT_global_priority`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_global_priority.html>
pub trait VK_EXT_global_priority: Debug {}
/// struct for `VK_EXT_global_priority`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_global_priority {}
impl VK_EXT_global_priority for Vulkan_EXT_global_priority {}
impl Default for Vulkan_EXT_global_priority {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_global_priority {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkImportMemoryHostPointerInfoEXT` from VK_EXT_external_memory_host
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImportMemoryHostPointerInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImportMemoryHostPointerInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleType: VkExternalMemoryHandleTypeFlagBits,
	pub pHostPointer: *mut c_void,
}
impl Debug for VkImportMemoryHostPointerInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImportMemoryHostPointerInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("handleType", &self.handleType)
		.field("pHostPointer", &self.pHostPointer)
		.finish()
	}
}
/// struct `VkMemoryHostPointerPropertiesEXT` from VK_EXT_external_memory_host
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryHostPointerPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryHostPointerPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryTypeBits: u32,
}
impl Debug for VkMemoryHostPointerPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryHostPointerPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("memoryTypeBits", &self.memoryTypeBits)
		.finish()
	}
}
/// struct `VkPhysicalDeviceExternalMemoryHostPropertiesEXT` from VK_EXT_external_memory_host
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExternalMemoryHostPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minImportedHostPointerAlignment: VkDeviceSize,
}
impl Debug for VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceExternalMemoryHostPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("minImportedHostPointerAlignment", &self.minImportedHostPointerAlignment)
		.finish()
	}
}
/// function prototype `PFN_vkGetMemoryHostPointerPropertiesEXT` from VK_EXT_external_memory_host
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryHostPointerPropertiesEXT.html>
type PFN_vkGetMemoryHostPointerPropertiesEXT = extern "system" fn(device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHostPointer: *const c_void, pMemoryHostPointerProperties: *mut VkMemoryHostPointerPropertiesEXT) -> VkResult;
/// The dummy function for `vkGetMemoryHostPointerPropertiesEXT` from `VK_EXT_external_memory_host`
extern "system" fn dummy_vkGetMemoryHostPointerPropertiesEXT(_: VkDevice, _: VkExternalMemoryHandleTypeFlagBits, _: *const c_void, _: *mut VkMemoryHostPointerPropertiesEXT) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetMemoryHostPointerPropertiesEXT"))
}
/// trait for `VK_EXT_external_memory_host`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_external_memory_host.html>
pub trait VK_EXT_external_memory_host: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryHostPointerPropertiesEXT.html>
	fn vkGetMemoryHostPointerPropertiesEXT(&self, device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHostPointer: *const c_void, pMemoryHostPointerProperties: *mut VkMemoryHostPointerPropertiesEXT) -> Result<()>;
}
/// struct for `VK_EXT_external_memory_host`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_external_memory_host {
	vk_get_memory_host_pointer_properties_ext: PFN_vkGetMemoryHostPointerPropertiesEXT,
}
impl VK_EXT_external_memory_host for Vulkan_EXT_external_memory_host {
	fn vkGetMemoryHostPointerPropertiesEXT(&self, device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHostPointer: *const c_void, pMemoryHostPointerProperties: *mut VkMemoryHostPointerPropertiesEXT) -> Result<()> {
		convert_result("vkGetMemoryHostPointerPropertiesEXT", catch_unwind(||((self.vk_get_memory_host_pointer_properties_ext)(device, handleType, pHostPointer, pMemoryHostPointerProperties))))
	}
}
impl Default for Vulkan_EXT_external_memory_host {
	fn default() -> Self {
		Self {
			vk_get_memory_host_pointer_properties_ext: dummy_vkGetMemoryHostPointerPropertiesEXT,
		}
	}
}
impl Vulkan_EXT_external_memory_host {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_memory_host_pointer_properties_ext: {let proc = get_instance_proc_address(instance, "vkGetMemoryHostPointerPropertiesEXT"); if proc == null() {dummy_vkGetMemoryHostPointerPropertiesEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// function prototype `PFN_vkCmdWriteBufferMarkerAMD` from VK_AMD_buffer_marker
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteBufferMarkerAMD.html>
type PFN_vkCmdWriteBufferMarkerAMD = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32);
/// function prototype `PFN_vkCmdWriteBufferMarker2AMD` from VK_AMD_buffer_marker
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteBufferMarker2AMD.html>
type PFN_vkCmdWriteBufferMarker2AMD = extern "system" fn(commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32);
/// The dummy function for `vkCmdWriteBufferMarkerAMD` from `VK_AMD_buffer_marker`
extern "system" fn dummy_vkCmdWriteBufferMarkerAMD(_: VkCommandBuffer, _: VkPipelineStageFlagBits, _: VkBuffer, _: VkDeviceSize, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdWriteBufferMarkerAMD"))
}
/// trait for `VK_AMD_buffer_marker`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_buffer_marker.html>
pub trait VK_AMD_buffer_marker: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteBufferMarkerAMD.html>
	fn vkCmdWriteBufferMarkerAMD(&self, commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32) -> Result<()>;
}
/// struct for `VK_AMD_buffer_marker`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_buffer_marker {
	vk_cmd_write_buffer_marker_amd: PFN_vkCmdWriteBufferMarkerAMD,
}
impl VK_AMD_buffer_marker for Vulkan_AMD_buffer_marker {
	fn vkCmdWriteBufferMarkerAMD(&self, commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_write_buffer_marker_amd)(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker))))
	}
}
impl Default for Vulkan_AMD_buffer_marker {
	fn default() -> Self {
		Self {
			vk_cmd_write_buffer_marker_amd: dummy_vkCmdWriteBufferMarkerAMD,
		}
	}
}
impl Vulkan_AMD_buffer_marker {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_write_buffer_marker_amd: {let proc = get_instance_proc_address(instance, "vkCmdWriteBufferMarkerAMD"); if proc == null() {dummy_vkCmdWriteBufferMarkerAMD} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPipelineCompilerControlFlagsAMD` from VK_AMD_pipeline_compiler_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCompilerControlFlagsAMD.html>
pub type VkPipelineCompilerControlFlagsAMD = VkFlags;
/// enum `VkPipelineCompilerControlFlagBitsAMD` from VK_AMD_pipeline_compiler_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCompilerControlFlagBitsAMD.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPipelineCompilerControlFlagBitsAMD {
	VK_PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD = 0x7fffffff,
}
/// struct `VkPipelineCompilerControlCreateInfoAMD` from VK_AMD_pipeline_compiler_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCompilerControlCreateInfoAMD.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineCompilerControlCreateInfoAMD {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub compilerControlFlags: VkPipelineCompilerControlFlagsAMD,
}
impl Debug for VkPipelineCompilerControlCreateInfoAMD {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineCompilerControlCreateInfoAMD")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("compilerControlFlags", &self.compilerControlFlags)
		.finish()
	}
}
/// trait for `VK_AMD_pipeline_compiler_control`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_pipeline_compiler_control.html>
pub trait VK_AMD_pipeline_compiler_control: Debug {}
/// struct for `VK_AMD_pipeline_compiler_control`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_pipeline_compiler_control {}
impl VK_AMD_pipeline_compiler_control for Vulkan_AMD_pipeline_compiler_control {}
impl Default for Vulkan_AMD_pipeline_compiler_control {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_pipeline_compiler_control {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkTimeDomainEXT` from VK_EXT_calibrated_timestamps
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTimeDomainEXT.html>
pub type VkTimeDomainEXT = VkTimeDomainKHR;
/// type definition `VkCalibratedTimestampInfoEXT` from VK_EXT_calibrated_timestamps
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCalibratedTimestampInfoEXT.html>
pub type VkCalibratedTimestampInfoEXT = VkCalibratedTimestampInfoKHR;
/// function prototype `PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT` from VK_EXT_calibrated_timestamps
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.html>
type PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = extern "system" fn(physicalDevice: VkPhysicalDevice, pTimeDomainCount: *mut uint32_t, pTimeDomains: *mut VkTimeDomainKHR) -> VkResult;
/// function prototype `PFN_vkGetCalibratedTimestampsEXT` from VK_EXT_calibrated_timestamps
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetCalibratedTimestampsEXT.html>
type PFN_vkGetCalibratedTimestampsEXT = extern "system" fn(device: VkDevice, timestampCount: u32, pTimestampInfos: *const VkCalibratedTimestampInfoKHR, pTimestamps: *mut uint64_t, pMaxDeviation: *mut uint64_t) -> VkResult;
/// The dummy function for `vkGetPhysicalDeviceCalibrateableTimeDomainsEXT` from `VK_EXT_calibrated_timestamps`
extern "system" fn dummy_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkTimeDomainKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT"))
}
/// trait for `VK_EXT_calibrated_timestamps`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_calibrated_timestamps.html>
pub trait VK_EXT_calibrated_timestamps: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.html>
	fn vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(&self, physicalDevice: VkPhysicalDevice, pTimeDomainCount: *mut uint32_t, pTimeDomains: *mut VkTimeDomainKHR) -> Result<()>;
}
/// struct for `VK_EXT_calibrated_timestamps`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_calibrated_timestamps {
	vk_get_physical_device_calibrateable_time_domains_ext: PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT,
}
impl VK_EXT_calibrated_timestamps for Vulkan_EXT_calibrated_timestamps {
	fn vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(&self, physicalDevice: VkPhysicalDevice, pTimeDomainCount: *mut uint32_t, pTimeDomains: *mut VkTimeDomainKHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT", catch_unwind(||((self.vk_get_physical_device_calibrateable_time_domains_ext)(physicalDevice, pTimeDomainCount, pTimeDomains))))
	}
}
impl Default for Vulkan_EXT_calibrated_timestamps {
	fn default() -> Self {
		Self {
			vk_get_physical_device_calibrateable_time_domains_ext: dummy_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT,
		}
	}
}
impl Vulkan_EXT_calibrated_timestamps {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_calibrateable_time_domains_ext: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT"); if proc == null() {dummy_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceShaderCorePropertiesAMD` from VK_AMD_shader_core_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderCorePropertiesAMD.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderCorePropertiesAMD {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderEngineCount: u32,
	pub shaderArraysPerEngineCount: u32,
	pub computeUnitsPerShaderArray: u32,
	pub simdPerComputeUnit: u32,
	pub wavefrontsPerSimd: u32,
	pub wavefrontSize: u32,
	pub sgprsPerSimd: u32,
	pub minSgprAllocation: u32,
	pub maxSgprAllocation: u32,
	pub sgprAllocationGranularity: u32,
	pub vgprsPerSimd: u32,
	pub minVgprAllocation: u32,
	pub maxVgprAllocation: u32,
	pub vgprAllocationGranularity: u32,
}
impl Debug for VkPhysicalDeviceShaderCorePropertiesAMD {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderCorePropertiesAMD")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderEngineCount", &self.shaderEngineCount)
		.field("shaderArraysPerEngineCount", &self.shaderArraysPerEngineCount)
		.field("computeUnitsPerShaderArray", &self.computeUnitsPerShaderArray)
		.field("simdPerComputeUnit", &self.simdPerComputeUnit)
		.field("wavefrontsPerSimd", &self.wavefrontsPerSimd)
		.field("wavefrontSize", &self.wavefrontSize)
		.field("sgprsPerSimd", &self.sgprsPerSimd)
		.field("minSgprAllocation", &self.minSgprAllocation)
		.field("maxSgprAllocation", &self.maxSgprAllocation)
		.field("sgprAllocationGranularity", &self.sgprAllocationGranularity)
		.field("vgprsPerSimd", &self.vgprsPerSimd)
		.field("minVgprAllocation", &self.minVgprAllocation)
		.field("maxVgprAllocation", &self.maxVgprAllocation)
		.field("vgprAllocationGranularity", &self.vgprAllocationGranularity)
		.finish()
	}
}
/// trait for `VK_AMD_shader_core_properties`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_shader_core_properties.html>
pub trait VK_AMD_shader_core_properties: Debug {}
/// struct for `VK_AMD_shader_core_properties`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_core_properties {}
impl VK_AMD_shader_core_properties for Vulkan_AMD_shader_core_properties {}
impl Default for Vulkan_AMD_shader_core_properties {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_shader_core_properties {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkMemoryOverallocationBehaviorAMD` from VK_AMD_memory_overallocation_behavior
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryOverallocationBehaviorAMD.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkMemoryOverallocationBehaviorAMD {
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0,
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1,
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2,
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD = 0x7fffffff,
}
/// struct `VkDeviceMemoryOverallocationCreateInfoAMD` from VK_AMD_memory_overallocation_behavior
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceMemoryOverallocationCreateInfoAMD.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceMemoryOverallocationCreateInfoAMD {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub overallocationBehavior: VkMemoryOverallocationBehaviorAMD,
}
impl Debug for VkDeviceMemoryOverallocationCreateInfoAMD {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceMemoryOverallocationCreateInfoAMD")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("overallocationBehavior", &self.overallocationBehavior)
		.finish()
	}
}
/// trait for `VK_AMD_memory_overallocation_behavior`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_memory_overallocation_behavior.html>
pub trait VK_AMD_memory_overallocation_behavior: Debug {}
/// struct for `VK_AMD_memory_overallocation_behavior`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_memory_overallocation_behavior {}
impl VK_AMD_memory_overallocation_behavior for Vulkan_AMD_memory_overallocation_behavior {}
impl Default for Vulkan_AMD_memory_overallocation_behavior {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_memory_overallocation_behavior {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkVertexInputBindingDivisorDescriptionEXT` from VK_EXT_vertex_attribute_divisor
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVertexInputBindingDivisorDescriptionEXT.html>
pub type VkVertexInputBindingDivisorDescriptionEXT = VkVertexInputBindingDivisorDescription;
/// type definition `VkPipelineVertexInputDivisorStateCreateInfoEXT` from VK_EXT_vertex_attribute_divisor
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineVertexInputDivisorStateCreateInfoEXT.html>
pub type VkPipelineVertexInputDivisorStateCreateInfoEXT = VkPipelineVertexInputDivisorStateCreateInfo;
/// type definition `VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT` from VK_EXT_vertex_attribute_divisor
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.html>
pub type VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT = VkPhysicalDeviceVertexAttributeDivisorFeatures;
/// struct `VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT` from VK_EXT_vertex_attribute_divisor
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxVertexAttribDivisor: u32,
}
impl Debug for VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxVertexAttribDivisor", &self.maxVertexAttribDivisor)
		.finish()
	}
}
/// trait for `VK_EXT_vertex_attribute_divisor`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_vertex_attribute_divisor.html>
pub trait VK_EXT_vertex_attribute_divisor: Debug {}
/// struct for `VK_EXT_vertex_attribute_divisor`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_vertex_attribute_divisor {}
impl VK_EXT_vertex_attribute_divisor for Vulkan_EXT_vertex_attribute_divisor {}
impl Default for Vulkan_EXT_vertex_attribute_divisor {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_vertex_attribute_divisor {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPipelineCreationFeedbackFlagBitsEXT` from VK_EXT_pipeline_creation_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreationFeedbackFlagBitsEXT.html>
pub type VkPipelineCreationFeedbackFlagBitsEXT = VkPipelineCreationFeedbackFlagBits;
/// type definition `VkPipelineCreationFeedbackFlagsEXT` from VK_EXT_pipeline_creation_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreationFeedbackFlagsEXT.html>
pub type VkPipelineCreationFeedbackFlagsEXT = VkPipelineCreationFeedbackFlags;
/// type definition `VkPipelineCreationFeedbackCreateInfoEXT` from VK_EXT_pipeline_creation_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreationFeedbackCreateInfoEXT.html>
pub type VkPipelineCreationFeedbackCreateInfoEXT = VkPipelineCreationFeedbackCreateInfo;
/// type definition `VkPipelineCreationFeedbackEXT` from VK_EXT_pipeline_creation_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCreationFeedbackEXT.html>
pub type VkPipelineCreationFeedbackEXT = VkPipelineCreationFeedback;
/// trait for `VK_EXT_pipeline_creation_feedback`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_pipeline_creation_feedback.html>
pub trait VK_EXT_pipeline_creation_feedback: Debug {}
/// struct for `VK_EXT_pipeline_creation_feedback`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_pipeline_creation_feedback {}
impl VK_EXT_pipeline_creation_feedback for Vulkan_EXT_pipeline_creation_feedback {}
impl Default for Vulkan_EXT_pipeline_creation_feedback {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_pipeline_creation_feedback {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_NV_shader_subgroup_partitioned`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_shader_subgroup_partitioned.html>
pub trait VK_NV_shader_subgroup_partitioned: Debug {}
/// struct for `VK_NV_shader_subgroup_partitioned`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_shader_subgroup_partitioned {}
impl VK_NV_shader_subgroup_partitioned for Vulkan_NV_shader_subgroup_partitioned {}
impl Default for Vulkan_NV_shader_subgroup_partitioned {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_shader_subgroup_partitioned {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceComputeShaderDerivativesFeaturesNV` from VK_NV_compute_shader_derivatives
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.html>
pub type VkPhysicalDeviceComputeShaderDerivativesFeaturesNV = VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR;
/// trait for `VK_NV_compute_shader_derivatives`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_compute_shader_derivatives.html>
pub trait VK_NV_compute_shader_derivatives: Debug {}
/// struct for `VK_NV_compute_shader_derivatives`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_compute_shader_derivatives {}
impl VK_NV_compute_shader_derivatives for Vulkan_NV_compute_shader_derivatives {}
impl Default for Vulkan_NV_compute_shader_derivatives {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_compute_shader_derivatives {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceMeshShaderFeaturesNV` from VK_NV_mesh_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMeshShaderFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMeshShaderFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub taskShader: VkBool32,
	pub meshShader: VkBool32,
}
impl Debug for VkPhysicalDeviceMeshShaderFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMeshShaderFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("taskShader", &self.taskShader)
		.field("meshShader", &self.meshShader)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMeshShaderPropertiesNV` from VK_NV_mesh_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMeshShaderPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMeshShaderPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxDrawMeshTasksCount: u32,
	pub maxTaskWorkGroupInvocations: u32,
	pub maxTaskWorkGroupSize: [u32; 3 as usize],
	pub maxTaskTotalMemorySize: u32,
	pub maxTaskOutputCount: u32,
	pub maxMeshWorkGroupInvocations: u32,
	pub maxMeshWorkGroupSize: [u32; 3 as usize],
	pub maxMeshTotalMemorySize: u32,
	pub maxMeshOutputVertices: u32,
	pub maxMeshOutputPrimitives: u32,
	pub maxMeshMultiviewViewCount: u32,
	pub meshOutputPerVertexGranularity: u32,
	pub meshOutputPerPrimitiveGranularity: u32,
}
impl Debug for VkPhysicalDeviceMeshShaderPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMeshShaderPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxDrawMeshTasksCount", &self.maxDrawMeshTasksCount)
		.field("maxTaskWorkGroupInvocations", &self.maxTaskWorkGroupInvocations)
		.field("maxTaskWorkGroupSize", &self.maxTaskWorkGroupSize)
		.field("maxTaskTotalMemorySize", &self.maxTaskTotalMemorySize)
		.field("maxTaskOutputCount", &self.maxTaskOutputCount)
		.field("maxMeshWorkGroupInvocations", &self.maxMeshWorkGroupInvocations)
		.field("maxMeshWorkGroupSize", &self.maxMeshWorkGroupSize)
		.field("maxMeshTotalMemorySize", &self.maxMeshTotalMemorySize)
		.field("maxMeshOutputVertices", &self.maxMeshOutputVertices)
		.field("maxMeshOutputPrimitives", &self.maxMeshOutputPrimitives)
		.field("maxMeshMultiviewViewCount", &self.maxMeshMultiviewViewCount)
		.field("meshOutputPerVertexGranularity", &self.meshOutputPerVertexGranularity)
		.field("meshOutputPerPrimitiveGranularity", &self.meshOutputPerPrimitiveGranularity)
		.finish()
	}
}
/// struct `VkDrawMeshTasksIndirectCommandNV` from VK_NV_mesh_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDrawMeshTasksIndirectCommandNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDrawMeshTasksIndirectCommandNV {
	pub taskCount: u32,
	pub firstTask: u32,
}
impl Debug for VkDrawMeshTasksIndirectCommandNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDrawMeshTasksIndirectCommandNV")
		.field("taskCount", &self.taskCount)
		.field("firstTask", &self.firstTask)
		.finish()
	}
}
/// function prototype `PFN_vkCmdDrawMeshTasksNV` from VK_NV_mesh_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMeshTasksNV.html>
type PFN_vkCmdDrawMeshTasksNV = extern "system" fn(commandBuffer: VkCommandBuffer, taskCount: u32, firstTask: u32);
/// function prototype `PFN_vkCmdDrawMeshTasksIndirectNV` from VK_NV_mesh_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMeshTasksIndirectNV.html>
type PFN_vkCmdDrawMeshTasksIndirectNV = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32);
/// function prototype `PFN_vkCmdDrawMeshTasksIndirectCountNV` from VK_NV_mesh_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMeshTasksIndirectCountNV.html>
type PFN_vkCmdDrawMeshTasksIndirectCountNV = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
/// The dummy function for `vkCmdDrawMeshTasksNV` from `VK_NV_mesh_shader`
extern "system" fn dummy_vkCmdDrawMeshTasksNV(_: VkCommandBuffer, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdDrawMeshTasksNV"))
}
/// trait for `VK_NV_mesh_shader`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_mesh_shader.html>
pub trait VK_NV_mesh_shader: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMeshTasksNV.html>
	fn vkCmdDrawMeshTasksNV(&self, commandBuffer: VkCommandBuffer, taskCount: u32, firstTask: u32) -> Result<()>;
}
/// struct for `VK_NV_mesh_shader`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_mesh_shader {
	vk_cmd_draw_mesh_tasks_nv: PFN_vkCmdDrawMeshTasksNV,
}
impl VK_NV_mesh_shader for Vulkan_NV_mesh_shader {
	fn vkCmdDrawMeshTasksNV(&self, commandBuffer: VkCommandBuffer, taskCount: u32, firstTask: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_draw_mesh_tasks_nv)(commandBuffer, taskCount, firstTask))))
	}
}
impl Default for Vulkan_NV_mesh_shader {
	fn default() -> Self {
		Self {
			vk_cmd_draw_mesh_tasks_nv: dummy_vkCmdDrawMeshTasksNV,
		}
	}
}
impl Vulkan_NV_mesh_shader {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_draw_mesh_tasks_nv: {let proc = get_instance_proc_address(instance, "vkCmdDrawMeshTasksNV"); if proc == null() {dummy_vkCmdDrawMeshTasksNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV` from VK_NV_fragment_shader_barycentric
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.html>
pub type VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV = VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
/// trait for `VK_NV_fragment_shader_barycentric`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_fragment_shader_barycentric.html>
pub trait VK_NV_fragment_shader_barycentric: Debug {}
/// struct for `VK_NV_fragment_shader_barycentric`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_fragment_shader_barycentric {}
impl VK_NV_fragment_shader_barycentric for Vulkan_NV_fragment_shader_barycentric {}
impl Default for Vulkan_NV_fragment_shader_barycentric {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_fragment_shader_barycentric {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceShaderImageFootprintFeaturesNV` from VK_NV_shader_image_footprint
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderImageFootprintFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderImageFootprintFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageFootprint: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderImageFootprintFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderImageFootprintFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("imageFootprint", &self.imageFootprint)
		.finish()
	}
}
/// trait for `VK_NV_shader_image_footprint`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_shader_image_footprint.html>
pub trait VK_NV_shader_image_footprint: Debug {}
/// struct for `VK_NV_shader_image_footprint`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_shader_image_footprint {}
impl VK_NV_shader_image_footprint for Vulkan_NV_shader_image_footprint {}
impl Default for Vulkan_NV_shader_image_footprint {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_shader_image_footprint {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPipelineViewportExclusiveScissorStateCreateInfoNV` from VK_NV_scissor_exclusive
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineViewportExclusiveScissorStateCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineViewportExclusiveScissorStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub exclusiveScissorCount: u32,
	pub pExclusiveScissors: *const VkRect2D,
}
impl Debug for VkPipelineViewportExclusiveScissorStateCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineViewportExclusiveScissorStateCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("exclusiveScissorCount", &self.exclusiveScissorCount)
		.field("pExclusiveScissors", &self.pExclusiveScissors)
		.finish()
	}
}
/// struct `VkPhysicalDeviceExclusiveScissorFeaturesNV` from VK_NV_scissor_exclusive
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExclusiveScissorFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceExclusiveScissorFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub exclusiveScissor: VkBool32,
}
impl Debug for VkPhysicalDeviceExclusiveScissorFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceExclusiveScissorFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("exclusiveScissor", &self.exclusiveScissor)
		.finish()
	}
}
/// function prototype `PFN_vkCmdSetExclusiveScissorEnableNV` from VK_NV_scissor_exclusive
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetExclusiveScissorEnableNV.html>
type PFN_vkCmdSetExclusiveScissorEnableNV = extern "system" fn(commandBuffer: VkCommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissorEnables: *const VkBool32);
/// function prototype `PFN_vkCmdSetExclusiveScissorNV` from VK_NV_scissor_exclusive
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetExclusiveScissorNV.html>
type PFN_vkCmdSetExclusiveScissorNV = extern "system" fn(commandBuffer: VkCommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissors: *const VkRect2D);
/// The dummy function for `vkCmdSetExclusiveScissorEnableNV` from `VK_NV_scissor_exclusive`
extern "system" fn dummy_vkCmdSetExclusiveScissorEnableNV(_: VkCommandBuffer, _: u32, _: u32, _: *const VkBool32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetExclusiveScissorEnableNV"))
}
/// trait for `VK_NV_scissor_exclusive`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_scissor_exclusive.html>
pub trait VK_NV_scissor_exclusive: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetExclusiveScissorEnableNV.html>
	fn vkCmdSetExclusiveScissorEnableNV(&self, commandBuffer: VkCommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissorEnables: *const VkBool32) -> Result<()>;
}
/// struct for `VK_NV_scissor_exclusive`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_scissor_exclusive {
	vk_cmd_set_exclusive_scissor_enable_nv: PFN_vkCmdSetExclusiveScissorEnableNV,
}
impl VK_NV_scissor_exclusive for Vulkan_NV_scissor_exclusive {
	fn vkCmdSetExclusiveScissorEnableNV(&self, commandBuffer: VkCommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissorEnables: *const VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_exclusive_scissor_enable_nv)(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables))))
	}
}
impl Default for Vulkan_NV_scissor_exclusive {
	fn default() -> Self {
		Self {
			vk_cmd_set_exclusive_scissor_enable_nv: dummy_vkCmdSetExclusiveScissorEnableNV,
		}
	}
}
impl Vulkan_NV_scissor_exclusive {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_exclusive_scissor_enable_nv: {let proc = get_instance_proc_address(instance, "vkCmdSetExclusiveScissorEnableNV"); if proc == null() {dummy_vkCmdSetExclusiveScissorEnableNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkQueueFamilyCheckpointPropertiesNV` from VK_NV_device_diagnostic_checkpoints
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueFamilyCheckpointPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkQueueFamilyCheckpointPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub checkpointExecutionStageMask: VkPipelineStageFlags,
}
impl Debug for VkQueueFamilyCheckpointPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkQueueFamilyCheckpointPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("checkpointExecutionStageMask", &self.checkpointExecutionStageMask)
		.finish()
	}
}
/// struct `VkCheckpointDataNV` from VK_NV_device_diagnostic_checkpoints
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCheckpointDataNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCheckpointDataNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub stage: VkPipelineStageFlagBits,
	pub pCheckpointMarker: *mut c_void,
}
impl Debug for VkCheckpointDataNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCheckpointDataNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stage", &self.stage)
		.field("pCheckpointMarker", &self.pCheckpointMarker)
		.finish()
	}
}
/// struct `VkQueueFamilyCheckpointProperties2NV` from VK_NV_device_diagnostic_checkpoints
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueFamilyCheckpointProperties2NV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkQueueFamilyCheckpointProperties2NV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub checkpointExecutionStageMask: VkPipelineStageFlags2,
}
impl Debug for VkQueueFamilyCheckpointProperties2NV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkQueueFamilyCheckpointProperties2NV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("checkpointExecutionStageMask", &self.checkpointExecutionStageMask)
		.finish()
	}
}
/// struct `VkCheckpointData2NV` from VK_NV_device_diagnostic_checkpoints
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCheckpointData2NV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCheckpointData2NV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub stage: VkPipelineStageFlags2,
	pub pCheckpointMarker: *mut c_void,
}
impl Debug for VkCheckpointData2NV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCheckpointData2NV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stage", &self.stage)
		.field("pCheckpointMarker", &self.pCheckpointMarker)
		.finish()
	}
}
/// function prototype `PFN_vkCmdSetCheckpointNV` from VK_NV_device_diagnostic_checkpoints
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCheckpointNV.html>
type PFN_vkCmdSetCheckpointNV = extern "system" fn(commandBuffer: VkCommandBuffer, pCheckpointMarker: *const c_void);
/// function prototype `PFN_vkGetQueueCheckpointDataNV` from VK_NV_device_diagnostic_checkpoints
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetQueueCheckpointDataNV.html>
type PFN_vkGetQueueCheckpointDataNV = extern "system" fn(queue: VkQueue, pCheckpointDataCount: *mut uint32_t, pCheckpointData: *mut VkCheckpointDataNV);
/// function prototype `PFN_vkGetQueueCheckpointData2NV` from VK_NV_device_diagnostic_checkpoints
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetQueueCheckpointData2NV.html>
type PFN_vkGetQueueCheckpointData2NV = extern "system" fn(queue: VkQueue, pCheckpointDataCount: *mut uint32_t, pCheckpointData: *mut VkCheckpointData2NV);
/// The dummy function for `vkCmdSetCheckpointNV` from `VK_NV_device_diagnostic_checkpoints`
extern "system" fn dummy_vkCmdSetCheckpointNV(_: VkCommandBuffer, _: *const c_void) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetCheckpointNV"))
}
/// trait for `VK_NV_device_diagnostic_checkpoints`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_device_diagnostic_checkpoints.html>
pub trait VK_NV_device_diagnostic_checkpoints: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCheckpointNV.html>
	fn vkCmdSetCheckpointNV(&self, commandBuffer: VkCommandBuffer, pCheckpointMarker: *const c_void) -> Result<()>;
}
/// struct for `VK_NV_device_diagnostic_checkpoints`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_device_diagnostic_checkpoints {
	vk_cmd_set_checkpoint_nv: PFN_vkCmdSetCheckpointNV,
}
impl VK_NV_device_diagnostic_checkpoints for Vulkan_NV_device_diagnostic_checkpoints {
	fn vkCmdSetCheckpointNV(&self, commandBuffer: VkCommandBuffer, pCheckpointMarker: *const c_void) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_checkpoint_nv)(commandBuffer, pCheckpointMarker))))
	}
}
impl Default for Vulkan_NV_device_diagnostic_checkpoints {
	fn default() -> Self {
		Self {
			vk_cmd_set_checkpoint_nv: dummy_vkCmdSetCheckpointNV,
		}
	}
}
impl Vulkan_NV_device_diagnostic_checkpoints {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_checkpoint_nv: {let proc = get_instance_proc_address(instance, "vkCmdSetCheckpointNV"); if proc == null() {dummy_vkCmdSetCheckpointNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL` from VK_INTEL_shader_integer_functions2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderIntegerFunctions2: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderIntegerFunctions2", &self.shaderIntegerFunctions2)
		.finish()
	}
}
/// trait for `VK_INTEL_shader_integer_functions2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_INTEL_shader_integer_functions2.html>
pub trait VK_INTEL_shader_integer_functions2: Debug {}
/// struct for `VK_INTEL_shader_integer_functions2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_INTEL_shader_integer_functions2 {}
impl VK_INTEL_shader_integer_functions2 for Vulkan_INTEL_shader_integer_functions2 {}
impl Default for Vulkan_INTEL_shader_integer_functions2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_INTEL_shader_integer_functions2 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkQueryPoolCreateInfoINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryPoolCreateInfoINTEL.html>
pub type VkQueryPoolCreateInfoINTEL = VkQueryPoolPerformanceQueryCreateInfoINTEL;
/// Non-dispatchable handle `VkPerformanceConfigurationINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceConfigurationINTEL.html
#[cfg(target_pointer_width = "32")] pub type VkPerformanceConfigurationINTEL = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkPerformanceConfigurationINTEL_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkPerformanceConfigurationINTEL = *const VkPerformanceConfigurationINTEL_T;
/// enum `VkPerformanceConfigurationTypeINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceConfigurationTypeINTEL.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPerformanceConfigurationTypeINTEL {
	VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0,
	VK_PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL = 0x7fffffff,
}
/// enum `VkQueryPoolSamplingModeINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryPoolSamplingModeINTEL.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkQueryPoolSamplingModeINTEL {
	VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0,
	VK_QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL = 0x7fffffff,
}
/// enum `VkPerformanceOverrideTypeINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceOverrideTypeINTEL.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPerformanceOverrideTypeINTEL {
	VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0,
	VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 1,
	VK_PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL = 0x7fffffff,
}
/// enum `VkPerformanceParameterTypeINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceParameterTypeINTEL.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPerformanceParameterTypeINTEL {
	VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0,
	VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 1,
	VK_PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL = 0x7fffffff,
}
/// enum `VkPerformanceValueTypeINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceValueTypeINTEL.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPerformanceValueTypeINTEL {
	VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0,
	VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 1,
	VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 2,
	VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 3,
	VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL = 4,
	VK_PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL = 0x7fffffff,
}
/// union `VkPerformanceValueDataINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceValueDataINTEL.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkPerformanceValueDataINTEL {
	pub value32: u32,
	pub value64: u64,
	pub valueFloat: f32,
	pub valueBool: VkBool32,
	pub valueString: *const i8,
}
impl Debug for VkPerformanceValueDataINTEL {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceValueDataINTEL")
		.field("value32", unsafe {&self.value32})
		.field("value64", unsafe {&self.value64})
		.field("valueFloat", unsafe {&self.valueFloat})
		.field("valueBool", unsafe {&self.valueBool})
		.field("valueString", unsafe {&self.valueString})
		.finish()
	}
}
/// struct `VkPerformanceValueINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceValueINTEL.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPerformanceValueINTEL {
	pub type_: VkPerformanceValueTypeINTEL,
	pub data: VkPerformanceValueDataINTEL,
}
impl Debug for VkPerformanceValueINTEL {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceValueINTEL")
		.field("type_", &self.type_)
		.field("data", &self.data)
		.finish()
	}
}
/// struct `VkInitializePerformanceApiInfoINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkInitializePerformanceApiInfoINTEL.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkInitializePerformanceApiInfoINTEL {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pUserData: *mut c_void,
}
impl Debug for VkInitializePerformanceApiInfoINTEL {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkInitializePerformanceApiInfoINTEL")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pUserData", &self.pUserData)
		.finish()
	}
}
/// struct `VkQueryPoolPerformanceQueryCreateInfoINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryPoolPerformanceQueryCreateInfoINTEL.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkQueryPoolPerformanceQueryCreateInfoINTEL {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub performanceCountersSampling: VkQueryPoolSamplingModeINTEL,
}
impl Debug for VkQueryPoolPerformanceQueryCreateInfoINTEL {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkQueryPoolPerformanceQueryCreateInfoINTEL")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("performanceCountersSampling", &self.performanceCountersSampling)
		.finish()
	}
}
/// struct `VkPerformanceMarkerInfoINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceMarkerInfoINTEL.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPerformanceMarkerInfoINTEL {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub marker: u64,
}
impl Debug for VkPerformanceMarkerInfoINTEL {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceMarkerInfoINTEL")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("marker", &self.marker)
		.finish()
	}
}
/// struct `VkPerformanceStreamMarkerInfoINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceStreamMarkerInfoINTEL.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPerformanceStreamMarkerInfoINTEL {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub marker: u32,
}
impl Debug for VkPerformanceStreamMarkerInfoINTEL {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceStreamMarkerInfoINTEL")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("marker", &self.marker)
		.finish()
	}
}
/// struct `VkPerformanceOverrideInfoINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceOverrideInfoINTEL.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPerformanceOverrideInfoINTEL {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkPerformanceOverrideTypeINTEL,
	pub enable: VkBool32,
	pub parameter: u64,
}
impl Debug for VkPerformanceOverrideInfoINTEL {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceOverrideInfoINTEL")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("type_", &self.type_)
		.field("enable", &self.enable)
		.field("parameter", &self.parameter)
		.finish()
	}
}
/// struct `VkPerformanceConfigurationAcquireInfoINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceConfigurationAcquireInfoINTEL.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPerformanceConfigurationAcquireInfoINTEL {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkPerformanceConfigurationTypeINTEL,
}
impl Debug for VkPerformanceConfigurationAcquireInfoINTEL {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPerformanceConfigurationAcquireInfoINTEL")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("type_", &self.type_)
		.finish()
	}
}
/// function prototype `PFN_vkInitializePerformanceApiINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkInitializePerformanceApiINTEL.html>
type PFN_vkInitializePerformanceApiINTEL = extern "system" fn(device: VkDevice, pInitializeInfo: *const VkInitializePerformanceApiInfoINTEL) -> VkResult;
/// function prototype `PFN_vkUninitializePerformanceApiINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkUninitializePerformanceApiINTEL.html>
type PFN_vkUninitializePerformanceApiINTEL = extern "system" fn(device: VkDevice);
/// function prototype `PFN_vkCmdSetPerformanceMarkerINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPerformanceMarkerINTEL.html>
type PFN_vkCmdSetPerformanceMarkerINTEL = extern "system" fn(commandBuffer: VkCommandBuffer, pMarkerInfo: *const VkPerformanceMarkerInfoINTEL) -> VkResult;
/// function prototype `PFN_vkCmdSetPerformanceStreamMarkerINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPerformanceStreamMarkerINTEL.html>
type PFN_vkCmdSetPerformanceStreamMarkerINTEL = extern "system" fn(commandBuffer: VkCommandBuffer, pMarkerInfo: *const VkPerformanceStreamMarkerInfoINTEL) -> VkResult;
/// function prototype `PFN_vkCmdSetPerformanceOverrideINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPerformanceOverrideINTEL.html>
type PFN_vkCmdSetPerformanceOverrideINTEL = extern "system" fn(commandBuffer: VkCommandBuffer, pOverrideInfo: *const VkPerformanceOverrideInfoINTEL) -> VkResult;
/// function prototype `PFN_vkAcquirePerformanceConfigurationINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquirePerformanceConfigurationINTEL.html>
type PFN_vkAcquirePerformanceConfigurationINTEL = extern "system" fn(device: VkDevice, pAcquireInfo: *const VkPerformanceConfigurationAcquireInfoINTEL, pConfiguration: *mut VkPerformanceConfigurationINTEL) -> VkResult;
/// function prototype `PFN_vkReleasePerformanceConfigurationINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleasePerformanceConfigurationINTEL.html>
type PFN_vkReleasePerformanceConfigurationINTEL = extern "system" fn(device: VkDevice, configuration: VkPerformanceConfigurationINTEL) -> VkResult;
/// function prototype `PFN_vkQueueSetPerformanceConfigurationINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueSetPerformanceConfigurationINTEL.html>
type PFN_vkQueueSetPerformanceConfigurationINTEL = extern "system" fn(queue: VkQueue, configuration: VkPerformanceConfigurationINTEL) -> VkResult;
/// function prototype `PFN_vkGetPerformanceParameterINTEL` from VK_INTEL_performance_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPerformanceParameterINTEL.html>
type PFN_vkGetPerformanceParameterINTEL = extern "system" fn(device: VkDevice, parameter: VkPerformanceParameterTypeINTEL, pValue: *mut VkPerformanceValueINTEL) -> VkResult;
/// The dummy function for `vkInitializePerformanceApiINTEL` from `VK_INTEL_performance_query`
extern "system" fn dummy_vkInitializePerformanceApiINTEL(_: VkDevice, _: *const VkInitializePerformanceApiInfoINTEL) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkInitializePerformanceApiINTEL"))
}
/// trait for `VK_INTEL_performance_query`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_INTEL_performance_query.html>
pub trait VK_INTEL_performance_query: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkInitializePerformanceApiINTEL.html>
	fn vkInitializePerformanceApiINTEL(&self, device: VkDevice, pInitializeInfo: *const VkInitializePerformanceApiInfoINTEL) -> Result<()>;
}
/// struct for `VK_INTEL_performance_query`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_INTEL_performance_query {
	vk_initialize_performance_api_intel: PFN_vkInitializePerformanceApiINTEL,
}
impl VK_INTEL_performance_query for Vulkan_INTEL_performance_query {
	fn vkInitializePerformanceApiINTEL(&self, device: VkDevice, pInitializeInfo: *const VkInitializePerformanceApiInfoINTEL) -> Result<()> {
		convert_result("vkInitializePerformanceApiINTEL", catch_unwind(||((self.vk_initialize_performance_api_intel)(device, pInitializeInfo))))
	}
}
impl Default for Vulkan_INTEL_performance_query {
	fn default() -> Self {
		Self {
			vk_initialize_performance_api_intel: dummy_vkInitializePerformanceApiINTEL,
		}
	}
}
impl Vulkan_INTEL_performance_query {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_initialize_performance_api_intel: {let proc = get_instance_proc_address(instance, "vkInitializePerformanceApiINTEL"); if proc == null() {dummy_vkInitializePerformanceApiINTEL} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDevicePCIBusInfoPropertiesEXT` from VK_EXT_pci_bus_info
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePCIBusInfoPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePCIBusInfoPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pciDomain: u32,
	pub pciBus: u32,
	pub pciDevice: u32,
	pub pciFunction: u32,
}
impl Debug for VkPhysicalDevicePCIBusInfoPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePCIBusInfoPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pciDomain", &self.pciDomain)
		.field("pciBus", &self.pciBus)
		.field("pciDevice", &self.pciDevice)
		.field("pciFunction", &self.pciFunction)
		.finish()
	}
}
/// trait for `VK_EXT_pci_bus_info`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_pci_bus_info.html>
pub trait VK_EXT_pci_bus_info: Debug {}
/// struct for `VK_EXT_pci_bus_info`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_pci_bus_info {}
impl VK_EXT_pci_bus_info for Vulkan_EXT_pci_bus_info {}
impl Default for Vulkan_EXT_pci_bus_info {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_pci_bus_info {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkDisplayNativeHdrSurfaceCapabilitiesAMD` from VK_AMD_display_native_hdr
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayNativeHdrSurfaceCapabilitiesAMD.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplayNativeHdrSurfaceCapabilitiesAMD {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub localDimmingSupport: VkBool32,
}
impl Debug for VkDisplayNativeHdrSurfaceCapabilitiesAMD {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayNativeHdrSurfaceCapabilitiesAMD")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("localDimmingSupport", &self.localDimmingSupport)
		.finish()
	}
}
/// struct `VkSwapchainDisplayNativeHdrCreateInfoAMD` from VK_AMD_display_native_hdr
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainDisplayNativeHdrCreateInfoAMD.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSwapchainDisplayNativeHdrCreateInfoAMD {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub localDimmingEnable: VkBool32,
}
impl Debug for VkSwapchainDisplayNativeHdrCreateInfoAMD {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSwapchainDisplayNativeHdrCreateInfoAMD")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("localDimmingEnable", &self.localDimmingEnable)
		.finish()
	}
}
/// function prototype `PFN_vkSetLocalDimmingAMD` from VK_AMD_display_native_hdr
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetLocalDimmingAMD.html>
type PFN_vkSetLocalDimmingAMD = extern "system" fn(device: VkDevice, swapChain: VkSwapchainKHR, localDimmingEnable: VkBool32);
/// The dummy function for `vkSetLocalDimmingAMD` from `VK_AMD_display_native_hdr`
extern "system" fn dummy_vkSetLocalDimmingAMD(_: VkDevice, _: VkSwapchainKHR, _: VkBool32) {
	panic_any(VkError::NullFunctionPointer("vkSetLocalDimmingAMD"))
}
/// trait for `VK_AMD_display_native_hdr`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_display_native_hdr.html>
pub trait VK_AMD_display_native_hdr: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetLocalDimmingAMD.html>
	fn vkSetLocalDimmingAMD(&self, device: VkDevice, swapChain: VkSwapchainKHR, localDimmingEnable: VkBool32) -> Result<()>;
}
/// struct for `VK_AMD_display_native_hdr`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_display_native_hdr {
	vk_set_local_dimming_amd: PFN_vkSetLocalDimmingAMD,
}
impl VK_AMD_display_native_hdr for Vulkan_AMD_display_native_hdr {
	fn vkSetLocalDimmingAMD(&self, device: VkDevice, swapChain: VkSwapchainKHR, localDimmingEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_set_local_dimming_amd)(device, swapChain, localDimmingEnable))))
	}
}
impl Default for Vulkan_AMD_display_native_hdr {
	fn default() -> Self {
		Self {
			vk_set_local_dimming_amd: dummy_vkSetLocalDimmingAMD,
		}
	}
}
impl Vulkan_AMD_display_native_hdr {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_set_local_dimming_amd: {let proc = get_instance_proc_address(instance, "vkSetLocalDimmingAMD"); if proc == null() {dummy_vkSetLocalDimmingAMD} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceFragmentDensityMapFeaturesEXT` from VK_EXT_fragment_density_map
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub fragmentDensityMap: VkBool32,
	pub fragmentDensityMapDynamic: VkBool32,
	pub fragmentDensityMapNonSubsampledImages: VkBool32,
}
impl Debug for VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentDensityMapFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("fragmentDensityMap", &self.fragmentDensityMap)
		.field("fragmentDensityMapDynamic", &self.fragmentDensityMapDynamic)
		.field("fragmentDensityMapNonSubsampledImages", &self.fragmentDensityMapNonSubsampledImages)
		.finish()
	}
}
/// struct `VkPhysicalDeviceFragmentDensityMapPropertiesEXT` from VK_EXT_fragment_density_map
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentDensityMapPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minFragmentDensityTexelSize: VkExtent2D,
	pub maxFragmentDensityTexelSize: VkExtent2D,
	pub fragmentDensityInvocations: VkBool32,
}
impl Debug for VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentDensityMapPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("minFragmentDensityTexelSize", &self.minFragmentDensityTexelSize)
		.field("maxFragmentDensityTexelSize", &self.maxFragmentDensityTexelSize)
		.field("fragmentDensityInvocations", &self.fragmentDensityInvocations)
		.finish()
	}
}
/// struct `VkRenderPassFragmentDensityMapCreateInfoEXT` from VK_EXT_fragment_density_map
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassFragmentDensityMapCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassFragmentDensityMapCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub fragmentDensityMapAttachment: VkAttachmentReference,
}
impl Debug for VkRenderPassFragmentDensityMapCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassFragmentDensityMapCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("fragmentDensityMapAttachment", &self.fragmentDensityMapAttachment)
		.finish()
	}
}
/// struct `VkRenderingFragmentDensityMapAttachmentInfoEXT` from VK_EXT_fragment_density_map
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingFragmentDensityMapAttachmentInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderingFragmentDensityMapAttachmentInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub imageView: VkImageView,
	pub imageLayout: VkImageLayout,
}
impl Debug for VkRenderingFragmentDensityMapAttachmentInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderingFragmentDensityMapAttachmentInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("imageView", &self.imageView)
		.field("imageLayout", &self.imageLayout)
		.finish()
	}
}
/// trait for `VK_EXT_fragment_density_map`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_fragment_density_map.html>
pub trait VK_EXT_fragment_density_map: Debug {}
/// struct for `VK_EXT_fragment_density_map`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_fragment_density_map {}
impl VK_EXT_fragment_density_map for Vulkan_EXT_fragment_density_map {}
impl Default for Vulkan_EXT_fragment_density_map {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_fragment_density_map {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceScalarBlockLayoutFeaturesEXT` from VK_EXT_scalar_block_layout
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.html>
pub type VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = VkPhysicalDeviceScalarBlockLayoutFeatures;
/// trait for `VK_EXT_scalar_block_layout`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_scalar_block_layout.html>
pub trait VK_EXT_scalar_block_layout: Debug {}
/// struct for `VK_EXT_scalar_block_layout`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_scalar_block_layout {}
impl VK_EXT_scalar_block_layout for Vulkan_EXT_scalar_block_layout {}
impl Default for Vulkan_EXT_scalar_block_layout {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_scalar_block_layout {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_GOOGLE_hlsl_functionality1`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_GOOGLE_hlsl_functionality1.html>
pub trait VK_GOOGLE_hlsl_functionality1: Debug {}
/// struct for `VK_GOOGLE_hlsl_functionality1`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_GOOGLE_hlsl_functionality1 {}
impl VK_GOOGLE_hlsl_functionality1 for Vulkan_GOOGLE_hlsl_functionality1 {}
impl Default for Vulkan_GOOGLE_hlsl_functionality1 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_GOOGLE_hlsl_functionality1 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_GOOGLE_decorate_string`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_GOOGLE_decorate_string.html>
pub trait VK_GOOGLE_decorate_string: Debug {}
/// struct for `VK_GOOGLE_decorate_string`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_GOOGLE_decorate_string {}
impl VK_GOOGLE_decorate_string for Vulkan_GOOGLE_decorate_string {}
impl Default for Vulkan_GOOGLE_decorate_string {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_GOOGLE_decorate_string {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceSubgroupSizeControlFeaturesEXT` from VK_EXT_subgroup_size_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.html>
pub type VkPhysicalDeviceSubgroupSizeControlFeaturesEXT = VkPhysicalDeviceSubgroupSizeControlFeatures;
/// type definition `VkPhysicalDeviceSubgroupSizeControlPropertiesEXT` from VK_EXT_subgroup_size_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSubgroupSizeControlPropertiesEXT.html>
pub type VkPhysicalDeviceSubgroupSizeControlPropertiesEXT = VkPhysicalDeviceSubgroupSizeControlProperties;
/// type definition `VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT` from VK_EXT_subgroup_size_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT.html>
pub type VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;
/// trait for `VK_EXT_subgroup_size_control`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_subgroup_size_control.html>
pub trait VK_EXT_subgroup_size_control: Debug {}
/// struct for `VK_EXT_subgroup_size_control`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_subgroup_size_control {}
impl VK_EXT_subgroup_size_control for Vulkan_EXT_subgroup_size_control {}
impl Default for Vulkan_EXT_subgroup_size_control {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_subgroup_size_control {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkShaderCorePropertiesFlagsAMD` from VK_AMD_shader_core_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderCorePropertiesFlagsAMD.html>
pub type VkShaderCorePropertiesFlagsAMD = VkFlags;
/// enum `VkShaderCorePropertiesFlagBitsAMD` from VK_AMD_shader_core_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderCorePropertiesFlagBitsAMD.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkShaderCorePropertiesFlagBitsAMD {
	VK_SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD = 0x7fffffff,
}
/// struct `VkPhysicalDeviceShaderCoreProperties2AMD` from VK_AMD_shader_core_properties2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderCoreProperties2AMD.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderCoreProperties2AMD {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderCoreFeatures: VkShaderCorePropertiesFlagsAMD,
	pub activeComputeUnitCount: u32,
}
impl Debug for VkPhysicalDeviceShaderCoreProperties2AMD {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderCoreProperties2AMD")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderCoreFeatures", &self.shaderCoreFeatures)
		.field("activeComputeUnitCount", &self.activeComputeUnitCount)
		.finish()
	}
}
/// trait for `VK_AMD_shader_core_properties2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_shader_core_properties2.html>
pub trait VK_AMD_shader_core_properties2: Debug {}
/// struct for `VK_AMD_shader_core_properties2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_core_properties2 {}
impl VK_AMD_shader_core_properties2 for Vulkan_AMD_shader_core_properties2 {}
impl Default for Vulkan_AMD_shader_core_properties2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_shader_core_properties2 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceCoherentMemoryFeaturesAMD` from VK_AMD_device_coherent_memory
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCoherentMemoryFeaturesAMD.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCoherentMemoryFeaturesAMD {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceCoherentMemory: VkBool32,
}
impl Debug for VkPhysicalDeviceCoherentMemoryFeaturesAMD {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCoherentMemoryFeaturesAMD")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceCoherentMemory", &self.deviceCoherentMemory)
		.finish()
	}
}
/// trait for `VK_AMD_device_coherent_memory`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_device_coherent_memory.html>
pub trait VK_AMD_device_coherent_memory: Debug {}
/// struct for `VK_AMD_device_coherent_memory`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_device_coherent_memory {}
impl VK_AMD_device_coherent_memory for Vulkan_AMD_device_coherent_memory {}
impl Default for Vulkan_AMD_device_coherent_memory {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_device_coherent_memory {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT` from VK_EXT_shader_image_atomic_int64
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderImageInt64Atomics: VkBool32,
	pub sparseImageInt64Atomics: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderImageInt64Atomics", &self.shaderImageInt64Atomics)
		.field("sparseImageInt64Atomics", &self.sparseImageInt64Atomics)
		.finish()
	}
}
/// trait for `VK_EXT_shader_image_atomic_int64`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_shader_image_atomic_int64.html>
pub trait VK_EXT_shader_image_atomic_int64: Debug {}
/// struct for `VK_EXT_shader_image_atomic_int64`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_image_atomic_int64 {}
impl VK_EXT_shader_image_atomic_int64 for Vulkan_EXT_shader_image_atomic_int64 {}
impl Default for Vulkan_EXT_shader_image_atomic_int64 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_image_atomic_int64 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceMemoryBudgetPropertiesEXT` from VK_EXT_memory_budget
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMemoryBudgetPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMemoryBudgetPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub heapBudget: [VkDeviceSize; VK_MAX_MEMORY_HEAPS as usize],
	pub heapUsage: [VkDeviceSize; VK_MAX_MEMORY_HEAPS as usize],
}
impl Debug for VkPhysicalDeviceMemoryBudgetPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMemoryBudgetPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("heapBudget", &self.heapBudget)
		.field("heapUsage", &self.heapUsage)
		.finish()
	}
}
/// trait for `VK_EXT_memory_budget`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_memory_budget.html>
pub trait VK_EXT_memory_budget: Debug {}
/// struct for `VK_EXT_memory_budget`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_memory_budget {}
impl VK_EXT_memory_budget for Vulkan_EXT_memory_budget {}
impl Default for Vulkan_EXT_memory_budget {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_memory_budget {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceMemoryPriorityFeaturesEXT` from VK_EXT_memory_priority
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMemoryPriorityFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMemoryPriorityFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryPriority: VkBool32,
}
impl Debug for VkPhysicalDeviceMemoryPriorityFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMemoryPriorityFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("memoryPriority", &self.memoryPriority)
		.finish()
	}
}
/// struct `VkMemoryPriorityAllocateInfoEXT` from VK_EXT_memory_priority
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryPriorityAllocateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryPriorityAllocateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub priority: f32,
}
impl Debug for VkMemoryPriorityAllocateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryPriorityAllocateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("priority", &self.priority)
		.finish()
	}
}
/// trait for `VK_EXT_memory_priority`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_memory_priority.html>
pub trait VK_EXT_memory_priority: Debug {}
/// struct for `VK_EXT_memory_priority`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_memory_priority {}
impl VK_EXT_memory_priority for Vulkan_EXT_memory_priority {}
impl Default for Vulkan_EXT_memory_priority {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_memory_priority {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV` from VK_NV_dedicated_allocation_image_aliasing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub dedicatedAllocationImageAliasing: VkBool32,
}
impl Debug for VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dedicatedAllocationImageAliasing", &self.dedicatedAllocationImageAliasing)
		.finish()
	}
}
/// trait for `VK_NV_dedicated_allocation_image_aliasing`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_dedicated_allocation_image_aliasing.html>
pub trait VK_NV_dedicated_allocation_image_aliasing: Debug {}
/// struct for `VK_NV_dedicated_allocation_image_aliasing`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_dedicated_allocation_image_aliasing {}
impl VK_NV_dedicated_allocation_image_aliasing for Vulkan_NV_dedicated_allocation_image_aliasing {}
impl Default for Vulkan_NV_dedicated_allocation_image_aliasing {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_dedicated_allocation_image_aliasing {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceBufferAddressFeaturesEXT` from VK_EXT_buffer_device_address
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceBufferAddressFeaturesEXT.html>
pub type VkPhysicalDeviceBufferAddressFeaturesEXT = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;
/// type definition `VkBufferDeviceAddressInfoEXT` from VK_EXT_buffer_device_address
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferDeviceAddressInfoEXT.html>
pub type VkBufferDeviceAddressInfoEXT = VkBufferDeviceAddressInfo;
/// struct `VkPhysicalDeviceBufferDeviceAddressFeaturesEXT` from VK_EXT_buffer_device_address
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub bufferDeviceAddress: VkBool32,
	pub bufferDeviceAddressCaptureReplay: VkBool32,
	pub bufferDeviceAddressMultiDevice: VkBool32,
}
impl Debug for VkPhysicalDeviceBufferDeviceAddressFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceBufferDeviceAddressFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("bufferDeviceAddress", &self.bufferDeviceAddress)
		.field("bufferDeviceAddressCaptureReplay", &self.bufferDeviceAddressCaptureReplay)
		.field("bufferDeviceAddressMultiDevice", &self.bufferDeviceAddressMultiDevice)
		.finish()
	}
}
/// struct `VkBufferDeviceAddressCreateInfoEXT` from VK_EXT_buffer_device_address
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferDeviceAddressCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBufferDeviceAddressCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub deviceAddress: VkDeviceAddress,
}
impl Debug for VkBufferDeviceAddressCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBufferDeviceAddressCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceAddress", &self.deviceAddress)
		.finish()
	}
}
/// function prototype `PFN_vkGetBufferDeviceAddressEXT` from VK_EXT_buffer_device_address
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferDeviceAddressEXT.html>
type PFN_vkGetBufferDeviceAddressEXT = extern "system" fn(device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress;
/// The dummy function for `vkGetBufferDeviceAddressEXT` from `VK_EXT_buffer_device_address`
extern "system" fn dummy_vkGetBufferDeviceAddressEXT(_: VkDevice, _: *const VkBufferDeviceAddressInfo) -> VkDeviceAddress {
	panic_any(VkError::NullFunctionPointer("vkGetBufferDeviceAddressEXT"))
}
/// trait for `VK_EXT_buffer_device_address`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_buffer_device_address.html>
pub trait VK_EXT_buffer_device_address: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferDeviceAddressEXT.html>
	fn vkGetBufferDeviceAddressEXT(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> Result<VkDeviceAddress>;
}
/// struct for `VK_EXT_buffer_device_address`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_buffer_device_address {
	vk_get_buffer_device_address_ext: PFN_vkGetBufferDeviceAddressEXT,
}
impl VK_EXT_buffer_device_address for Vulkan_EXT_buffer_device_address {
	fn vkGetBufferDeviceAddressEXT(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> Result<VkDeviceAddress> {
		process_catch(catch_unwind(||((self.vk_get_buffer_device_address_ext)(device, pInfo))))
	}
}
impl Default for Vulkan_EXT_buffer_device_address {
	fn default() -> Self {
		Self {
			vk_get_buffer_device_address_ext: dummy_vkGetBufferDeviceAddressEXT,
		}
	}
}
impl Vulkan_EXT_buffer_device_address {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_buffer_device_address_ext: {let proc = get_instance_proc_address(instance, "vkGetBufferDeviceAddressEXT"); if proc == null() {dummy_vkGetBufferDeviceAddressEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkToolPurposeFlagBitsEXT` from VK_EXT_tooling_info
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkToolPurposeFlagBitsEXT.html>
pub type VkToolPurposeFlagBitsEXT = VkToolPurposeFlagBits;
/// type definition `VkToolPurposeFlagsEXT` from VK_EXT_tooling_info
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkToolPurposeFlagsEXT.html>
pub type VkToolPurposeFlagsEXT = VkToolPurposeFlags;
/// type definition `VkPhysicalDeviceToolPropertiesEXT` from VK_EXT_tooling_info
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceToolPropertiesEXT.html>
pub type VkPhysicalDeviceToolPropertiesEXT = VkPhysicalDeviceToolProperties;
/// function prototype `PFN_vkGetPhysicalDeviceToolPropertiesEXT` from VK_EXT_tooling_info
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceToolPropertiesEXT.html>
type PFN_vkGetPhysicalDeviceToolPropertiesEXT = extern "system" fn(physicalDevice: VkPhysicalDevice, pToolCount: *mut uint32_t, pToolProperties: *mut VkPhysicalDeviceToolProperties) -> VkResult;
/// The dummy function for `vkGetPhysicalDeviceToolPropertiesEXT` from `VK_EXT_tooling_info`
extern "system" fn dummy_vkGetPhysicalDeviceToolPropertiesEXT(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkPhysicalDeviceToolProperties) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceToolPropertiesEXT"))
}
/// trait for `VK_EXT_tooling_info`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_tooling_info.html>
pub trait VK_EXT_tooling_info: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceToolPropertiesEXT.html>
	fn vkGetPhysicalDeviceToolPropertiesEXT(&self, physicalDevice: VkPhysicalDevice, pToolCount: *mut uint32_t, pToolProperties: *mut VkPhysicalDeviceToolProperties) -> Result<()>;
}
/// struct for `VK_EXT_tooling_info`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_tooling_info {
	vk_get_physical_device_tool_properties_ext: PFN_vkGetPhysicalDeviceToolPropertiesEXT,
}
impl VK_EXT_tooling_info for Vulkan_EXT_tooling_info {
	fn vkGetPhysicalDeviceToolPropertiesEXT(&self, physicalDevice: VkPhysicalDevice, pToolCount: *mut uint32_t, pToolProperties: *mut VkPhysicalDeviceToolProperties) -> Result<()> {
		convert_result("vkGetPhysicalDeviceToolPropertiesEXT", catch_unwind(||((self.vk_get_physical_device_tool_properties_ext)(physicalDevice, pToolCount, pToolProperties))))
	}
}
impl Default for Vulkan_EXT_tooling_info {
	fn default() -> Self {
		Self {
			vk_get_physical_device_tool_properties_ext: dummy_vkGetPhysicalDeviceToolPropertiesEXT,
		}
	}
}
impl Vulkan_EXT_tooling_info {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_tool_properties_ext: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceToolPropertiesEXT"); if proc == null() {dummy_vkGetPhysicalDeviceToolPropertiesEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkImageStencilUsageCreateInfoEXT` from VK_EXT_separate_stencil_usage
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageStencilUsageCreateInfoEXT.html>
pub type VkImageStencilUsageCreateInfoEXT = VkImageStencilUsageCreateInfo;
/// trait for `VK_EXT_separate_stencil_usage`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_separate_stencil_usage.html>
pub trait VK_EXT_separate_stencil_usage: Debug {}
/// struct for `VK_EXT_separate_stencil_usage`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_separate_stencil_usage {}
impl VK_EXT_separate_stencil_usage for Vulkan_EXT_separate_stencil_usage {}
impl Default for Vulkan_EXT_separate_stencil_usage {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_separate_stencil_usage {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkValidationFeatureEnableEXT` from VK_EXT_validation_features
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkValidationFeatureEnableEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkValidationFeatureEnableEXT {
	VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0,
	VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1,
	VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2,
	VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT = 3,
	VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 4,
	VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkValidationFeatureDisableEXT` from VK_EXT_validation_features
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkValidationFeatureDisableEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkValidationFeatureDisableEXT {
	VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0,
	VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1,
	VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2,
	VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3,
	VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4,
	VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5,
	VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6,
	VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = 7,
	VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkValidationFeaturesEXT` from VK_EXT_validation_features
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkValidationFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkValidationFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub enabledValidationFeatureCount: u32,
	pub pEnabledValidationFeatures: *const VkValidationFeatureEnableEXT,
	pub disabledValidationFeatureCount: u32,
	pub pDisabledValidationFeatures: *const VkValidationFeatureDisableEXT,
}
impl Debug for VkValidationFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkValidationFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("enabledValidationFeatureCount", &self.enabledValidationFeatureCount)
		.field("pEnabledValidationFeatures", &self.pEnabledValidationFeatures)
		.field("disabledValidationFeatureCount", &self.disabledValidationFeatureCount)
		.field("pDisabledValidationFeatures", &self.pDisabledValidationFeatures)
		.finish()
	}
}
/// trait for `VK_EXT_validation_features`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_validation_features.html>
pub trait VK_EXT_validation_features: Debug {}
/// struct for `VK_EXT_validation_features`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_validation_features {}
impl VK_EXT_validation_features for Vulkan_EXT_validation_features {}
impl Default for Vulkan_EXT_validation_features {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_validation_features {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkComponentTypeNV` from VK_NV_cooperative_matrix
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkComponentTypeNV.html>
pub type VkComponentTypeNV = VkComponentTypeKHR;
/// type definition `VkScopeNV` from VK_NV_cooperative_matrix
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkScopeNV.html>
pub type VkScopeNV = VkScopeKHR;
/// struct `VkCooperativeMatrixPropertiesNV` from VK_NV_cooperative_matrix
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCooperativeMatrixPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCooperativeMatrixPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub MSize: u32,
	pub NSize: u32,
	pub KSize: u32,
	pub AType: VkComponentTypeNV,
	pub BType: VkComponentTypeNV,
	pub CType: VkComponentTypeNV,
	pub DType: VkComponentTypeNV,
	pub scope: VkScopeNV,
}
impl Debug for VkCooperativeMatrixPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCooperativeMatrixPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("MSize", &self.MSize)
		.field("NSize", &self.NSize)
		.field("KSize", &self.KSize)
		.field("AType", &self.AType)
		.field("BType", &self.BType)
		.field("CType", &self.CType)
		.field("DType", &self.DType)
		.field("scope", &self.scope)
		.finish()
	}
}
/// struct `VkPhysicalDeviceCooperativeMatrixFeaturesNV` from VK_NV_cooperative_matrix
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCooperativeMatrixFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCooperativeMatrixFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cooperativeMatrix: VkBool32,
	pub cooperativeMatrixRobustBufferAccess: VkBool32,
}
impl Debug for VkPhysicalDeviceCooperativeMatrixFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCooperativeMatrixFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("cooperativeMatrix", &self.cooperativeMatrix)
		.field("cooperativeMatrixRobustBufferAccess", &self.cooperativeMatrixRobustBufferAccess)
		.finish()
	}
}
/// struct `VkPhysicalDeviceCooperativeMatrixPropertiesNV` from VK_NV_cooperative_matrix
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCooperativeMatrixPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCooperativeMatrixPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cooperativeMatrixSupportedStages: VkShaderStageFlags,
}
impl Debug for VkPhysicalDeviceCooperativeMatrixPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCooperativeMatrixPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("cooperativeMatrixSupportedStages", &self.cooperativeMatrixSupportedStages)
		.finish()
	}
}
/// function prototype `PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV` from VK_NV_cooperative_matrix
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.html>
type PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixPropertiesNV) -> VkResult;
/// The dummy function for `vkGetPhysicalDeviceCooperativeMatrixPropertiesNV` from `VK_NV_cooperative_matrix`
extern "system" fn dummy_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkCooperativeMatrixPropertiesNV) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV"))
}
/// trait for `VK_NV_cooperative_matrix`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_cooperative_matrix.html>
pub trait VK_NV_cooperative_matrix: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.html>
	fn vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixPropertiesNV) -> Result<()>;
}
/// struct for `VK_NV_cooperative_matrix`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_cooperative_matrix {
	vk_get_physical_device_cooperative_matrix_properties_nv: PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV,
}
impl VK_NV_cooperative_matrix for Vulkan_NV_cooperative_matrix {
	fn vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixPropertiesNV) -> Result<()> {
		convert_result("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", catch_unwind(||((self.vk_get_physical_device_cooperative_matrix_properties_nv)(physicalDevice, pPropertyCount, pProperties))))
	}
}
impl Default for Vulkan_NV_cooperative_matrix {
	fn default() -> Self {
		Self {
			vk_get_physical_device_cooperative_matrix_properties_nv: dummy_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV,
		}
	}
}
impl Vulkan_NV_cooperative_matrix {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_cooperative_matrix_properties_nv: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV"); if proc == null() {dummy_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPipelineCoverageReductionStateCreateFlagsNV` from VK_NV_coverage_reduction_mode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCoverageReductionStateCreateFlagsNV.html>
pub type VkPipelineCoverageReductionStateCreateFlagsNV = VkFlags;
/// enum `VkCoverageReductionModeNV` from VK_NV_coverage_reduction_mode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCoverageReductionModeNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCoverageReductionModeNV {
	VK_COVERAGE_REDUCTION_MODE_MERGE_NV = 0,
	VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1,
	VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV = 0x7fffffff,
}
/// struct `VkPhysicalDeviceCoverageReductionModeFeaturesNV` from VK_NV_coverage_reduction_mode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCoverageReductionModeFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCoverageReductionModeFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub coverageReductionMode: VkBool32,
}
impl Debug for VkPhysicalDeviceCoverageReductionModeFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCoverageReductionModeFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("coverageReductionMode", &self.coverageReductionMode)
		.finish()
	}
}
/// struct `VkPipelineCoverageReductionStateCreateInfoNV` from VK_NV_coverage_reduction_mode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCoverageReductionStateCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineCoverageReductionStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCoverageReductionStateCreateFlagsNV,
	pub coverageReductionMode: VkCoverageReductionModeNV,
}
impl Debug for VkPipelineCoverageReductionStateCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineCoverageReductionStateCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("coverageReductionMode", &self.coverageReductionMode)
		.finish()
	}
}
/// struct `VkFramebufferMixedSamplesCombinationNV` from VK_NV_coverage_reduction_mode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFramebufferMixedSamplesCombinationNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkFramebufferMixedSamplesCombinationNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub coverageReductionMode: VkCoverageReductionModeNV,
	pub rasterizationSamples: VkSampleCountFlagBits,
	pub depthStencilSamples: VkSampleCountFlags,
	pub colorSamples: VkSampleCountFlags,
}
impl Debug for VkFramebufferMixedSamplesCombinationNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkFramebufferMixedSamplesCombinationNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("coverageReductionMode", &self.coverageReductionMode)
		.field("rasterizationSamples", &self.rasterizationSamples)
		.field("depthStencilSamples", &self.depthStencilSamples)
		.field("colorSamples", &self.colorSamples)
		.finish()
	}
}
/// function prototype `PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV` from VK_NV_coverage_reduction_mode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.html>
type PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = extern "system" fn(physicalDevice: VkPhysicalDevice, pCombinationCount: *mut uint32_t, pCombinations: *mut VkFramebufferMixedSamplesCombinationNV) -> VkResult;
/// The dummy function for `vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV` from `VK_NV_coverage_reduction_mode`
extern "system" fn dummy_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkFramebufferMixedSamplesCombinationNV) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV"))
}
/// trait for `VK_NV_coverage_reduction_mode`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_coverage_reduction_mode.html>
pub trait VK_NV_coverage_reduction_mode: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.html>
	fn vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(&self, physicalDevice: VkPhysicalDevice, pCombinationCount: *mut uint32_t, pCombinations: *mut VkFramebufferMixedSamplesCombinationNV) -> Result<()>;
}
/// struct for `VK_NV_coverage_reduction_mode`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_coverage_reduction_mode {
	vk_get_physical_device_supported_framebuffer_mixed_samples_combinations_nv: PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV,
}
impl VK_NV_coverage_reduction_mode for Vulkan_NV_coverage_reduction_mode {
	fn vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(&self, physicalDevice: VkPhysicalDevice, pCombinationCount: *mut uint32_t, pCombinations: *mut VkFramebufferMixedSamplesCombinationNV) -> Result<()> {
		convert_result("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", catch_unwind(||((self.vk_get_physical_device_supported_framebuffer_mixed_samples_combinations_nv)(physicalDevice, pCombinationCount, pCombinations))))
	}
}
impl Default for Vulkan_NV_coverage_reduction_mode {
	fn default() -> Self {
		Self {
			vk_get_physical_device_supported_framebuffer_mixed_samples_combinations_nv: dummy_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV,
		}
	}
}
impl Vulkan_NV_coverage_reduction_mode {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_supported_framebuffer_mixed_samples_combinations_nv: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV"); if proc == null() {dummy_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT` from VK_EXT_fragment_shader_interlock
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub fragmentShaderSampleInterlock: VkBool32,
	pub fragmentShaderPixelInterlock: VkBool32,
	pub fragmentShaderShadingRateInterlock: VkBool32,
}
impl Debug for VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("fragmentShaderSampleInterlock", &self.fragmentShaderSampleInterlock)
		.field("fragmentShaderPixelInterlock", &self.fragmentShaderPixelInterlock)
		.field("fragmentShaderShadingRateInterlock", &self.fragmentShaderShadingRateInterlock)
		.finish()
	}
}
/// trait for `VK_EXT_fragment_shader_interlock`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_fragment_shader_interlock.html>
pub trait VK_EXT_fragment_shader_interlock: Debug {}
/// struct for `VK_EXT_fragment_shader_interlock`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_fragment_shader_interlock {}
impl VK_EXT_fragment_shader_interlock for Vulkan_EXT_fragment_shader_interlock {}
impl Default for Vulkan_EXT_fragment_shader_interlock {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_fragment_shader_interlock {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceYcbcrImageArraysFeaturesEXT` from VK_EXT_ycbcr_image_arrays
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub ycbcrImageArrays: VkBool32,
}
impl Debug for VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceYcbcrImageArraysFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("ycbcrImageArrays", &self.ycbcrImageArrays)
		.finish()
	}
}
/// trait for `VK_EXT_ycbcr_image_arrays`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_ycbcr_image_arrays.html>
pub trait VK_EXT_ycbcr_image_arrays: Debug {}
/// struct for `VK_EXT_ycbcr_image_arrays`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_ycbcr_image_arrays {}
impl VK_EXT_ycbcr_image_arrays for Vulkan_EXT_ycbcr_image_arrays {}
impl Default for Vulkan_EXT_ycbcr_image_arrays {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_ycbcr_image_arrays {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkProvokingVertexModeEXT` from VK_EXT_provoking_vertex
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkProvokingVertexModeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkProvokingVertexModeEXT {
	VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = 0,
	VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = 1,
	VK_PROVOKING_VERTEX_MODE_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkPhysicalDeviceProvokingVertexFeaturesEXT` from VK_EXT_provoking_vertex
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceProvokingVertexFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceProvokingVertexFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub provokingVertexLast: VkBool32,
	pub transformFeedbackPreservesProvokingVertex: VkBool32,
}
impl Debug for VkPhysicalDeviceProvokingVertexFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceProvokingVertexFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("provokingVertexLast", &self.provokingVertexLast)
		.field("transformFeedbackPreservesProvokingVertex", &self.transformFeedbackPreservesProvokingVertex)
		.finish()
	}
}
/// struct `VkPhysicalDeviceProvokingVertexPropertiesEXT` from VK_EXT_provoking_vertex
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceProvokingVertexPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceProvokingVertexPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub provokingVertexModePerPipeline: VkBool32,
	pub transformFeedbackPreservesTriangleFanProvokingVertex: VkBool32,
}
impl Debug for VkPhysicalDeviceProvokingVertexPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceProvokingVertexPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("provokingVertexModePerPipeline", &self.provokingVertexModePerPipeline)
		.field("transformFeedbackPreservesTriangleFanProvokingVertex", &self.transformFeedbackPreservesTriangleFanProvokingVertex)
		.finish()
	}
}
/// struct `VkPipelineRasterizationProvokingVertexStateCreateInfoEXT` from VK_EXT_provoking_vertex
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRasterizationProvokingVertexStateCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineRasterizationProvokingVertexStateCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub provokingVertexMode: VkProvokingVertexModeEXT,
}
impl Debug for VkPipelineRasterizationProvokingVertexStateCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineRasterizationProvokingVertexStateCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("provokingVertexMode", &self.provokingVertexMode)
		.finish()
	}
}
/// trait for `VK_EXT_provoking_vertex`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_provoking_vertex.html>
pub trait VK_EXT_provoking_vertex: Debug {}
/// struct for `VK_EXT_provoking_vertex`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_provoking_vertex {}
impl VK_EXT_provoking_vertex for Vulkan_EXT_provoking_vertex {}
impl Default for Vulkan_EXT_provoking_vertex {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_provoking_vertex {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkHeadlessSurfaceCreateFlagsEXT` from VK_EXT_headless_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkHeadlessSurfaceCreateFlagsEXT.html>
pub type VkHeadlessSurfaceCreateFlagsEXT = VkFlags;
/// struct `VkHeadlessSurfaceCreateInfoEXT` from VK_EXT_headless_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkHeadlessSurfaceCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkHeadlessSurfaceCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkHeadlessSurfaceCreateFlagsEXT,
}
impl Debug for VkHeadlessSurfaceCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkHeadlessSurfaceCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.finish()
	}
}
/// function prototype `PFN_vkCreateHeadlessSurfaceEXT` from VK_EXT_headless_surface
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateHeadlessSurfaceEXT.html>
type PFN_vkCreateHeadlessSurfaceEXT = extern "system" fn(instance: VkInstance, pCreateInfo: *const VkHeadlessSurfaceCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR) -> VkResult;
/// The dummy function for `vkCreateHeadlessSurfaceEXT` from `VK_EXT_headless_surface`
extern "system" fn dummy_vkCreateHeadlessSurfaceEXT(_: VkInstance, _: *const VkHeadlessSurfaceCreateInfoEXT, _: *const VkAllocationCallbacks, _: *mut VkSurfaceKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateHeadlessSurfaceEXT"))
}
/// trait for `VK_EXT_headless_surface`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_headless_surface.html>
pub trait VK_EXT_headless_surface: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateHeadlessSurfaceEXT.html>
	fn vkCreateHeadlessSurfaceEXT(&self, instance: VkInstance, pCreateInfo: *const VkHeadlessSurfaceCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR) -> Result<()>;
}
/// struct for `VK_EXT_headless_surface`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_headless_surface {
	vk_create_headless_surface_ext: PFN_vkCreateHeadlessSurfaceEXT,
}
impl VK_EXT_headless_surface for Vulkan_EXT_headless_surface {
	fn vkCreateHeadlessSurfaceEXT(&self, instance: VkInstance, pCreateInfo: *const VkHeadlessSurfaceCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR) -> Result<()> {
		convert_result("vkCreateHeadlessSurfaceEXT", catch_unwind(||((self.vk_create_headless_surface_ext)(instance, pCreateInfo, pAllocator, pSurface))))
	}
}
impl Default for Vulkan_EXT_headless_surface {
	fn default() -> Self {
		Self {
			vk_create_headless_surface_ext: dummy_vkCreateHeadlessSurfaceEXT,
		}
	}
}
impl Vulkan_EXT_headless_surface {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_headless_surface_ext: {let proc = get_instance_proc_address(instance, "vkCreateHeadlessSurfaceEXT"); if proc == null() {dummy_vkCreateHeadlessSurfaceEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkLineRasterizationModeEXT` from VK_EXT_line_rasterization
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkLineRasterizationModeEXT.html>
pub type VkLineRasterizationModeEXT = VkLineRasterizationMode;
/// type definition `VkPhysicalDeviceLineRasterizationFeaturesEXT` from VK_EXT_line_rasterization
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLineRasterizationFeaturesEXT.html>
pub type VkPhysicalDeviceLineRasterizationFeaturesEXT = VkPhysicalDeviceLineRasterizationFeatures;
/// type definition `VkPhysicalDeviceLineRasterizationPropertiesEXT` from VK_EXT_line_rasterization
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLineRasterizationPropertiesEXT.html>
pub type VkPhysicalDeviceLineRasterizationPropertiesEXT = VkPhysicalDeviceLineRasterizationProperties;
/// type definition `VkPipelineRasterizationLineStateCreateInfoEXT` from VK_EXT_line_rasterization
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineRasterizationLineStateCreateInfoEXT.html>
pub type VkPipelineRasterizationLineStateCreateInfoEXT = VkPipelineRasterizationLineStateCreateInfo;
/// function prototype `PFN_vkCmdSetLineStippleEXT` from VK_EXT_line_rasterization
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLineStippleEXT.html>
type PFN_vkCmdSetLineStippleEXT = extern "system" fn(commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16);
/// The dummy function for `vkCmdSetLineStippleEXT` from `VK_EXT_line_rasterization`
extern "system" fn dummy_vkCmdSetLineStippleEXT(_: VkCommandBuffer, _: u32, _: u16) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetLineStippleEXT"))
}
/// trait for `VK_EXT_line_rasterization`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_line_rasterization.html>
pub trait VK_EXT_line_rasterization: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLineStippleEXT.html>
	fn vkCmdSetLineStippleEXT(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) -> Result<()>;
}
/// struct for `VK_EXT_line_rasterization`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_line_rasterization {
	vk_cmd_set_line_stipple_ext: PFN_vkCmdSetLineStippleEXT,
}
impl VK_EXT_line_rasterization for Vulkan_EXT_line_rasterization {
	fn vkCmdSetLineStippleEXT(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_line_stipple_ext)(commandBuffer, lineStippleFactor, lineStipplePattern))))
	}
}
impl Default for Vulkan_EXT_line_rasterization {
	fn default() -> Self {
		Self {
			vk_cmd_set_line_stipple_ext: dummy_vkCmdSetLineStippleEXT,
		}
	}
}
impl Vulkan_EXT_line_rasterization {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_line_stipple_ext: {let proc = get_instance_proc_address(instance, "vkCmdSetLineStippleEXT"); if proc == null() {dummy_vkCmdSetLineStippleEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceShaderAtomicFloatFeaturesEXT` from VK_EXT_shader_atomic_float
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderBufferFloat32Atomics: VkBool32,
	pub shaderBufferFloat32AtomicAdd: VkBool32,
	pub shaderBufferFloat64Atomics: VkBool32,
	pub shaderBufferFloat64AtomicAdd: VkBool32,
	pub shaderSharedFloat32Atomics: VkBool32,
	pub shaderSharedFloat32AtomicAdd: VkBool32,
	pub shaderSharedFloat64Atomics: VkBool32,
	pub shaderSharedFloat64AtomicAdd: VkBool32,
	pub shaderImageFloat32Atomics: VkBool32,
	pub shaderImageFloat32AtomicAdd: VkBool32,
	pub sparseImageFloat32Atomics: VkBool32,
	pub sparseImageFloat32AtomicAdd: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderAtomicFloatFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderAtomicFloatFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderBufferFloat32Atomics", &self.shaderBufferFloat32Atomics)
		.field("shaderBufferFloat32AtomicAdd", &self.shaderBufferFloat32AtomicAdd)
		.field("shaderBufferFloat64Atomics", &self.shaderBufferFloat64Atomics)
		.field("shaderBufferFloat64AtomicAdd", &self.shaderBufferFloat64AtomicAdd)
		.field("shaderSharedFloat32Atomics", &self.shaderSharedFloat32Atomics)
		.field("shaderSharedFloat32AtomicAdd", &self.shaderSharedFloat32AtomicAdd)
		.field("shaderSharedFloat64Atomics", &self.shaderSharedFloat64Atomics)
		.field("shaderSharedFloat64AtomicAdd", &self.shaderSharedFloat64AtomicAdd)
		.field("shaderImageFloat32Atomics", &self.shaderImageFloat32Atomics)
		.field("shaderImageFloat32AtomicAdd", &self.shaderImageFloat32AtomicAdd)
		.field("sparseImageFloat32Atomics", &self.sparseImageFloat32Atomics)
		.field("sparseImageFloat32AtomicAdd", &self.sparseImageFloat32AtomicAdd)
		.finish()
	}
}
/// trait for `VK_EXT_shader_atomic_float`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_shader_atomic_float.html>
pub trait VK_EXT_shader_atomic_float: Debug {}
/// struct for `VK_EXT_shader_atomic_float`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_atomic_float {}
impl VK_EXT_shader_atomic_float for Vulkan_EXT_shader_atomic_float {}
impl Default for Vulkan_EXT_shader_atomic_float {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_atomic_float {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceHostQueryResetFeaturesEXT` from VK_EXT_host_query_reset
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceHostQueryResetFeaturesEXT.html>
pub type VkPhysicalDeviceHostQueryResetFeaturesEXT = VkPhysicalDeviceHostQueryResetFeatures;
/// function prototype `PFN_vkResetQueryPoolEXT` from VK_EXT_host_query_reset
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetQueryPoolEXT.html>
type PFN_vkResetQueryPoolEXT = extern "system" fn(device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32);
/// The dummy function for `vkResetQueryPoolEXT` from `VK_EXT_host_query_reset`
extern "system" fn dummy_vkResetQueryPoolEXT(_: VkDevice, _: VkQueryPool, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkResetQueryPoolEXT"))
}
/// trait for `VK_EXT_host_query_reset`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_host_query_reset.html>
pub trait VK_EXT_host_query_reset: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetQueryPoolEXT.html>
	fn vkResetQueryPoolEXT(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) -> Result<()>;
}
/// struct for `VK_EXT_host_query_reset`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_host_query_reset {
	vk_reset_query_pool_ext: PFN_vkResetQueryPoolEXT,
}
impl VK_EXT_host_query_reset for Vulkan_EXT_host_query_reset {
	fn vkResetQueryPoolEXT(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_reset_query_pool_ext)(device, queryPool, firstQuery, queryCount))))
	}
}
impl Default for Vulkan_EXT_host_query_reset {
	fn default() -> Self {
		Self {
			vk_reset_query_pool_ext: dummy_vkResetQueryPoolEXT,
		}
	}
}
impl Vulkan_EXT_host_query_reset {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_reset_query_pool_ext: {let proc = get_instance_proc_address(instance, "vkResetQueryPoolEXT"); if proc == null() {dummy_vkResetQueryPoolEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceIndexTypeUint8FeaturesEXT` from VK_EXT_index_type_uint8
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceIndexTypeUint8FeaturesEXT.html>
pub type VkPhysicalDeviceIndexTypeUint8FeaturesEXT = VkPhysicalDeviceIndexTypeUint8Features;
/// trait for `VK_EXT_index_type_uint8`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_index_type_uint8.html>
pub trait VK_EXT_index_type_uint8: Debug {}
/// struct for `VK_EXT_index_type_uint8`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_index_type_uint8 {}
impl VK_EXT_index_type_uint8 for Vulkan_EXT_index_type_uint8 {}
impl Default for Vulkan_EXT_index_type_uint8 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_index_type_uint8 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceExtendedDynamicStateFeaturesEXT` from VK_EXT_extended_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceExtendedDynamicStateFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub extendedDynamicState: VkBool32,
}
impl Debug for VkPhysicalDeviceExtendedDynamicStateFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceExtendedDynamicStateFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("extendedDynamicState", &self.extendedDynamicState)
		.finish()
	}
}
/// function prototype `PFN_vkCmdSetCullModeEXT` from VK_EXT_extended_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCullModeEXT.html>
type PFN_vkCmdSetCullModeEXT = extern "system" fn(commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags);
/// function prototype `PFN_vkCmdSetFrontFaceEXT` from VK_EXT_extended_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetFrontFaceEXT.html>
type PFN_vkCmdSetFrontFaceEXT = extern "system" fn(commandBuffer: VkCommandBuffer, frontFace: VkFrontFace);
/// function prototype `PFN_vkCmdSetPrimitiveTopologyEXT` from VK_EXT_extended_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPrimitiveTopologyEXT.html>
type PFN_vkCmdSetPrimitiveTopologyEXT = extern "system" fn(commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology);
/// function prototype `PFN_vkCmdSetViewportWithCountEXT` from VK_EXT_extended_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportWithCountEXT.html>
type PFN_vkCmdSetViewportWithCountEXT = extern "system" fn(commandBuffer: VkCommandBuffer, viewportCount: u32, pViewports: *const VkViewport);
/// function prototype `PFN_vkCmdSetScissorWithCountEXT` from VK_EXT_extended_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetScissorWithCountEXT.html>
type PFN_vkCmdSetScissorWithCountEXT = extern "system" fn(commandBuffer: VkCommandBuffer, scissorCount: u32, pScissors: *const VkRect2D);
/// function prototype `PFN_vkCmdBindVertexBuffers2EXT` from VK_EXT_extended_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindVertexBuffers2EXT.html>
type PFN_vkCmdBindVertexBuffers2EXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize, pStrides: *const VkDeviceSize);
/// function prototype `PFN_vkCmdSetDepthTestEnableEXT` from VK_EXT_extended_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthTestEnableEXT.html>
type PFN_vkCmdSetDepthTestEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32);
/// function prototype `PFN_vkCmdSetDepthWriteEnableEXT` from VK_EXT_extended_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthWriteEnableEXT.html>
type PFN_vkCmdSetDepthWriteEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32);
/// function prototype `PFN_vkCmdSetDepthCompareOpEXT` from VK_EXT_extended_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthCompareOpEXT.html>
type PFN_vkCmdSetDepthCompareOpEXT = extern "system" fn(commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp);
/// function prototype `PFN_vkCmdSetDepthBoundsTestEnableEXT` from VK_EXT_extended_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBoundsTestEnableEXT.html>
type PFN_vkCmdSetDepthBoundsTestEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32);
/// function prototype `PFN_vkCmdSetStencilTestEnableEXT` from VK_EXT_extended_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilTestEnableEXT.html>
type PFN_vkCmdSetStencilTestEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32);
/// function prototype `PFN_vkCmdSetStencilOpEXT` from VK_EXT_extended_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilOpEXT.html>
type PFN_vkCmdSetStencilOpEXT = extern "system" fn(commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp);
/// The dummy function for `vkCmdSetCullModeEXT` from `VK_EXT_extended_dynamic_state`
extern "system" fn dummy_vkCmdSetCullModeEXT(_: VkCommandBuffer, _: VkCullModeFlags) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetCullModeEXT"))
}
/// trait for `VK_EXT_extended_dynamic_state`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_extended_dynamic_state.html>
pub trait VK_EXT_extended_dynamic_state: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCullModeEXT.html>
	fn vkCmdSetCullModeEXT(&self, commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) -> Result<()>;
}
/// struct for `VK_EXT_extended_dynamic_state`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_extended_dynamic_state {
	vk_cmd_set_cull_mode_ext: PFN_vkCmdSetCullModeEXT,
}
impl VK_EXT_extended_dynamic_state for Vulkan_EXT_extended_dynamic_state {
	fn vkCmdSetCullModeEXT(&self, commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_cull_mode_ext)(commandBuffer, cullMode))))
	}
}
impl Default for Vulkan_EXT_extended_dynamic_state {
	fn default() -> Self {
		Self {
			vk_cmd_set_cull_mode_ext: dummy_vkCmdSetCullModeEXT,
		}
	}
}
impl Vulkan_EXT_extended_dynamic_state {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_cull_mode_ext: {let proc = get_instance_proc_address(instance, "vkCmdSetCullModeEXT"); if proc == null() {dummy_vkCmdSetCullModeEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkHostImageCopyFlagBitsEXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkHostImageCopyFlagBitsEXT.html>
pub type VkHostImageCopyFlagBitsEXT = VkHostImageCopyFlagBits;
/// type definition `VkHostImageCopyFlagsEXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkHostImageCopyFlagsEXT.html>
pub type VkHostImageCopyFlagsEXT = VkHostImageCopyFlags;
/// type definition `VkPhysicalDeviceHostImageCopyFeaturesEXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceHostImageCopyFeaturesEXT.html>
pub type VkPhysicalDeviceHostImageCopyFeaturesEXT = VkPhysicalDeviceHostImageCopyFeatures;
/// type definition `VkPhysicalDeviceHostImageCopyPropertiesEXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceHostImageCopyPropertiesEXT.html>
pub type VkPhysicalDeviceHostImageCopyPropertiesEXT = VkPhysicalDeviceHostImageCopyProperties;
/// type definition `VkMemoryToImageCopyEXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryToImageCopyEXT.html>
pub type VkMemoryToImageCopyEXT = VkMemoryToImageCopy;
/// type definition `VkImageToMemoryCopyEXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageToMemoryCopyEXT.html>
pub type VkImageToMemoryCopyEXT = VkImageToMemoryCopy;
/// type definition `VkCopyMemoryToImageInfoEXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyMemoryToImageInfoEXT.html>
pub type VkCopyMemoryToImageInfoEXT = VkCopyMemoryToImageInfo;
/// type definition `VkCopyImageToMemoryInfoEXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyImageToMemoryInfoEXT.html>
pub type VkCopyImageToMemoryInfoEXT = VkCopyImageToMemoryInfo;
/// type definition `VkCopyImageToImageInfoEXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyImageToImageInfoEXT.html>
pub type VkCopyImageToImageInfoEXT = VkCopyImageToImageInfo;
/// type definition `VkHostImageLayoutTransitionInfoEXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkHostImageLayoutTransitionInfoEXT.html>
pub type VkHostImageLayoutTransitionInfoEXT = VkHostImageLayoutTransitionInfo;
/// type definition `VkSubresourceHostMemcpySizeEXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubresourceHostMemcpySizeEXT.html>
pub type VkSubresourceHostMemcpySizeEXT = VkSubresourceHostMemcpySize;
/// type definition `VkHostImageCopyDevicePerformanceQueryEXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkHostImageCopyDevicePerformanceQueryEXT.html>
pub type VkHostImageCopyDevicePerformanceQueryEXT = VkHostImageCopyDevicePerformanceQuery;
/// type definition `VkSubresourceLayout2EXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubresourceLayout2EXT.html>
pub type VkSubresourceLayout2EXT = VkSubresourceLayout2;
/// type definition `VkImageSubresource2EXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageSubresource2EXT.html>
pub type VkImageSubresource2EXT = VkImageSubresource2;
/// function prototype `PFN_vkCopyMemoryToImageEXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToImageEXT.html>
type PFN_vkCopyMemoryToImageEXT = extern "system" fn(device: VkDevice, pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo) -> VkResult;
/// function prototype `PFN_vkCopyImageToMemoryEXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToMemoryEXT.html>
type PFN_vkCopyImageToMemoryEXT = extern "system" fn(device: VkDevice, pCopyImageToMemoryInfo: *const VkCopyImageToMemoryInfo) -> VkResult;
/// function prototype `PFN_vkCopyImageToImageEXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToImageEXT.html>
type PFN_vkCopyImageToImageEXT = extern "system" fn(device: VkDevice, pCopyImageToImageInfo: *const VkCopyImageToImageInfo) -> VkResult;
/// function prototype `PFN_vkTransitionImageLayoutEXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkTransitionImageLayoutEXT.html>
type PFN_vkTransitionImageLayoutEXT = extern "system" fn(device: VkDevice, transitionCount: u32, pTransitions: *const VkHostImageLayoutTransitionInfo) -> VkResult;
/// function prototype `PFN_vkGetImageSubresourceLayout2EXT` from VK_EXT_host_image_copy
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout2EXT.html>
type PFN_vkGetImageSubresourceLayout2EXT = extern "system" fn(device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource2, pLayout: *mut VkSubresourceLayout2);
/// The dummy function for `vkCopyMemoryToImageEXT` from `VK_EXT_host_image_copy`
extern "system" fn dummy_vkCopyMemoryToImageEXT(_: VkDevice, _: *const VkCopyMemoryToImageInfo) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCopyMemoryToImageEXT"))
}
/// trait for `VK_EXT_host_image_copy`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_host_image_copy.html>
pub trait VK_EXT_host_image_copy: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToImageEXT.html>
	fn vkCopyMemoryToImageEXT(&self, device: VkDevice, pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo) -> Result<()>;
}
/// struct for `VK_EXT_host_image_copy`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_host_image_copy {
	vk_copy_memory_to_image_ext: PFN_vkCopyMemoryToImageEXT,
}
impl VK_EXT_host_image_copy for Vulkan_EXT_host_image_copy {
	fn vkCopyMemoryToImageEXT(&self, device: VkDevice, pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo) -> Result<()> {
		convert_result("vkCopyMemoryToImageEXT", catch_unwind(||((self.vk_copy_memory_to_image_ext)(device, pCopyMemoryToImageInfo))))
	}
}
impl Default for Vulkan_EXT_host_image_copy {
	fn default() -> Self {
		Self {
			vk_copy_memory_to_image_ext: dummy_vkCopyMemoryToImageEXT,
		}
	}
}
impl Vulkan_EXT_host_image_copy {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_copy_memory_to_image_ext: {let proc = get_instance_proc_address(instance, "vkCopyMemoryToImageEXT"); if proc == null() {dummy_vkCopyMemoryToImageEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceMapMemoryPlacedFeaturesEXT` from VK_EXT_map_memory_placed
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMapMemoryPlacedFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMapMemoryPlacedFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryMapPlaced: VkBool32,
	pub memoryMapRangePlaced: VkBool32,
	pub memoryUnmapReserve: VkBool32,
}
impl Debug for VkPhysicalDeviceMapMemoryPlacedFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMapMemoryPlacedFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("memoryMapPlaced", &self.memoryMapPlaced)
		.field("memoryMapRangePlaced", &self.memoryMapRangePlaced)
		.field("memoryUnmapReserve", &self.memoryUnmapReserve)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMapMemoryPlacedPropertiesEXT` from VK_EXT_map_memory_placed
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMapMemoryPlacedPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMapMemoryPlacedPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minPlacedMemoryMapAlignment: VkDeviceSize,
}
impl Debug for VkPhysicalDeviceMapMemoryPlacedPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMapMemoryPlacedPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("minPlacedMemoryMapAlignment", &self.minPlacedMemoryMapAlignment)
		.finish()
	}
}
/// struct `VkMemoryMapPlacedInfoEXT` from VK_EXT_map_memory_placed
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryMapPlacedInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryMapPlacedInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pPlacedAddress: *mut c_void,
}
impl Debug for VkMemoryMapPlacedInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryMapPlacedInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pPlacedAddress", &self.pPlacedAddress)
		.finish()
	}
}
/// trait for `VK_EXT_map_memory_placed`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_map_memory_placed.html>
pub trait VK_EXT_map_memory_placed: Debug {}
/// struct for `VK_EXT_map_memory_placed`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_map_memory_placed {}
impl VK_EXT_map_memory_placed for Vulkan_EXT_map_memory_placed {}
impl Default for Vulkan_EXT_map_memory_placed {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_map_memory_placed {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT` from VK_EXT_shader_atomic_float2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderBufferFloat16Atomics: VkBool32,
	pub shaderBufferFloat16AtomicAdd: VkBool32,
	pub shaderBufferFloat16AtomicMinMax: VkBool32,
	pub shaderBufferFloat32AtomicMinMax: VkBool32,
	pub shaderBufferFloat64AtomicMinMax: VkBool32,
	pub shaderSharedFloat16Atomics: VkBool32,
	pub shaderSharedFloat16AtomicAdd: VkBool32,
	pub shaderSharedFloat16AtomicMinMax: VkBool32,
	pub shaderSharedFloat32AtomicMinMax: VkBool32,
	pub shaderSharedFloat64AtomicMinMax: VkBool32,
	pub shaderImageFloat32AtomicMinMax: VkBool32,
	pub sparseImageFloat32AtomicMinMax: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderBufferFloat16Atomics", &self.shaderBufferFloat16Atomics)
		.field("shaderBufferFloat16AtomicAdd", &self.shaderBufferFloat16AtomicAdd)
		.field("shaderBufferFloat16AtomicMinMax", &self.shaderBufferFloat16AtomicMinMax)
		.field("shaderBufferFloat32AtomicMinMax", &self.shaderBufferFloat32AtomicMinMax)
		.field("shaderBufferFloat64AtomicMinMax", &self.shaderBufferFloat64AtomicMinMax)
		.field("shaderSharedFloat16Atomics", &self.shaderSharedFloat16Atomics)
		.field("shaderSharedFloat16AtomicAdd", &self.shaderSharedFloat16AtomicAdd)
		.field("shaderSharedFloat16AtomicMinMax", &self.shaderSharedFloat16AtomicMinMax)
		.field("shaderSharedFloat32AtomicMinMax", &self.shaderSharedFloat32AtomicMinMax)
		.field("shaderSharedFloat64AtomicMinMax", &self.shaderSharedFloat64AtomicMinMax)
		.field("shaderImageFloat32AtomicMinMax", &self.shaderImageFloat32AtomicMinMax)
		.field("sparseImageFloat32AtomicMinMax", &self.sparseImageFloat32AtomicMinMax)
		.finish()
	}
}
/// trait for `VK_EXT_shader_atomic_float2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_shader_atomic_float2.html>
pub trait VK_EXT_shader_atomic_float2: Debug {}
/// struct for `VK_EXT_shader_atomic_float2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_atomic_float2 {}
impl VK_EXT_shader_atomic_float2 for Vulkan_EXT_shader_atomic_float2 {}
impl Default for Vulkan_EXT_shader_atomic_float2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_atomic_float2 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPresentScalingFlagBitsEXT` from VK_EXT_surface_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentScalingFlagBitsEXT.html>
pub type VkPresentScalingFlagBitsEXT = VkPresentScalingFlagBitsKHR;
/// type definition `VkPresentScalingFlagsEXT` from VK_EXT_surface_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentScalingFlagsEXT.html>
pub type VkPresentScalingFlagsEXT = VkPresentScalingFlagsKHR;
/// type definition `VkPresentGravityFlagBitsEXT` from VK_EXT_surface_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentGravityFlagBitsEXT.html>
pub type VkPresentGravityFlagBitsEXT = VkPresentGravityFlagBitsKHR;
/// type definition `VkPresentGravityFlagsEXT` from VK_EXT_surface_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPresentGravityFlagsEXT.html>
pub type VkPresentGravityFlagsEXT = VkPresentGravityFlagsKHR;
/// type definition `VkSurfacePresentModeEXT` from VK_EXT_surface_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfacePresentModeEXT.html>
pub type VkSurfacePresentModeEXT = VkSurfacePresentModeKHR;
/// type definition `VkSurfacePresentScalingCapabilitiesEXT` from VK_EXT_surface_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfacePresentScalingCapabilitiesEXT.html>
pub type VkSurfacePresentScalingCapabilitiesEXT = VkSurfacePresentScalingCapabilitiesKHR;
/// type definition `VkSurfacePresentModeCompatibilityEXT` from VK_EXT_surface_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfacePresentModeCompatibilityEXT.html>
pub type VkSurfacePresentModeCompatibilityEXT = VkSurfacePresentModeCompatibilityKHR;
/// trait for `VK_EXT_surface_maintenance1`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_surface_maintenance1.html>
pub trait VK_EXT_surface_maintenance1: Debug {}
/// struct for `VK_EXT_surface_maintenance1`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_surface_maintenance1 {}
impl VK_EXT_surface_maintenance1 for Vulkan_EXT_surface_maintenance1 {}
impl Default for Vulkan_EXT_surface_maintenance1 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_surface_maintenance1 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT` from VK_EXT_swapchain_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT.html>
pub type VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT = VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR;
/// type definition `VkSwapchainPresentFenceInfoEXT` from VK_EXT_swapchain_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainPresentFenceInfoEXT.html>
pub type VkSwapchainPresentFenceInfoEXT = VkSwapchainPresentFenceInfoKHR;
/// type definition `VkSwapchainPresentModesCreateInfoEXT` from VK_EXT_swapchain_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainPresentModesCreateInfoEXT.html>
pub type VkSwapchainPresentModesCreateInfoEXT = VkSwapchainPresentModesCreateInfoKHR;
/// type definition `VkSwapchainPresentModeInfoEXT` from VK_EXT_swapchain_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainPresentModeInfoEXT.html>
pub type VkSwapchainPresentModeInfoEXT = VkSwapchainPresentModeInfoKHR;
/// type definition `VkSwapchainPresentScalingCreateInfoEXT` from VK_EXT_swapchain_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainPresentScalingCreateInfoEXT.html>
pub type VkSwapchainPresentScalingCreateInfoEXT = VkSwapchainPresentScalingCreateInfoKHR;
/// type definition `VkReleaseSwapchainImagesInfoEXT` from VK_EXT_swapchain_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkReleaseSwapchainImagesInfoEXT.html>
pub type VkReleaseSwapchainImagesInfoEXT = VkReleaseSwapchainImagesInfoKHR;
/// function prototype `PFN_vkReleaseSwapchainImagesEXT` from VK_EXT_swapchain_maintenance1
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseSwapchainImagesEXT.html>
type PFN_vkReleaseSwapchainImagesEXT = extern "system" fn(device: VkDevice, pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR) -> VkResult;
/// The dummy function for `vkReleaseSwapchainImagesEXT` from `VK_EXT_swapchain_maintenance1`
extern "system" fn dummy_vkReleaseSwapchainImagesEXT(_: VkDevice, _: *const VkReleaseSwapchainImagesInfoKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkReleaseSwapchainImagesEXT"))
}
/// trait for `VK_EXT_swapchain_maintenance1`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_swapchain_maintenance1.html>
pub trait VK_EXT_swapchain_maintenance1: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseSwapchainImagesEXT.html>
	fn vkReleaseSwapchainImagesEXT(&self, device: VkDevice, pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR) -> Result<()>;
}
/// struct for `VK_EXT_swapchain_maintenance1`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_swapchain_maintenance1 {
	vk_release_swapchain_images_ext: PFN_vkReleaseSwapchainImagesEXT,
}
impl VK_EXT_swapchain_maintenance1 for Vulkan_EXT_swapchain_maintenance1 {
	fn vkReleaseSwapchainImagesEXT(&self, device: VkDevice, pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR) -> Result<()> {
		convert_result("vkReleaseSwapchainImagesEXT", catch_unwind(||((self.vk_release_swapchain_images_ext)(device, pReleaseInfo))))
	}
}
impl Default for Vulkan_EXT_swapchain_maintenance1 {
	fn default() -> Self {
		Self {
			vk_release_swapchain_images_ext: dummy_vkReleaseSwapchainImagesEXT,
		}
	}
}
impl Vulkan_EXT_swapchain_maintenance1 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_release_swapchain_images_ext: {let proc = get_instance_proc_address(instance, "vkReleaseSwapchainImagesEXT"); if proc == null() {dummy_vkReleaseSwapchainImagesEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT` from VK_EXT_shader_demote_to_helper_invocation
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.html>
pub type VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures;
/// trait for `VK_EXT_shader_demote_to_helper_invocation`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_shader_demote_to_helper_invocation.html>
pub trait VK_EXT_shader_demote_to_helper_invocation: Debug {}
/// struct for `VK_EXT_shader_demote_to_helper_invocation`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_demote_to_helper_invocation {}
impl VK_EXT_shader_demote_to_helper_invocation for Vulkan_EXT_shader_demote_to_helper_invocation {}
impl Default for Vulkan_EXT_shader_demote_to_helper_invocation {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_demote_to_helper_invocation {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkIndirectStateFlagsNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectStateFlagsNV.html>
pub type VkIndirectStateFlagsNV = VkFlags;
/// type definition `VkIndirectCommandsLayoutUsageFlagsNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsLayoutUsageFlagsNV.html>
pub type VkIndirectCommandsLayoutUsageFlagsNV = VkFlags;
/// Non-dispatchable handle `VkIndirectCommandsLayoutNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsLayoutNV.html
#[cfg(target_pointer_width = "32")] pub type VkIndirectCommandsLayoutNV = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkIndirectCommandsLayoutNV_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkIndirectCommandsLayoutNV = *const VkIndirectCommandsLayoutNV_T;
/// enum `VkIndirectCommandsTokenTypeNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsTokenTypeNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkIndirectCommandsTokenTypeNV {
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = 0,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = 1,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = 2,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = 3,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = 4,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 5,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 6,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 7,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV = 1000328000,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV = 1000428003,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV = 1000428004,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkIndirectStateFlagBitsNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectStateFlagBitsNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkIndirectStateFlagBitsNV {
	VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV = 0x00000001,
	VK_INDIRECT_STATE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkIndirectCommandsLayoutUsageFlagBitsNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsLayoutUsageFlagBitsNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkIndirectCommandsLayoutUsageFlagBitsNV {
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV = 0x00000001,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV = 0x00000002,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV = 0x00000004,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
/// struct `VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxGraphicsShaderGroupCount: u32,
	pub maxIndirectSequenceCount: u32,
	pub maxIndirectCommandsTokenCount: u32,
	pub maxIndirectCommandsStreamCount: u32,
	pub maxIndirectCommandsTokenOffset: u32,
	pub maxIndirectCommandsStreamStride: u32,
	pub minSequencesCountBufferOffsetAlignment: u32,
	pub minSequencesIndexBufferOffsetAlignment: u32,
	pub minIndirectCommandsBufferOffsetAlignment: u32,
}
impl Debug for VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxGraphicsShaderGroupCount", &self.maxGraphicsShaderGroupCount)
		.field("maxIndirectSequenceCount", &self.maxIndirectSequenceCount)
		.field("maxIndirectCommandsTokenCount", &self.maxIndirectCommandsTokenCount)
		.field("maxIndirectCommandsStreamCount", &self.maxIndirectCommandsStreamCount)
		.field("maxIndirectCommandsTokenOffset", &self.maxIndirectCommandsTokenOffset)
		.field("maxIndirectCommandsStreamStride", &self.maxIndirectCommandsStreamStride)
		.field("minSequencesCountBufferOffsetAlignment", &self.minSequencesCountBufferOffsetAlignment)
		.field("minSequencesIndexBufferOffsetAlignment", &self.minSequencesIndexBufferOffsetAlignment)
		.field("minIndirectCommandsBufferOffsetAlignment", &self.minIndirectCommandsBufferOffsetAlignment)
		.finish()
	}
}
/// struct `VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceGeneratedCommands: VkBool32,
}
impl Debug for VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceGeneratedCommands", &self.deviceGeneratedCommands)
		.finish()
	}
}
/// struct `VkGraphicsShaderGroupCreateInfoNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGraphicsShaderGroupCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkGraphicsShaderGroupCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stageCount: u32,
	pub pStages: *const VkPipelineShaderStageCreateInfo,
	pub pVertexInputState: *const VkPipelineVertexInputStateCreateInfo,
	pub pTessellationState: *const VkPipelineTessellationStateCreateInfo,
}
impl Debug for VkGraphicsShaderGroupCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkGraphicsShaderGroupCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stageCount", &self.stageCount)
		.field("pStages", &self.pStages)
		.field("pVertexInputState", &self.pVertexInputState)
		.field("pTessellationState", &self.pTessellationState)
		.finish()
	}
}
/// struct `VkGraphicsPipelineShaderGroupsCreateInfoNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGraphicsPipelineShaderGroupsCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkGraphicsPipelineShaderGroupsCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub groupCount: u32,
	pub pGroups: *const VkGraphicsShaderGroupCreateInfoNV,
	pub pipelineCount: u32,
	pub pPipelines: *const VkPipeline,
}
impl Debug for VkGraphicsPipelineShaderGroupsCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkGraphicsPipelineShaderGroupsCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("groupCount", &self.groupCount)
		.field("pGroups", &self.pGroups)
		.field("pipelineCount", &self.pipelineCount)
		.field("pPipelines", &self.pPipelines)
		.finish()
	}
}
/// struct `VkBindShaderGroupIndirectCommandNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindShaderGroupIndirectCommandNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindShaderGroupIndirectCommandNV {
	pub groupIndex: u32,
}
impl Debug for VkBindShaderGroupIndirectCommandNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindShaderGroupIndirectCommandNV")
		.field("groupIndex", &self.groupIndex)
		.finish()
	}
}
/// struct `VkBindIndexBufferIndirectCommandNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindIndexBufferIndirectCommandNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindIndexBufferIndirectCommandNV {
	pub bufferAddress: VkDeviceAddress,
	pub size: u32,
	pub indexType: VkIndexType,
}
impl Debug for VkBindIndexBufferIndirectCommandNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindIndexBufferIndirectCommandNV")
		.field("bufferAddress", &self.bufferAddress)
		.field("size", &self.size)
		.field("indexType", &self.indexType)
		.finish()
	}
}
/// struct `VkBindVertexBufferIndirectCommandNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindVertexBufferIndirectCommandNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindVertexBufferIndirectCommandNV {
	pub bufferAddress: VkDeviceAddress,
	pub size: u32,
	pub stride: u32,
}
impl Debug for VkBindVertexBufferIndirectCommandNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindVertexBufferIndirectCommandNV")
		.field("bufferAddress", &self.bufferAddress)
		.field("size", &self.size)
		.field("stride", &self.stride)
		.finish()
	}
}
/// struct `VkSetStateFlagsIndirectCommandNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSetStateFlagsIndirectCommandNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSetStateFlagsIndirectCommandNV {
	pub data: u32,
}
impl Debug for VkSetStateFlagsIndirectCommandNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSetStateFlagsIndirectCommandNV")
		.field("data", &self.data)
		.finish()
	}
}
/// struct `VkIndirectCommandsStreamNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsStreamNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkIndirectCommandsStreamNV {
	pub buffer: VkBuffer,
	pub offset: VkDeviceSize,
}
impl Debug for VkIndirectCommandsStreamNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectCommandsStreamNV")
		.field("buffer", &self.buffer)
		.field("offset", &self.offset)
		.finish()
	}
}
/// struct `VkIndirectCommandsLayoutTokenNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsLayoutTokenNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkIndirectCommandsLayoutTokenNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tokenType: VkIndirectCommandsTokenTypeNV,
	pub stream: u32,
	pub offset: u32,
	pub vertexBindingUnit: u32,
	pub vertexDynamicStride: VkBool32,
	pub pushconstantPipelineLayout: VkPipelineLayout,
	pub pushconstantShaderStageFlags: VkShaderStageFlags,
	pub pushconstantOffset: u32,
	pub pushconstantSize: u32,
	pub indirectStateFlags: VkIndirectStateFlagsNV,
	pub indexTypeCount: u32,
	pub pIndexTypes: *const VkIndexType,
	pub pIndexTypeValues: *const uint32_t,
}
impl Debug for VkIndirectCommandsLayoutTokenNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectCommandsLayoutTokenNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tokenType", &self.tokenType)
		.field("stream", &self.stream)
		.field("offset", &self.offset)
		.field("vertexBindingUnit", &self.vertexBindingUnit)
		.field("vertexDynamicStride", &self.vertexDynamicStride)
		.field("pushconstantPipelineLayout", &self.pushconstantPipelineLayout)
		.field("pushconstantShaderStageFlags", &self.pushconstantShaderStageFlags)
		.field("pushconstantOffset", &self.pushconstantOffset)
		.field("pushconstantSize", &self.pushconstantSize)
		.field("indirectStateFlags", &self.indirectStateFlags)
		.field("indexTypeCount", &self.indexTypeCount)
		.field("pIndexTypes", &self.pIndexTypes)
		.field("pIndexTypeValues", &self.pIndexTypeValues)
		.finish()
	}
}
/// struct `VkIndirectCommandsLayoutCreateInfoNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsLayoutCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkIndirectCommandsLayoutCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkIndirectCommandsLayoutUsageFlagsNV,
	pub pipelineBindPoint: VkPipelineBindPoint,
	pub tokenCount: u32,
	pub pTokens: *const VkIndirectCommandsLayoutTokenNV,
	pub streamCount: u32,
	pub pStreamStrides: *const uint32_t,
}
impl Debug for VkIndirectCommandsLayoutCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectCommandsLayoutCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("pipelineBindPoint", &self.pipelineBindPoint)
		.field("tokenCount", &self.tokenCount)
		.field("pTokens", &self.pTokens)
		.field("streamCount", &self.streamCount)
		.field("pStreamStrides", &self.pStreamStrides)
		.finish()
	}
}
/// struct `VkGeneratedCommandsInfoNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeneratedCommandsInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkGeneratedCommandsInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pipelineBindPoint: VkPipelineBindPoint,
	pub pipeline: VkPipeline,
	pub indirectCommandsLayout: VkIndirectCommandsLayoutNV,
	pub streamCount: u32,
	pub pStreams: *const VkIndirectCommandsStreamNV,
	pub sequencesCount: u32,
	pub preprocessBuffer: VkBuffer,
	pub preprocessOffset: VkDeviceSize,
	pub preprocessSize: VkDeviceSize,
	pub sequencesCountBuffer: VkBuffer,
	pub sequencesCountOffset: VkDeviceSize,
	pub sequencesIndexBuffer: VkBuffer,
	pub sequencesIndexOffset: VkDeviceSize,
}
impl Debug for VkGeneratedCommandsInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkGeneratedCommandsInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelineBindPoint", &self.pipelineBindPoint)
		.field("pipeline", &self.pipeline)
		.field("indirectCommandsLayout", &self.indirectCommandsLayout)
		.field("streamCount", &self.streamCount)
		.field("pStreams", &self.pStreams)
		.field("sequencesCount", &self.sequencesCount)
		.field("preprocessBuffer", &self.preprocessBuffer)
		.field("preprocessOffset", &self.preprocessOffset)
		.field("preprocessSize", &self.preprocessSize)
		.field("sequencesCountBuffer", &self.sequencesCountBuffer)
		.field("sequencesCountOffset", &self.sequencesCountOffset)
		.field("sequencesIndexBuffer", &self.sequencesIndexBuffer)
		.field("sequencesIndexOffset", &self.sequencesIndexOffset)
		.finish()
	}
}
/// struct `VkGeneratedCommandsMemoryRequirementsInfoNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeneratedCommandsMemoryRequirementsInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkGeneratedCommandsMemoryRequirementsInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pipelineBindPoint: VkPipelineBindPoint,
	pub pipeline: VkPipeline,
	pub indirectCommandsLayout: VkIndirectCommandsLayoutNV,
	pub maxSequencesCount: u32,
}
impl Debug for VkGeneratedCommandsMemoryRequirementsInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkGeneratedCommandsMemoryRequirementsInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelineBindPoint", &self.pipelineBindPoint)
		.field("pipeline", &self.pipeline)
		.field("indirectCommandsLayout", &self.indirectCommandsLayout)
		.field("maxSequencesCount", &self.maxSequencesCount)
		.finish()
	}
}
/// function prototype `PFN_vkGetGeneratedCommandsMemoryRequirementsNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetGeneratedCommandsMemoryRequirementsNV.html>
type PFN_vkGetGeneratedCommandsMemoryRequirementsNV = extern "system" fn(device: VkDevice, pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoNV, pMemoryRequirements: *mut VkMemoryRequirements2);
/// function prototype `PFN_vkCmdPreprocessGeneratedCommandsNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPreprocessGeneratedCommandsNV.html>
type PFN_vkCmdPreprocessGeneratedCommandsNV = extern "system" fn(commandBuffer: VkCommandBuffer, pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoNV);
/// function prototype `PFN_vkCmdExecuteGeneratedCommandsNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdExecuteGeneratedCommandsNV.html>
type PFN_vkCmdExecuteGeneratedCommandsNV = extern "system" fn(commandBuffer: VkCommandBuffer, isPreprocessed: VkBool32, pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoNV);
/// function prototype `PFN_vkCmdBindPipelineShaderGroupNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindPipelineShaderGroupNV.html>
type PFN_vkCmdBindPipelineShaderGroupNV = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline, groupIndex: u32);
/// function prototype `PFN_vkCreateIndirectCommandsLayoutNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateIndirectCommandsLayoutNV.html>
type PFN_vkCreateIndirectCommandsLayoutNV = extern "system" fn(device: VkDevice, pCreateInfo: *const VkIndirectCommandsLayoutCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pIndirectCommandsLayout: *mut VkIndirectCommandsLayoutNV) -> VkResult;
/// function prototype `PFN_vkDestroyIndirectCommandsLayoutNV` from VK_NV_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyIndirectCommandsLayoutNV.html>
type PFN_vkDestroyIndirectCommandsLayoutNV = extern "system" fn(device: VkDevice, indirectCommandsLayout: VkIndirectCommandsLayoutNV, pAllocator: *const VkAllocationCallbacks);
/// The dummy function for `vkGetGeneratedCommandsMemoryRequirementsNV` from `VK_NV_device_generated_commands`
extern "system" fn dummy_vkGetGeneratedCommandsMemoryRequirementsNV(_: VkDevice, _: *const VkGeneratedCommandsMemoryRequirementsInfoNV, _: *mut VkMemoryRequirements2) {
	panic_any(VkError::NullFunctionPointer("vkGetGeneratedCommandsMemoryRequirementsNV"))
}
/// trait for `VK_NV_device_generated_commands`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_device_generated_commands.html>
pub trait VK_NV_device_generated_commands: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetGeneratedCommandsMemoryRequirementsNV.html>
	fn vkGetGeneratedCommandsMemoryRequirementsNV(&self, device: VkDevice, pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoNV, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()>;
}
/// struct for `VK_NV_device_generated_commands`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_device_generated_commands {
	vk_get_generated_commands_memory_requirements_nv: PFN_vkGetGeneratedCommandsMemoryRequirementsNV,
}
impl VK_NV_device_generated_commands for Vulkan_NV_device_generated_commands {
	fn vkGetGeneratedCommandsMemoryRequirementsNV(&self, device: VkDevice, pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoNV, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_generated_commands_memory_requirements_nv)(device, pInfo, pMemoryRequirements))))
	}
}
impl Default for Vulkan_NV_device_generated_commands {
	fn default() -> Self {
		Self {
			vk_get_generated_commands_memory_requirements_nv: dummy_vkGetGeneratedCommandsMemoryRequirementsNV,
		}
	}
}
impl Vulkan_NV_device_generated_commands {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_generated_commands_memory_requirements_nv: {let proc = get_instance_proc_address(instance, "vkGetGeneratedCommandsMemoryRequirementsNV"); if proc == null() {dummy_vkGetGeneratedCommandsMemoryRequirementsNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceInheritedViewportScissorFeaturesNV` from VK_NV_inherited_viewport_scissor
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceInheritedViewportScissorFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceInheritedViewportScissorFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub inheritedViewportScissor2D: VkBool32,
}
impl Debug for VkPhysicalDeviceInheritedViewportScissorFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceInheritedViewportScissorFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("inheritedViewportScissor2D", &self.inheritedViewportScissor2D)
		.finish()
	}
}
/// struct `VkCommandBufferInheritanceViewportScissorInfoNV` from VK_NV_inherited_viewport_scissor
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferInheritanceViewportScissorInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCommandBufferInheritanceViewportScissorInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub viewportScissor2D: VkBool32,
	pub viewportDepthCount: u32,
	pub pViewportDepths: *const VkViewport,
}
impl Debug for VkCommandBufferInheritanceViewportScissorInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCommandBufferInheritanceViewportScissorInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("viewportScissor2D", &self.viewportScissor2D)
		.field("viewportDepthCount", &self.viewportDepthCount)
		.field("pViewportDepths", &self.pViewportDepths)
		.finish()
	}
}
/// trait for `VK_NV_inherited_viewport_scissor`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_inherited_viewport_scissor.html>
pub trait VK_NV_inherited_viewport_scissor: Debug {}
/// struct for `VK_NV_inherited_viewport_scissor`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_inherited_viewport_scissor {}
impl VK_NV_inherited_viewport_scissor for Vulkan_NV_inherited_viewport_scissor {}
impl Default for Vulkan_NV_inherited_viewport_scissor {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_inherited_viewport_scissor {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT` from VK_EXT_texel_buffer_alignment
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.html>
pub type VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT = VkPhysicalDeviceTexelBufferAlignmentProperties;
/// struct `VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT` from VK_EXT_texel_buffer_alignment
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub texelBufferAlignment: VkBool32,
}
impl Debug for VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("texelBufferAlignment", &self.texelBufferAlignment)
		.finish()
	}
}
/// trait for `VK_EXT_texel_buffer_alignment`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_texel_buffer_alignment.html>
pub trait VK_EXT_texel_buffer_alignment: Debug {}
/// struct for `VK_EXT_texel_buffer_alignment`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_texel_buffer_alignment {}
impl VK_EXT_texel_buffer_alignment for Vulkan_EXT_texel_buffer_alignment {}
impl Default for Vulkan_EXT_texel_buffer_alignment {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_texel_buffer_alignment {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkRenderPassTransformBeginInfoQCOM` from VK_QCOM_render_pass_transform
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassTransformBeginInfoQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassTransformBeginInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub transform: VkSurfaceTransformFlagBitsKHR,
}
impl Debug for VkRenderPassTransformBeginInfoQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassTransformBeginInfoQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("transform", &self.transform)
		.finish()
	}
}
/// struct `VkCommandBufferInheritanceRenderPassTransformInfoQCOM` from VK_QCOM_render_pass_transform
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBufferInheritanceRenderPassTransformInfoQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCommandBufferInheritanceRenderPassTransformInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub transform: VkSurfaceTransformFlagBitsKHR,
	pub renderArea: VkRect2D,
}
impl Debug for VkCommandBufferInheritanceRenderPassTransformInfoQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCommandBufferInheritanceRenderPassTransformInfoQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("transform", &self.transform)
		.field("renderArea", &self.renderArea)
		.finish()
	}
}
/// trait for `VK_QCOM_render_pass_transform`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QCOM_render_pass_transform.html>
pub trait VK_QCOM_render_pass_transform: Debug {}
/// struct for `VK_QCOM_render_pass_transform`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_render_pass_transform {}
impl VK_QCOM_render_pass_transform for Vulkan_QCOM_render_pass_transform {}
impl Default for Vulkan_QCOM_render_pass_transform {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_render_pass_transform {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkDepthBiasRepresentationEXT` from VK_EXT_depth_bias_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDepthBiasRepresentationEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDepthBiasRepresentationEXT {
	VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT = 0,
	VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT = 1,
	VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT = 2,
	VK_DEPTH_BIAS_REPRESENTATION_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkPhysicalDeviceDepthBiasControlFeaturesEXT` from VK_EXT_depth_bias_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDepthBiasControlFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDepthBiasControlFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub depthBiasControl: VkBool32,
	pub leastRepresentableValueForceUnormRepresentation: VkBool32,
	pub floatRepresentation: VkBool32,
	pub depthBiasExact: VkBool32,
}
impl Debug for VkPhysicalDeviceDepthBiasControlFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDepthBiasControlFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("depthBiasControl", &self.depthBiasControl)
		.field("leastRepresentableValueForceUnormRepresentation", &self.leastRepresentableValueForceUnormRepresentation)
		.field("floatRepresentation", &self.floatRepresentation)
		.field("depthBiasExact", &self.depthBiasExact)
		.finish()
	}
}
/// struct `VkDepthBiasInfoEXT` from VK_EXT_depth_bias_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDepthBiasInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDepthBiasInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub depthBiasConstantFactor: f32,
	pub depthBiasClamp: f32,
	pub depthBiasSlopeFactor: f32,
}
impl Debug for VkDepthBiasInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDepthBiasInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("depthBiasConstantFactor", &self.depthBiasConstantFactor)
		.field("depthBiasClamp", &self.depthBiasClamp)
		.field("depthBiasSlopeFactor", &self.depthBiasSlopeFactor)
		.finish()
	}
}
/// struct `VkDepthBiasRepresentationInfoEXT` from VK_EXT_depth_bias_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDepthBiasRepresentationInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDepthBiasRepresentationInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub depthBiasRepresentation: VkDepthBiasRepresentationEXT,
	pub depthBiasExact: VkBool32,
}
impl Debug for VkDepthBiasRepresentationInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDepthBiasRepresentationInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("depthBiasRepresentation", &self.depthBiasRepresentation)
		.field("depthBiasExact", &self.depthBiasExact)
		.finish()
	}
}
/// function prototype `PFN_vkCmdSetDepthBias2EXT` from VK_EXT_depth_bias_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBias2EXT.html>
type PFN_vkCmdSetDepthBias2EXT = extern "system" fn(commandBuffer: VkCommandBuffer, pDepthBiasInfo: *const VkDepthBiasInfoEXT);
/// The dummy function for `vkCmdSetDepthBias2EXT` from `VK_EXT_depth_bias_control`
extern "system" fn dummy_vkCmdSetDepthBias2EXT(_: VkCommandBuffer, _: *const VkDepthBiasInfoEXT) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetDepthBias2EXT"))
}
/// trait for `VK_EXT_depth_bias_control`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_depth_bias_control.html>
pub trait VK_EXT_depth_bias_control: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBias2EXT.html>
	fn vkCmdSetDepthBias2EXT(&self, commandBuffer: VkCommandBuffer, pDepthBiasInfo: *const VkDepthBiasInfoEXT) -> Result<()>;
}
/// struct for `VK_EXT_depth_bias_control`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_depth_bias_control {
	vk_cmd_set_depth_bias2_ext: PFN_vkCmdSetDepthBias2EXT,
}
impl VK_EXT_depth_bias_control for Vulkan_EXT_depth_bias_control {
	fn vkCmdSetDepthBias2EXT(&self, commandBuffer: VkCommandBuffer, pDepthBiasInfo: *const VkDepthBiasInfoEXT) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_depth_bias2_ext)(commandBuffer, pDepthBiasInfo))))
	}
}
impl Default for Vulkan_EXT_depth_bias_control {
	fn default() -> Self {
		Self {
			vk_cmd_set_depth_bias2_ext: dummy_vkCmdSetDepthBias2EXT,
		}
	}
}
impl Vulkan_EXT_depth_bias_control {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_depth_bias2_ext: {let proc = get_instance_proc_address(instance, "vkCmdSetDepthBias2EXT"); if proc == null() {dummy_vkCmdSetDepthBias2EXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkDeviceMemoryReportFlagsEXT` from VK_EXT_device_memory_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceMemoryReportFlagsEXT.html>
pub type VkDeviceMemoryReportFlagsEXT = VkFlags;
/// enum `VkDeviceMemoryReportEventTypeEXT` from VK_EXT_device_memory_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceMemoryReportEventTypeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceMemoryReportEventTypeEXT {
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 1,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 2,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 3,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 4,
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkPhysicalDeviceDeviceMemoryReportFeaturesEXT` from VK_EXT_device_memory_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDeviceMemoryReportFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceMemoryReport: VkBool32,
}
impl Debug for VkPhysicalDeviceDeviceMemoryReportFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDeviceMemoryReportFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceMemoryReport", &self.deviceMemoryReport)
		.finish()
	}
}
/// struct `VkDeviceMemoryReportCallbackDataEXT` from VK_EXT_device_memory_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceMemoryReportCallbackDataEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceMemoryReportCallbackDataEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkDeviceMemoryReportFlagsEXT,
	pub type_: VkDeviceMemoryReportEventTypeEXT,
	pub memoryObjectId: u64,
	pub size: VkDeviceSize,
	pub objectType: VkObjectType,
	pub objectHandle: u64,
	pub heapIndex: u32,
}
impl Debug for VkDeviceMemoryReportCallbackDataEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceMemoryReportCallbackDataEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("type_", &self.type_)
		.field("memoryObjectId", &self.memoryObjectId)
		.field("size", &self.size)
		.field("objectType", &self.objectType)
		.field("objectHandle", &self.objectHandle)
		.field("heapIndex", &self.heapIndex)
		.finish()
	}
}
/// struct `VkDeviceDeviceMemoryReportCreateInfoEXT` from VK_EXT_device_memory_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceDeviceMemoryReportCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceDeviceMemoryReportCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDeviceMemoryReportFlagsEXT,
	pub pfnUserCallback: PFN_vkDeviceMemoryReportCallbackEXT,
	pub pUserData: *mut c_void,
}
impl Debug for VkDeviceDeviceMemoryReportCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceDeviceMemoryReportCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("pfnUserCallback", &self.pfnUserCallback)
		.field("pUserData", &self.pUserData)
		.finish()
	}
}
/// function prototype `PFN_vkDeviceMemoryReportCallbackEXT` from VK_EXT_device_memory_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDeviceMemoryReportCallbackEXT.html>
type PFN_vkDeviceMemoryReportCallbackEXT = extern "system" fn(pCallbackData: *const VkDeviceMemoryReportCallbackDataEXT, pUserData: *mut c_void);
/// trait for `VK_EXT_device_memory_report`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_device_memory_report.html>
pub trait VK_EXT_device_memory_report: Debug {}
/// struct for `VK_EXT_device_memory_report`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_device_memory_report {}
impl VK_EXT_device_memory_report for Vulkan_EXT_device_memory_report {}
impl Default for Vulkan_EXT_device_memory_report {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_device_memory_report {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// function prototype `PFN_vkAcquireDrmDisplayEXT` from VK_EXT_acquire_drm_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireDrmDisplayEXT.html>
type PFN_vkAcquireDrmDisplayEXT = extern "system" fn(physicalDevice: VkPhysicalDevice, drmFd: i32, display: VkDisplayKHR) -> VkResult;
/// function prototype `PFN_vkGetDrmDisplayEXT` from VK_EXT_acquire_drm_display
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDrmDisplayEXT.html>
type PFN_vkGetDrmDisplayEXT = extern "system" fn(physicalDevice: VkPhysicalDevice, drmFd: i32, connectorId: u32, display: *mut VkDisplayKHR) -> VkResult;
/// The dummy function for `vkAcquireDrmDisplayEXT` from `VK_EXT_acquire_drm_display`
extern "system" fn dummy_vkAcquireDrmDisplayEXT(_: VkPhysicalDevice, _: i32, _: VkDisplayKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkAcquireDrmDisplayEXT"))
}
/// trait for `VK_EXT_acquire_drm_display`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_acquire_drm_display.html>
pub trait VK_EXT_acquire_drm_display: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireDrmDisplayEXT.html>
	fn vkAcquireDrmDisplayEXT(&self, physicalDevice: VkPhysicalDevice, drmFd: i32, display: VkDisplayKHR) -> Result<()>;
}
/// struct for `VK_EXT_acquire_drm_display`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_acquire_drm_display {
	vk_acquire_drm_display_ext: PFN_vkAcquireDrmDisplayEXT,
}
impl VK_EXT_acquire_drm_display for Vulkan_EXT_acquire_drm_display {
	fn vkAcquireDrmDisplayEXT(&self, physicalDevice: VkPhysicalDevice, drmFd: i32, display: VkDisplayKHR) -> Result<()> {
		convert_result("vkAcquireDrmDisplayEXT", catch_unwind(||((self.vk_acquire_drm_display_ext)(physicalDevice, drmFd, display))))
	}
}
impl Default for Vulkan_EXT_acquire_drm_display {
	fn default() -> Self {
		Self {
			vk_acquire_drm_display_ext: dummy_vkAcquireDrmDisplayEXT,
		}
	}
}
impl Vulkan_EXT_acquire_drm_display {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_acquire_drm_display_ext: {let proc = get_instance_proc_address(instance, "vkAcquireDrmDisplayEXT"); if proc == null() {dummy_vkAcquireDrmDisplayEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceRobustness2FeaturesEXT` from VK_EXT_robustness2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRobustness2FeaturesEXT.html>
pub type VkPhysicalDeviceRobustness2FeaturesEXT = VkPhysicalDeviceRobustness2FeaturesKHR;
/// type definition `VkPhysicalDeviceRobustness2PropertiesEXT` from VK_EXT_robustness2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRobustness2PropertiesEXT.html>
pub type VkPhysicalDeviceRobustness2PropertiesEXT = VkPhysicalDeviceRobustness2PropertiesKHR;
/// trait for `VK_EXT_robustness2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_robustness2.html>
pub trait VK_EXT_robustness2: Debug {}
/// struct for `VK_EXT_robustness2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_robustness2 {}
impl VK_EXT_robustness2 for Vulkan_EXT_robustness2 {}
impl Default for Vulkan_EXT_robustness2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_robustness2 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkSamplerCustomBorderColorCreateInfoEXT` from VK_EXT_custom_border_color
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerCustomBorderColorCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSamplerCustomBorderColorCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub customBorderColor: VkClearColorValue,
	pub format: VkFormat,
}
impl Debug for VkSamplerCustomBorderColorCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSamplerCustomBorderColorCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("customBorderColor", &self.customBorderColor)
		.field("format", &self.format)
		.finish()
	}
}
/// struct `VkPhysicalDeviceCustomBorderColorPropertiesEXT` from VK_EXT_custom_border_color
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCustomBorderColorPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCustomBorderColorPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxCustomBorderColorSamplers: u32,
}
impl Debug for VkPhysicalDeviceCustomBorderColorPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCustomBorderColorPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxCustomBorderColorSamplers", &self.maxCustomBorderColorSamplers)
		.finish()
	}
}
/// struct `VkPhysicalDeviceCustomBorderColorFeaturesEXT` from VK_EXT_custom_border_color
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCustomBorderColorFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCustomBorderColorFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub customBorderColors: VkBool32,
	pub customBorderColorWithoutFormat: VkBool32,
}
impl Debug for VkPhysicalDeviceCustomBorderColorFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCustomBorderColorFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("customBorderColors", &self.customBorderColors)
		.field("customBorderColorWithoutFormat", &self.customBorderColorWithoutFormat)
		.finish()
	}
}
/// trait for `VK_EXT_custom_border_color`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_custom_border_color.html>
pub trait VK_EXT_custom_border_color: Debug {}
/// struct for `VK_EXT_custom_border_color`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_custom_border_color {}
impl VK_EXT_custom_border_color for Vulkan_EXT_custom_border_color {}
impl Default for Vulkan_EXT_custom_border_color {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_custom_border_color {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_GOOGLE_user_type`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_GOOGLE_user_type.html>
pub trait VK_GOOGLE_user_type: Debug {}
/// struct for `VK_GOOGLE_user_type`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_GOOGLE_user_type {}
impl VK_GOOGLE_user_type for Vulkan_GOOGLE_user_type {}
impl Default for Vulkan_GOOGLE_user_type {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_GOOGLE_user_type {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDevicePresentBarrierFeaturesNV` from VK_NV_present_barrier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePresentBarrierFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePresentBarrierFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentBarrier: VkBool32,
}
impl Debug for VkPhysicalDevicePresentBarrierFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePresentBarrierFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentBarrier", &self.presentBarrier)
		.finish()
	}
}
/// struct `VkSurfaceCapabilitiesPresentBarrierNV` from VK_NV_present_barrier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfaceCapabilitiesPresentBarrierNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSurfaceCapabilitiesPresentBarrierNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentBarrierSupported: VkBool32,
}
impl Debug for VkSurfaceCapabilitiesPresentBarrierNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSurfaceCapabilitiesPresentBarrierNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentBarrierSupported", &self.presentBarrierSupported)
		.finish()
	}
}
/// struct `VkSwapchainPresentBarrierCreateInfoNV` from VK_NV_present_barrier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainPresentBarrierCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSwapchainPresentBarrierCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentBarrierEnable: VkBool32,
}
impl Debug for VkSwapchainPresentBarrierCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSwapchainPresentBarrierCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentBarrierEnable", &self.presentBarrierEnable)
		.finish()
	}
}
/// trait for `VK_NV_present_barrier`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_present_barrier.html>
pub trait VK_NV_present_barrier: Debug {}
/// struct for `VK_NV_present_barrier`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_present_barrier {}
impl VK_NV_present_barrier for Vulkan_NV_present_barrier {}
impl Default for Vulkan_NV_present_barrier {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_present_barrier {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPrivateDataSlotEXT` from VK_EXT_private_data
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPrivateDataSlotEXT.html>
pub type VkPrivateDataSlotEXT = VkPrivateDataSlot;
/// type definition `VkPrivateDataSlotCreateFlagsEXT` from VK_EXT_private_data
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPrivateDataSlotCreateFlagsEXT.html>
pub type VkPrivateDataSlotCreateFlagsEXT = VkPrivateDataSlotCreateFlags;
/// type definition `VkPhysicalDevicePrivateDataFeaturesEXT` from VK_EXT_private_data
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePrivateDataFeaturesEXT.html>
pub type VkPhysicalDevicePrivateDataFeaturesEXT = VkPhysicalDevicePrivateDataFeatures;
/// type definition `VkDevicePrivateDataCreateInfoEXT` from VK_EXT_private_data
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDevicePrivateDataCreateInfoEXT.html>
pub type VkDevicePrivateDataCreateInfoEXT = VkDevicePrivateDataCreateInfo;
/// type definition `VkPrivateDataSlotCreateInfoEXT` from VK_EXT_private_data
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPrivateDataSlotCreateInfoEXT.html>
pub type VkPrivateDataSlotCreateInfoEXT = VkPrivateDataSlotCreateInfo;
/// function prototype `PFN_vkCreatePrivateDataSlotEXT` from VK_EXT_private_data
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePrivateDataSlotEXT.html>
type PFN_vkCreatePrivateDataSlotEXT = extern "system" fn(device: VkDevice, pCreateInfo: *const VkPrivateDataSlotCreateInfo, pAllocator: *const VkAllocationCallbacks, pPrivateDataSlot: *mut VkPrivateDataSlot) -> VkResult;
/// function prototype `PFN_vkDestroyPrivateDataSlotEXT` from VK_EXT_private_data
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPrivateDataSlotEXT.html>
type PFN_vkDestroyPrivateDataSlotEXT = extern "system" fn(device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkSetPrivateDataEXT` from VK_EXT_private_data
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetPrivateDataEXT.html>
type PFN_vkSetPrivateDataEXT = extern "system" fn(device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, data: u64) -> VkResult;
/// function prototype `PFN_vkGetPrivateDataEXT` from VK_EXT_private_data
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPrivateDataEXT.html>
type PFN_vkGetPrivateDataEXT = extern "system" fn(device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, pData: *mut uint64_t);
/// The dummy function for `vkCreatePrivateDataSlotEXT` from `VK_EXT_private_data`
extern "system" fn dummy_vkCreatePrivateDataSlotEXT(_: VkDevice, _: *const VkPrivateDataSlotCreateInfo, _: *const VkAllocationCallbacks, _: *mut VkPrivateDataSlot) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreatePrivateDataSlotEXT"))
}
/// trait for `VK_EXT_private_data`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_private_data.html>
pub trait VK_EXT_private_data: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePrivateDataSlotEXT.html>
	fn vkCreatePrivateDataSlotEXT(&self, device: VkDevice, pCreateInfo: *const VkPrivateDataSlotCreateInfo, pAllocator: *const VkAllocationCallbacks, pPrivateDataSlot: *mut VkPrivateDataSlot) -> Result<()>;
}
/// struct for `VK_EXT_private_data`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_private_data {
	vk_create_private_data_slot_ext: PFN_vkCreatePrivateDataSlotEXT,
}
impl VK_EXT_private_data for Vulkan_EXT_private_data {
	fn vkCreatePrivateDataSlotEXT(&self, device: VkDevice, pCreateInfo: *const VkPrivateDataSlotCreateInfo, pAllocator: *const VkAllocationCallbacks, pPrivateDataSlot: *mut VkPrivateDataSlot) -> Result<()> {
		convert_result("vkCreatePrivateDataSlotEXT", catch_unwind(||((self.vk_create_private_data_slot_ext)(device, pCreateInfo, pAllocator, pPrivateDataSlot))))
	}
}
impl Default for Vulkan_EXT_private_data {
	fn default() -> Self {
		Self {
			vk_create_private_data_slot_ext: dummy_vkCreatePrivateDataSlotEXT,
		}
	}
}
impl Vulkan_EXT_private_data {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_private_data_slot_ext: {let proc = get_instance_proc_address(instance, "vkCreatePrivateDataSlotEXT"); if proc == null() {dummy_vkCreatePrivateDataSlotEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT` from VK_EXT_pipeline_creation_cache_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT.html>
pub type VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT = VkPhysicalDevicePipelineCreationCacheControlFeatures;
/// trait for `VK_EXT_pipeline_creation_cache_control`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_pipeline_creation_cache_control.html>
pub trait VK_EXT_pipeline_creation_cache_control: Debug {}
/// struct for `VK_EXT_pipeline_creation_cache_control`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_pipeline_creation_cache_control {}
impl VK_EXT_pipeline_creation_cache_control for Vulkan_EXT_pipeline_creation_cache_control {}
impl Default for Vulkan_EXT_pipeline_creation_cache_control {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_pipeline_creation_cache_control {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkDeviceDiagnosticsConfigFlagsNV` from VK_NV_device_diagnostics_config
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceDiagnosticsConfigFlagsNV.html>
pub type VkDeviceDiagnosticsConfigFlagsNV = VkFlags;
/// enum `VkDeviceDiagnosticsConfigFlagBitsNV` from VK_NV_device_diagnostics_config
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceDiagnosticsConfigFlagBitsNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceDiagnosticsConfigFlagBitsNV {
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = 0x00000001,
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = 0x00000002,
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = 0x00000004,
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV = 0x00000008,
	VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
/// struct `VkPhysicalDeviceDiagnosticsConfigFeaturesNV` from VK_NV_device_diagnostics_config
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDiagnosticsConfigFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDiagnosticsConfigFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub diagnosticsConfig: VkBool32,
}
impl Debug for VkPhysicalDeviceDiagnosticsConfigFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDiagnosticsConfigFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("diagnosticsConfig", &self.diagnosticsConfig)
		.finish()
	}
}
/// struct `VkDeviceDiagnosticsConfigCreateInfoNV` from VK_NV_device_diagnostics_config
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceDiagnosticsConfigCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceDiagnosticsConfigCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDeviceDiagnosticsConfigFlagsNV,
}
impl Debug for VkDeviceDiagnosticsConfigCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceDiagnosticsConfigCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.finish()
	}
}
/// trait for `VK_NV_device_diagnostics_config`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_device_diagnostics_config.html>
pub trait VK_NV_device_diagnostics_config: Debug {}
/// struct for `VK_NV_device_diagnostics_config`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_device_diagnostics_config {}
impl VK_NV_device_diagnostics_config for Vulkan_NV_device_diagnostics_config {}
impl Default for Vulkan_NV_device_diagnostics_config {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_device_diagnostics_config {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_QCOM_render_pass_store_ops`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QCOM_render_pass_store_ops.html>
pub trait VK_QCOM_render_pass_store_ops: Debug {}
/// struct for `VK_QCOM_render_pass_store_ops`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_render_pass_store_ops {}
impl VK_QCOM_render_pass_store_ops for Vulkan_QCOM_render_pass_store_ops {}
impl Default for Vulkan_QCOM_render_pass_store_ops {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_render_pass_store_ops {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkTileShadingRenderPassFlagsQCOM` from VK_QCOM_tile_shading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTileShadingRenderPassFlagsQCOM.html>
pub type VkTileShadingRenderPassFlagsQCOM = VkFlags;
/// enum `VkTileShadingRenderPassFlagBitsQCOM` from VK_QCOM_tile_shading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTileShadingRenderPassFlagBitsQCOM.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkTileShadingRenderPassFlagBitsQCOM {
	VK_TILE_SHADING_RENDER_PASS_ENABLE_BIT_QCOM = 0x00000001,
	VK_TILE_SHADING_RENDER_PASS_PER_TILE_EXECUTION_BIT_QCOM = 0x00000002,
	VK_TILE_SHADING_RENDER_PASS_FLAG_BITS_MAX_ENUM_QCOM = 0x7fffffff,
}
/// struct `VkPhysicalDeviceTileShadingFeaturesQCOM` from VK_QCOM_tile_shading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTileShadingFeaturesQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceTileShadingFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub tileShading: VkBool32,
	pub tileShadingFragmentStage: VkBool32,
	pub tileShadingColorAttachments: VkBool32,
	pub tileShadingDepthAttachments: VkBool32,
	pub tileShadingStencilAttachments: VkBool32,
	pub tileShadingInputAttachments: VkBool32,
	pub tileShadingSampledAttachments: VkBool32,
	pub tileShadingPerTileDraw: VkBool32,
	pub tileShadingPerTileDispatch: VkBool32,
	pub tileShadingDispatchTile: VkBool32,
	pub tileShadingApron: VkBool32,
	pub tileShadingAnisotropicApron: VkBool32,
	pub tileShadingAtomicOps: VkBool32,
	pub tileShadingImageProcessing: VkBool32,
}
impl Debug for VkPhysicalDeviceTileShadingFeaturesQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceTileShadingFeaturesQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tileShading", &self.tileShading)
		.field("tileShadingFragmentStage", &self.tileShadingFragmentStage)
		.field("tileShadingColorAttachments", &self.tileShadingColorAttachments)
		.field("tileShadingDepthAttachments", &self.tileShadingDepthAttachments)
		.field("tileShadingStencilAttachments", &self.tileShadingStencilAttachments)
		.field("tileShadingInputAttachments", &self.tileShadingInputAttachments)
		.field("tileShadingSampledAttachments", &self.tileShadingSampledAttachments)
		.field("tileShadingPerTileDraw", &self.tileShadingPerTileDraw)
		.field("tileShadingPerTileDispatch", &self.tileShadingPerTileDispatch)
		.field("tileShadingDispatchTile", &self.tileShadingDispatchTile)
		.field("tileShadingApron", &self.tileShadingApron)
		.field("tileShadingAnisotropicApron", &self.tileShadingAnisotropicApron)
		.field("tileShadingAtomicOps", &self.tileShadingAtomicOps)
		.field("tileShadingImageProcessing", &self.tileShadingImageProcessing)
		.finish()
	}
}
/// struct `VkPhysicalDeviceTileShadingPropertiesQCOM` from VK_QCOM_tile_shading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTileShadingPropertiesQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceTileShadingPropertiesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxApronSize: u32,
	pub preferNonCoherent: VkBool32,
	pub tileGranularity: VkExtent2D,
	pub maxTileShadingRate: VkExtent2D,
}
impl Debug for VkPhysicalDeviceTileShadingPropertiesQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceTileShadingPropertiesQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxApronSize", &self.maxApronSize)
		.field("preferNonCoherent", &self.preferNonCoherent)
		.field("tileGranularity", &self.tileGranularity)
		.field("maxTileShadingRate", &self.maxTileShadingRate)
		.finish()
	}
}
/// struct `VkRenderPassTileShadingCreateInfoQCOM` from VK_QCOM_tile_shading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassTileShadingCreateInfoQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassTileShadingCreateInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkTileShadingRenderPassFlagsQCOM,
	pub tileApronSize: VkExtent2D,
}
impl Debug for VkRenderPassTileShadingCreateInfoQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassTileShadingCreateInfoQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("tileApronSize", &self.tileApronSize)
		.finish()
	}
}
/// struct `VkPerTileBeginInfoQCOM` from VK_QCOM_tile_shading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerTileBeginInfoQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPerTileBeginInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
}
impl Debug for VkPerTileBeginInfoQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPerTileBeginInfoQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.finish()
	}
}
/// struct `VkPerTileEndInfoQCOM` from VK_QCOM_tile_shading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerTileEndInfoQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPerTileEndInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
}
impl Debug for VkPerTileEndInfoQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPerTileEndInfoQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.finish()
	}
}
/// struct `VkDispatchTileInfoQCOM` from VK_QCOM_tile_shading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDispatchTileInfoQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDispatchTileInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
}
impl Debug for VkDispatchTileInfoQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDispatchTileInfoQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.finish()
	}
}
/// function prototype `PFN_vkCmdDispatchTileQCOM` from VK_QCOM_tile_shading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchTileQCOM.html>
type PFN_vkCmdDispatchTileQCOM = extern "system" fn(commandBuffer: VkCommandBuffer, pDispatchTileInfo: *const VkDispatchTileInfoQCOM);
/// function prototype `PFN_vkCmdBeginPerTileExecutionQCOM` from VK_QCOM_tile_shading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginPerTileExecutionQCOM.html>
type PFN_vkCmdBeginPerTileExecutionQCOM = extern "system" fn(commandBuffer: VkCommandBuffer, pPerTileBeginInfo: *const VkPerTileBeginInfoQCOM);
/// function prototype `PFN_vkCmdEndPerTileExecutionQCOM` from VK_QCOM_tile_shading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndPerTileExecutionQCOM.html>
type PFN_vkCmdEndPerTileExecutionQCOM = extern "system" fn(commandBuffer: VkCommandBuffer, pPerTileEndInfo: *const VkPerTileEndInfoQCOM);
/// The dummy function for `vkCmdDispatchTileQCOM` from `VK_QCOM_tile_shading`
extern "system" fn dummy_vkCmdDispatchTileQCOM(_: VkCommandBuffer, _: *const VkDispatchTileInfoQCOM) {
	panic_any(VkError::NullFunctionPointer("vkCmdDispatchTileQCOM"))
}
/// trait for `VK_QCOM_tile_shading`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QCOM_tile_shading.html>
pub trait VK_QCOM_tile_shading: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchTileQCOM.html>
	fn vkCmdDispatchTileQCOM(&self, commandBuffer: VkCommandBuffer, pDispatchTileInfo: *const VkDispatchTileInfoQCOM) -> Result<()>;
}
/// struct for `VK_QCOM_tile_shading`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_tile_shading {
	vk_cmd_dispatch_tile_qcom: PFN_vkCmdDispatchTileQCOM,
}
impl VK_QCOM_tile_shading for Vulkan_QCOM_tile_shading {
	fn vkCmdDispatchTileQCOM(&self, commandBuffer: VkCommandBuffer, pDispatchTileInfo: *const VkDispatchTileInfoQCOM) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_dispatch_tile_qcom)(commandBuffer, pDispatchTileInfo))))
	}
}
impl Default for Vulkan_QCOM_tile_shading {
	fn default() -> Self {
		Self {
			vk_cmd_dispatch_tile_qcom: dummy_vkCmdDispatchTileQCOM,
		}
	}
}
impl Vulkan_QCOM_tile_shading {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_dispatch_tile_qcom: {let proc = get_instance_proc_address(instance, "vkCmdDispatchTileQCOM"); if proc == null() {dummy_vkCmdDispatchTileQCOM} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkQueryLowLatencySupportNV` from VK_NV_low_latency
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryLowLatencySupportNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkQueryLowLatencySupportNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pQueriedLowLatencyData: *mut c_void,
}
impl Debug for VkQueryLowLatencySupportNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkQueryLowLatencySupportNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pQueriedLowLatencyData", &self.pQueriedLowLatencyData)
		.finish()
	}
}
/// trait for `VK_NV_low_latency`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_low_latency.html>
pub trait VK_NV_low_latency: Debug {}
/// struct for `VK_NV_low_latency`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_low_latency {}
impl VK_NV_low_latency for Vulkan_NV_low_latency {}
impl Default for Vulkan_NV_low_latency {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_low_latency {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// Non-dispatchable handle `VkAccelerationStructureKHR` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureKHR.html
#[cfg(target_pointer_width = "32")] pub type VkAccelerationStructureKHR = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkAccelerationStructureKHR_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkAccelerationStructureKHR = *const VkAccelerationStructureKHR_T;
/// union `VkDescriptorDataEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorDataEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkDescriptorDataEXT {
	pub pSampler: *const VkSampler,
	pub pCombinedImageSampler: *const VkDescriptorImageInfo,
	pub pInputAttachmentImage: *const VkDescriptorImageInfo,
	pub pSampledImage: *const VkDescriptorImageInfo,
	pub pStorageImage: *const VkDescriptorImageInfo,
	pub pUniformTexelBuffer: *const VkDescriptorAddressInfoEXT,
	pub pStorageTexelBuffer: *const VkDescriptorAddressInfoEXT,
	pub pUniformBuffer: *const VkDescriptorAddressInfoEXT,
	pub pStorageBuffer: *const VkDescriptorAddressInfoEXT,
	pub accelerationStructure: VkDeviceAddress,
}
impl Debug for VkDescriptorDataEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorDataEXT")
		.field("pSampler", unsafe {&self.pSampler})
		.field("pCombinedImageSampler", unsafe {&self.pCombinedImageSampler})
		.field("pInputAttachmentImage", unsafe {&self.pInputAttachmentImage})
		.field("pSampledImage", unsafe {&self.pSampledImage})
		.field("pStorageImage", unsafe {&self.pStorageImage})
		.field("pUniformTexelBuffer", unsafe {&self.pUniformTexelBuffer})
		.field("pStorageTexelBuffer", unsafe {&self.pStorageTexelBuffer})
		.field("pUniformBuffer", unsafe {&self.pUniformBuffer})
		.field("pStorageBuffer", unsafe {&self.pStorageBuffer})
		.field("accelerationStructure", unsafe {&self.accelerationStructure})
		.finish()
	}
}
/// struct `VkPhysicalDeviceDescriptorBufferPropertiesEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDescriptorBufferPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorBufferPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub combinedImageSamplerDescriptorSingleArray: VkBool32,
	pub bufferlessPushDescriptors: VkBool32,
	pub allowSamplerImageViewPostSubmitCreation: VkBool32,
	pub descriptorBufferOffsetAlignment: VkDeviceSize,
	pub maxDescriptorBufferBindings: u32,
	pub maxResourceDescriptorBufferBindings: u32,
	pub maxSamplerDescriptorBufferBindings: u32,
	pub maxEmbeddedImmutableSamplerBindings: u32,
	pub maxEmbeddedImmutableSamplers: u32,
	pub bufferCaptureReplayDescriptorDataSize: usize,
	pub imageCaptureReplayDescriptorDataSize: usize,
	pub imageViewCaptureReplayDescriptorDataSize: usize,
	pub samplerCaptureReplayDescriptorDataSize: usize,
	pub accelerationStructureCaptureReplayDescriptorDataSize: usize,
	pub samplerDescriptorSize: usize,
	pub combinedImageSamplerDescriptorSize: usize,
	pub sampledImageDescriptorSize: usize,
	pub storageImageDescriptorSize: usize,
	pub uniformTexelBufferDescriptorSize: usize,
	pub robustUniformTexelBufferDescriptorSize: usize,
	pub storageTexelBufferDescriptorSize: usize,
	pub robustStorageTexelBufferDescriptorSize: usize,
	pub uniformBufferDescriptorSize: usize,
	pub robustUniformBufferDescriptorSize: usize,
	pub storageBufferDescriptorSize: usize,
	pub robustStorageBufferDescriptorSize: usize,
	pub inputAttachmentDescriptorSize: usize,
	pub accelerationStructureDescriptorSize: usize,
	pub maxSamplerDescriptorBufferRange: VkDeviceSize,
	pub maxResourceDescriptorBufferRange: VkDeviceSize,
	pub samplerDescriptorBufferAddressSpaceSize: VkDeviceSize,
	pub resourceDescriptorBufferAddressSpaceSize: VkDeviceSize,
	pub descriptorBufferAddressSpaceSize: VkDeviceSize,
}
impl Debug for VkPhysicalDeviceDescriptorBufferPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDescriptorBufferPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("combinedImageSamplerDescriptorSingleArray", &self.combinedImageSamplerDescriptorSingleArray)
		.field("bufferlessPushDescriptors", &self.bufferlessPushDescriptors)
		.field("allowSamplerImageViewPostSubmitCreation", &self.allowSamplerImageViewPostSubmitCreation)
		.field("descriptorBufferOffsetAlignment", &self.descriptorBufferOffsetAlignment)
		.field("maxDescriptorBufferBindings", &self.maxDescriptorBufferBindings)
		.field("maxResourceDescriptorBufferBindings", &self.maxResourceDescriptorBufferBindings)
		.field("maxSamplerDescriptorBufferBindings", &self.maxSamplerDescriptorBufferBindings)
		.field("maxEmbeddedImmutableSamplerBindings", &self.maxEmbeddedImmutableSamplerBindings)
		.field("maxEmbeddedImmutableSamplers", &self.maxEmbeddedImmutableSamplers)
		.field("bufferCaptureReplayDescriptorDataSize", &self.bufferCaptureReplayDescriptorDataSize)
		.field("imageCaptureReplayDescriptorDataSize", &self.imageCaptureReplayDescriptorDataSize)
		.field("imageViewCaptureReplayDescriptorDataSize", &self.imageViewCaptureReplayDescriptorDataSize)
		.field("samplerCaptureReplayDescriptorDataSize", &self.samplerCaptureReplayDescriptorDataSize)
		.field("accelerationStructureCaptureReplayDescriptorDataSize", &self.accelerationStructureCaptureReplayDescriptorDataSize)
		.field("samplerDescriptorSize", &self.samplerDescriptorSize)
		.field("combinedImageSamplerDescriptorSize", &self.combinedImageSamplerDescriptorSize)
		.field("sampledImageDescriptorSize", &self.sampledImageDescriptorSize)
		.field("storageImageDescriptorSize", &self.storageImageDescriptorSize)
		.field("uniformTexelBufferDescriptorSize", &self.uniformTexelBufferDescriptorSize)
		.field("robustUniformTexelBufferDescriptorSize", &self.robustUniformTexelBufferDescriptorSize)
		.field("storageTexelBufferDescriptorSize", &self.storageTexelBufferDescriptorSize)
		.field("robustStorageTexelBufferDescriptorSize", &self.robustStorageTexelBufferDescriptorSize)
		.field("uniformBufferDescriptorSize", &self.uniformBufferDescriptorSize)
		.field("robustUniformBufferDescriptorSize", &self.robustUniformBufferDescriptorSize)
		.field("storageBufferDescriptorSize", &self.storageBufferDescriptorSize)
		.field("robustStorageBufferDescriptorSize", &self.robustStorageBufferDescriptorSize)
		.field("inputAttachmentDescriptorSize", &self.inputAttachmentDescriptorSize)
		.field("accelerationStructureDescriptorSize", &self.accelerationStructureDescriptorSize)
		.field("maxSamplerDescriptorBufferRange", &self.maxSamplerDescriptorBufferRange)
		.field("maxResourceDescriptorBufferRange", &self.maxResourceDescriptorBufferRange)
		.field("samplerDescriptorBufferAddressSpaceSize", &self.samplerDescriptorBufferAddressSpaceSize)
		.field("resourceDescriptorBufferAddressSpaceSize", &self.resourceDescriptorBufferAddressSpaceSize)
		.field("descriptorBufferAddressSpaceSize", &self.descriptorBufferAddressSpaceSize)
		.finish()
	}
}
/// struct `VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub combinedImageSamplerDensityMapDescriptorSize: usize,
}
impl Debug for VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("combinedImageSamplerDensityMapDescriptorSize", &self.combinedImageSamplerDensityMapDescriptorSize)
		.finish()
	}
}
/// struct `VkPhysicalDeviceDescriptorBufferFeaturesEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDescriptorBufferFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorBufferFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub descriptorBuffer: VkBool32,
	pub descriptorBufferCaptureReplay: VkBool32,
	pub descriptorBufferImageLayoutIgnored: VkBool32,
	pub descriptorBufferPushDescriptors: VkBool32,
}
impl Debug for VkPhysicalDeviceDescriptorBufferFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDescriptorBufferFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("descriptorBuffer", &self.descriptorBuffer)
		.field("descriptorBufferCaptureReplay", &self.descriptorBufferCaptureReplay)
		.field("descriptorBufferImageLayoutIgnored", &self.descriptorBufferImageLayoutIgnored)
		.field("descriptorBufferPushDescriptors", &self.descriptorBufferPushDescriptors)
		.finish()
	}
}
/// struct `VkDescriptorAddressInfoEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorAddressInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorAddressInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub address: VkDeviceAddress,
	pub range: VkDeviceSize,
	pub format: VkFormat,
}
impl Debug for VkDescriptorAddressInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorAddressInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("address", &self.address)
		.field("range", &self.range)
		.field("format", &self.format)
		.finish()
	}
}
/// struct `VkDescriptorBufferBindingInfoEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorBufferBindingInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorBufferBindingInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub address: VkDeviceAddress,
	pub usage: VkBufferUsageFlags,
}
impl Debug for VkDescriptorBufferBindingInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorBufferBindingInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("address", &self.address)
		.field("usage", &self.usage)
		.finish()
	}
}
/// struct `VkDescriptorBufferBindingPushDescriptorBufferHandleEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorBufferBindingPushDescriptorBufferHandleEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorBufferBindingPushDescriptorBufferHandleEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub buffer: VkBuffer,
}
impl Debug for VkDescriptorBufferBindingPushDescriptorBufferHandleEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorBufferBindingPushDescriptorBufferHandleEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("buffer", &self.buffer)
		.finish()
	}
}
/// struct `VkDescriptorGetInfoEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorGetInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorGetInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkDescriptorType,
	pub data: VkDescriptorDataEXT,
}
impl Debug for VkDescriptorGetInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorGetInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("type_", &self.type_)
		.field("data", &self.data)
		.finish()
	}
}
/// struct `VkBufferCaptureDescriptorDataInfoEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferCaptureDescriptorDataInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBufferCaptureDescriptorDataInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub buffer: VkBuffer,
}
impl Debug for VkBufferCaptureDescriptorDataInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBufferCaptureDescriptorDataInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("buffer", &self.buffer)
		.finish()
	}
}
/// struct `VkImageCaptureDescriptorDataInfoEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCaptureDescriptorDataInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageCaptureDescriptorDataInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub image: VkImage,
}
impl Debug for VkImageCaptureDescriptorDataInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageCaptureDescriptorDataInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("image", &self.image)
		.finish()
	}
}
/// struct `VkImageViewCaptureDescriptorDataInfoEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageViewCaptureDescriptorDataInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageViewCaptureDescriptorDataInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub imageView: VkImageView,
}
impl Debug for VkImageViewCaptureDescriptorDataInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageViewCaptureDescriptorDataInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("imageView", &self.imageView)
		.finish()
	}
}
/// struct `VkSamplerCaptureDescriptorDataInfoEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerCaptureDescriptorDataInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSamplerCaptureDescriptorDataInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub sampler: VkSampler,
}
impl Debug for VkSamplerCaptureDescriptorDataInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSamplerCaptureDescriptorDataInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("sampler", &self.sampler)
		.finish()
	}
}
/// struct `VkOpaqueCaptureDescriptorDataCreateInfoEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpaqueCaptureDescriptorDataCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkOpaqueCaptureDescriptorDataCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub opaqueCaptureDescriptorData: *const c_void,
}
impl Debug for VkOpaqueCaptureDescriptorDataCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkOpaqueCaptureDescriptorDataCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("opaqueCaptureDescriptorData", &self.opaqueCaptureDescriptorData)
		.finish()
	}
}
/// struct `VkAccelerationStructureCaptureDescriptorDataInfoEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureCaptureDescriptorDataInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureCaptureDescriptorDataInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub accelerationStructure: VkAccelerationStructureKHR,
	pub accelerationStructureNV: VkAccelerationStructureNV,
}
impl Debug for VkAccelerationStructureCaptureDescriptorDataInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureCaptureDescriptorDataInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("accelerationStructure", &self.accelerationStructure)
		.field("accelerationStructureNV", &self.accelerationStructureNV)
		.finish()
	}
}
/// function prototype `PFN_vkGetDescriptorSetLayoutSizeEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutSizeEXT.html>
type PFN_vkGetDescriptorSetLayoutSizeEXT = extern "system" fn(device: VkDevice, layout: VkDescriptorSetLayout, pLayoutSizeInBytes: *mut VkDeviceSize);
/// function prototype `PFN_vkGetDescriptorSetLayoutBindingOffsetEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutBindingOffsetEXT.html>
type PFN_vkGetDescriptorSetLayoutBindingOffsetEXT = extern "system" fn(device: VkDevice, layout: VkDescriptorSetLayout, binding: u32, pOffset: *mut VkDeviceSize);
/// function prototype `PFN_vkGetDescriptorEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorEXT.html>
type PFN_vkGetDescriptorEXT = extern "system" fn(device: VkDevice, pDescriptorInfo: *const VkDescriptorGetInfoEXT, dataSize: usize, pDescriptor: *mut c_void);
/// function prototype `PFN_vkCmdBindDescriptorBuffersEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorBuffersEXT.html>
type PFN_vkCmdBindDescriptorBuffersEXT = extern "system" fn(commandBuffer: VkCommandBuffer, bufferCount: u32, pBindingInfos: *const VkDescriptorBufferBindingInfoEXT);
/// function prototype `PFN_vkCmdSetDescriptorBufferOffsetsEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDescriptorBufferOffsetsEXT.html>
type PFN_vkCmdSetDescriptorBufferOffsetsEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: u32, setCount: u32, pBufferIndices: *const uint32_t, pOffsets: *const VkDeviceSize);
/// function prototype `PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorBufferEmbeddedSamplersEXT.html>
type PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32);
/// function prototype `PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferOpaqueCaptureDescriptorDataEXT.html>
type PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT = extern "system" fn(device: VkDevice, pInfo: *const VkBufferCaptureDescriptorDataInfoEXT, pData: *mut c_void) -> VkResult;
/// function prototype `PFN_vkGetImageOpaqueCaptureDescriptorDataEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageOpaqueCaptureDescriptorDataEXT.html>
type PFN_vkGetImageOpaqueCaptureDescriptorDataEXT = extern "system" fn(device: VkDevice, pInfo: *const VkImageCaptureDescriptorDataInfoEXT, pData: *mut c_void) -> VkResult;
/// function prototype `PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageViewOpaqueCaptureDescriptorDataEXT.html>
type PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT = extern "system" fn(device: VkDevice, pInfo: *const VkImageViewCaptureDescriptorDataInfoEXT, pData: *mut c_void) -> VkResult;
/// function prototype `PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSamplerOpaqueCaptureDescriptorDataEXT.html>
type PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT = extern "system" fn(device: VkDevice, pInfo: *const VkSamplerCaptureDescriptorDataInfoEXT, pData: *mut c_void) -> VkResult;
/// function prototype `PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT` from VK_EXT_descriptor_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT.html>
type PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = extern "system" fn(device: VkDevice, pInfo: *const VkAccelerationStructureCaptureDescriptorDataInfoEXT, pData: *mut c_void) -> VkResult;
/// The dummy function for `vkGetDescriptorSetLayoutSizeEXT` from `VK_EXT_descriptor_buffer`
extern "system" fn dummy_vkGetDescriptorSetLayoutSizeEXT(_: VkDevice, _: VkDescriptorSetLayout, _: *mut VkDeviceSize) {
	panic_any(VkError::NullFunctionPointer("vkGetDescriptorSetLayoutSizeEXT"))
}
/// trait for `VK_EXT_descriptor_buffer`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_descriptor_buffer.html>
pub trait VK_EXT_descriptor_buffer: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutSizeEXT.html>
	fn vkGetDescriptorSetLayoutSizeEXT(&self, device: VkDevice, layout: VkDescriptorSetLayout, pLayoutSizeInBytes: *mut VkDeviceSize) -> Result<()>;
}
/// struct for `VK_EXT_descriptor_buffer`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_descriptor_buffer {
	vk_get_descriptor_set_layout_size_ext: PFN_vkGetDescriptorSetLayoutSizeEXT,
}
impl VK_EXT_descriptor_buffer for Vulkan_EXT_descriptor_buffer {
	fn vkGetDescriptorSetLayoutSizeEXT(&self, device: VkDevice, layout: VkDescriptorSetLayout, pLayoutSizeInBytes: *mut VkDeviceSize) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_descriptor_set_layout_size_ext)(device, layout, pLayoutSizeInBytes))))
	}
}
impl Default for Vulkan_EXT_descriptor_buffer {
	fn default() -> Self {
		Self {
			vk_get_descriptor_set_layout_size_ext: dummy_vkGetDescriptorSetLayoutSizeEXT,
		}
	}
}
impl Vulkan_EXT_descriptor_buffer {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_descriptor_set_layout_size_ext: {let proc = get_instance_proc_address(instance, "vkGetDescriptorSetLayoutSizeEXT"); if proc == null() {dummy_vkGetDescriptorSetLayoutSizeEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkGraphicsPipelineLibraryFlagsEXT` from VK_EXT_graphics_pipeline_library
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGraphicsPipelineLibraryFlagsEXT.html>
pub type VkGraphicsPipelineLibraryFlagsEXT = VkFlags;
/// enum `VkGraphicsPipelineLibraryFlagBitsEXT` from VK_EXT_graphics_pipeline_library
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGraphicsPipelineLibraryFlagBitsEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkGraphicsPipelineLibraryFlagBitsEXT {
	VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT = 0x00000001,
	VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT = 0x00000002,
	VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT = 0x00000004,
	VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT = 0x00000008,
	VK_GRAPHICS_PIPELINE_LIBRARY_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT` from VK_EXT_graphics_pipeline_library
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub graphicsPipelineLibrary: VkBool32,
}
impl Debug for VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("graphicsPipelineLibrary", &self.graphicsPipelineLibrary)
		.finish()
	}
}
/// struct `VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT` from VK_EXT_graphics_pipeline_library
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub graphicsPipelineLibraryFastLinking: VkBool32,
	pub graphicsPipelineLibraryIndependentInterpolationDecoration: VkBool32,
}
impl Debug for VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("graphicsPipelineLibraryFastLinking", &self.graphicsPipelineLibraryFastLinking)
		.field("graphicsPipelineLibraryIndependentInterpolationDecoration", &self.graphicsPipelineLibraryIndependentInterpolationDecoration)
		.finish()
	}
}
/// struct `VkGraphicsPipelineLibraryCreateInfoEXT` from VK_EXT_graphics_pipeline_library
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGraphicsPipelineLibraryCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkGraphicsPipelineLibraryCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkGraphicsPipelineLibraryFlagsEXT,
}
impl Debug for VkGraphicsPipelineLibraryCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkGraphicsPipelineLibraryCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.finish()
	}
}
/// trait for `VK_EXT_graphics_pipeline_library`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_graphics_pipeline_library.html>
pub trait VK_EXT_graphics_pipeline_library: Debug {}
/// struct for `VK_EXT_graphics_pipeline_library`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_graphics_pipeline_library {}
impl VK_EXT_graphics_pipeline_library for Vulkan_EXT_graphics_pipeline_library {}
impl Default for Vulkan_EXT_graphics_pipeline_library {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_graphics_pipeline_library {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD` from VK_AMD_shader_early_and_late_fragment_tests
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderEarlyAndLateFragmentTests: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderEarlyAndLateFragmentTests", &self.shaderEarlyAndLateFragmentTests)
		.finish()
	}
}
/// trait for `VK_AMD_shader_early_and_late_fragment_tests`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_shader_early_and_late_fragment_tests.html>
pub trait VK_AMD_shader_early_and_late_fragment_tests: Debug {}
/// struct for `VK_AMD_shader_early_and_late_fragment_tests`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_shader_early_and_late_fragment_tests {}
impl VK_AMD_shader_early_and_late_fragment_tests for Vulkan_AMD_shader_early_and_late_fragment_tests {}
impl Default for Vulkan_AMD_shader_early_and_late_fragment_tests {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_AMD_shader_early_and_late_fragment_tests {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkFragmentShadingRateTypeNV` from VK_NV_fragment_shading_rate_enums
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFragmentShadingRateTypeNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFragmentShadingRateTypeNV {
	VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = 0,
	VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = 1,
	VK_FRAGMENT_SHADING_RATE_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkFragmentShadingRateNV` from VK_NV_fragment_shading_rate_enums
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFragmentShadingRateNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFragmentShadingRateNV {
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 1,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 4,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 5,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 6,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 10,
	VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 11,
	VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 12,
	VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 13,
	VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 14,
	VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = 15,
	VK_FRAGMENT_SHADING_RATE_MAX_ENUM_NV = 0x7fffffff,
}
/// struct `VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV` from VK_NV_fragment_shading_rate_enums
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub fragmentShadingRateEnums: VkBool32,
	pub supersampleFragmentShadingRates: VkBool32,
	pub noInvocationFragmentShadingRates: VkBool32,
}
impl Debug for VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("fragmentShadingRateEnums", &self.fragmentShadingRateEnums)
		.field("supersampleFragmentShadingRates", &self.supersampleFragmentShadingRates)
		.field("noInvocationFragmentShadingRates", &self.noInvocationFragmentShadingRates)
		.finish()
	}
}
/// struct `VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV` from VK_NV_fragment_shading_rate_enums
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxFragmentShadingRateInvocationCount: VkSampleCountFlagBits,
}
impl Debug for VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxFragmentShadingRateInvocationCount", &self.maxFragmentShadingRateInvocationCount)
		.finish()
	}
}
/// struct `VkPipelineFragmentShadingRateEnumStateCreateInfoNV` from VK_NV_fragment_shading_rate_enums
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineFragmentShadingRateEnumStateCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineFragmentShadingRateEnumStateCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub shadingRateType: VkFragmentShadingRateTypeNV,
	pub shadingRate: VkFragmentShadingRateNV,
	pub combinerOps: [VkFragmentShadingRateCombinerOpKHR; 2 as usize],
}
impl Debug for VkPipelineFragmentShadingRateEnumStateCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineFragmentShadingRateEnumStateCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shadingRateType", &self.shadingRateType)
		.field("shadingRate", &self.shadingRate)
		.field("combinerOps", &self.combinerOps)
		.finish()
	}
}
/// function prototype `PFN_vkCmdSetFragmentShadingRateEnumNV` from VK_NV_fragment_shading_rate_enums
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetFragmentShadingRateEnumNV.html>
type PFN_vkCmdSetFragmentShadingRateEnumNV = extern "system" fn(commandBuffer: VkCommandBuffer, shadingRate: VkFragmentShadingRateNV, combinerOps: &[VkFragmentShadingRateCombinerOpKHR; 2 as usize]);
/// The dummy function for `vkCmdSetFragmentShadingRateEnumNV` from `VK_NV_fragment_shading_rate_enums`
extern "system" fn dummy_vkCmdSetFragmentShadingRateEnumNV(_: VkCommandBuffer, _: VkFragmentShadingRateNV, _: &[VkFragmentShadingRateCombinerOpKHR; 2 as usize]) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetFragmentShadingRateEnumNV"))
}
/// trait for `VK_NV_fragment_shading_rate_enums`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_fragment_shading_rate_enums.html>
pub trait VK_NV_fragment_shading_rate_enums: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetFragmentShadingRateEnumNV.html>
	fn vkCmdSetFragmentShadingRateEnumNV(&self, commandBuffer: VkCommandBuffer, shadingRate: VkFragmentShadingRateNV, combinerOps: &[VkFragmentShadingRateCombinerOpKHR; 2 as usize]) -> Result<()>;
}
/// struct for `VK_NV_fragment_shading_rate_enums`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_fragment_shading_rate_enums {
	vk_cmd_set_fragment_shading_rate_enum_nv: PFN_vkCmdSetFragmentShadingRateEnumNV,
}
impl VK_NV_fragment_shading_rate_enums for Vulkan_NV_fragment_shading_rate_enums {
	fn vkCmdSetFragmentShadingRateEnumNV(&self, commandBuffer: VkCommandBuffer, shadingRate: VkFragmentShadingRateNV, combinerOps: &[VkFragmentShadingRateCombinerOpKHR; 2 as usize]) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_fragment_shading_rate_enum_nv)(commandBuffer, shadingRate, combinerOps))))
	}
}
impl Default for Vulkan_NV_fragment_shading_rate_enums {
	fn default() -> Self {
		Self {
			vk_cmd_set_fragment_shading_rate_enum_nv: dummy_vkCmdSetFragmentShadingRateEnumNV,
		}
	}
}
impl Vulkan_NV_fragment_shading_rate_enums {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_fragment_shading_rate_enum_nv: {let proc = get_instance_proc_address(instance, "vkCmdSetFragmentShadingRateEnumNV"); if proc == null() {dummy_vkCmdSetFragmentShadingRateEnumNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkAccelerationStructureMotionInfoFlagsNV` from VK_NV_ray_tracing_motion_blur
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureMotionInfoFlagsNV.html>
pub type VkAccelerationStructureMotionInfoFlagsNV = VkFlags;
/// type definition `VkAccelerationStructureMotionInstanceFlagsNV` from VK_NV_ray_tracing_motion_blur
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureMotionInstanceFlagsNV.html>
pub type VkAccelerationStructureMotionInstanceFlagsNV = VkFlags;
/// enum `VkAccelerationStructureMotionInstanceTypeNV` from VK_NV_ray_tracing_motion_blur
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureMotionInstanceTypeNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAccelerationStructureMotionInstanceTypeNV {
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = 0,
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = 1,
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = 2,
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
/// union `VkDeviceOrHostAddressConstKHR` from VK_NV_ray_tracing_motion_blur
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceOrHostAddressConstKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkDeviceOrHostAddressConstKHR {
	pub deviceAddress: VkDeviceAddress,
	pub hostAddress: *const c_void,
}
impl Debug for VkDeviceOrHostAddressConstKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceOrHostAddressConstKHR")
		.field("deviceAddress", unsafe {&self.deviceAddress})
		.field("hostAddress", unsafe {&self.hostAddress})
		.finish()
	}
}
/// union `VkAccelerationStructureMotionInstanceDataNV` from VK_NV_ray_tracing_motion_blur
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureMotionInstanceDataNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkAccelerationStructureMotionInstanceDataNV {
	pub staticInstance: VkAccelerationStructureInstanceKHR,
	pub matrixMotionInstance: VkAccelerationStructureMatrixMotionInstanceNV,
	pub srtMotionInstance: VkAccelerationStructureSRTMotionInstanceNV,
}
impl Debug for VkAccelerationStructureMotionInstanceDataNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureMotionInstanceDataNV")
		.field("staticInstance", unsafe {&self.staticInstance})
		.field("matrixMotionInstance", unsafe {&self.matrixMotionInstance})
		.field("srtMotionInstance", unsafe {&self.srtMotionInstance})
		.finish()
	}
}
/// struct `VkAccelerationStructureGeometryMotionTrianglesDataNV` from VK_NV_ray_tracing_motion_blur
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryMotionTrianglesDataNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureGeometryMotionTrianglesDataNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub vertexData: VkDeviceOrHostAddressConstKHR,
}
impl Debug for VkAccelerationStructureGeometryMotionTrianglesDataNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureGeometryMotionTrianglesDataNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("vertexData", &self.vertexData)
		.finish()
	}
}
/// struct `VkAccelerationStructureMotionInfoNV` from VK_NV_ray_tracing_motion_blur
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureMotionInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureMotionInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maxInstances: u32,
	pub flags: VkAccelerationStructureMotionInfoFlagsNV,
}
impl Debug for VkAccelerationStructureMotionInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureMotionInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxInstances", &self.maxInstances)
		.field("flags", &self.flags)
		.finish()
	}
}
/// struct `VkAccelerationStructureMatrixMotionInstanceNV` from VK_NV_ray_tracing_motion_blur
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureMatrixMotionInstanceNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureMatrixMotionInstanceNV {
	pub transformT0: VkTransformMatrixKHR,
	pub transformT1: VkTransformMatrixKHR,
	/// Bitfield: instanceCustomIndex: u32 in 24 bits
	/// Bitfield: mask: u32 in 8 bits
	bitfield1: u32,
	/// Bitfield: instanceShaderBindingTableRecordOffset: u32 in 24 bits
	/// Bitfield: flags: VkGeometryInstanceFlagsKHR in 8 bits
	bitfield2: u32,
	pub accelerationStructureReference: u64,
}
impl VkAccelerationStructureMatrixMotionInstanceNV {
	pub fn get_instanceCustomIndex(&self) -> u32 {
		(self.bitfield1 >> 0) & 0xffffff
	}
	pub fn set_instanceCustomIndex(&mut self, value: u32) {
		self.bitfield1 = (value & 0xffffff) << 0;
	}
	pub fn get_mask(&self) -> u32 {
		(self.bitfield1 >> 24) & 0xff
	}
	pub fn set_mask(&mut self, value: u32) {
		self.bitfield1 = (value & 0xff) << 24;
	}
	pub fn get_instanceShaderBindingTableRecordOffset(&self) -> u32 {
		(self.bitfield2 >> 0) & 0xffffff
	}
	pub fn set_instanceShaderBindingTableRecordOffset(&mut self, value: u32) {
		self.bitfield2 = (value & 0xffffff) << 0;
	}
	pub fn get_flags(&self) -> u32 {
		(self.bitfield2 >> 24) & 0xff
	}
	pub fn set_flags(&mut self, value: u32) {
		self.bitfield2 = (value & 0xff) << 24;
	}
}
impl Debug for VkAccelerationStructureMatrixMotionInstanceNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureMatrixMotionInstanceNV")
		.field("transformT0", &self.transformT0)
		.field("transformT1", &self.transformT1)
		.field("instanceCustomIndex", &self.get_instanceCustomIndex())
		.field("mask", &self.get_mask())
		.field("instanceShaderBindingTableRecordOffset", &self.get_instanceShaderBindingTableRecordOffset())
		.field("flags", &self.get_flags())
		.field("accelerationStructureReference", &self.accelerationStructureReference)
		.finish()
	}
}
/// struct `VkSRTDataNV` from VK_NV_ray_tracing_motion_blur
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSRTDataNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSRTDataNV {
	pub sx: f32,
	pub a: f32,
	pub b: f32,
	pub pvx: f32,
	pub sy: f32,
	pub c: f32,
	pub pvy: f32,
	pub sz: f32,
	pub pvz: f32,
	pub qx: f32,
	pub qy: f32,
	pub qz: f32,
	pub qw: f32,
	pub tx: f32,
	pub ty: f32,
	pub tz: f32,
}
impl Debug for VkSRTDataNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSRTDataNV")
		.field("sx", &self.sx)
		.field("a", &self.a)
		.field("b", &self.b)
		.field("pvx", &self.pvx)
		.field("sy", &self.sy)
		.field("c", &self.c)
		.field("pvy", &self.pvy)
		.field("sz", &self.sz)
		.field("pvz", &self.pvz)
		.field("qx", &self.qx)
		.field("qy", &self.qy)
		.field("qz", &self.qz)
		.field("qw", &self.qw)
		.field("tx", &self.tx)
		.field("ty", &self.ty)
		.field("tz", &self.tz)
		.finish()
	}
}
/// struct `VkAccelerationStructureSRTMotionInstanceNV` from VK_NV_ray_tracing_motion_blur
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureSRTMotionInstanceNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureSRTMotionInstanceNV {
	pub transformT0: VkSRTDataNV,
	pub transformT1: VkSRTDataNV,
	/// Bitfield: instanceCustomIndex: u32 in 24 bits
	/// Bitfield: mask: u32 in 8 bits
	bitfield1: u32,
	/// Bitfield: instanceShaderBindingTableRecordOffset: u32 in 24 bits
	/// Bitfield: flags: VkGeometryInstanceFlagsKHR in 8 bits
	bitfield2: u32,
	pub accelerationStructureReference: u64,
}
impl VkAccelerationStructureSRTMotionInstanceNV {
	pub fn get_instanceCustomIndex(&self) -> u32 {
		(self.bitfield1 >> 0) & 0xffffff
	}
	pub fn set_instanceCustomIndex(&mut self, value: u32) {
		self.bitfield1 = (value & 0xffffff) << 0;
	}
	pub fn get_mask(&self) -> u32 {
		(self.bitfield1 >> 24) & 0xff
	}
	pub fn set_mask(&mut self, value: u32) {
		self.bitfield1 = (value & 0xff) << 24;
	}
	pub fn get_instanceShaderBindingTableRecordOffset(&self) -> u32 {
		(self.bitfield2 >> 0) & 0xffffff
	}
	pub fn set_instanceShaderBindingTableRecordOffset(&mut self, value: u32) {
		self.bitfield2 = (value & 0xffffff) << 0;
	}
	pub fn get_flags(&self) -> u32 {
		(self.bitfield2 >> 24) & 0xff
	}
	pub fn set_flags(&mut self, value: u32) {
		self.bitfield2 = (value & 0xff) << 24;
	}
}
impl Debug for VkAccelerationStructureSRTMotionInstanceNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureSRTMotionInstanceNV")
		.field("transformT0", &self.transformT0)
		.field("transformT1", &self.transformT1)
		.field("instanceCustomIndex", &self.get_instanceCustomIndex())
		.field("mask", &self.get_mask())
		.field("instanceShaderBindingTableRecordOffset", &self.get_instanceShaderBindingTableRecordOffset())
		.field("flags", &self.get_flags())
		.field("accelerationStructureReference", &self.accelerationStructureReference)
		.finish()
	}
}
/// struct `VkAccelerationStructureMotionInstanceNV` from VK_NV_ray_tracing_motion_blur
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureMotionInstanceNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureMotionInstanceNV {
	pub type_: VkAccelerationStructureMotionInstanceTypeNV,
	pub flags: VkAccelerationStructureMotionInstanceFlagsNV,
	pub data: VkAccelerationStructureMotionInstanceDataNV,
}
impl Debug for VkAccelerationStructureMotionInstanceNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureMotionInstanceNV")
		.field("type_", &self.type_)
		.field("flags", &self.flags)
		.field("data", &self.data)
		.finish()
	}
}
/// struct `VkPhysicalDeviceRayTracingMotionBlurFeaturesNV` from VK_NV_ray_tracing_motion_blur
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingMotionBlurFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rayTracingMotionBlur: VkBool32,
	pub rayTracingMotionBlurPipelineTraceRaysIndirect: VkBool32,
}
impl Debug for VkPhysicalDeviceRayTracingMotionBlurFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRayTracingMotionBlurFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("rayTracingMotionBlur", &self.rayTracingMotionBlur)
		.field("rayTracingMotionBlurPipelineTraceRaysIndirect", &self.rayTracingMotionBlurPipelineTraceRaysIndirect)
		.finish()
	}
}
/// trait for `VK_NV_ray_tracing_motion_blur`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_ray_tracing_motion_blur.html>
pub trait VK_NV_ray_tracing_motion_blur: Debug {}
/// struct for `VK_NV_ray_tracing_motion_blur`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_ray_tracing_motion_blur {}
impl VK_NV_ray_tracing_motion_blur for Vulkan_NV_ray_tracing_motion_blur {}
impl Default for Vulkan_NV_ray_tracing_motion_blur {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_ray_tracing_motion_blur {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT` from VK_EXT_ycbcr_2plane_444_formats
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub ycbcr2plane444Formats: VkBool32,
}
impl Debug for VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("ycbcr2plane444Formats", &self.ycbcr2plane444Formats)
		.finish()
	}
}
/// trait for `VK_EXT_ycbcr_2plane_444_formats`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_ycbcr_2plane_444_formats.html>
pub trait VK_EXT_ycbcr_2plane_444_formats: Debug {}
/// struct for `VK_EXT_ycbcr_2plane_444_formats`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_ycbcr_2plane_444_formats {}
impl VK_EXT_ycbcr_2plane_444_formats for Vulkan_EXT_ycbcr_2plane_444_formats {}
impl Default for Vulkan_EXT_ycbcr_2plane_444_formats {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_ycbcr_2plane_444_formats {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceFragmentDensityMap2FeaturesEXT` from VK_EXT_fragment_density_map2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFragmentDensityMap2FeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub fragmentDensityMapDeferred: VkBool32,
}
impl Debug for VkPhysicalDeviceFragmentDensityMap2FeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentDensityMap2FeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("fragmentDensityMapDeferred", &self.fragmentDensityMapDeferred)
		.finish()
	}
}
/// struct `VkPhysicalDeviceFragmentDensityMap2PropertiesEXT` from VK_EXT_fragment_density_map2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFragmentDensityMap2PropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub subsampledLoads: VkBool32,
	pub subsampledCoarseReconstructionEarlyAccess: VkBool32,
	pub maxSubsampledArrayLayers: u32,
	pub maxDescriptorSetSubsampledSamplers: u32,
}
impl Debug for VkPhysicalDeviceFragmentDensityMap2PropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentDensityMap2PropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("subsampledLoads", &self.subsampledLoads)
		.field("subsampledCoarseReconstructionEarlyAccess", &self.subsampledCoarseReconstructionEarlyAccess)
		.field("maxSubsampledArrayLayers", &self.maxSubsampledArrayLayers)
		.field("maxDescriptorSetSubsampledSamplers", &self.maxDescriptorSetSubsampledSamplers)
		.finish()
	}
}
/// trait for `VK_EXT_fragment_density_map2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_fragment_density_map2.html>
pub trait VK_EXT_fragment_density_map2: Debug {}
/// struct for `VK_EXT_fragment_density_map2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_fragment_density_map2 {}
impl VK_EXT_fragment_density_map2 for Vulkan_EXT_fragment_density_map2 {}
impl Default for Vulkan_EXT_fragment_density_map2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_fragment_density_map2 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkCopyCommandTransformInfoQCOM` from VK_QCOM_rotated_copy_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyCommandTransformInfoQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyCommandTransformInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub transform: VkSurfaceTransformFlagBitsKHR,
}
impl Debug for VkCopyCommandTransformInfoQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyCommandTransformInfoQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("transform", &self.transform)
		.finish()
	}
}
/// trait for `VK_QCOM_rotated_copy_commands`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QCOM_rotated_copy_commands.html>
pub trait VK_QCOM_rotated_copy_commands: Debug {}
/// struct for `VK_QCOM_rotated_copy_commands`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_rotated_copy_commands {}
impl VK_QCOM_rotated_copy_commands for Vulkan_QCOM_rotated_copy_commands {}
impl Default for Vulkan_QCOM_rotated_copy_commands {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_rotated_copy_commands {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceImageRobustnessFeaturesEXT` from VK_EXT_image_robustness
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImageRobustnessFeaturesEXT.html>
pub type VkPhysicalDeviceImageRobustnessFeaturesEXT = VkPhysicalDeviceImageRobustnessFeatures;
/// trait for `VK_EXT_image_robustness`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_image_robustness.html>
pub trait VK_EXT_image_robustness: Debug {}
/// struct for `VK_EXT_image_robustness`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_image_robustness {}
impl VK_EXT_image_robustness for Vulkan_EXT_image_robustness {}
impl Default for Vulkan_EXT_image_robustness {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_image_robustness {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkImageCompressionFlagsEXT` from VK_EXT_image_compression_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCompressionFlagsEXT.html>
pub type VkImageCompressionFlagsEXT = VkFlags;
/// type definition `VkImageCompressionFixedRateFlagsEXT` from VK_EXT_image_compression_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCompressionFixedRateFlagsEXT.html>
pub type VkImageCompressionFixedRateFlagsEXT = VkFlags;
/// enum `VkImageCompressionFlagBitsEXT` from VK_EXT_image_compression_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCompressionFlagBitsEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageCompressionFlagBitsEXT {
	VK_IMAGE_COMPRESSION_DEFAULT_EXT = 0,
	VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT = 0x00000001,
	VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT = 0x00000002,
	VK_IMAGE_COMPRESSION_DISABLED_EXT = 0x00000004,
	VK_IMAGE_COMPRESSION_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkImageCompressionFixedRateFlagBitsEXT` from VK_EXT_image_compression_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCompressionFixedRateFlagBitsEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkImageCompressionFixedRateFlagBitsEXT {
	VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT = 0,
	VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT = 0x00000001,
	VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT = 0x00000002,
	VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT = 0x00000004,
	VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT = 0x00000008,
	VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT = 0x00000010,
	VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT = 0x00000020,
	VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT = 0x00000040,
	VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT = 0x00000080,
	VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT = 0x00000100,
	VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT = 0x00000200,
	VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT = 0x00000400,
	VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT = 0x00000800,
	VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT = 0x00001000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT = 0x00002000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT = 0x00004000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT = 0x00008000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT = 0x00010000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT = 0x00020000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT = 0x00040000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT = 0x00080000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT = 0x00100000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT = 0x00200000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT = 0x00400000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT = 0x00800000,
	VK_IMAGE_COMPRESSION_FIXED_RATE_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkPhysicalDeviceImageCompressionControlFeaturesEXT` from VK_EXT_image_compression_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImageCompressionControlFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceImageCompressionControlFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageCompressionControl: VkBool32,
}
impl Debug for VkPhysicalDeviceImageCompressionControlFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceImageCompressionControlFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("imageCompressionControl", &self.imageCompressionControl)
		.finish()
	}
}
/// struct `VkImageCompressionControlEXT` from VK_EXT_image_compression_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCompressionControlEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageCompressionControlEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkImageCompressionFlagsEXT,
	pub compressionControlPlaneCount: u32,
	pub pFixedRateFlags: *mut VkImageCompressionFixedRateFlagsEXT,
}
impl Debug for VkImageCompressionControlEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageCompressionControlEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("compressionControlPlaneCount", &self.compressionControlPlaneCount)
		.field("pFixedRateFlags", &self.pFixedRateFlags)
		.finish()
	}
}
/// struct `VkImageCompressionPropertiesEXT` from VK_EXT_image_compression_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageCompressionPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageCompressionPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageCompressionFlags: VkImageCompressionFlagsEXT,
	pub imageCompressionFixedRateFlags: VkImageCompressionFixedRateFlagsEXT,
}
impl Debug for VkImageCompressionPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageCompressionPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("imageCompressionFlags", &self.imageCompressionFlags)
		.field("imageCompressionFixedRateFlags", &self.imageCompressionFixedRateFlags)
		.finish()
	}
}
/// trait for `VK_EXT_image_compression_control`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_image_compression_control.html>
pub trait VK_EXT_image_compression_control: Debug {}
/// struct for `VK_EXT_image_compression_control`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_image_compression_control {}
impl VK_EXT_image_compression_control for Vulkan_EXT_image_compression_control {}
impl Default for Vulkan_EXT_image_compression_control {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_image_compression_control {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT` from VK_EXT_attachment_feedback_loop_layout
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub attachmentFeedbackLoopLayout: VkBool32,
}
impl Debug for VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("attachmentFeedbackLoopLayout", &self.attachmentFeedbackLoopLayout)
		.finish()
	}
}
/// trait for `VK_EXT_attachment_feedback_loop_layout`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_attachment_feedback_loop_layout.html>
pub trait VK_EXT_attachment_feedback_loop_layout: Debug {}
/// struct for `VK_EXT_attachment_feedback_loop_layout`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_attachment_feedback_loop_layout {}
impl VK_EXT_attachment_feedback_loop_layout for Vulkan_EXT_attachment_feedback_loop_layout {}
impl Default for Vulkan_EXT_attachment_feedback_loop_layout {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_attachment_feedback_loop_layout {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDevice4444FormatsFeaturesEXT` from VK_EXT_4444_formats
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevice4444FormatsFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevice4444FormatsFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub formatA4R4G4B4: VkBool32,
	pub formatA4B4G4R4: VkBool32,
}
impl Debug for VkPhysicalDevice4444FormatsFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevice4444FormatsFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("formatA4R4G4B4", &self.formatA4R4G4B4)
		.field("formatA4B4G4R4", &self.formatA4B4G4R4)
		.finish()
	}
}
/// trait for `VK_EXT_4444_formats`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_4444_formats.html>
pub trait VK_EXT_4444_formats: Debug {}
/// struct for `VK_EXT_4444_formats`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_4444_formats {}
impl VK_EXT_4444_formats for Vulkan_EXT_4444_formats {}
impl Default for Vulkan_EXT_4444_formats {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_4444_formats {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkDeviceFaultAddressTypeEXT` from VK_EXT_device_fault
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceFaultAddressTypeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceFaultAddressTypeEXT {
	VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT = 0,
	VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT = 1,
	VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT = 2,
	VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT = 3,
	VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT = 4,
	VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT = 5,
	VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT = 6,
	VK_DEVICE_FAULT_ADDRESS_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkDeviceFaultVendorBinaryHeaderVersionEXT` from VK_EXT_device_fault
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceFaultVendorBinaryHeaderVersionEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceFaultVendorBinaryHeaderVersionEXT {
	VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT = 1,
	VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkPhysicalDeviceFaultFeaturesEXT` from VK_EXT_device_fault
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFaultFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFaultFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceFault: VkBool32,
	pub deviceFaultVendorBinary: VkBool32,
}
impl Debug for VkPhysicalDeviceFaultFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFaultFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceFault", &self.deviceFault)
		.field("deviceFaultVendorBinary", &self.deviceFaultVendorBinary)
		.finish()
	}
}
/// struct `VkDeviceFaultCountsEXT` from VK_EXT_device_fault
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceFaultCountsEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceFaultCountsEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub addressInfoCount: u32,
	pub vendorInfoCount: u32,
	pub vendorBinarySize: VkDeviceSize,
}
impl Debug for VkDeviceFaultCountsEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceFaultCountsEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("addressInfoCount", &self.addressInfoCount)
		.field("vendorInfoCount", &self.vendorInfoCount)
		.field("vendorBinarySize", &self.vendorBinarySize)
		.finish()
	}
}
/// struct `VkDeviceFaultAddressInfoEXT` from VK_EXT_device_fault
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceFaultAddressInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceFaultAddressInfoEXT {
	pub addressType: VkDeviceFaultAddressTypeEXT,
	pub reportedAddress: VkDeviceAddress,
	pub addressPrecision: VkDeviceSize,
}
impl Debug for VkDeviceFaultAddressInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceFaultAddressInfoEXT")
		.field("addressType", &self.addressType)
		.field("reportedAddress", &self.reportedAddress)
		.field("addressPrecision", &self.addressPrecision)
		.finish()
	}
}
/// struct `VkDeviceFaultVendorInfoEXT` from VK_EXT_device_fault
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceFaultVendorInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceFaultVendorInfoEXT {
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub vendorFaultCode: u64,
	pub vendorFaultData: u64,
}
impl Debug for VkDeviceFaultVendorInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceFaultVendorInfoEXT")
		.field("description", &format_args!("{}", maybe_string(&self.description)))
		.field("vendorFaultCode", &self.vendorFaultCode)
		.field("vendorFaultData", &self.vendorFaultData)
		.finish()
	}
}
/// struct `VkDeviceFaultInfoEXT` from VK_EXT_device_fault
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceFaultInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceFaultInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub pAddressInfos: *mut VkDeviceFaultAddressInfoEXT,
	pub pVendorInfos: *mut VkDeviceFaultVendorInfoEXT,
	pub pVendorBinaryData: *mut c_void,
}
impl Debug for VkDeviceFaultInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceFaultInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("description", &format_args!("{}", maybe_string(&self.description)))
		.field("pAddressInfos", &self.pAddressInfos)
		.field("pVendorInfos", &self.pVendorInfos)
		.field("pVendorBinaryData", &self.pVendorBinaryData)
		.finish()
	}
}
/// struct `VkDeviceFaultVendorBinaryHeaderVersionOneEXT` from VK_EXT_device_fault
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceFaultVendorBinaryHeaderVersionOneEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceFaultVendorBinaryHeaderVersionOneEXT {
	pub headerSize: u32,
	pub headerVersion: VkDeviceFaultVendorBinaryHeaderVersionEXT,
	pub vendorID: u32,
	pub deviceID: u32,
	pub driverVersion: u32,
	pub pipelineCacheUUID: [u8; VK_UUID_SIZE as usize],
	pub applicationNameOffset: u32,
	pub applicationVersion: u32,
	pub engineNameOffset: u32,
	pub engineVersion: u32,
	pub apiVersion: u32,
}
impl Debug for VkDeviceFaultVendorBinaryHeaderVersionOneEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceFaultVendorBinaryHeaderVersionOneEXT")
		.field("headerSize", &self.headerSize)
		.field("headerVersion", &self.headerVersion)
		.field("vendorID", &self.vendorID)
		.field("deviceID", &self.deviceID)
		.field("driverVersion", &self.driverVersion)
		.field("pipelineCacheUUID", &self.pipelineCacheUUID)
		.field("applicationNameOffset", &self.applicationNameOffset)
		.field("applicationVersion", &self.applicationVersion)
		.field("engineNameOffset", &self.engineNameOffset)
		.field("engineVersion", &self.engineVersion)
		.field("apiVersion", &self.apiVersion)
		.finish()
	}
}
/// function prototype `PFN_vkGetDeviceFaultInfoEXT` from VK_EXT_device_fault
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceFaultInfoEXT.html>
type PFN_vkGetDeviceFaultInfoEXT = extern "system" fn(device: VkDevice, pFaultCounts: *mut VkDeviceFaultCountsEXT, pFaultInfo: *mut VkDeviceFaultInfoEXT) -> VkResult;
/// The dummy function for `vkGetDeviceFaultInfoEXT` from `VK_EXT_device_fault`
extern "system" fn dummy_vkGetDeviceFaultInfoEXT(_: VkDevice, _: *mut VkDeviceFaultCountsEXT, _: *mut VkDeviceFaultInfoEXT) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetDeviceFaultInfoEXT"))
}
/// trait for `VK_EXT_device_fault`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_device_fault.html>
pub trait VK_EXT_device_fault: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceFaultInfoEXT.html>
	fn vkGetDeviceFaultInfoEXT(&self, device: VkDevice, pFaultCounts: *mut VkDeviceFaultCountsEXT, pFaultInfo: *mut VkDeviceFaultInfoEXT) -> Result<()>;
}
/// struct for `VK_EXT_device_fault`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_device_fault {
	vk_get_device_fault_info_ext: PFN_vkGetDeviceFaultInfoEXT,
}
impl VK_EXT_device_fault for Vulkan_EXT_device_fault {
	fn vkGetDeviceFaultInfoEXT(&self, device: VkDevice, pFaultCounts: *mut VkDeviceFaultCountsEXT, pFaultInfo: *mut VkDeviceFaultInfoEXT) -> Result<()> {
		convert_result("vkGetDeviceFaultInfoEXT", catch_unwind(||((self.vk_get_device_fault_info_ext)(device, pFaultCounts, pFaultInfo))))
	}
}
impl Default for Vulkan_EXT_device_fault {
	fn default() -> Self {
		Self {
			vk_get_device_fault_info_ext: dummy_vkGetDeviceFaultInfoEXT,
		}
	}
}
impl Vulkan_EXT_device_fault {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_device_fault_info_ext: {let proc = get_instance_proc_address(instance, "vkGetDeviceFaultInfoEXT"); if proc == null() {dummy_vkGetDeviceFaultInfoEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM` from VK_ARM_rasterization_order_attachment_access
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM.html>
pub type VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
/// struct `VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT` from VK_ARM_rasterization_order_attachment_access
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rasterizationOrderColorAttachmentAccess: VkBool32,
	pub rasterizationOrderDepthAttachmentAccess: VkBool32,
	pub rasterizationOrderStencilAttachmentAccess: VkBool32,
}
impl Debug for VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("rasterizationOrderColorAttachmentAccess", &self.rasterizationOrderColorAttachmentAccess)
		.field("rasterizationOrderDepthAttachmentAccess", &self.rasterizationOrderDepthAttachmentAccess)
		.field("rasterizationOrderStencilAttachmentAccess", &self.rasterizationOrderStencilAttachmentAccess)
		.finish()
	}
}
/// trait for `VK_ARM_rasterization_order_attachment_access`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_ARM_rasterization_order_attachment_access.html>
pub trait VK_ARM_rasterization_order_attachment_access: Debug {}
/// struct for `VK_ARM_rasterization_order_attachment_access`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_rasterization_order_attachment_access {}
impl VK_ARM_rasterization_order_attachment_access for Vulkan_ARM_rasterization_order_attachment_access {}
impl Default for Vulkan_ARM_rasterization_order_attachment_access {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_ARM_rasterization_order_attachment_access {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT` from VK_EXT_rgba10x6_formats
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub formatRgba10x6WithoutYCbCrSampler: VkBool32,
}
impl Debug for VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("formatRgba10x6WithoutYCbCrSampler", &self.formatRgba10x6WithoutYCbCrSampler)
		.finish()
	}
}
/// trait for `VK_EXT_rgba10x6_formats`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_rgba10x6_formats.html>
pub trait VK_EXT_rgba10x6_formats: Debug {}
/// struct for `VK_EXT_rgba10x6_formats`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_rgba10x6_formats {}
impl VK_EXT_rgba10x6_formats for Vulkan_EXT_rgba10x6_formats {}
impl Default for Vulkan_EXT_rgba10x6_formats {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_rgba10x6_formats {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE` from VK_VALVE_mutable_descriptor_type
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE.html>
pub type VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE = VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT;
/// type definition `VkMutableDescriptorTypeListVALVE` from VK_VALVE_mutable_descriptor_type
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMutableDescriptorTypeListVALVE.html>
pub type VkMutableDescriptorTypeListVALVE = VkMutableDescriptorTypeListEXT;
/// type definition `VkMutableDescriptorTypeCreateInfoVALVE` from VK_VALVE_mutable_descriptor_type
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMutableDescriptorTypeCreateInfoVALVE.html>
pub type VkMutableDescriptorTypeCreateInfoVALVE = VkMutableDescriptorTypeCreateInfoEXT;
/// struct `VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT` from VK_VALVE_mutable_descriptor_type
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub mutableDescriptorType: VkBool32,
}
impl Debug for VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("mutableDescriptorType", &self.mutableDescriptorType)
		.finish()
	}
}
/// struct `VkMutableDescriptorTypeListEXT` from VK_VALVE_mutable_descriptor_type
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMutableDescriptorTypeListEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMutableDescriptorTypeListEXT {
	pub descriptorTypeCount: u32,
	pub pDescriptorTypes: *const VkDescriptorType,
}
impl Debug for VkMutableDescriptorTypeListEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMutableDescriptorTypeListEXT")
		.field("descriptorTypeCount", &self.descriptorTypeCount)
		.field("pDescriptorTypes", &self.pDescriptorTypes)
		.finish()
	}
}
/// struct `VkMutableDescriptorTypeCreateInfoEXT` from VK_VALVE_mutable_descriptor_type
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMutableDescriptorTypeCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMutableDescriptorTypeCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub mutableDescriptorTypeListCount: u32,
	pub pMutableDescriptorTypeLists: *const VkMutableDescriptorTypeListEXT,
}
impl Debug for VkMutableDescriptorTypeCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMutableDescriptorTypeCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("mutableDescriptorTypeListCount", &self.mutableDescriptorTypeListCount)
		.field("pMutableDescriptorTypeLists", &self.pMutableDescriptorTypeLists)
		.finish()
	}
}
/// trait for `VK_VALVE_mutable_descriptor_type`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_VALVE_mutable_descriptor_type.html>
pub trait VK_VALVE_mutable_descriptor_type: Debug {}
/// struct for `VK_VALVE_mutable_descriptor_type`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_VALVE_mutable_descriptor_type {}
impl VK_VALVE_mutable_descriptor_type for Vulkan_VALVE_mutable_descriptor_type {}
impl Default for Vulkan_VALVE_mutable_descriptor_type {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_VALVE_mutable_descriptor_type {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT` from VK_EXT_vertex_input_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub vertexInputDynamicState: VkBool32,
}
impl Debug for VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("vertexInputDynamicState", &self.vertexInputDynamicState)
		.finish()
	}
}
/// struct `VkVertexInputBindingDescription2EXT` from VK_EXT_vertex_input_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVertexInputBindingDescription2EXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVertexInputBindingDescription2EXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub binding: u32,
	pub stride: u32,
	pub inputRate: VkVertexInputRate,
	pub divisor: u32,
}
impl Debug for VkVertexInputBindingDescription2EXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVertexInputBindingDescription2EXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("binding", &self.binding)
		.field("stride", &self.stride)
		.field("inputRate", &self.inputRate)
		.field("divisor", &self.divisor)
		.finish()
	}
}
/// struct `VkVertexInputAttributeDescription2EXT` from VK_EXT_vertex_input_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkVertexInputAttributeDescription2EXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkVertexInputAttributeDescription2EXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub location: u32,
	pub binding: u32,
	pub format: VkFormat,
	pub offset: u32,
}
impl Debug for VkVertexInputAttributeDescription2EXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkVertexInputAttributeDescription2EXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("location", &self.location)
		.field("binding", &self.binding)
		.field("format", &self.format)
		.field("offset", &self.offset)
		.finish()
	}
}
/// function prototype `PFN_vkCmdSetVertexInputEXT` from VK_EXT_vertex_input_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetVertexInputEXT.html>
type PFN_vkCmdSetVertexInputEXT = extern "system" fn(commandBuffer: VkCommandBuffer, vertexBindingDescriptionCount: u32, pVertexBindingDescriptions: *const VkVertexInputBindingDescription2EXT, vertexAttributeDescriptionCount: u32, pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription2EXT);
/// The dummy function for `vkCmdSetVertexInputEXT` from `VK_EXT_vertex_input_dynamic_state`
extern "system" fn dummy_vkCmdSetVertexInputEXT(_: VkCommandBuffer, _: u32, _: *const VkVertexInputBindingDescription2EXT, _: u32, _: *const VkVertexInputAttributeDescription2EXT) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetVertexInputEXT"))
}
/// trait for `VK_EXT_vertex_input_dynamic_state`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_vertex_input_dynamic_state.html>
pub trait VK_EXT_vertex_input_dynamic_state: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetVertexInputEXT.html>
	fn vkCmdSetVertexInputEXT(&self, commandBuffer: VkCommandBuffer, vertexBindingDescriptionCount: u32, pVertexBindingDescriptions: *const VkVertexInputBindingDescription2EXT, vertexAttributeDescriptionCount: u32, pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription2EXT) -> Result<()>;
}
/// struct for `VK_EXT_vertex_input_dynamic_state`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_vertex_input_dynamic_state {
	vk_cmd_set_vertex_input_ext: PFN_vkCmdSetVertexInputEXT,
}
impl VK_EXT_vertex_input_dynamic_state for Vulkan_EXT_vertex_input_dynamic_state {
	fn vkCmdSetVertexInputEXT(&self, commandBuffer: VkCommandBuffer, vertexBindingDescriptionCount: u32, pVertexBindingDescriptions: *const VkVertexInputBindingDescription2EXT, vertexAttributeDescriptionCount: u32, pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription2EXT) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_vertex_input_ext)(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions))))
	}
}
impl Default for Vulkan_EXT_vertex_input_dynamic_state {
	fn default() -> Self {
		Self {
			vk_cmd_set_vertex_input_ext: dummy_vkCmdSetVertexInputEXT,
		}
	}
}
impl Vulkan_EXT_vertex_input_dynamic_state {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_vertex_input_ext: {let proc = get_instance_proc_address(instance, "vkCmdSetVertexInputEXT"); if proc == null() {dummy_vkCmdSetVertexInputEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceDrmPropertiesEXT` from VK_EXT_physical_device_drm
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDrmPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDrmPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub hasPrimary: VkBool32,
	pub hasRender: VkBool32,
	pub primaryMajor: i64,
	pub primaryMinor: i64,
	pub renderMajor: i64,
	pub renderMinor: i64,
}
impl Debug for VkPhysicalDeviceDrmPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDrmPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("hasPrimary", &self.hasPrimary)
		.field("hasRender", &self.hasRender)
		.field("primaryMajor", &self.primaryMajor)
		.field("primaryMinor", &self.primaryMinor)
		.field("renderMajor", &self.renderMajor)
		.field("renderMinor", &self.renderMinor)
		.finish()
	}
}
/// trait for `VK_EXT_physical_device_drm`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_physical_device_drm.html>
pub trait VK_EXT_physical_device_drm: Debug {}
/// struct for `VK_EXT_physical_device_drm`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_physical_device_drm {}
impl VK_EXT_physical_device_drm for Vulkan_EXT_physical_device_drm {}
impl Default for Vulkan_EXT_physical_device_drm {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_physical_device_drm {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkDeviceAddressBindingFlagsEXT` from VK_EXT_device_address_binding_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceAddressBindingFlagsEXT.html>
pub type VkDeviceAddressBindingFlagsEXT = VkFlags;
/// enum `VkDeviceAddressBindingTypeEXT` from VK_EXT_device_address_binding_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceAddressBindingTypeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceAddressBindingTypeEXT {
	VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT = 0,
	VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT = 1,
	VK_DEVICE_ADDRESS_BINDING_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkDeviceAddressBindingFlagBitsEXT` from VK_EXT_device_address_binding_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceAddressBindingFlagBitsEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDeviceAddressBindingFlagBitsEXT {
	VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT = 0x00000001,
	VK_DEVICE_ADDRESS_BINDING_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkPhysicalDeviceAddressBindingReportFeaturesEXT` from VK_EXT_device_address_binding_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceAddressBindingReportFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceAddressBindingReportFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub reportAddressBinding: VkBool32,
}
impl Debug for VkPhysicalDeviceAddressBindingReportFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceAddressBindingReportFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("reportAddressBinding", &self.reportAddressBinding)
		.finish()
	}
}
/// struct `VkDeviceAddressBindingCallbackDataEXT` from VK_EXT_device_address_binding_report
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceAddressBindingCallbackDataEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceAddressBindingCallbackDataEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkDeviceAddressBindingFlagsEXT,
	pub baseAddress: VkDeviceAddress,
	pub size: VkDeviceSize,
	pub bindingType: VkDeviceAddressBindingTypeEXT,
}
impl Debug for VkDeviceAddressBindingCallbackDataEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceAddressBindingCallbackDataEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("baseAddress", &self.baseAddress)
		.field("size", &self.size)
		.field("bindingType", &self.bindingType)
		.finish()
	}
}
/// trait for `VK_EXT_device_address_binding_report`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_device_address_binding_report.html>
pub trait VK_EXT_device_address_binding_report: Debug {}
/// struct for `VK_EXT_device_address_binding_report`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_device_address_binding_report {}
impl VK_EXT_device_address_binding_report for Vulkan_EXT_device_address_binding_report {}
impl Default for Vulkan_EXT_device_address_binding_report {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_device_address_binding_report {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceDepthClipControlFeaturesEXT` from VK_EXT_depth_clip_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDepthClipControlFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDepthClipControlFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub depthClipControl: VkBool32,
}
impl Debug for VkPhysicalDeviceDepthClipControlFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDepthClipControlFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("depthClipControl", &self.depthClipControl)
		.finish()
	}
}
/// struct `VkPipelineViewportDepthClipControlCreateInfoEXT` from VK_EXT_depth_clip_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineViewportDepthClipControlCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineViewportDepthClipControlCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub negativeOneToOne: VkBool32,
}
impl Debug for VkPipelineViewportDepthClipControlCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineViewportDepthClipControlCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("negativeOneToOne", &self.negativeOneToOne)
		.finish()
	}
}
/// trait for `VK_EXT_depth_clip_control`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_depth_clip_control.html>
pub trait VK_EXT_depth_clip_control: Debug {}
/// struct for `VK_EXT_depth_clip_control`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_depth_clip_control {}
impl VK_EXT_depth_clip_control for Vulkan_EXT_depth_clip_control {}
impl Default for Vulkan_EXT_depth_clip_control {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_depth_clip_control {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT` from VK_EXT_primitive_topology_list_restart
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub primitiveTopologyListRestart: VkBool32,
	pub primitiveTopologyPatchListRestart: VkBool32,
}
impl Debug for VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("primitiveTopologyListRestart", &self.primitiveTopologyListRestart)
		.field("primitiveTopologyPatchListRestart", &self.primitiveTopologyPatchListRestart)
		.finish()
	}
}
/// trait for `VK_EXT_primitive_topology_list_restart`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_primitive_topology_list_restart.html>
pub trait VK_EXT_primitive_topology_list_restart: Debug {}
/// struct for `VK_EXT_primitive_topology_list_restart`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_primitive_topology_list_restart {}
impl VK_EXT_primitive_topology_list_restart for Vulkan_EXT_primitive_topology_list_restart {}
impl Default for Vulkan_EXT_primitive_topology_list_restart {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_primitive_topology_list_restart {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT` from VK_EXT_present_mode_fifo_latest_ready
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT.html>
pub type VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT = VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR;
/// trait for `VK_EXT_present_mode_fifo_latest_ready`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_present_mode_fifo_latest_ready.html>
pub trait VK_EXT_present_mode_fifo_latest_ready: Debug {}
/// struct for `VK_EXT_present_mode_fifo_latest_ready`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_present_mode_fifo_latest_ready {}
impl VK_EXT_present_mode_fifo_latest_ready for Vulkan_EXT_present_mode_fifo_latest_ready {}
impl Default for Vulkan_EXT_present_mode_fifo_latest_ready {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_present_mode_fifo_latest_ready {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkSubpassShadingPipelineCreateInfoHUAWEI` from VK_HUAWEI_subpass_shading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassShadingPipelineCreateInfoHUAWEI.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSubpassShadingPipelineCreateInfoHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub renderPass: VkRenderPass,
	pub subpass: u32,
}
impl Debug for VkSubpassShadingPipelineCreateInfoHUAWEI {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSubpassShadingPipelineCreateInfoHUAWEI")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("renderPass", &self.renderPass)
		.field("subpass", &self.subpass)
		.finish()
	}
}
/// struct `VkPhysicalDeviceSubpassShadingFeaturesHUAWEI` from VK_HUAWEI_subpass_shading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSubpassShadingFeaturesHUAWEI.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSubpassShadingFeaturesHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub subpassShading: VkBool32,
}
impl Debug for VkPhysicalDeviceSubpassShadingFeaturesHUAWEI {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSubpassShadingFeaturesHUAWEI")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("subpassShading", &self.subpassShading)
		.finish()
	}
}
/// struct `VkPhysicalDeviceSubpassShadingPropertiesHUAWEI` from VK_HUAWEI_subpass_shading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSubpassShadingPropertiesHUAWEI.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSubpassShadingPropertiesHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxSubpassShadingWorkgroupSizeAspectRatio: u32,
}
impl Debug for VkPhysicalDeviceSubpassShadingPropertiesHUAWEI {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSubpassShadingPropertiesHUAWEI")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxSubpassShadingWorkgroupSizeAspectRatio", &self.maxSubpassShadingWorkgroupSizeAspectRatio)
		.finish()
	}
}
/// function prototype `PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI` from VK_HUAWEI_subpass_shading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.html>
type PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = extern "system" fn(device: VkDevice, renderpass: VkRenderPass, pMaxWorkgroupSize: *mut VkExtent2D) -> VkResult;
/// function prototype `PFN_vkCmdSubpassShadingHUAWEI` from VK_HUAWEI_subpass_shading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSubpassShadingHUAWEI.html>
type PFN_vkCmdSubpassShadingHUAWEI = extern "system" fn(commandBuffer: VkCommandBuffer);
/// The dummy function for `vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI` from `VK_HUAWEI_subpass_shading`
extern "system" fn dummy_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(_: VkDevice, _: VkRenderPass, _: *mut VkExtent2D) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI"))
}
/// trait for `VK_HUAWEI_subpass_shading`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_HUAWEI_subpass_shading.html>
pub trait VK_HUAWEI_subpass_shading: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.html>
	fn vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(&self, device: VkDevice, renderpass: VkRenderPass, pMaxWorkgroupSize: *mut VkExtent2D) -> Result<()>;
}
/// struct for `VK_HUAWEI_subpass_shading`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_HUAWEI_subpass_shading {
	vk_get_device_subpass_shading_max_workgroup_size_huawei: PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI,
}
impl VK_HUAWEI_subpass_shading for Vulkan_HUAWEI_subpass_shading {
	fn vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(&self, device: VkDevice, renderpass: VkRenderPass, pMaxWorkgroupSize: *mut VkExtent2D) -> Result<()> {
		convert_result("vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI", catch_unwind(||((self.vk_get_device_subpass_shading_max_workgroup_size_huawei)(device, renderpass, pMaxWorkgroupSize))))
	}
}
impl Default for Vulkan_HUAWEI_subpass_shading {
	fn default() -> Self {
		Self {
			vk_get_device_subpass_shading_max_workgroup_size_huawei: dummy_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI,
		}
	}
}
impl Vulkan_HUAWEI_subpass_shading {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_device_subpass_shading_max_workgroup_size_huawei: {let proc = get_instance_proc_address(instance, "vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI"); if proc == null() {dummy_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceInvocationMaskFeaturesHUAWEI` from VK_HUAWEI_invocation_mask
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceInvocationMaskFeaturesHUAWEI.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceInvocationMaskFeaturesHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub invocationMask: VkBool32,
}
impl Debug for VkPhysicalDeviceInvocationMaskFeaturesHUAWEI {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceInvocationMaskFeaturesHUAWEI")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("invocationMask", &self.invocationMask)
		.finish()
	}
}
/// function prototype `PFN_vkCmdBindInvocationMaskHUAWEI` from VK_HUAWEI_invocation_mask
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindInvocationMaskHUAWEI.html>
type PFN_vkCmdBindInvocationMaskHUAWEI = extern "system" fn(commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout);
/// The dummy function for `vkCmdBindInvocationMaskHUAWEI` from `VK_HUAWEI_invocation_mask`
extern "system" fn dummy_vkCmdBindInvocationMaskHUAWEI(_: VkCommandBuffer, _: VkImageView, _: VkImageLayout) {
	panic_any(VkError::NullFunctionPointer("vkCmdBindInvocationMaskHUAWEI"))
}
/// trait for `VK_HUAWEI_invocation_mask`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_HUAWEI_invocation_mask.html>
pub trait VK_HUAWEI_invocation_mask: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindInvocationMaskHUAWEI.html>
	fn vkCmdBindInvocationMaskHUAWEI(&self, commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) -> Result<()>;
}
/// struct for `VK_HUAWEI_invocation_mask`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_HUAWEI_invocation_mask {
	vk_cmd_bind_invocation_mask_huawei: PFN_vkCmdBindInvocationMaskHUAWEI,
}
impl VK_HUAWEI_invocation_mask for Vulkan_HUAWEI_invocation_mask {
	fn vkCmdBindInvocationMaskHUAWEI(&self, commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_bind_invocation_mask_huawei)(commandBuffer, imageView, imageLayout))))
	}
}
impl Default for Vulkan_HUAWEI_invocation_mask {
	fn default() -> Self {
		Self {
			vk_cmd_bind_invocation_mask_huawei: dummy_vkCmdBindInvocationMaskHUAWEI,
		}
	}
}
impl Vulkan_HUAWEI_invocation_mask {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_bind_invocation_mask_huawei: {let proc = get_instance_proc_address(instance, "vkCmdBindInvocationMaskHUAWEI"); if proc == null() {dummy_vkCmdBindInvocationMaskHUAWEI} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkRemoteAddressNV` from VK_NV_external_memory_rdma
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRemoteAddressNV.html>
pub type VkRemoteAddressNV = *mut c_void;
/// struct `VkMemoryGetRemoteAddressInfoNV` from VK_NV_external_memory_rdma
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryGetRemoteAddressInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryGetRemoteAddressInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub memory: VkDeviceMemory,
	pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
impl Debug for VkMemoryGetRemoteAddressInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryGetRemoteAddressInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("memory", &self.memory)
		.field("handleType", &self.handleType)
		.finish()
	}
}
/// struct `VkPhysicalDeviceExternalMemoryRDMAFeaturesNV` from VK_NV_external_memory_rdma
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExternalMemoryRDMAFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceExternalMemoryRDMAFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub externalMemoryRDMA: VkBool32,
}
impl Debug for VkPhysicalDeviceExternalMemoryRDMAFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceExternalMemoryRDMAFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("externalMemoryRDMA", &self.externalMemoryRDMA)
		.finish()
	}
}
/// function prototype `PFN_vkGetMemoryRemoteAddressNV` from VK_NV_external_memory_rdma
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryRemoteAddressNV.html>
type PFN_vkGetMemoryRemoteAddressNV = extern "system" fn(device: VkDevice, pMemoryGetRemoteAddressInfo: *const VkMemoryGetRemoteAddressInfoNV, pAddress: *mut VkRemoteAddressNV) -> VkResult;
/// The dummy function for `vkGetMemoryRemoteAddressNV` from `VK_NV_external_memory_rdma`
extern "system" fn dummy_vkGetMemoryRemoteAddressNV(_: VkDevice, _: *const VkMemoryGetRemoteAddressInfoNV, _: *mut VkRemoteAddressNV) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetMemoryRemoteAddressNV"))
}
/// trait for `VK_NV_external_memory_rdma`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_external_memory_rdma.html>
pub trait VK_NV_external_memory_rdma: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryRemoteAddressNV.html>
	fn vkGetMemoryRemoteAddressNV(&self, device: VkDevice, pMemoryGetRemoteAddressInfo: *const VkMemoryGetRemoteAddressInfoNV, pAddress: *mut VkRemoteAddressNV) -> Result<()>;
}
/// struct for `VK_NV_external_memory_rdma`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_external_memory_rdma {
	vk_get_memory_remote_address_nv: PFN_vkGetMemoryRemoteAddressNV,
}
impl VK_NV_external_memory_rdma for Vulkan_NV_external_memory_rdma {
	fn vkGetMemoryRemoteAddressNV(&self, device: VkDevice, pMemoryGetRemoteAddressInfo: *const VkMemoryGetRemoteAddressInfoNV, pAddress: *mut VkRemoteAddressNV) -> Result<()> {
		convert_result("vkGetMemoryRemoteAddressNV", catch_unwind(||((self.vk_get_memory_remote_address_nv)(device, pMemoryGetRemoteAddressInfo, pAddress))))
	}
}
impl Default for Vulkan_NV_external_memory_rdma {
	fn default() -> Self {
		Self {
			vk_get_memory_remote_address_nv: dummy_vkGetMemoryRemoteAddressNV,
		}
	}
}
impl Vulkan_NV_external_memory_rdma {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_memory_remote_address_nv: {let proc = get_instance_proc_address(instance, "vkGetMemoryRemoteAddressNV"); if proc == null() {dummy_vkGetMemoryRemoteAddressNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPipelineInfoEXT` from VK_EXT_pipeline_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineInfoEXT.html>
pub type VkPipelineInfoEXT = VkPipelineInfoKHR;
/// struct `VkPipelinePropertiesIdentifierEXT` from VK_EXT_pipeline_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelinePropertiesIdentifierEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelinePropertiesIdentifierEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineIdentifier: [u8; VK_UUID_SIZE as usize],
}
impl Debug for VkPipelinePropertiesIdentifierEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelinePropertiesIdentifierEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelineIdentifier", &self.pipelineIdentifier)
		.finish()
	}
}
/// struct `VkPhysicalDevicePipelinePropertiesFeaturesEXT` from VK_EXT_pipeline_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePipelinePropertiesFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePipelinePropertiesFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelinePropertiesIdentifier: VkBool32,
}
impl Debug for VkPhysicalDevicePipelinePropertiesFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePipelinePropertiesFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelinePropertiesIdentifier", &self.pipelinePropertiesIdentifier)
		.finish()
	}
}
/// function prototype `PFN_vkGetPipelinePropertiesEXT` from VK_EXT_pipeline_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelinePropertiesEXT.html>
type PFN_vkGetPipelinePropertiesEXT = extern "system" fn(device: VkDevice, pPipelineInfo: *const VkPipelineInfoEXT, pPipelineProperties: *mut VkBaseOutStructure) -> VkResult;
/// The dummy function for `vkGetPipelinePropertiesEXT` from `VK_EXT_pipeline_properties`
extern "system" fn dummy_vkGetPipelinePropertiesEXT(_: VkDevice, _: *const VkPipelineInfoEXT, _: *mut VkBaseOutStructure) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPipelinePropertiesEXT"))
}
/// trait for `VK_EXT_pipeline_properties`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_pipeline_properties.html>
pub trait VK_EXT_pipeline_properties: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelinePropertiesEXT.html>
	fn vkGetPipelinePropertiesEXT(&self, device: VkDevice, pPipelineInfo: *const VkPipelineInfoEXT, pPipelineProperties: *mut VkBaseOutStructure) -> Result<()>;
}
/// struct for `VK_EXT_pipeline_properties`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_pipeline_properties {
	vk_get_pipeline_properties_ext: PFN_vkGetPipelinePropertiesEXT,
}
impl VK_EXT_pipeline_properties for Vulkan_EXT_pipeline_properties {
	fn vkGetPipelinePropertiesEXT(&self, device: VkDevice, pPipelineInfo: *const VkPipelineInfoEXT, pPipelineProperties: *mut VkBaseOutStructure) -> Result<()> {
		convert_result("vkGetPipelinePropertiesEXT", catch_unwind(||((self.vk_get_pipeline_properties_ext)(device, pPipelineInfo, pPipelineProperties))))
	}
}
impl Default for Vulkan_EXT_pipeline_properties {
	fn default() -> Self {
		Self {
			vk_get_pipeline_properties_ext: dummy_vkGetPipelinePropertiesEXT,
		}
	}
}
impl Vulkan_EXT_pipeline_properties {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_pipeline_properties_ext: {let proc = get_instance_proc_address(instance, "vkGetPipelinePropertiesEXT"); if proc == null() {dummy_vkGetPipelinePropertiesEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkFrameBoundaryFlagsEXT` from VK_EXT_frame_boundary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFrameBoundaryFlagsEXT.html>
pub type VkFrameBoundaryFlagsEXT = VkFlags;
/// enum `VkFrameBoundaryFlagBitsEXT` from VK_EXT_frame_boundary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFrameBoundaryFlagBitsEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkFrameBoundaryFlagBitsEXT {
	VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT = 0x00000001,
	VK_FRAME_BOUNDARY_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkPhysicalDeviceFrameBoundaryFeaturesEXT` from VK_EXT_frame_boundary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFrameBoundaryFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFrameBoundaryFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub frameBoundary: VkBool32,
}
impl Debug for VkPhysicalDeviceFrameBoundaryFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFrameBoundaryFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("frameBoundary", &self.frameBoundary)
		.finish()
	}
}
/// struct `VkFrameBoundaryEXT` from VK_EXT_frame_boundary
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFrameBoundaryEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkFrameBoundaryEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkFrameBoundaryFlagsEXT,
	pub frameID: u64,
	pub imageCount: u32,
	pub pImages: *const VkImage,
	pub bufferCount: u32,
	pub pBuffers: *const VkBuffer,
	pub tagName: u64,
	pub tagSize: usize,
	pub pTag: *const c_void,
}
impl Debug for VkFrameBoundaryEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkFrameBoundaryEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("frameID", &self.frameID)
		.field("imageCount", &self.imageCount)
		.field("pImages", &self.pImages)
		.field("bufferCount", &self.bufferCount)
		.field("pBuffers", &self.pBuffers)
		.field("tagName", &self.tagName)
		.field("tagSize", &self.tagSize)
		.field("pTag", &self.pTag)
		.finish()
	}
}
/// trait for `VK_EXT_frame_boundary`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_frame_boundary.html>
pub trait VK_EXT_frame_boundary: Debug {}
/// struct for `VK_EXT_frame_boundary`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_frame_boundary {}
impl VK_EXT_frame_boundary for Vulkan_EXT_frame_boundary {}
impl Default for Vulkan_EXT_frame_boundary {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_frame_boundary {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT` from VK_EXT_multisampled_render_to_single_sampled
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub multisampledRenderToSingleSampled: VkBool32,
}
impl Debug for VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("multisampledRenderToSingleSampled", &self.multisampledRenderToSingleSampled)
		.finish()
	}
}
/// struct `VkSubpassResolvePerformanceQueryEXT` from VK_EXT_multisampled_render_to_single_sampled
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassResolvePerformanceQueryEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSubpassResolvePerformanceQueryEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub optimal: VkBool32,
}
impl Debug for VkSubpassResolvePerformanceQueryEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSubpassResolvePerformanceQueryEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("optimal", &self.optimal)
		.finish()
	}
}
/// struct `VkMultisampledRenderToSingleSampledInfoEXT` from VK_EXT_multisampled_render_to_single_sampled
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMultisampledRenderToSingleSampledInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMultisampledRenderToSingleSampledInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub multisampledRenderToSingleSampledEnable: VkBool32,
	pub rasterizationSamples: VkSampleCountFlagBits,
}
impl Debug for VkMultisampledRenderToSingleSampledInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMultisampledRenderToSingleSampledInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("multisampledRenderToSingleSampledEnable", &self.multisampledRenderToSingleSampledEnable)
		.field("rasterizationSamples", &self.rasterizationSamples)
		.finish()
	}
}
/// trait for `VK_EXT_multisampled_render_to_single_sampled`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_multisampled_render_to_single_sampled.html>
pub trait VK_EXT_multisampled_render_to_single_sampled: Debug {}
/// struct for `VK_EXT_multisampled_render_to_single_sampled`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_multisampled_render_to_single_sampled {}
impl VK_EXT_multisampled_render_to_single_sampled for Vulkan_EXT_multisampled_render_to_single_sampled {}
impl Default for Vulkan_EXT_multisampled_render_to_single_sampled {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_multisampled_render_to_single_sampled {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceExtendedDynamicState2FeaturesEXT` from VK_EXT_extended_dynamic_state2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceExtendedDynamicState2FeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub extendedDynamicState2: VkBool32,
	pub extendedDynamicState2LogicOp: VkBool32,
	pub extendedDynamicState2PatchControlPoints: VkBool32,
}
impl Debug for VkPhysicalDeviceExtendedDynamicState2FeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceExtendedDynamicState2FeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("extendedDynamicState2", &self.extendedDynamicState2)
		.field("extendedDynamicState2LogicOp", &self.extendedDynamicState2LogicOp)
		.field("extendedDynamicState2PatchControlPoints", &self.extendedDynamicState2PatchControlPoints)
		.finish()
	}
}
/// function prototype `PFN_vkCmdSetPatchControlPointsEXT` from VK_EXT_extended_dynamic_state2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPatchControlPointsEXT.html>
type PFN_vkCmdSetPatchControlPointsEXT = extern "system" fn(commandBuffer: VkCommandBuffer, patchControlPoints: u32);
/// function prototype `PFN_vkCmdSetRasterizerDiscardEnableEXT` from VK_EXT_extended_dynamic_state2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRasterizerDiscardEnableEXT.html>
type PFN_vkCmdSetRasterizerDiscardEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32);
/// function prototype `PFN_vkCmdSetDepthBiasEnableEXT` from VK_EXT_extended_dynamic_state2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBiasEnableEXT.html>
type PFN_vkCmdSetDepthBiasEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32);
/// function prototype `PFN_vkCmdSetLogicOpEXT` from VK_EXT_extended_dynamic_state2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLogicOpEXT.html>
type PFN_vkCmdSetLogicOpEXT = extern "system" fn(commandBuffer: VkCommandBuffer, logicOp: VkLogicOp);
/// function prototype `PFN_vkCmdSetPrimitiveRestartEnableEXT` from VK_EXT_extended_dynamic_state2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPrimitiveRestartEnableEXT.html>
type PFN_vkCmdSetPrimitiveRestartEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32);
/// The dummy function for `vkCmdSetPatchControlPointsEXT` from `VK_EXT_extended_dynamic_state2`
extern "system" fn dummy_vkCmdSetPatchControlPointsEXT(_: VkCommandBuffer, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetPatchControlPointsEXT"))
}
/// trait for `VK_EXT_extended_dynamic_state2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_extended_dynamic_state2.html>
pub trait VK_EXT_extended_dynamic_state2: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPatchControlPointsEXT.html>
	fn vkCmdSetPatchControlPointsEXT(&self, commandBuffer: VkCommandBuffer, patchControlPoints: u32) -> Result<()>;
}
/// struct for `VK_EXT_extended_dynamic_state2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_extended_dynamic_state2 {
	vk_cmd_set_patch_control_points_ext: PFN_vkCmdSetPatchControlPointsEXT,
}
impl VK_EXT_extended_dynamic_state2 for Vulkan_EXT_extended_dynamic_state2 {
	fn vkCmdSetPatchControlPointsEXT(&self, commandBuffer: VkCommandBuffer, patchControlPoints: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_patch_control_points_ext)(commandBuffer, patchControlPoints))))
	}
}
impl Default for Vulkan_EXT_extended_dynamic_state2 {
	fn default() -> Self {
		Self {
			vk_cmd_set_patch_control_points_ext: dummy_vkCmdSetPatchControlPointsEXT,
		}
	}
}
impl Vulkan_EXT_extended_dynamic_state2 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_patch_control_points_ext: {let proc = get_instance_proc_address(instance, "vkCmdSetPatchControlPointsEXT"); if proc == null() {dummy_vkCmdSetPatchControlPointsEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceColorWriteEnableFeaturesEXT` from VK_EXT_color_write_enable
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceColorWriteEnableFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceColorWriteEnableFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub colorWriteEnable: VkBool32,
}
impl Debug for VkPhysicalDeviceColorWriteEnableFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceColorWriteEnableFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("colorWriteEnable", &self.colorWriteEnable)
		.finish()
	}
}
/// struct `VkPipelineColorWriteCreateInfoEXT` from VK_EXT_color_write_enable
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineColorWriteCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineColorWriteCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub attachmentCount: u32,
	pub pColorWriteEnables: *const VkBool32,
}
impl Debug for VkPipelineColorWriteCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineColorWriteCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("attachmentCount", &self.attachmentCount)
		.field("pColorWriteEnables", &self.pColorWriteEnables)
		.finish()
	}
}
/// function prototype `PFN_vkCmdSetColorWriteEnableEXT` from VK_EXT_color_write_enable
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetColorWriteEnableEXT.html>
type PFN_vkCmdSetColorWriteEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, attachmentCount: u32, pColorWriteEnables: *const VkBool32);
/// The dummy function for `vkCmdSetColorWriteEnableEXT` from `VK_EXT_color_write_enable`
extern "system" fn dummy_vkCmdSetColorWriteEnableEXT(_: VkCommandBuffer, _: u32, _: *const VkBool32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetColorWriteEnableEXT"))
}
/// trait for `VK_EXT_color_write_enable`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_color_write_enable.html>
pub trait VK_EXT_color_write_enable: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetColorWriteEnableEXT.html>
	fn vkCmdSetColorWriteEnableEXT(&self, commandBuffer: VkCommandBuffer, attachmentCount: u32, pColorWriteEnables: *const VkBool32) -> Result<()>;
}
/// struct for `VK_EXT_color_write_enable`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_color_write_enable {
	vk_cmd_set_color_write_enable_ext: PFN_vkCmdSetColorWriteEnableEXT,
}
impl VK_EXT_color_write_enable for Vulkan_EXT_color_write_enable {
	fn vkCmdSetColorWriteEnableEXT(&self, commandBuffer: VkCommandBuffer, attachmentCount: u32, pColorWriteEnables: *const VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_color_write_enable_ext)(commandBuffer, attachmentCount, pColorWriteEnables))))
	}
}
impl Default for Vulkan_EXT_color_write_enable {
	fn default() -> Self {
		Self {
			vk_cmd_set_color_write_enable_ext: dummy_vkCmdSetColorWriteEnableEXT,
		}
	}
}
impl Vulkan_EXT_color_write_enable {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_color_write_enable_ext: {let proc = get_instance_proc_address(instance, "vkCmdSetColorWriteEnableEXT"); if proc == null() {dummy_vkCmdSetColorWriteEnableEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT` from VK_EXT_primitives_generated_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub primitivesGeneratedQuery: VkBool32,
	pub primitivesGeneratedQueryWithRasterizerDiscard: VkBool32,
	pub primitivesGeneratedQueryWithNonZeroStreams: VkBool32,
}
impl Debug for VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("primitivesGeneratedQuery", &self.primitivesGeneratedQuery)
		.field("primitivesGeneratedQueryWithRasterizerDiscard", &self.primitivesGeneratedQueryWithRasterizerDiscard)
		.field("primitivesGeneratedQueryWithNonZeroStreams", &self.primitivesGeneratedQueryWithNonZeroStreams)
		.finish()
	}
}
/// trait for `VK_EXT_primitives_generated_query`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_primitives_generated_query.html>
pub trait VK_EXT_primitives_generated_query: Debug {}
/// struct for `VK_EXT_primitives_generated_query`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_primitives_generated_query {}
impl VK_EXT_primitives_generated_query for Vulkan_EXT_primitives_generated_query {}
impl Default for Vulkan_EXT_primitives_generated_query {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_primitives_generated_query {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `VK_MAX_GLOBAL_PRIORITY_SIZE_EXT` from VK_EXT_global_priority_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_GLOBAL_PRIORITY_SIZE_EXT.html>
pub const VK_MAX_GLOBAL_PRIORITY_SIZE_EXT: u32 = 16u32;
/// type definition `VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT` from VK_EXT_global_priority_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT.html>
pub type VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT = VkPhysicalDeviceGlobalPriorityQueryFeatures;
/// type definition `VkQueueFamilyGlobalPriorityPropertiesEXT` from VK_EXT_global_priority_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueFamilyGlobalPriorityPropertiesEXT.html>
pub type VkQueueFamilyGlobalPriorityPropertiesEXT = VkQueueFamilyGlobalPriorityProperties;
/// trait for `VK_EXT_global_priority_query`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_global_priority_query.html>
pub trait VK_EXT_global_priority_query: Debug {}
/// struct for `VK_EXT_global_priority_query`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_global_priority_query {}
impl VK_EXT_global_priority_query for Vulkan_EXT_global_priority_query {}
impl Default for Vulkan_EXT_global_priority_query {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_global_priority_query {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceImageViewMinLodFeaturesEXT` from VK_EXT_image_view_min_lod
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImageViewMinLodFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceImageViewMinLodFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub minLod: VkBool32,
}
impl Debug for VkPhysicalDeviceImageViewMinLodFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceImageViewMinLodFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("minLod", &self.minLod)
		.finish()
	}
}
/// struct `VkImageViewMinLodCreateInfoEXT` from VK_EXT_image_view_min_lod
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageViewMinLodCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageViewMinLodCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub minLod: f32,
}
impl Debug for VkImageViewMinLodCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageViewMinLodCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("minLod", &self.minLod)
		.finish()
	}
}
/// trait for `VK_EXT_image_view_min_lod`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_image_view_min_lod.html>
pub trait VK_EXT_image_view_min_lod: Debug {}
/// struct for `VK_EXT_image_view_min_lod`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_image_view_min_lod {}
impl VK_EXT_image_view_min_lod for Vulkan_EXT_image_view_min_lod {}
impl Default for Vulkan_EXT_image_view_min_lod {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_image_view_min_lod {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceMultiDrawFeaturesEXT` from VK_EXT_multi_draw
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMultiDrawFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMultiDrawFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub multiDraw: VkBool32,
}
impl Debug for VkPhysicalDeviceMultiDrawFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMultiDrawFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("multiDraw", &self.multiDraw)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMultiDrawPropertiesEXT` from VK_EXT_multi_draw
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMultiDrawPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMultiDrawPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxMultiDrawCount: u32,
}
impl Debug for VkPhysicalDeviceMultiDrawPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMultiDrawPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxMultiDrawCount", &self.maxMultiDrawCount)
		.finish()
	}
}
/// struct `VkMultiDrawInfoEXT` from VK_EXT_multi_draw
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMultiDrawInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMultiDrawInfoEXT {
	pub firstVertex: u32,
	pub vertexCount: u32,
}
impl Debug for VkMultiDrawInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMultiDrawInfoEXT")
		.field("firstVertex", &self.firstVertex)
		.field("vertexCount", &self.vertexCount)
		.finish()
	}
}
/// struct `VkMultiDrawIndexedInfoEXT` from VK_EXT_multi_draw
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMultiDrawIndexedInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMultiDrawIndexedInfoEXT {
	pub firstIndex: u32,
	pub indexCount: u32,
	pub vertexOffset: i32,
}
impl Debug for VkMultiDrawIndexedInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMultiDrawIndexedInfoEXT")
		.field("firstIndex", &self.firstIndex)
		.field("indexCount", &self.indexCount)
		.field("vertexOffset", &self.vertexOffset)
		.finish()
	}
}
/// function prototype `PFN_vkCmdDrawMultiEXT` from VK_EXT_multi_draw
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMultiEXT.html>
type PFN_vkCmdDrawMultiEXT = extern "system" fn(commandBuffer: VkCommandBuffer, drawCount: u32, pVertexInfo: *const VkMultiDrawInfoEXT, instanceCount: u32, firstInstance: u32, stride: u32);
/// function prototype `PFN_vkCmdDrawMultiIndexedEXT` from VK_EXT_multi_draw
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMultiIndexedEXT.html>
type PFN_vkCmdDrawMultiIndexedEXT = extern "system" fn(commandBuffer: VkCommandBuffer, drawCount: u32, pIndexInfo: *const VkMultiDrawIndexedInfoEXT, instanceCount: u32, firstInstance: u32, stride: u32, pVertexOffset: *const int32_t);
/// The dummy function for `vkCmdDrawMultiEXT` from `VK_EXT_multi_draw`
extern "system" fn dummy_vkCmdDrawMultiEXT(_: VkCommandBuffer, _: u32, _: *const VkMultiDrawInfoEXT, _: u32, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdDrawMultiEXT"))
}
/// trait for `VK_EXT_multi_draw`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_multi_draw.html>
pub trait VK_EXT_multi_draw: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMultiEXT.html>
	fn vkCmdDrawMultiEXT(&self, commandBuffer: VkCommandBuffer, drawCount: u32, pVertexInfo: *const VkMultiDrawInfoEXT, instanceCount: u32, firstInstance: u32, stride: u32) -> Result<()>;
}
/// struct for `VK_EXT_multi_draw`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_multi_draw {
	vk_cmd_draw_multi_ext: PFN_vkCmdDrawMultiEXT,
}
impl VK_EXT_multi_draw for Vulkan_EXT_multi_draw {
	fn vkCmdDrawMultiEXT(&self, commandBuffer: VkCommandBuffer, drawCount: u32, pVertexInfo: *const VkMultiDrawInfoEXT, instanceCount: u32, firstInstance: u32, stride: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_draw_multi_ext)(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride))))
	}
}
impl Default for Vulkan_EXT_multi_draw {
	fn default() -> Self {
		Self {
			vk_cmd_draw_multi_ext: dummy_vkCmdDrawMultiEXT,
		}
	}
}
impl Vulkan_EXT_multi_draw {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_draw_multi_ext: {let proc = get_instance_proc_address(instance, "vkCmdDrawMultiEXT"); if proc == null() {dummy_vkCmdDrawMultiEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceImage2DViewOf3DFeaturesEXT` from VK_EXT_image_2d_view_of_3d
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImage2DViewOf3DFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceImage2DViewOf3DFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub image2DViewOf3D: VkBool32,
	pub sampler2DViewOf3D: VkBool32,
}
impl Debug for VkPhysicalDeviceImage2DViewOf3DFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceImage2DViewOf3DFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("image2DViewOf3D", &self.image2DViewOf3D)
		.field("sampler2DViewOf3D", &self.sampler2DViewOf3D)
		.finish()
	}
}
/// trait for `VK_EXT_image_2d_view_of_3d`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_image_2d_view_of_3d.html>
pub trait VK_EXT_image_2d_view_of_3d: Debug {}
/// struct for `VK_EXT_image_2d_view_of_3d`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_image_2d_view_of_3d {}
impl VK_EXT_image_2d_view_of_3d for Vulkan_EXT_image_2d_view_of_3d {}
impl Default for Vulkan_EXT_image_2d_view_of_3d {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_image_2d_view_of_3d {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceShaderTileImageFeaturesEXT` from VK_EXT_shader_tile_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderTileImageFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderTileImageFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderTileImageColorReadAccess: VkBool32,
	pub shaderTileImageDepthReadAccess: VkBool32,
	pub shaderTileImageStencilReadAccess: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderTileImageFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderTileImageFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderTileImageColorReadAccess", &self.shaderTileImageColorReadAccess)
		.field("shaderTileImageDepthReadAccess", &self.shaderTileImageDepthReadAccess)
		.field("shaderTileImageStencilReadAccess", &self.shaderTileImageStencilReadAccess)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShaderTileImagePropertiesEXT` from VK_EXT_shader_tile_image
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderTileImagePropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderTileImagePropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderTileImageCoherentReadAccelerated: VkBool32,
	pub shaderTileImageReadSampleFromPixelRateInvocation: VkBool32,
	pub shaderTileImageReadFromHelperInvocation: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderTileImagePropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderTileImagePropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderTileImageCoherentReadAccelerated", &self.shaderTileImageCoherentReadAccelerated)
		.field("shaderTileImageReadSampleFromPixelRateInvocation", &self.shaderTileImageReadSampleFromPixelRateInvocation)
		.field("shaderTileImageReadFromHelperInvocation", &self.shaderTileImageReadFromHelperInvocation)
		.finish()
	}
}
/// trait for `VK_EXT_shader_tile_image`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_shader_tile_image.html>
pub trait VK_EXT_shader_tile_image: Debug {}
/// struct for `VK_EXT_shader_tile_image`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_tile_image {}
impl VK_EXT_shader_tile_image for Vulkan_EXT_shader_tile_image {}
impl Default for Vulkan_EXT_shader_tile_image {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_tile_image {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkBuildMicromapFlagsEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBuildMicromapFlagsEXT.html>
pub type VkBuildMicromapFlagsEXT = VkFlags;
/// type definition `VkMicromapCreateFlagsEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMicromapCreateFlagsEXT.html>
pub type VkMicromapCreateFlagsEXT = VkFlags;
/// Non-dispatchable handle `VkMicromapEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMicromapEXT.html
#[cfg(target_pointer_width = "32")] pub type VkMicromapEXT = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkMicromapEXT_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkMicromapEXT = *const VkMicromapEXT_T;
/// enum `VkMicromapTypeEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMicromapTypeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkMicromapTypeEXT {
	VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT = 0,
	VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV = 1000397000,
	VK_MICROMAP_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkBuildMicromapModeEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBuildMicromapModeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBuildMicromapModeEXT {
	VK_BUILD_MICROMAP_MODE_BUILD_EXT = 0,
	VK_BUILD_MICROMAP_MODE_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkCopyMicromapModeEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyMicromapModeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCopyMicromapModeEXT {
	VK_COPY_MICROMAP_MODE_CLONE_EXT = 0,
	VK_COPY_MICROMAP_MODE_SERIALIZE_EXT = 1,
	VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT = 2,
	VK_COPY_MICROMAP_MODE_COMPACT_EXT = 3,
	VK_COPY_MICROMAP_MODE_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkOpacityMicromapFormatEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpacityMicromapFormatEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOpacityMicromapFormatEXT {
	VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT = 1,
	VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT = 2,
	VK_OPACITY_MICROMAP_FORMAT_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkOpacityMicromapSpecialIndexEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpacityMicromapSpecialIndexEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOpacityMicromapSpecialIndexEXT {
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT = -1,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT = -2,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT = -3,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT = -4,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV = -5,
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkAccelerationStructureCompatibilityKHR` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureCompatibilityKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAccelerationStructureCompatibilityKHR {
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = 0,
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = 1,
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkAccelerationStructureBuildTypeKHR` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildTypeKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAccelerationStructureBuildTypeKHR {
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0,
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 1,
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 2,
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkBuildMicromapFlagBitsEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBuildMicromapFlagBitsEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBuildMicromapFlagBitsEXT {
	VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT = 0x00000001,
	VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT = 0x00000002,
	VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT = 0x00000004,
	VK_BUILD_MICROMAP_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkMicromapCreateFlagBitsEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMicromapCreateFlagBitsEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkMicromapCreateFlagBitsEXT {
	VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 0x00000001,
	VK_MICROMAP_CREATE_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
/// union `VkDeviceOrHostAddressKHR` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceOrHostAddressKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkDeviceOrHostAddressKHR {
	pub deviceAddress: VkDeviceAddress,
	pub hostAddress: *mut c_void,
}
impl Debug for VkDeviceOrHostAddressKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceOrHostAddressKHR")
		.field("deviceAddress", unsafe {&self.deviceAddress})
		.field("hostAddress", unsafe {&self.hostAddress})
		.finish()
	}
}
/// struct `VkMicromapUsageEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMicromapUsageEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMicromapUsageEXT {
	pub count: u32,
	pub subdivisionLevel: u32,
	pub format: u32,
}
impl Debug for VkMicromapUsageEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMicromapUsageEXT")
		.field("count", &self.count)
		.field("subdivisionLevel", &self.subdivisionLevel)
		.field("format", &self.format)
		.finish()
	}
}
/// struct `VkMicromapBuildInfoEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMicromapBuildInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMicromapBuildInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkMicromapTypeEXT,
	pub flags: VkBuildMicromapFlagsEXT,
	pub mode: VkBuildMicromapModeEXT,
	pub dstMicromap: VkMicromapEXT,
	pub usageCountsCount: u32,
	pub pUsageCounts: *const VkMicromapUsageEXT,
	pub ppUsageCounts: *const *const VkMicromapUsageEXT,
	pub data: VkDeviceOrHostAddressConstKHR,
	pub scratchData: VkDeviceOrHostAddressKHR,
	pub triangleArray: VkDeviceOrHostAddressConstKHR,
	pub triangleArrayStride: VkDeviceSize,
}
impl Debug for VkMicromapBuildInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMicromapBuildInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("type_", &self.type_)
		.field("flags", &self.flags)
		.field("mode", &self.mode)
		.field("dstMicromap", &self.dstMicromap)
		.field("usageCountsCount", &self.usageCountsCount)
		.field("pUsageCounts", &self.pUsageCounts)
		.field("ppUsageCounts", &self.ppUsageCounts)
		.field("data", &self.data)
		.field("scratchData", &self.scratchData)
		.field("triangleArray", &self.triangleArray)
		.field("triangleArrayStride", &self.triangleArrayStride)
		.finish()
	}
}
/// struct `VkMicromapCreateInfoEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMicromapCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMicromapCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub createFlags: VkMicromapCreateFlagsEXT,
	pub buffer: VkBuffer,
	pub offset: VkDeviceSize,
	pub size: VkDeviceSize,
	pub type_: VkMicromapTypeEXT,
	pub deviceAddress: VkDeviceAddress,
}
impl Debug for VkMicromapCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMicromapCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("createFlags", &self.createFlags)
		.field("buffer", &self.buffer)
		.field("offset", &self.offset)
		.field("size", &self.size)
		.field("type_", &self.type_)
		.field("deviceAddress", &self.deviceAddress)
		.finish()
	}
}
/// struct `VkPhysicalDeviceOpacityMicromapFeaturesEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceOpacityMicromapFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceOpacityMicromapFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub micromap: VkBool32,
	pub micromapCaptureReplay: VkBool32,
	pub micromapHostCommands: VkBool32,
}
impl Debug for VkPhysicalDeviceOpacityMicromapFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceOpacityMicromapFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("micromap", &self.micromap)
		.field("micromapCaptureReplay", &self.micromapCaptureReplay)
		.field("micromapHostCommands", &self.micromapHostCommands)
		.finish()
	}
}
/// struct `VkPhysicalDeviceOpacityMicromapPropertiesEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceOpacityMicromapPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceOpacityMicromapPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxOpacity2StateSubdivisionLevel: u32,
	pub maxOpacity4StateSubdivisionLevel: u32,
}
impl Debug for VkPhysicalDeviceOpacityMicromapPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceOpacityMicromapPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxOpacity2StateSubdivisionLevel", &self.maxOpacity2StateSubdivisionLevel)
		.field("maxOpacity4StateSubdivisionLevel", &self.maxOpacity4StateSubdivisionLevel)
		.finish()
	}
}
/// struct `VkMicromapVersionInfoEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMicromapVersionInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMicromapVersionInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pVersionData: *const uint8_t,
}
impl Debug for VkMicromapVersionInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMicromapVersionInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pVersionData", &self.pVersionData)
		.finish()
	}
}
/// struct `VkCopyMicromapToMemoryInfoEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyMicromapToMemoryInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyMicromapToMemoryInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub src: VkMicromapEXT,
	pub dst: VkDeviceOrHostAddressKHR,
	pub mode: VkCopyMicromapModeEXT,
}
impl Debug for VkCopyMicromapToMemoryInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyMicromapToMemoryInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("src", &self.src)
		.field("dst", &self.dst)
		.field("mode", &self.mode)
		.finish()
	}
}
/// struct `VkCopyMemoryToMicromapInfoEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyMemoryToMicromapInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyMemoryToMicromapInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub src: VkDeviceOrHostAddressConstKHR,
	pub dst: VkMicromapEXT,
	pub mode: VkCopyMicromapModeEXT,
}
impl Debug for VkCopyMemoryToMicromapInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyMemoryToMicromapInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("src", &self.src)
		.field("dst", &self.dst)
		.field("mode", &self.mode)
		.finish()
	}
}
/// struct `VkCopyMicromapInfoEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyMicromapInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyMicromapInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub src: VkMicromapEXT,
	pub dst: VkMicromapEXT,
	pub mode: VkCopyMicromapModeEXT,
}
impl Debug for VkCopyMicromapInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyMicromapInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("src", &self.src)
		.field("dst", &self.dst)
		.field("mode", &self.mode)
		.finish()
	}
}
/// struct `VkMicromapBuildSizesInfoEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMicromapBuildSizesInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMicromapBuildSizesInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub micromapSize: VkDeviceSize,
	pub buildScratchSize: VkDeviceSize,
	pub discardable: VkBool32,
}
impl Debug for VkMicromapBuildSizesInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMicromapBuildSizesInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("micromapSize", &self.micromapSize)
		.field("buildScratchSize", &self.buildScratchSize)
		.field("discardable", &self.discardable)
		.finish()
	}
}
/// struct `VkAccelerationStructureTrianglesOpacityMicromapEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureTrianglesOpacityMicromapEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureTrianglesOpacityMicromapEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub indexType: VkIndexType,
	pub indexBuffer: VkDeviceOrHostAddressConstKHR,
	pub indexStride: VkDeviceSize,
	pub baseTriangle: u32,
	pub usageCountsCount: u32,
	pub pUsageCounts: *const VkMicromapUsageEXT,
	pub ppUsageCounts: *const *const VkMicromapUsageEXT,
	pub micromap: VkMicromapEXT,
}
impl Debug for VkAccelerationStructureTrianglesOpacityMicromapEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureTrianglesOpacityMicromapEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("indexType", &self.indexType)
		.field("indexBuffer", &self.indexBuffer)
		.field("indexStride", &self.indexStride)
		.field("baseTriangle", &self.baseTriangle)
		.field("usageCountsCount", &self.usageCountsCount)
		.field("pUsageCounts", &self.pUsageCounts)
		.field("ppUsageCounts", &self.ppUsageCounts)
		.field("micromap", &self.micromap)
		.finish()
	}
}
/// struct `VkMicromapTriangleEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMicromapTriangleEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMicromapTriangleEXT {
	pub dataOffset: u32,
	pub subdivisionLevel: u16,
	pub format: u16,
}
impl Debug for VkMicromapTriangleEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMicromapTriangleEXT")
		.field("dataOffset", &self.dataOffset)
		.field("subdivisionLevel", &self.subdivisionLevel)
		.field("format", &self.format)
		.finish()
	}
}
/// function prototype `PFN_vkCreateMicromapEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateMicromapEXT.html>
type PFN_vkCreateMicromapEXT = extern "system" fn(device: VkDevice, pCreateInfo: *const VkMicromapCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pMicromap: *mut VkMicromapEXT) -> VkResult;
/// function prototype `PFN_vkDestroyMicromapEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyMicromapEXT.html>
type PFN_vkDestroyMicromapEXT = extern "system" fn(device: VkDevice, micromap: VkMicromapEXT, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCmdBuildMicromapsEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildMicromapsEXT.html>
type PFN_vkCmdBuildMicromapsEXT = extern "system" fn(commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *const VkMicromapBuildInfoEXT);
/// function prototype `PFN_vkBuildMicromapsEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBuildMicromapsEXT.html>
type PFN_vkBuildMicromapsEXT = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, infoCount: u32, pInfos: *const VkMicromapBuildInfoEXT) -> VkResult;
/// function prototype `PFN_vkCopyMicromapEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMicromapEXT.html>
type PFN_vkCopyMicromapEXT = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *const VkCopyMicromapInfoEXT) -> VkResult;
/// function prototype `PFN_vkCopyMicromapToMemoryEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMicromapToMemoryEXT.html>
type PFN_vkCopyMicromapToMemoryEXT = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *const VkCopyMicromapToMemoryInfoEXT) -> VkResult;
/// function prototype `PFN_vkCopyMemoryToMicromapEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToMicromapEXT.html>
type PFN_vkCopyMemoryToMicromapEXT = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *const VkCopyMemoryToMicromapInfoEXT) -> VkResult;
/// function prototype `PFN_vkWriteMicromapsPropertiesEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkWriteMicromapsPropertiesEXT.html>
type PFN_vkWriteMicromapsPropertiesEXT = extern "system" fn(device: VkDevice, micromapCount: u32, pMicromaps: *const VkMicromapEXT, queryType: VkQueryType, dataSize: usize, pData: *mut c_void, stride: usize) -> VkResult;
/// function prototype `PFN_vkCmdCopyMicromapEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMicromapEXT.html>
type PFN_vkCmdCopyMicromapEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pInfo: *const VkCopyMicromapInfoEXT);
/// function prototype `PFN_vkCmdCopyMicromapToMemoryEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMicromapToMemoryEXT.html>
type PFN_vkCmdCopyMicromapToMemoryEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pInfo: *const VkCopyMicromapToMemoryInfoEXT);
/// function prototype `PFN_vkCmdCopyMemoryToMicromapEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMemoryToMicromapEXT.html>
type PFN_vkCmdCopyMemoryToMicromapEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pInfo: *const VkCopyMemoryToMicromapInfoEXT);
/// function prototype `PFN_vkCmdWriteMicromapsPropertiesEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteMicromapsPropertiesEXT.html>
type PFN_vkCmdWriteMicromapsPropertiesEXT = extern "system" fn(commandBuffer: VkCommandBuffer, micromapCount: u32, pMicromaps: *const VkMicromapEXT, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: u32);
/// function prototype `PFN_vkGetDeviceMicromapCompatibilityEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceMicromapCompatibilityEXT.html>
type PFN_vkGetDeviceMicromapCompatibilityEXT = extern "system" fn(device: VkDevice, pVersionInfo: *const VkMicromapVersionInfoEXT, pCompatibility: *mut VkAccelerationStructureCompatibilityKHR);
/// function prototype `PFN_vkGetMicromapBuildSizesEXT` from VK_EXT_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMicromapBuildSizesEXT.html>
type PFN_vkGetMicromapBuildSizesEXT = extern "system" fn(device: VkDevice, buildType: VkAccelerationStructureBuildTypeKHR, pBuildInfo: *const VkMicromapBuildInfoEXT, pSizeInfo: *mut VkMicromapBuildSizesInfoEXT);
/// The dummy function for `vkCreateMicromapEXT` from `VK_EXT_opacity_micromap`
extern "system" fn dummy_vkCreateMicromapEXT(_: VkDevice, _: *const VkMicromapCreateInfoEXT, _: *const VkAllocationCallbacks, _: *mut VkMicromapEXT) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateMicromapEXT"))
}
/// trait for `VK_EXT_opacity_micromap`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_opacity_micromap.html>
pub trait VK_EXT_opacity_micromap: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateMicromapEXT.html>
	fn vkCreateMicromapEXT(&self, device: VkDevice, pCreateInfo: *const VkMicromapCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pMicromap: *mut VkMicromapEXT) -> Result<()>;
}
/// struct for `VK_EXT_opacity_micromap`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_opacity_micromap {
	vk_create_micromap_ext: PFN_vkCreateMicromapEXT,
}
impl VK_EXT_opacity_micromap for Vulkan_EXT_opacity_micromap {
	fn vkCreateMicromapEXT(&self, device: VkDevice, pCreateInfo: *const VkMicromapCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pMicromap: *mut VkMicromapEXT) -> Result<()> {
		convert_result("vkCreateMicromapEXT", catch_unwind(||((self.vk_create_micromap_ext)(device, pCreateInfo, pAllocator, pMicromap))))
	}
}
impl Default for Vulkan_EXT_opacity_micromap {
	fn default() -> Self {
		Self {
			vk_create_micromap_ext: dummy_vkCreateMicromapEXT,
		}
	}
}
impl Vulkan_EXT_opacity_micromap {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_micromap_ext: {let proc = get_instance_proc_address(instance, "vkCreateMicromapEXT"); if proc == null() {dummy_vkCreateMicromapEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// trait for `VK_EXT_load_store_op_none`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_load_store_op_none.html>
pub trait VK_EXT_load_store_op_none: Debug {}
/// struct for `VK_EXT_load_store_op_none`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_load_store_op_none {}
impl VK_EXT_load_store_op_none for Vulkan_EXT_load_store_op_none {}
impl Default for Vulkan_EXT_load_store_op_none {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_load_store_op_none {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI` from VK_HUAWEI_cluster_culling_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub clustercullingShader: VkBool32,
	pub multiviewClusterCullingShader: VkBool32,
}
impl Debug for VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("clustercullingShader", &self.clustercullingShader)
		.field("multiviewClusterCullingShader", &self.multiviewClusterCullingShader)
		.finish()
	}
}
/// struct `VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI` from VK_HUAWEI_cluster_culling_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxWorkGroupCount: [u32; 3 as usize],
	pub maxWorkGroupSize: [u32; 3 as usize],
	pub maxOutputClusterCount: u32,
	pub indirectBufferOffsetAlignment: VkDeviceSize,
}
impl Debug for VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxWorkGroupCount", &self.maxWorkGroupCount)
		.field("maxWorkGroupSize", &self.maxWorkGroupSize)
		.field("maxOutputClusterCount", &self.maxOutputClusterCount)
		.field("indirectBufferOffsetAlignment", &self.indirectBufferOffsetAlignment)
		.finish()
	}
}
/// struct `VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI` from VK_HUAWEI_cluster_culling_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub clusterShadingRate: VkBool32,
}
impl Debug for VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("clusterShadingRate", &self.clusterShadingRate)
		.finish()
	}
}
/// function prototype `PFN_vkCmdDrawClusterHUAWEI` from VK_HUAWEI_cluster_culling_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawClusterHUAWEI.html>
type PFN_vkCmdDrawClusterHUAWEI = extern "system" fn(commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32);
/// function prototype `PFN_vkCmdDrawClusterIndirectHUAWEI` from VK_HUAWEI_cluster_culling_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawClusterIndirectHUAWEI.html>
type PFN_vkCmdDrawClusterIndirectHUAWEI = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize);
/// The dummy function for `vkCmdDrawClusterHUAWEI` from `VK_HUAWEI_cluster_culling_shader`
extern "system" fn dummy_vkCmdDrawClusterHUAWEI(_: VkCommandBuffer, _: u32, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdDrawClusterHUAWEI"))
}
/// trait for `VK_HUAWEI_cluster_culling_shader`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_HUAWEI_cluster_culling_shader.html>
pub trait VK_HUAWEI_cluster_culling_shader: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawClusterHUAWEI.html>
	fn vkCmdDrawClusterHUAWEI(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> Result<()>;
}
/// struct for `VK_HUAWEI_cluster_culling_shader`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_HUAWEI_cluster_culling_shader {
	vk_cmd_draw_cluster_huawei: PFN_vkCmdDrawClusterHUAWEI,
}
impl VK_HUAWEI_cluster_culling_shader for Vulkan_HUAWEI_cluster_culling_shader {
	fn vkCmdDrawClusterHUAWEI(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_draw_cluster_huawei)(commandBuffer, groupCountX, groupCountY, groupCountZ))))
	}
}
impl Default for Vulkan_HUAWEI_cluster_culling_shader {
	fn default() -> Self {
		Self {
			vk_cmd_draw_cluster_huawei: dummy_vkCmdDrawClusterHUAWEI,
		}
	}
}
impl Vulkan_HUAWEI_cluster_culling_shader {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_draw_cluster_huawei: {let proc = get_instance_proc_address(instance, "vkCmdDrawClusterHUAWEI"); if proc == null() {dummy_vkCmdDrawClusterHUAWEI} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceBorderColorSwizzleFeaturesEXT` from VK_EXT_border_color_swizzle
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceBorderColorSwizzleFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceBorderColorSwizzleFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub borderColorSwizzle: VkBool32,
	pub borderColorSwizzleFromImage: VkBool32,
}
impl Debug for VkPhysicalDeviceBorderColorSwizzleFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceBorderColorSwizzleFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("borderColorSwizzle", &self.borderColorSwizzle)
		.field("borderColorSwizzleFromImage", &self.borderColorSwizzleFromImage)
		.finish()
	}
}
/// struct `VkSamplerBorderColorComponentMappingCreateInfoEXT` from VK_EXT_border_color_swizzle
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerBorderColorComponentMappingCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSamplerBorderColorComponentMappingCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub components: VkComponentMapping,
	pub srgb: VkBool32,
}
impl Debug for VkSamplerBorderColorComponentMappingCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSamplerBorderColorComponentMappingCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("components", &self.components)
		.field("srgb", &self.srgb)
		.finish()
	}
}
/// trait for `VK_EXT_border_color_swizzle`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_border_color_swizzle.html>
pub trait VK_EXT_border_color_swizzle: Debug {}
/// struct for `VK_EXT_border_color_swizzle`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_border_color_swizzle {}
impl VK_EXT_border_color_swizzle for Vulkan_EXT_border_color_swizzle {}
impl Default for Vulkan_EXT_border_color_swizzle {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_border_color_swizzle {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT` from VK_EXT_pageable_device_local_memory
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pageableDeviceLocalMemory: VkBool32,
}
impl Debug for VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pageableDeviceLocalMemory", &self.pageableDeviceLocalMemory)
		.finish()
	}
}
/// function prototype `PFN_vkSetDeviceMemoryPriorityEXT` from VK_EXT_pageable_device_local_memory
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetDeviceMemoryPriorityEXT.html>
type PFN_vkSetDeviceMemoryPriorityEXT = extern "system" fn(device: VkDevice, memory: VkDeviceMemory, priority: f32);
/// The dummy function for `vkSetDeviceMemoryPriorityEXT` from `VK_EXT_pageable_device_local_memory`
extern "system" fn dummy_vkSetDeviceMemoryPriorityEXT(_: VkDevice, _: VkDeviceMemory, _: f32) {
	panic_any(VkError::NullFunctionPointer("vkSetDeviceMemoryPriorityEXT"))
}
/// trait for `VK_EXT_pageable_device_local_memory`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_pageable_device_local_memory.html>
pub trait VK_EXT_pageable_device_local_memory: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetDeviceMemoryPriorityEXT.html>
	fn vkSetDeviceMemoryPriorityEXT(&self, device: VkDevice, memory: VkDeviceMemory, priority: f32) -> Result<()>;
}
/// struct for `VK_EXT_pageable_device_local_memory`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_pageable_device_local_memory {
	vk_set_device_memory_priority_ext: PFN_vkSetDeviceMemoryPriorityEXT,
}
impl VK_EXT_pageable_device_local_memory for Vulkan_EXT_pageable_device_local_memory {
	fn vkSetDeviceMemoryPriorityEXT(&self, device: VkDevice, memory: VkDeviceMemory, priority: f32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_set_device_memory_priority_ext)(device, memory, priority))))
	}
}
impl Default for Vulkan_EXT_pageable_device_local_memory {
	fn default() -> Self {
		Self {
			vk_set_device_memory_priority_ext: dummy_vkSetDeviceMemoryPriorityEXT,
		}
	}
}
impl Vulkan_EXT_pageable_device_local_memory {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_set_device_memory_priority_ext: {let proc = get_instance_proc_address(instance, "vkSetDeviceMemoryPriorityEXT"); if proc == null() {dummy_vkSetDeviceMemoryPriorityEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceShaderCorePropertiesARM` from VK_ARM_shader_core_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderCorePropertiesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderCorePropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pixelRate: u32,
	pub texelRate: u32,
	pub fmaRate: u32,
}
impl Debug for VkPhysicalDeviceShaderCorePropertiesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderCorePropertiesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pixelRate", &self.pixelRate)
		.field("texelRate", &self.texelRate)
		.field("fmaRate", &self.fmaRate)
		.finish()
	}
}
/// trait for `VK_ARM_shader_core_properties`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_ARM_shader_core_properties.html>
pub trait VK_ARM_shader_core_properties: Debug {}
/// struct for `VK_ARM_shader_core_properties`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_shader_core_properties {}
impl VK_ARM_shader_core_properties for Vulkan_ARM_shader_core_properties {}
impl Default for Vulkan_ARM_shader_core_properties {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_ARM_shader_core_properties {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceSchedulingControlsFlagsARM` from VK_ARM_scheduling_controls
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSchedulingControlsFlagsARM.html>
pub type VkPhysicalDeviceSchedulingControlsFlagsARM = VkFlags64;
/// type definition `VkPhysicalDeviceSchedulingControlsFlagBitsARM` from VK_ARM_scheduling_controls
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSchedulingControlsFlagBitsARM.html>
pub type VkPhysicalDeviceSchedulingControlsFlagBitsARM = VkFlags64;
/// struct `VkDeviceQueueShaderCoreControlCreateInfoARM` from VK_ARM_scheduling_controls
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceQueueShaderCoreControlCreateInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceQueueShaderCoreControlCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderCoreCount: u32,
}
impl Debug for VkDeviceQueueShaderCoreControlCreateInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceQueueShaderCoreControlCreateInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderCoreCount", &self.shaderCoreCount)
		.finish()
	}
}
/// struct `VkPhysicalDeviceSchedulingControlsFeaturesARM` from VK_ARM_scheduling_controls
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSchedulingControlsFeaturesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSchedulingControlsFeaturesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub schedulingControls: VkBool32,
}
impl Debug for VkPhysicalDeviceSchedulingControlsFeaturesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSchedulingControlsFeaturesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("schedulingControls", &self.schedulingControls)
		.finish()
	}
}
/// struct `VkPhysicalDeviceSchedulingControlsPropertiesARM` from VK_ARM_scheduling_controls
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSchedulingControlsPropertiesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSchedulingControlsPropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub schedulingControlsFlags: VkPhysicalDeviceSchedulingControlsFlagsARM,
}
impl Debug for VkPhysicalDeviceSchedulingControlsPropertiesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSchedulingControlsPropertiesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("schedulingControlsFlags", &self.schedulingControlsFlags)
		.finish()
	}
}
/// trait for `VK_ARM_scheduling_controls`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_ARM_scheduling_controls.html>
pub trait VK_ARM_scheduling_controls: Debug {}
/// struct for `VK_ARM_scheduling_controls`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_scheduling_controls {}
impl VK_ARM_scheduling_controls for Vulkan_ARM_scheduling_controls {}
impl Default for Vulkan_ARM_scheduling_controls {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_ARM_scheduling_controls {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// constant `VK_REMAINING_3D_SLICES_EXT` from VK_EXT_image_sliced_view_of_3d
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_REMAINING_3D_SLICES_EXT.html>
pub const VK_REMAINING_3D_SLICES_EXT: u32 = !0u32;
/// struct `VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT` from VK_EXT_image_sliced_view_of_3d
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageSlicedViewOf3D: VkBool32,
}
impl Debug for VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("imageSlicedViewOf3D", &self.imageSlicedViewOf3D)
		.finish()
	}
}
/// struct `VkImageViewSlicedCreateInfoEXT` from VK_EXT_image_sliced_view_of_3d
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageViewSlicedCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageViewSlicedCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub sliceOffset: u32,
	pub sliceCount: u32,
}
impl Debug for VkImageViewSlicedCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageViewSlicedCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("sliceOffset", &self.sliceOffset)
		.field("sliceCount", &self.sliceCount)
		.finish()
	}
}
/// trait for `VK_EXT_image_sliced_view_of_3d`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_image_sliced_view_of_3d.html>
pub trait VK_EXT_image_sliced_view_of_3d: Debug {}
/// struct for `VK_EXT_image_sliced_view_of_3d`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_image_sliced_view_of_3d {}
impl VK_EXT_image_sliced_view_of_3d for Vulkan_EXT_image_sliced_view_of_3d {}
impl Default for Vulkan_EXT_image_sliced_view_of_3d {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_image_sliced_view_of_3d {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE` from VK_VALVE_descriptor_set_host_mapping
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub descriptorSetHostMapping: VkBool32,
}
impl Debug for VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("descriptorSetHostMapping", &self.descriptorSetHostMapping)
		.finish()
	}
}
/// struct `VkDescriptorSetBindingReferenceVALVE` from VK_VALVE_descriptor_set_host_mapping
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetBindingReferenceVALVE.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorSetBindingReferenceVALVE {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub descriptorSetLayout: VkDescriptorSetLayout,
	pub binding: u32,
}
impl Debug for VkDescriptorSetBindingReferenceVALVE {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorSetBindingReferenceVALVE")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("descriptorSetLayout", &self.descriptorSetLayout)
		.field("binding", &self.binding)
		.finish()
	}
}
/// struct `VkDescriptorSetLayoutHostMappingInfoVALVE` from VK_VALVE_descriptor_set_host_mapping
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayoutHostMappingInfoVALVE.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorSetLayoutHostMappingInfoVALVE {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub descriptorOffset: usize,
	pub descriptorSize: u32,
}
impl Debug for VkDescriptorSetLayoutHostMappingInfoVALVE {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorSetLayoutHostMappingInfoVALVE")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("descriptorOffset", &self.descriptorOffset)
		.field("descriptorSize", &self.descriptorSize)
		.finish()
	}
}
/// function prototype `PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE` from VK_VALVE_descriptor_set_host_mapping
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutHostMappingInfoVALVE.html>
type PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE = extern "system" fn(device: VkDevice, pBindingReference: *const VkDescriptorSetBindingReferenceVALVE, pHostMapping: *mut VkDescriptorSetLayoutHostMappingInfoVALVE);
/// function prototype `PFN_vkGetDescriptorSetHostMappingVALVE` from VK_VALVE_descriptor_set_host_mapping
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetHostMappingVALVE.html>
type PFN_vkGetDescriptorSetHostMappingVALVE = extern "system" fn(device: VkDevice, descriptorSet: VkDescriptorSet, ppData: *mut *mut c_void);
/// The dummy function for `vkGetDescriptorSetLayoutHostMappingInfoVALVE` from `VK_VALVE_descriptor_set_host_mapping`
extern "system" fn dummy_vkGetDescriptorSetLayoutHostMappingInfoVALVE(_: VkDevice, _: *const VkDescriptorSetBindingReferenceVALVE, _: *mut VkDescriptorSetLayoutHostMappingInfoVALVE) {
	panic_any(VkError::NullFunctionPointer("vkGetDescriptorSetLayoutHostMappingInfoVALVE"))
}
/// trait for `VK_VALVE_descriptor_set_host_mapping`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_VALVE_descriptor_set_host_mapping.html>
pub trait VK_VALVE_descriptor_set_host_mapping: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutHostMappingInfoVALVE.html>
	fn vkGetDescriptorSetLayoutHostMappingInfoVALVE(&self, device: VkDevice, pBindingReference: *const VkDescriptorSetBindingReferenceVALVE, pHostMapping: *mut VkDescriptorSetLayoutHostMappingInfoVALVE) -> Result<()>;
}
/// struct for `VK_VALVE_descriptor_set_host_mapping`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_VALVE_descriptor_set_host_mapping {
	vk_get_descriptor_set_layout_host_mapping_info_valve: PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE,
}
impl VK_VALVE_descriptor_set_host_mapping for Vulkan_VALVE_descriptor_set_host_mapping {
	fn vkGetDescriptorSetLayoutHostMappingInfoVALVE(&self, device: VkDevice, pBindingReference: *const VkDescriptorSetBindingReferenceVALVE, pHostMapping: *mut VkDescriptorSetLayoutHostMappingInfoVALVE) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_descriptor_set_layout_host_mapping_info_valve)(device, pBindingReference, pHostMapping))))
	}
}
impl Default for Vulkan_VALVE_descriptor_set_host_mapping {
	fn default() -> Self {
		Self {
			vk_get_descriptor_set_layout_host_mapping_info_valve: dummy_vkGetDescriptorSetLayoutHostMappingInfoVALVE,
		}
	}
}
impl Vulkan_VALVE_descriptor_set_host_mapping {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_descriptor_set_layout_host_mapping_info_valve: {let proc = get_instance_proc_address(instance, "vkGetDescriptorSetLayoutHostMappingInfoVALVE"); if proc == null() {dummy_vkGetDescriptorSetLayoutHostMappingInfoVALVE} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkPhysicalDeviceDepthClampZeroOneFeaturesEXT` from VK_EXT_depth_clamp_zero_one
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDepthClampZeroOneFeaturesEXT.html>
pub type VkPhysicalDeviceDepthClampZeroOneFeaturesEXT = VkPhysicalDeviceDepthClampZeroOneFeaturesKHR;
/// trait for `VK_EXT_depth_clamp_zero_one`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_depth_clamp_zero_one.html>
pub trait VK_EXT_depth_clamp_zero_one: Debug {}
/// struct for `VK_EXT_depth_clamp_zero_one`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_depth_clamp_zero_one {}
impl VK_EXT_depth_clamp_zero_one for Vulkan_EXT_depth_clamp_zero_one {}
impl Default for Vulkan_EXT_depth_clamp_zero_one {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_depth_clamp_zero_one {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT` from VK_EXT_non_seamless_cube_map
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub nonSeamlessCubeMap: VkBool32,
}
impl Debug for VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("nonSeamlessCubeMap", &self.nonSeamlessCubeMap)
		.finish()
	}
}
/// trait for `VK_EXT_non_seamless_cube_map`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_non_seamless_cube_map.html>
pub trait VK_EXT_non_seamless_cube_map: Debug {}
/// struct for `VK_EXT_non_seamless_cube_map`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_non_seamless_cube_map {}
impl VK_EXT_non_seamless_cube_map for Vulkan_EXT_non_seamless_cube_map {}
impl Default for Vulkan_EXT_non_seamless_cube_map {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_non_seamless_cube_map {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceRenderPassStripedFeaturesARM` from VK_ARM_render_pass_striped
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRenderPassStripedFeaturesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRenderPassStripedFeaturesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub renderPassStriped: VkBool32,
}
impl Debug for VkPhysicalDeviceRenderPassStripedFeaturesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRenderPassStripedFeaturesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("renderPassStriped", &self.renderPassStriped)
		.finish()
	}
}
/// struct `VkPhysicalDeviceRenderPassStripedPropertiesARM` from VK_ARM_render_pass_striped
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRenderPassStripedPropertiesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRenderPassStripedPropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub renderPassStripeGranularity: VkExtent2D,
	pub maxRenderPassStripes: u32,
}
impl Debug for VkPhysicalDeviceRenderPassStripedPropertiesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRenderPassStripedPropertiesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("renderPassStripeGranularity", &self.renderPassStripeGranularity)
		.field("maxRenderPassStripes", &self.maxRenderPassStripes)
		.finish()
	}
}
/// struct `VkRenderPassStripeInfoARM` from VK_ARM_render_pass_striped
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassStripeInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassStripeInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stripeArea: VkRect2D,
}
impl Debug for VkRenderPassStripeInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassStripeInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stripeArea", &self.stripeArea)
		.finish()
	}
}
/// struct `VkRenderPassStripeBeginInfoARM` from VK_ARM_render_pass_striped
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassStripeBeginInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassStripeBeginInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stripeInfoCount: u32,
	pub pStripeInfos: *const VkRenderPassStripeInfoARM,
}
impl Debug for VkRenderPassStripeBeginInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassStripeBeginInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stripeInfoCount", &self.stripeInfoCount)
		.field("pStripeInfos", &self.pStripeInfos)
		.finish()
	}
}
/// struct `VkRenderPassStripeSubmitInfoARM` from VK_ARM_render_pass_striped
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassStripeSubmitInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassStripeSubmitInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stripeSemaphoreInfoCount: u32,
	pub pStripeSemaphoreInfos: *const VkSemaphoreSubmitInfo,
}
impl Debug for VkRenderPassStripeSubmitInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassStripeSubmitInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stripeSemaphoreInfoCount", &self.stripeSemaphoreInfoCount)
		.field("pStripeSemaphoreInfos", &self.pStripeSemaphoreInfos)
		.finish()
	}
}
/// trait for `VK_ARM_render_pass_striped`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_ARM_render_pass_striped.html>
pub trait VK_ARM_render_pass_striped: Debug {}
/// struct for `VK_ARM_render_pass_striped`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_render_pass_striped {}
impl VK_ARM_render_pass_striped for Vulkan_ARM_render_pass_striped {}
impl Default for Vulkan_ARM_render_pass_striped {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_ARM_render_pass_striped {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM` from VK_QCOM_fragment_density_map_offset
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM.html>
pub type VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM = VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT;
/// type definition `VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM` from VK_QCOM_fragment_density_map_offset
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM.html>
pub type VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM = VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT;
/// type definition `VkSubpassFragmentDensityMapOffsetEndInfoQCOM` from VK_QCOM_fragment_density_map_offset
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassFragmentDensityMapOffsetEndInfoQCOM.html>
pub type VkSubpassFragmentDensityMapOffsetEndInfoQCOM = VkRenderPassFragmentDensityMapOffsetEndInfoEXT;
/// struct `VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT` from VK_QCOM_fragment_density_map_offset
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub fragmentDensityMapOffset: VkBool32,
}
impl Debug for VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("fragmentDensityMapOffset", &self.fragmentDensityMapOffset)
		.finish()
	}
}
/// struct `VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT` from VK_QCOM_fragment_density_map_offset
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub fragmentDensityOffsetGranularity: VkExtent2D,
}
impl Debug for VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("fragmentDensityOffsetGranularity", &self.fragmentDensityOffsetGranularity)
		.finish()
	}
}
/// struct `VkRenderPassFragmentDensityMapOffsetEndInfoEXT` from VK_QCOM_fragment_density_map_offset
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassFragmentDensityMapOffsetEndInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassFragmentDensityMapOffsetEndInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub fragmentDensityOffsetCount: u32,
	pub pFragmentDensityOffsets: *const VkOffset2D,
}
impl Debug for VkRenderPassFragmentDensityMapOffsetEndInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassFragmentDensityMapOffsetEndInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("fragmentDensityOffsetCount", &self.fragmentDensityOffsetCount)
		.field("pFragmentDensityOffsets", &self.pFragmentDensityOffsets)
		.finish()
	}
}
/// trait for `VK_QCOM_fragment_density_map_offset`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QCOM_fragment_density_map_offset.html>
pub trait VK_QCOM_fragment_density_map_offset: Debug {}
/// struct for `VK_QCOM_fragment_density_map_offset`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_fragment_density_map_offset {}
impl VK_QCOM_fragment_density_map_offset for Vulkan_QCOM_fragment_density_map_offset {}
impl Default for Vulkan_QCOM_fragment_density_map_offset {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_fragment_density_map_offset {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkCopyMemoryIndirectCommandNV` from VK_NV_copy_memory_indirect
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyMemoryIndirectCommandNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyMemoryIndirectCommandNV {
	pub srcAddress: VkDeviceAddress,
	pub dstAddress: VkDeviceAddress,
	pub size: VkDeviceSize,
}
impl Debug for VkCopyMemoryIndirectCommandNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyMemoryIndirectCommandNV")
		.field("srcAddress", &self.srcAddress)
		.field("dstAddress", &self.dstAddress)
		.field("size", &self.size)
		.finish()
	}
}
/// struct `VkCopyMemoryToImageIndirectCommandNV` from VK_NV_copy_memory_indirect
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyMemoryToImageIndirectCommandNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyMemoryToImageIndirectCommandNV {
	pub srcAddress: VkDeviceAddress,
	pub bufferRowLength: u32,
	pub bufferImageHeight: u32,
	pub imageSubresource: VkImageSubresourceLayers,
	pub imageOffset: VkOffset3D,
	pub imageExtent: VkExtent3D,
}
impl Debug for VkCopyMemoryToImageIndirectCommandNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyMemoryToImageIndirectCommandNV")
		.field("srcAddress", &self.srcAddress)
		.field("bufferRowLength", &self.bufferRowLength)
		.field("bufferImageHeight", &self.bufferImageHeight)
		.field("imageSubresource", &self.imageSubresource)
		.field("imageOffset", &self.imageOffset)
		.field("imageExtent", &self.imageExtent)
		.finish()
	}
}
/// struct `VkPhysicalDeviceCopyMemoryIndirectFeaturesNV` from VK_NV_copy_memory_indirect
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCopyMemoryIndirectFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCopyMemoryIndirectFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub indirectCopy: VkBool32,
}
impl Debug for VkPhysicalDeviceCopyMemoryIndirectFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCopyMemoryIndirectFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("indirectCopy", &self.indirectCopy)
		.finish()
	}
}
/// struct `VkPhysicalDeviceCopyMemoryIndirectPropertiesNV` from VK_NV_copy_memory_indirect
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCopyMemoryIndirectPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCopyMemoryIndirectPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub supportedQueues: VkQueueFlags,
}
impl Debug for VkPhysicalDeviceCopyMemoryIndirectPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCopyMemoryIndirectPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("supportedQueues", &self.supportedQueues)
		.finish()
	}
}
/// function prototype `PFN_vkCmdCopyMemoryIndirectNV` from VK_NV_copy_memory_indirect
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMemoryIndirectNV.html>
type PFN_vkCmdCopyMemoryIndirectNV = extern "system" fn(commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: u32, stride: u32);
/// function prototype `PFN_vkCmdCopyMemoryToImageIndirectNV` from VK_NV_copy_memory_indirect
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMemoryToImageIndirectNV.html>
type PFN_vkCmdCopyMemoryToImageIndirectNV = extern "system" fn(commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: u32, stride: u32, dstImage: VkImage, dstImageLayout: VkImageLayout, pImageSubresources: *const VkImageSubresourceLayers);
/// The dummy function for `vkCmdCopyMemoryIndirectNV` from `VK_NV_copy_memory_indirect`
extern "system" fn dummy_vkCmdCopyMemoryIndirectNV(_: VkCommandBuffer, _: VkDeviceAddress, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdCopyMemoryIndirectNV"))
}
/// trait for `VK_NV_copy_memory_indirect`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_copy_memory_indirect.html>
pub trait VK_NV_copy_memory_indirect: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMemoryIndirectNV.html>
	fn vkCmdCopyMemoryIndirectNV(&self, commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: u32, stride: u32) -> Result<()>;
}
/// struct for `VK_NV_copy_memory_indirect`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_copy_memory_indirect {
	vk_cmd_copy_memory_indirect_nv: PFN_vkCmdCopyMemoryIndirectNV,
}
impl VK_NV_copy_memory_indirect for Vulkan_NV_copy_memory_indirect {
	fn vkCmdCopyMemoryIndirectNV(&self, commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: u32, stride: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_copy_memory_indirect_nv)(commandBuffer, copyBufferAddress, copyCount, stride))))
	}
}
impl Default for Vulkan_NV_copy_memory_indirect {
	fn default() -> Self {
		Self {
			vk_cmd_copy_memory_indirect_nv: dummy_vkCmdCopyMemoryIndirectNV,
		}
	}
}
impl Vulkan_NV_copy_memory_indirect {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_copy_memory_indirect_nv: {let proc = get_instance_proc_address(instance, "vkCmdCopyMemoryIndirectNV"); if proc == null() {dummy_vkCmdCopyMemoryIndirectNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkMemoryDecompressionMethodFlagBitsNV` from VK_NV_memory_decompression
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryDecompressionMethodFlagBitsNV.html>
pub type VkMemoryDecompressionMethodFlagBitsNV = VkFlags64;
/// type definition `VkMemoryDecompressionMethodFlagsNV` from VK_NV_memory_decompression
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryDecompressionMethodFlagsNV.html>
pub type VkMemoryDecompressionMethodFlagsNV = VkFlags64;
/// struct `VkDecompressMemoryRegionNV` from VK_NV_memory_decompression
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDecompressMemoryRegionNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDecompressMemoryRegionNV {
	pub srcAddress: VkDeviceAddress,
	pub dstAddress: VkDeviceAddress,
	pub compressedSize: VkDeviceSize,
	pub decompressedSize: VkDeviceSize,
	pub decompressionMethod: VkMemoryDecompressionMethodFlagsNV,
}
impl Debug for VkDecompressMemoryRegionNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDecompressMemoryRegionNV")
		.field("srcAddress", &self.srcAddress)
		.field("dstAddress", &self.dstAddress)
		.field("compressedSize", &self.compressedSize)
		.field("decompressedSize", &self.decompressedSize)
		.field("decompressionMethod", &self.decompressionMethod)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMemoryDecompressionFeaturesNV` from VK_NV_memory_decompression
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMemoryDecompressionFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMemoryDecompressionFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub memoryDecompression: VkBool32,
}
impl Debug for VkPhysicalDeviceMemoryDecompressionFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMemoryDecompressionFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("memoryDecompression", &self.memoryDecompression)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMemoryDecompressionPropertiesNV` from VK_NV_memory_decompression
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMemoryDecompressionPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMemoryDecompressionPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub decompressionMethods: VkMemoryDecompressionMethodFlagsNV,
	pub maxDecompressionIndirectCount: u64,
}
impl Debug for VkPhysicalDeviceMemoryDecompressionPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMemoryDecompressionPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("decompressionMethods", &self.decompressionMethods)
		.field("maxDecompressionIndirectCount", &self.maxDecompressionIndirectCount)
		.finish()
	}
}
/// function prototype `PFN_vkCmdDecompressMemoryNV` from VK_NV_memory_decompression
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDecompressMemoryNV.html>
type PFN_vkCmdDecompressMemoryNV = extern "system" fn(commandBuffer: VkCommandBuffer, decompressRegionCount: u32, pDecompressMemoryRegions: *const VkDecompressMemoryRegionNV);
/// function prototype `PFN_vkCmdDecompressMemoryIndirectCountNV` from VK_NV_memory_decompression
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDecompressMemoryIndirectCountNV.html>
type PFN_vkCmdDecompressMemoryIndirectCountNV = extern "system" fn(commandBuffer: VkCommandBuffer, indirectCommandsAddress: VkDeviceAddress, indirectCommandsCountAddress: VkDeviceAddress, stride: u32);
/// The dummy function for `vkCmdDecompressMemoryNV` from `VK_NV_memory_decompression`
extern "system" fn dummy_vkCmdDecompressMemoryNV(_: VkCommandBuffer, _: u32, _: *const VkDecompressMemoryRegionNV) {
	panic_any(VkError::NullFunctionPointer("vkCmdDecompressMemoryNV"))
}
/// trait for `VK_NV_memory_decompression`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_memory_decompression.html>
pub trait VK_NV_memory_decompression: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDecompressMemoryNV.html>
	fn vkCmdDecompressMemoryNV(&self, commandBuffer: VkCommandBuffer, decompressRegionCount: u32, pDecompressMemoryRegions: *const VkDecompressMemoryRegionNV) -> Result<()>;
}
/// struct for `VK_NV_memory_decompression`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_memory_decompression {
	vk_cmd_decompress_memory_nv: PFN_vkCmdDecompressMemoryNV,
}
impl VK_NV_memory_decompression for Vulkan_NV_memory_decompression {
	fn vkCmdDecompressMemoryNV(&self, commandBuffer: VkCommandBuffer, decompressRegionCount: u32, pDecompressMemoryRegions: *const VkDecompressMemoryRegionNV) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_decompress_memory_nv)(commandBuffer, decompressRegionCount, pDecompressMemoryRegions))))
	}
}
impl Default for Vulkan_NV_memory_decompression {
	fn default() -> Self {
		Self {
			vk_cmd_decompress_memory_nv: dummy_vkCmdDecompressMemoryNV,
		}
	}
}
impl Vulkan_NV_memory_decompression {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_decompress_memory_nv: {let proc = get_instance_proc_address(instance, "vkCmdDecompressMemoryNV"); if proc == null() {dummy_vkCmdDecompressMemoryNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV` from VK_NV_device_generated_commands_compute
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceGeneratedCompute: VkBool32,
	pub deviceGeneratedComputePipelines: VkBool32,
	pub deviceGeneratedComputeCaptureReplay: VkBool32,
}
impl Debug for VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceGeneratedCompute", &self.deviceGeneratedCompute)
		.field("deviceGeneratedComputePipelines", &self.deviceGeneratedComputePipelines)
		.field("deviceGeneratedComputeCaptureReplay", &self.deviceGeneratedComputeCaptureReplay)
		.finish()
	}
}
/// struct `VkComputePipelineIndirectBufferInfoNV` from VK_NV_device_generated_commands_compute
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkComputePipelineIndirectBufferInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkComputePipelineIndirectBufferInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub deviceAddress: VkDeviceAddress,
	pub size: VkDeviceSize,
	pub pipelineDeviceAddressCaptureReplay: VkDeviceAddress,
}
impl Debug for VkComputePipelineIndirectBufferInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkComputePipelineIndirectBufferInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceAddress", &self.deviceAddress)
		.field("size", &self.size)
		.field("pipelineDeviceAddressCaptureReplay", &self.pipelineDeviceAddressCaptureReplay)
		.finish()
	}
}
/// struct `VkPipelineIndirectDeviceAddressInfoNV` from VK_NV_device_generated_commands_compute
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineIndirectDeviceAddressInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineIndirectDeviceAddressInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pipelineBindPoint: VkPipelineBindPoint,
	pub pipeline: VkPipeline,
}
impl Debug for VkPipelineIndirectDeviceAddressInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineIndirectDeviceAddressInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelineBindPoint", &self.pipelineBindPoint)
		.field("pipeline", &self.pipeline)
		.finish()
	}
}
/// struct `VkBindPipelineIndirectCommandNV` from VK_NV_device_generated_commands_compute
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindPipelineIndirectCommandNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindPipelineIndirectCommandNV {
	pub pipelineAddress: VkDeviceAddress,
}
impl Debug for VkBindPipelineIndirectCommandNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindPipelineIndirectCommandNV")
		.field("pipelineAddress", &self.pipelineAddress)
		.finish()
	}
}
/// function prototype `PFN_vkGetPipelineIndirectMemoryRequirementsNV` from VK_NV_device_generated_commands_compute
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineIndirectMemoryRequirementsNV.html>
type PFN_vkGetPipelineIndirectMemoryRequirementsNV = extern "system" fn(device: VkDevice, pCreateInfo: *const VkComputePipelineCreateInfo, pMemoryRequirements: *mut VkMemoryRequirements2);
/// function prototype `PFN_vkCmdUpdatePipelineIndirectBufferNV` from VK_NV_device_generated_commands_compute
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdUpdatePipelineIndirectBufferNV.html>
type PFN_vkCmdUpdatePipelineIndirectBufferNV = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline);
/// function prototype `PFN_vkGetPipelineIndirectDeviceAddressNV` from VK_NV_device_generated_commands_compute
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineIndirectDeviceAddressNV.html>
type PFN_vkGetPipelineIndirectDeviceAddressNV = extern "system" fn(device: VkDevice, pInfo: *const VkPipelineIndirectDeviceAddressInfoNV) -> VkDeviceAddress;
/// The dummy function for `vkGetPipelineIndirectMemoryRequirementsNV` from `VK_NV_device_generated_commands_compute`
extern "system" fn dummy_vkGetPipelineIndirectMemoryRequirementsNV(_: VkDevice, _: *const VkComputePipelineCreateInfo, _: *mut VkMemoryRequirements2) {
	panic_any(VkError::NullFunctionPointer("vkGetPipelineIndirectMemoryRequirementsNV"))
}
/// trait for `VK_NV_device_generated_commands_compute`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_device_generated_commands_compute.html>
pub trait VK_NV_device_generated_commands_compute: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineIndirectMemoryRequirementsNV.html>
	fn vkGetPipelineIndirectMemoryRequirementsNV(&self, device: VkDevice, pCreateInfo: *const VkComputePipelineCreateInfo, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()>;
}
/// struct for `VK_NV_device_generated_commands_compute`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_device_generated_commands_compute {
	vk_get_pipeline_indirect_memory_requirements_nv: PFN_vkGetPipelineIndirectMemoryRequirementsNV,
}
impl VK_NV_device_generated_commands_compute for Vulkan_NV_device_generated_commands_compute {
	fn vkGetPipelineIndirectMemoryRequirementsNV(&self, device: VkDevice, pCreateInfo: *const VkComputePipelineCreateInfo, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_pipeline_indirect_memory_requirements_nv)(device, pCreateInfo, pMemoryRequirements))))
	}
}
impl Default for Vulkan_NV_device_generated_commands_compute {
	fn default() -> Self {
		Self {
			vk_get_pipeline_indirect_memory_requirements_nv: dummy_vkGetPipelineIndirectMemoryRequirementsNV,
		}
	}
}
impl Vulkan_NV_device_generated_commands_compute {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_pipeline_indirect_memory_requirements_nv: {let proc = get_instance_proc_address(instance, "vkGetPipelineIndirectMemoryRequirementsNV"); if proc == null() {dummy_vkGetPipelineIndirectMemoryRequirementsNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// enum `VkRayTracingLssIndexingModeNV` from VK_NV_ray_tracing_linear_swept_spheres
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRayTracingLssIndexingModeNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkRayTracingLssIndexingModeNV {
	VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV = 0,
	VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV = 1,
	VK_RAY_TRACING_LSS_INDEXING_MODE_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkRayTracingLssPrimitiveEndCapsModeNV` from VK_NV_ray_tracing_linear_swept_spheres
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRayTracingLssPrimitiveEndCapsModeNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkRayTracingLssPrimitiveEndCapsModeNV {
	VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV = 0,
	VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV = 1,
	VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_MAX_ENUM_NV = 0x7fffffff,
}
/// struct `VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV` from VK_NV_ray_tracing_linear_swept_spheres
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub spheres: VkBool32,
	pub linearSweptSpheres: VkBool32,
}
impl Debug for VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("spheres", &self.spheres)
		.field("linearSweptSpheres", &self.linearSweptSpheres)
		.finish()
	}
}
/// struct `VkAccelerationStructureGeometryLinearSweptSpheresDataNV` from VK_NV_ray_tracing_linear_swept_spheres
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryLinearSweptSpheresDataNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureGeometryLinearSweptSpheresDataNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub vertexFormat: VkFormat,
	pub vertexData: VkDeviceOrHostAddressConstKHR,
	pub vertexStride: VkDeviceSize,
	pub radiusFormat: VkFormat,
	pub radiusData: VkDeviceOrHostAddressConstKHR,
	pub radiusStride: VkDeviceSize,
	pub indexType: VkIndexType,
	pub indexData: VkDeviceOrHostAddressConstKHR,
	pub indexStride: VkDeviceSize,
	pub indexingMode: VkRayTracingLssIndexingModeNV,
	pub endCapsMode: VkRayTracingLssPrimitiveEndCapsModeNV,
}
impl Debug for VkAccelerationStructureGeometryLinearSweptSpheresDataNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureGeometryLinearSweptSpheresDataNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("vertexFormat", &self.vertexFormat)
		.field("vertexData", &self.vertexData)
		.field("vertexStride", &self.vertexStride)
		.field("radiusFormat", &self.radiusFormat)
		.field("radiusData", &self.radiusData)
		.field("radiusStride", &self.radiusStride)
		.field("indexType", &self.indexType)
		.field("indexData", &self.indexData)
		.field("indexStride", &self.indexStride)
		.field("indexingMode", &self.indexingMode)
		.field("endCapsMode", &self.endCapsMode)
		.finish()
	}
}
/// struct `VkAccelerationStructureGeometrySpheresDataNV` from VK_NV_ray_tracing_linear_swept_spheres
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometrySpheresDataNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureGeometrySpheresDataNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub vertexFormat: VkFormat,
	pub vertexData: VkDeviceOrHostAddressConstKHR,
	pub vertexStride: VkDeviceSize,
	pub radiusFormat: VkFormat,
	pub radiusData: VkDeviceOrHostAddressConstKHR,
	pub radiusStride: VkDeviceSize,
	pub indexType: VkIndexType,
	pub indexData: VkDeviceOrHostAddressConstKHR,
	pub indexStride: VkDeviceSize,
}
impl Debug for VkAccelerationStructureGeometrySpheresDataNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureGeometrySpheresDataNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("vertexFormat", &self.vertexFormat)
		.field("vertexData", &self.vertexData)
		.field("vertexStride", &self.vertexStride)
		.field("radiusFormat", &self.radiusFormat)
		.field("radiusData", &self.radiusData)
		.field("radiusStride", &self.radiusStride)
		.field("indexType", &self.indexType)
		.field("indexData", &self.indexData)
		.field("indexStride", &self.indexStride)
		.finish()
	}
}
/// trait for `VK_NV_ray_tracing_linear_swept_spheres`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_ray_tracing_linear_swept_spheres.html>
pub trait VK_NV_ray_tracing_linear_swept_spheres: Debug {}
/// struct for `VK_NV_ray_tracing_linear_swept_spheres`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_ray_tracing_linear_swept_spheres {}
impl VK_NV_ray_tracing_linear_swept_spheres for Vulkan_NV_ray_tracing_linear_swept_spheres {}
impl Default for Vulkan_NV_ray_tracing_linear_swept_spheres {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_ray_tracing_linear_swept_spheres {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceLinearColorAttachmentFeaturesNV` from VK_NV_linear_color_attachment
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLinearColorAttachmentFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceLinearColorAttachmentFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub linearColorAttachment: VkBool32,
}
impl Debug for VkPhysicalDeviceLinearColorAttachmentFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceLinearColorAttachmentFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("linearColorAttachment", &self.linearColorAttachment)
		.finish()
	}
}
/// trait for `VK_NV_linear_color_attachment`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_linear_color_attachment.html>
pub trait VK_NV_linear_color_attachment: Debug {}
/// struct for `VK_NV_linear_color_attachment`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_linear_color_attachment {}
impl VK_NV_linear_color_attachment for Vulkan_NV_linear_color_attachment {}
impl Default for Vulkan_NV_linear_color_attachment {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_linear_color_attachment {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_GOOGLE_surfaceless_query`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_GOOGLE_surfaceless_query.html>
pub trait VK_GOOGLE_surfaceless_query: Debug {}
/// struct for `VK_GOOGLE_surfaceless_query`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_GOOGLE_surfaceless_query {}
impl VK_GOOGLE_surfaceless_query for Vulkan_GOOGLE_surfaceless_query {}
impl Default for Vulkan_GOOGLE_surfaceless_query {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_GOOGLE_surfaceless_query {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT` from VK_EXT_image_compression_control_swapchain
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageCompressionControlSwapchain: VkBool32,
}
impl Debug for VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("imageCompressionControlSwapchain", &self.imageCompressionControlSwapchain)
		.finish()
	}
}
/// trait for `VK_EXT_image_compression_control_swapchain`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_image_compression_control_swapchain.html>
pub trait VK_EXT_image_compression_control_swapchain: Debug {}
/// struct for `VK_EXT_image_compression_control_swapchain`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_image_compression_control_swapchain {}
impl VK_EXT_image_compression_control_swapchain for Vulkan_EXT_image_compression_control_swapchain {}
impl Default for Vulkan_EXT_image_compression_control_swapchain {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_image_compression_control_swapchain {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkImageViewSampleWeightCreateInfoQCOM` from VK_QCOM_image_processing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageViewSampleWeightCreateInfoQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageViewSampleWeightCreateInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub filterCenter: VkOffset2D,
	pub filterSize: VkExtent2D,
	pub numPhases: u32,
}
impl Debug for VkImageViewSampleWeightCreateInfoQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageViewSampleWeightCreateInfoQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("filterCenter", &self.filterCenter)
		.field("filterSize", &self.filterSize)
		.field("numPhases", &self.numPhases)
		.finish()
	}
}
/// struct `VkPhysicalDeviceImageProcessingFeaturesQCOM` from VK_QCOM_image_processing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImageProcessingFeaturesQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceImageProcessingFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub textureSampleWeighted: VkBool32,
	pub textureBoxFilter: VkBool32,
	pub textureBlockMatch: VkBool32,
}
impl Debug for VkPhysicalDeviceImageProcessingFeaturesQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceImageProcessingFeaturesQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("textureSampleWeighted", &self.textureSampleWeighted)
		.field("textureBoxFilter", &self.textureBoxFilter)
		.field("textureBlockMatch", &self.textureBlockMatch)
		.finish()
	}
}
/// struct `VkPhysicalDeviceImageProcessingPropertiesQCOM` from VK_QCOM_image_processing
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImageProcessingPropertiesQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceImageProcessingPropertiesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxWeightFilterPhases: u32,
	pub maxWeightFilterDimension: VkExtent2D,
	pub maxBlockMatchRegion: VkExtent2D,
	pub maxBoxFilterBlockSize: VkExtent2D,
}
impl Debug for VkPhysicalDeviceImageProcessingPropertiesQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceImageProcessingPropertiesQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxWeightFilterPhases", &self.maxWeightFilterPhases)
		.field("maxWeightFilterDimension", &self.maxWeightFilterDimension)
		.field("maxBlockMatchRegion", &self.maxBlockMatchRegion)
		.field("maxBoxFilterBlockSize", &self.maxBoxFilterBlockSize)
		.finish()
	}
}
/// trait for `VK_QCOM_image_processing`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QCOM_image_processing.html>
pub trait VK_QCOM_image_processing: Debug {}
/// struct for `VK_QCOM_image_processing`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_image_processing {}
impl VK_QCOM_image_processing for Vulkan_QCOM_image_processing {}
impl Default for Vulkan_QCOM_image_processing {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_image_processing {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceNestedCommandBufferFeaturesEXT` from VK_EXT_nested_command_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceNestedCommandBufferFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceNestedCommandBufferFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub nestedCommandBuffer: VkBool32,
	pub nestedCommandBufferRendering: VkBool32,
	pub nestedCommandBufferSimultaneousUse: VkBool32,
}
impl Debug for VkPhysicalDeviceNestedCommandBufferFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceNestedCommandBufferFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("nestedCommandBuffer", &self.nestedCommandBuffer)
		.field("nestedCommandBufferRendering", &self.nestedCommandBufferRendering)
		.field("nestedCommandBufferSimultaneousUse", &self.nestedCommandBufferSimultaneousUse)
		.finish()
	}
}
/// struct `VkPhysicalDeviceNestedCommandBufferPropertiesEXT` from VK_EXT_nested_command_buffer
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceNestedCommandBufferPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceNestedCommandBufferPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxCommandBufferNestingLevel: u32,
}
impl Debug for VkPhysicalDeviceNestedCommandBufferPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceNestedCommandBufferPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxCommandBufferNestingLevel", &self.maxCommandBufferNestingLevel)
		.finish()
	}
}
/// trait for `VK_EXT_nested_command_buffer`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_nested_command_buffer.html>
pub trait VK_EXT_nested_command_buffer: Debug {}
/// struct for `VK_EXT_nested_command_buffer`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_nested_command_buffer {}
impl VK_EXT_nested_command_buffer for Vulkan_EXT_nested_command_buffer {}
impl Default for Vulkan_EXT_nested_command_buffer {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_nested_command_buffer {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkExternalMemoryAcquireUnmodifiedEXT` from VK_EXT_external_memory_acquire_unmodified
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryAcquireUnmodifiedEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExternalMemoryAcquireUnmodifiedEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub acquireUnmodifiedMemory: VkBool32,
}
impl Debug for VkExternalMemoryAcquireUnmodifiedEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExternalMemoryAcquireUnmodifiedEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("acquireUnmodifiedMemory", &self.acquireUnmodifiedMemory)
		.finish()
	}
}
/// trait for `VK_EXT_external_memory_acquire_unmodified`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_external_memory_acquire_unmodified.html>
pub trait VK_EXT_external_memory_acquire_unmodified: Debug {}
/// struct for `VK_EXT_external_memory_acquire_unmodified`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_external_memory_acquire_unmodified {}
impl VK_EXT_external_memory_acquire_unmodified for Vulkan_EXT_external_memory_acquire_unmodified {}
impl Default for Vulkan_EXT_external_memory_acquire_unmodified {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_external_memory_acquire_unmodified {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceExtendedDynamicState3FeaturesEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceExtendedDynamicState3FeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub extendedDynamicState3TessellationDomainOrigin: VkBool32,
	pub extendedDynamicState3DepthClampEnable: VkBool32,
	pub extendedDynamicState3PolygonMode: VkBool32,
	pub extendedDynamicState3RasterizationSamples: VkBool32,
	pub extendedDynamicState3SampleMask: VkBool32,
	pub extendedDynamicState3AlphaToCoverageEnable: VkBool32,
	pub extendedDynamicState3AlphaToOneEnable: VkBool32,
	pub extendedDynamicState3LogicOpEnable: VkBool32,
	pub extendedDynamicState3ColorBlendEnable: VkBool32,
	pub extendedDynamicState3ColorBlendEquation: VkBool32,
	pub extendedDynamicState3ColorWriteMask: VkBool32,
	pub extendedDynamicState3RasterizationStream: VkBool32,
	pub extendedDynamicState3ConservativeRasterizationMode: VkBool32,
	pub extendedDynamicState3ExtraPrimitiveOverestimationSize: VkBool32,
	pub extendedDynamicState3DepthClipEnable: VkBool32,
	pub extendedDynamicState3SampleLocationsEnable: VkBool32,
	pub extendedDynamicState3ColorBlendAdvanced: VkBool32,
	pub extendedDynamicState3ProvokingVertexMode: VkBool32,
	pub extendedDynamicState3LineRasterizationMode: VkBool32,
	pub extendedDynamicState3LineStippleEnable: VkBool32,
	pub extendedDynamicState3DepthClipNegativeOneToOne: VkBool32,
	pub extendedDynamicState3ViewportWScalingEnable: VkBool32,
	pub extendedDynamicState3ViewportSwizzle: VkBool32,
	pub extendedDynamicState3CoverageToColorEnable: VkBool32,
	pub extendedDynamicState3CoverageToColorLocation: VkBool32,
	pub extendedDynamicState3CoverageModulationMode: VkBool32,
	pub extendedDynamicState3CoverageModulationTableEnable: VkBool32,
	pub extendedDynamicState3CoverageModulationTable: VkBool32,
	pub extendedDynamicState3CoverageReductionMode: VkBool32,
	pub extendedDynamicState3RepresentativeFragmentTestEnable: VkBool32,
	pub extendedDynamicState3ShadingRateImageEnable: VkBool32,
}
impl Debug for VkPhysicalDeviceExtendedDynamicState3FeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceExtendedDynamicState3FeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("extendedDynamicState3TessellationDomainOrigin", &self.extendedDynamicState3TessellationDomainOrigin)
		.field("extendedDynamicState3DepthClampEnable", &self.extendedDynamicState3DepthClampEnable)
		.field("extendedDynamicState3PolygonMode", &self.extendedDynamicState3PolygonMode)
		.field("extendedDynamicState3RasterizationSamples", &self.extendedDynamicState3RasterizationSamples)
		.field("extendedDynamicState3SampleMask", &self.extendedDynamicState3SampleMask)
		.field("extendedDynamicState3AlphaToCoverageEnable", &self.extendedDynamicState3AlphaToCoverageEnable)
		.field("extendedDynamicState3AlphaToOneEnable", &self.extendedDynamicState3AlphaToOneEnable)
		.field("extendedDynamicState3LogicOpEnable", &self.extendedDynamicState3LogicOpEnable)
		.field("extendedDynamicState3ColorBlendEnable", &self.extendedDynamicState3ColorBlendEnable)
		.field("extendedDynamicState3ColorBlendEquation", &self.extendedDynamicState3ColorBlendEquation)
		.field("extendedDynamicState3ColorWriteMask", &self.extendedDynamicState3ColorWriteMask)
		.field("extendedDynamicState3RasterizationStream", &self.extendedDynamicState3RasterizationStream)
		.field("extendedDynamicState3ConservativeRasterizationMode", &self.extendedDynamicState3ConservativeRasterizationMode)
		.field("extendedDynamicState3ExtraPrimitiveOverestimationSize", &self.extendedDynamicState3ExtraPrimitiveOverestimationSize)
		.field("extendedDynamicState3DepthClipEnable", &self.extendedDynamicState3DepthClipEnable)
		.field("extendedDynamicState3SampleLocationsEnable", &self.extendedDynamicState3SampleLocationsEnable)
		.field("extendedDynamicState3ColorBlendAdvanced", &self.extendedDynamicState3ColorBlendAdvanced)
		.field("extendedDynamicState3ProvokingVertexMode", &self.extendedDynamicState3ProvokingVertexMode)
		.field("extendedDynamicState3LineRasterizationMode", &self.extendedDynamicState3LineRasterizationMode)
		.field("extendedDynamicState3LineStippleEnable", &self.extendedDynamicState3LineStippleEnable)
		.field("extendedDynamicState3DepthClipNegativeOneToOne", &self.extendedDynamicState3DepthClipNegativeOneToOne)
		.field("extendedDynamicState3ViewportWScalingEnable", &self.extendedDynamicState3ViewportWScalingEnable)
		.field("extendedDynamicState3ViewportSwizzle", &self.extendedDynamicState3ViewportSwizzle)
		.field("extendedDynamicState3CoverageToColorEnable", &self.extendedDynamicState3CoverageToColorEnable)
		.field("extendedDynamicState3CoverageToColorLocation", &self.extendedDynamicState3CoverageToColorLocation)
		.field("extendedDynamicState3CoverageModulationMode", &self.extendedDynamicState3CoverageModulationMode)
		.field("extendedDynamicState3CoverageModulationTableEnable", &self.extendedDynamicState3CoverageModulationTableEnable)
		.field("extendedDynamicState3CoverageModulationTable", &self.extendedDynamicState3CoverageModulationTable)
		.field("extendedDynamicState3CoverageReductionMode", &self.extendedDynamicState3CoverageReductionMode)
		.field("extendedDynamicState3RepresentativeFragmentTestEnable", &self.extendedDynamicState3RepresentativeFragmentTestEnable)
		.field("extendedDynamicState3ShadingRateImageEnable", &self.extendedDynamicState3ShadingRateImageEnable)
		.finish()
	}
}
/// struct `VkPhysicalDeviceExtendedDynamicState3PropertiesEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExtendedDynamicState3PropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceExtendedDynamicState3PropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub dynamicPrimitiveTopologyUnrestricted: VkBool32,
}
impl Debug for VkPhysicalDeviceExtendedDynamicState3PropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceExtendedDynamicState3PropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dynamicPrimitiveTopologyUnrestricted", &self.dynamicPrimitiveTopologyUnrestricted)
		.finish()
	}
}
/// struct `VkColorBlendEquationEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkColorBlendEquationEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkColorBlendEquationEXT {
	pub srcColorBlendFactor: VkBlendFactor,
	pub dstColorBlendFactor: VkBlendFactor,
	pub colorBlendOp: VkBlendOp,
	pub srcAlphaBlendFactor: VkBlendFactor,
	pub dstAlphaBlendFactor: VkBlendFactor,
	pub alphaBlendOp: VkBlendOp,
}
impl Debug for VkColorBlendEquationEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkColorBlendEquationEXT")
		.field("srcColorBlendFactor", &self.srcColorBlendFactor)
		.field("dstColorBlendFactor", &self.dstColorBlendFactor)
		.field("colorBlendOp", &self.colorBlendOp)
		.field("srcAlphaBlendFactor", &self.srcAlphaBlendFactor)
		.field("dstAlphaBlendFactor", &self.dstAlphaBlendFactor)
		.field("alphaBlendOp", &self.alphaBlendOp)
		.finish()
	}
}
/// struct `VkColorBlendAdvancedEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkColorBlendAdvancedEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkColorBlendAdvancedEXT {
	pub advancedBlendOp: VkBlendOp,
	pub srcPremultiplied: VkBool32,
	pub dstPremultiplied: VkBool32,
	pub blendOverlap: VkBlendOverlapEXT,
	pub clampResults: VkBool32,
}
impl Debug for VkColorBlendAdvancedEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkColorBlendAdvancedEXT")
		.field("advancedBlendOp", &self.advancedBlendOp)
		.field("srcPremultiplied", &self.srcPremultiplied)
		.field("dstPremultiplied", &self.dstPremultiplied)
		.field("blendOverlap", &self.blendOverlap)
		.field("clampResults", &self.clampResults)
		.finish()
	}
}
/// function prototype `PFN_vkCmdSetDepthClampEnableEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthClampEnableEXT.html>
type PFN_vkCmdSetDepthClampEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, depthClampEnable: VkBool32);
/// function prototype `PFN_vkCmdSetPolygonModeEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPolygonModeEXT.html>
type PFN_vkCmdSetPolygonModeEXT = extern "system" fn(commandBuffer: VkCommandBuffer, polygonMode: VkPolygonMode);
/// function prototype `PFN_vkCmdSetRasterizationSamplesEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRasterizationSamplesEXT.html>
type PFN_vkCmdSetRasterizationSamplesEXT = extern "system" fn(commandBuffer: VkCommandBuffer, rasterizationSamples: VkSampleCountFlagBits);
/// function prototype `PFN_vkCmdSetSampleMaskEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetSampleMaskEXT.html>
type PFN_vkCmdSetSampleMaskEXT = extern "system" fn(commandBuffer: VkCommandBuffer, samples: VkSampleCountFlagBits, pSampleMask: *const VkSampleMask);
/// function prototype `PFN_vkCmdSetAlphaToCoverageEnableEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetAlphaToCoverageEnableEXT.html>
type PFN_vkCmdSetAlphaToCoverageEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, alphaToCoverageEnable: VkBool32);
/// function prototype `PFN_vkCmdSetAlphaToOneEnableEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetAlphaToOneEnableEXT.html>
type PFN_vkCmdSetAlphaToOneEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, alphaToOneEnable: VkBool32);
/// function prototype `PFN_vkCmdSetLogicOpEnableEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLogicOpEnableEXT.html>
type PFN_vkCmdSetLogicOpEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, logicOpEnable: VkBool32);
/// function prototype `PFN_vkCmdSetColorBlendEnableEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetColorBlendEnableEXT.html>
type PFN_vkCmdSetColorBlendEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorBlendEnables: *const VkBool32);
/// function prototype `PFN_vkCmdSetColorBlendEquationEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetColorBlendEquationEXT.html>
type PFN_vkCmdSetColorBlendEquationEXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorBlendEquations: *const VkColorBlendEquationEXT);
/// function prototype `PFN_vkCmdSetColorWriteMaskEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetColorWriteMaskEXT.html>
type PFN_vkCmdSetColorWriteMaskEXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorWriteMasks: *const VkColorComponentFlags);
/// function prototype `PFN_vkCmdSetTessellationDomainOriginEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetTessellationDomainOriginEXT.html>
type PFN_vkCmdSetTessellationDomainOriginEXT = extern "system" fn(commandBuffer: VkCommandBuffer, domainOrigin: VkTessellationDomainOrigin);
/// function prototype `PFN_vkCmdSetRasterizationStreamEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRasterizationStreamEXT.html>
type PFN_vkCmdSetRasterizationStreamEXT = extern "system" fn(commandBuffer: VkCommandBuffer, rasterizationStream: u32);
/// function prototype `PFN_vkCmdSetConservativeRasterizationModeEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetConservativeRasterizationModeEXT.html>
type PFN_vkCmdSetConservativeRasterizationModeEXT = extern "system" fn(commandBuffer: VkCommandBuffer, conservativeRasterizationMode: VkConservativeRasterizationModeEXT);
/// function prototype `PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetExtraPrimitiveOverestimationSizeEXT.html>
type PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT = extern "system" fn(commandBuffer: VkCommandBuffer, extraPrimitiveOverestimationSize: f32);
/// function prototype `PFN_vkCmdSetDepthClipEnableEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthClipEnableEXT.html>
type PFN_vkCmdSetDepthClipEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, depthClipEnable: VkBool32);
/// function prototype `PFN_vkCmdSetSampleLocationsEnableEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetSampleLocationsEnableEXT.html>
type PFN_vkCmdSetSampleLocationsEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, sampleLocationsEnable: VkBool32);
/// function prototype `PFN_vkCmdSetColorBlendAdvancedEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetColorBlendAdvancedEXT.html>
type PFN_vkCmdSetColorBlendAdvancedEXT = extern "system" fn(commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorBlendAdvanced: *const VkColorBlendAdvancedEXT);
/// function prototype `PFN_vkCmdSetProvokingVertexModeEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetProvokingVertexModeEXT.html>
type PFN_vkCmdSetProvokingVertexModeEXT = extern "system" fn(commandBuffer: VkCommandBuffer, provokingVertexMode: VkProvokingVertexModeEXT);
/// function prototype `PFN_vkCmdSetLineRasterizationModeEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLineRasterizationModeEXT.html>
type PFN_vkCmdSetLineRasterizationModeEXT = extern "system" fn(commandBuffer: VkCommandBuffer, lineRasterizationMode: VkLineRasterizationModeEXT);
/// function prototype `PFN_vkCmdSetLineStippleEnableEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLineStippleEnableEXT.html>
type PFN_vkCmdSetLineStippleEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, stippledLineEnable: VkBool32);
/// function prototype `PFN_vkCmdSetDepthClipNegativeOneToOneEXT` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthClipNegativeOneToOneEXT.html>
type PFN_vkCmdSetDepthClipNegativeOneToOneEXT = extern "system" fn(commandBuffer: VkCommandBuffer, negativeOneToOne: VkBool32);
/// function prototype `PFN_vkCmdSetViewportWScalingEnableNV` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportWScalingEnableNV.html>
type PFN_vkCmdSetViewportWScalingEnableNV = extern "system" fn(commandBuffer: VkCommandBuffer, viewportWScalingEnable: VkBool32);
/// function prototype `PFN_vkCmdSetViewportSwizzleNV` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportSwizzleNV.html>
type PFN_vkCmdSetViewportSwizzleNV = extern "system" fn(commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportSwizzles: *const VkViewportSwizzleNV);
/// function prototype `PFN_vkCmdSetCoverageToColorEnableNV` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCoverageToColorEnableNV.html>
type PFN_vkCmdSetCoverageToColorEnableNV = extern "system" fn(commandBuffer: VkCommandBuffer, coverageToColorEnable: VkBool32);
/// function prototype `PFN_vkCmdSetCoverageToColorLocationNV` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCoverageToColorLocationNV.html>
type PFN_vkCmdSetCoverageToColorLocationNV = extern "system" fn(commandBuffer: VkCommandBuffer, coverageToColorLocation: u32);
/// function prototype `PFN_vkCmdSetCoverageModulationModeNV` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCoverageModulationModeNV.html>
type PFN_vkCmdSetCoverageModulationModeNV = extern "system" fn(commandBuffer: VkCommandBuffer, coverageModulationMode: VkCoverageModulationModeNV);
/// function prototype `PFN_vkCmdSetCoverageModulationTableEnableNV` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCoverageModulationTableEnableNV.html>
type PFN_vkCmdSetCoverageModulationTableEnableNV = extern "system" fn(commandBuffer: VkCommandBuffer, coverageModulationTableEnable: VkBool32);
/// function prototype `PFN_vkCmdSetCoverageModulationTableNV` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCoverageModulationTableNV.html>
type PFN_vkCmdSetCoverageModulationTableNV = extern "system" fn(commandBuffer: VkCommandBuffer, coverageModulationTableCount: u32, pCoverageModulationTable: *const float);
/// function prototype `PFN_vkCmdSetShadingRateImageEnableNV` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetShadingRateImageEnableNV.html>
type PFN_vkCmdSetShadingRateImageEnableNV = extern "system" fn(commandBuffer: VkCommandBuffer, shadingRateImageEnable: VkBool32);
/// function prototype `PFN_vkCmdSetRepresentativeFragmentTestEnableNV` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRepresentativeFragmentTestEnableNV.html>
type PFN_vkCmdSetRepresentativeFragmentTestEnableNV = extern "system" fn(commandBuffer: VkCommandBuffer, representativeFragmentTestEnable: VkBool32);
/// function prototype `PFN_vkCmdSetCoverageReductionModeNV` from VK_EXT_extended_dynamic_state3
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCoverageReductionModeNV.html>
type PFN_vkCmdSetCoverageReductionModeNV = extern "system" fn(commandBuffer: VkCommandBuffer, coverageReductionMode: VkCoverageReductionModeNV);
/// The dummy function for `vkCmdSetDepthClampEnableEXT` from `VK_EXT_extended_dynamic_state3`
extern "system" fn dummy_vkCmdSetDepthClampEnableEXT(_: VkCommandBuffer, _: VkBool32) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetDepthClampEnableEXT"))
}
/// trait for `VK_EXT_extended_dynamic_state3`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_extended_dynamic_state3.html>
pub trait VK_EXT_extended_dynamic_state3: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthClampEnableEXT.html>
	fn vkCmdSetDepthClampEnableEXT(&self, commandBuffer: VkCommandBuffer, depthClampEnable: VkBool32) -> Result<()>;
}
/// struct for `VK_EXT_extended_dynamic_state3`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_extended_dynamic_state3 {
	vk_cmd_set_depth_clamp_enable_ext: PFN_vkCmdSetDepthClampEnableEXT,
}
impl VK_EXT_extended_dynamic_state3 for Vulkan_EXT_extended_dynamic_state3 {
	fn vkCmdSetDepthClampEnableEXT(&self, commandBuffer: VkCommandBuffer, depthClampEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_depth_clamp_enable_ext)(commandBuffer, depthClampEnable))))
	}
}
impl Default for Vulkan_EXT_extended_dynamic_state3 {
	fn default() -> Self {
		Self {
			vk_cmd_set_depth_clamp_enable_ext: dummy_vkCmdSetDepthClampEnableEXT,
		}
	}
}
impl Vulkan_EXT_extended_dynamic_state3 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_depth_clamp_enable_ext: {let proc = get_instance_proc_address(instance, "vkCmdSetDepthClampEnableEXT"); if proc == null() {dummy_vkCmdSetDepthClampEnableEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// enum `VkSubpassMergeStatusEXT` from VK_EXT_subpass_merge_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSubpassMergeStatusEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkSubpassMergeStatusEXT {
	VK_SUBPASS_MERGE_STATUS_MERGED_EXT = 0,
	VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT = 1,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT = 2,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT = 3,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT = 4,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT = 5,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT = 6,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT = 7,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT = 8,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT = 9,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT = 10,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT = 11,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT = 12,
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT = 13,
	VK_SUBPASS_MERGE_STATUS_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT` from VK_EXT_subpass_merge_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub subpassMergeFeedback: VkBool32,
}
impl Debug for VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("subpassMergeFeedback", &self.subpassMergeFeedback)
		.finish()
	}
}
/// struct `VkRenderPassCreationControlEXT` from VK_EXT_subpass_merge_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassCreationControlEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassCreationControlEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub disallowMerging: VkBool32,
}
impl Debug for VkRenderPassCreationControlEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassCreationControlEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("disallowMerging", &self.disallowMerging)
		.finish()
	}
}
/// struct `VkRenderPassCreationFeedbackInfoEXT` from VK_EXT_subpass_merge_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassCreationFeedbackInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassCreationFeedbackInfoEXT {
	pub postMergeSubpassCount: u32,
}
impl Debug for VkRenderPassCreationFeedbackInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassCreationFeedbackInfoEXT")
		.field("postMergeSubpassCount", &self.postMergeSubpassCount)
		.finish()
	}
}
/// struct `VkRenderPassCreationFeedbackCreateInfoEXT` from VK_EXT_subpass_merge_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassCreationFeedbackCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassCreationFeedbackCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pRenderPassFeedback: *mut VkRenderPassCreationFeedbackInfoEXT,
}
impl Debug for VkRenderPassCreationFeedbackCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassCreationFeedbackCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pRenderPassFeedback", &self.pRenderPassFeedback)
		.finish()
	}
}
/// struct `VkRenderPassSubpassFeedbackInfoEXT` from VK_EXT_subpass_merge_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassSubpassFeedbackInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassSubpassFeedbackInfoEXT {
	pub subpassMergeStatus: VkSubpassMergeStatusEXT,
	pub description: [i8; VK_MAX_DESCRIPTION_SIZE as usize],
	pub postMergeIndex: u32,
}
impl Debug for VkRenderPassSubpassFeedbackInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassSubpassFeedbackInfoEXT")
		.field("subpassMergeStatus", &self.subpassMergeStatus)
		.field("description", &format_args!("{}", maybe_string(&self.description)))
		.field("postMergeIndex", &self.postMergeIndex)
		.finish()
	}
}
/// struct `VkRenderPassSubpassFeedbackCreateInfoEXT` from VK_EXT_subpass_merge_feedback
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPassSubpassFeedbackCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderPassSubpassFeedbackCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pSubpassFeedback: *mut VkRenderPassSubpassFeedbackInfoEXT,
}
impl Debug for VkRenderPassSubpassFeedbackCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderPassSubpassFeedbackCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pSubpassFeedback", &self.pSubpassFeedback)
		.finish()
	}
}
/// trait for `VK_EXT_subpass_merge_feedback`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_subpass_merge_feedback.html>
pub trait VK_EXT_subpass_merge_feedback: Debug {}
/// struct for `VK_EXT_subpass_merge_feedback`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_subpass_merge_feedback {}
impl VK_EXT_subpass_merge_feedback for Vulkan_EXT_subpass_merge_feedback {}
impl Default for Vulkan_EXT_subpass_merge_feedback {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_subpass_merge_feedback {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkDirectDriverLoadingFlagsLUNARG` from VK_LUNARG_direct_driver_loading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDirectDriverLoadingFlagsLUNARG.html>
pub type VkDirectDriverLoadingFlagsLUNARG = VkFlags;
/// enum `VkDirectDriverLoadingModeLUNARG` from VK_LUNARG_direct_driver_loading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDirectDriverLoadingModeLUNARG.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDirectDriverLoadingModeLUNARG {
	VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG = 0,
	VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG = 1,
	VK_DIRECT_DRIVER_LOADING_MODE_MAX_ENUM_LUNARG = 0x7fffffff,
}
/// struct `VkDirectDriverLoadingInfoLUNARG` from VK_LUNARG_direct_driver_loading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDirectDriverLoadingInfoLUNARG.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDirectDriverLoadingInfoLUNARG {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkDirectDriverLoadingFlagsLUNARG,
	pub pfnGetInstanceProcAddr: PFN_vkGetInstanceProcAddrLUNARG,
}
impl Debug for VkDirectDriverLoadingInfoLUNARG {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDirectDriverLoadingInfoLUNARG")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("pfnGetInstanceProcAddr", &self.pfnGetInstanceProcAddr)
		.finish()
	}
}
/// struct `VkDirectDriverLoadingListLUNARG` from VK_LUNARG_direct_driver_loading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDirectDriverLoadingListLUNARG.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDirectDriverLoadingListLUNARG {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub mode: VkDirectDriverLoadingModeLUNARG,
	pub driverCount: u32,
	pub pDrivers: *const VkDirectDriverLoadingInfoLUNARG,
}
impl Debug for VkDirectDriverLoadingListLUNARG {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDirectDriverLoadingListLUNARG")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("mode", &self.mode)
		.field("driverCount", &self.driverCount)
		.field("pDrivers", &self.pDrivers)
		.finish()
	}
}
/// function prototype `PFN_vkGetInstanceProcAddrLUNARG` from VK_LUNARG_direct_driver_loading
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetInstanceProcAddrLUNARG.html>
type PFN_vkGetInstanceProcAddrLUNARG = extern "system" fn(instance: VkInstance, pName: *const i8) -> PFN_vkVoidFunction;
/// trait for `VK_LUNARG_direct_driver_loading`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_LUNARG_direct_driver_loading.html>
pub trait VK_LUNARG_direct_driver_loading: Debug {}
/// struct for `VK_LUNARG_direct_driver_loading`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_LUNARG_direct_driver_loading {}
impl VK_LUNARG_direct_driver_loading for Vulkan_LUNARG_direct_driver_loading {}
impl Default for Vulkan_LUNARG_direct_driver_loading {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_LUNARG_direct_driver_loading {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkTensorCreateFlagsARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorCreateFlagsARM.html>
pub type VkTensorCreateFlagsARM = VkFlags64;
/// type definition `VkTensorCreateFlagBitsARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorCreateFlagBitsARM.html>
pub type VkTensorCreateFlagBitsARM = VkFlags64;
/// type definition `VkTensorViewCreateFlagsARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorViewCreateFlagsARM.html>
pub type VkTensorViewCreateFlagsARM = VkFlags64;
/// type definition `VkTensorViewCreateFlagBitsARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorViewCreateFlagBitsARM.html>
pub type VkTensorViewCreateFlagBitsARM = VkFlags64;
/// type definition `VkTensorUsageFlagsARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorUsageFlagsARM.html>
pub type VkTensorUsageFlagsARM = VkFlags64;
/// type definition `VkTensorUsageFlagBitsARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorUsageFlagBitsARM.html>
pub type VkTensorUsageFlagBitsARM = VkFlags64;
/// Non-dispatchable handle `VkTensorARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorARM.html
#[cfg(target_pointer_width = "32")] pub type VkTensorARM = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkTensorARM_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkTensorARM = *const VkTensorARM_T;
/// Non-dispatchable handle `VkTensorViewARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorViewARM.html
#[cfg(target_pointer_width = "32")] pub type VkTensorViewARM = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkTensorViewARM_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkTensorViewARM = *const VkTensorViewARM_T;
/// enum `VkTensorTilingARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorTilingARM.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkTensorTilingARM {
	VK_TENSOR_TILING_OPTIMAL_ARM = 0,
	VK_TENSOR_TILING_LINEAR_ARM = 1,
	VK_TENSOR_TILING_MAX_ENUM_ARM = 0x7fffffff,
}
/// struct `VkTensorDescriptionARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorDescriptionARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTensorDescriptionARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tiling: VkTensorTilingARM,
	pub format: VkFormat,
	pub dimensionCount: u32,
	pub pDimensions: *const int64_t,
	pub pStrides: *const int64_t,
	pub usage: VkTensorUsageFlagsARM,
}
impl Debug for VkTensorDescriptionARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTensorDescriptionARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tiling", &self.tiling)
		.field("format", &self.format)
		.field("dimensionCount", &self.dimensionCount)
		.field("pDimensions", &self.pDimensions)
		.field("pStrides", &self.pStrides)
		.field("usage", &self.usage)
		.finish()
	}
}
/// struct `VkTensorCreateInfoARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorCreateInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTensorCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkTensorCreateFlagsARM,
	pub pDescription: *const VkTensorDescriptionARM,
	pub sharingMode: VkSharingMode,
	pub queueFamilyIndexCount: u32,
	pub pQueueFamilyIndices: *const uint32_t,
}
impl Debug for VkTensorCreateInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTensorCreateInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("pDescription", &self.pDescription)
		.field("sharingMode", &self.sharingMode)
		.field("queueFamilyIndexCount", &self.queueFamilyIndexCount)
		.field("pQueueFamilyIndices", &self.pQueueFamilyIndices)
		.finish()
	}
}
/// struct `VkTensorViewCreateInfoARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorViewCreateInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTensorViewCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkTensorViewCreateFlagsARM,
	pub tensor: VkTensorARM,
	pub format: VkFormat,
}
impl Debug for VkTensorViewCreateInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTensorViewCreateInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("tensor", &self.tensor)
		.field("format", &self.format)
		.finish()
	}
}
/// struct `VkTensorMemoryRequirementsInfoARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorMemoryRequirementsInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTensorMemoryRequirementsInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensor: VkTensorARM,
}
impl Debug for VkTensorMemoryRequirementsInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTensorMemoryRequirementsInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tensor", &self.tensor)
		.finish()
	}
}
/// struct `VkBindTensorMemoryInfoARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindTensorMemoryInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindTensorMemoryInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensor: VkTensorARM,
	pub memory: VkDeviceMemory,
	pub memoryOffset: VkDeviceSize,
}
impl Debug for VkBindTensorMemoryInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindTensorMemoryInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tensor", &self.tensor)
		.field("memory", &self.memory)
		.field("memoryOffset", &self.memoryOffset)
		.finish()
	}
}
/// struct `VkWriteDescriptorSetTensorARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetTensorARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkWriteDescriptorSetTensorARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensorViewCount: u32,
	pub pTensorViews: *const VkTensorViewARM,
}
impl Debug for VkWriteDescriptorSetTensorARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkWriteDescriptorSetTensorARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tensorViewCount", &self.tensorViewCount)
		.field("pTensorViews", &self.pTensorViews)
		.finish()
	}
}
/// struct `VkTensorFormatPropertiesARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorFormatPropertiesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTensorFormatPropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub optimalTilingTensorFeatures: VkFormatFeatureFlags2,
	pub linearTilingTensorFeatures: VkFormatFeatureFlags2,
}
impl Debug for VkTensorFormatPropertiesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTensorFormatPropertiesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("optimalTilingTensorFeatures", &self.optimalTilingTensorFeatures)
		.field("linearTilingTensorFeatures", &self.linearTilingTensorFeatures)
		.finish()
	}
}
/// struct `VkPhysicalDeviceTensorPropertiesARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTensorPropertiesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceTensorPropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxTensorDimensionCount: u32,
	pub maxTensorElements: u64,
	pub maxPerDimensionTensorElements: u64,
	pub maxTensorStride: i64,
	pub maxTensorSize: u64,
	pub maxTensorShaderAccessArrayLength: u32,
	pub maxTensorShaderAccessSize: u32,
	pub maxDescriptorSetStorageTensors: u32,
	pub maxPerStageDescriptorSetStorageTensors: u32,
	pub maxDescriptorSetUpdateAfterBindStorageTensors: u32,
	pub maxPerStageDescriptorUpdateAfterBindStorageTensors: u32,
	pub shaderStorageTensorArrayNonUniformIndexingNative: VkBool32,
	pub shaderTensorSupportedStages: VkShaderStageFlags,
}
impl Debug for VkPhysicalDeviceTensorPropertiesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceTensorPropertiesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxTensorDimensionCount", &self.maxTensorDimensionCount)
		.field("maxTensorElements", &self.maxTensorElements)
		.field("maxPerDimensionTensorElements", &self.maxPerDimensionTensorElements)
		.field("maxTensorStride", &self.maxTensorStride)
		.field("maxTensorSize", &self.maxTensorSize)
		.field("maxTensorShaderAccessArrayLength", &self.maxTensorShaderAccessArrayLength)
		.field("maxTensorShaderAccessSize", &self.maxTensorShaderAccessSize)
		.field("maxDescriptorSetStorageTensors", &self.maxDescriptorSetStorageTensors)
		.field("maxPerStageDescriptorSetStorageTensors", &self.maxPerStageDescriptorSetStorageTensors)
		.field("maxDescriptorSetUpdateAfterBindStorageTensors", &self.maxDescriptorSetUpdateAfterBindStorageTensors)
		.field("maxPerStageDescriptorUpdateAfterBindStorageTensors", &self.maxPerStageDescriptorUpdateAfterBindStorageTensors)
		.field("shaderStorageTensorArrayNonUniformIndexingNative", &self.shaderStorageTensorArrayNonUniformIndexingNative)
		.field("shaderTensorSupportedStages", &self.shaderTensorSupportedStages)
		.finish()
	}
}
/// struct `VkTensorMemoryBarrierARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorMemoryBarrierARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTensorMemoryBarrierARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcStageMask: VkPipelineStageFlags2,
	pub srcAccessMask: VkAccessFlags2,
	pub dstStageMask: VkPipelineStageFlags2,
	pub dstAccessMask: VkAccessFlags2,
	pub srcQueueFamilyIndex: u32,
	pub dstQueueFamilyIndex: u32,
	pub tensor: VkTensorARM,
}
impl Debug for VkTensorMemoryBarrierARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTensorMemoryBarrierARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcStageMask", &self.srcStageMask)
		.field("srcAccessMask", &self.srcAccessMask)
		.field("dstStageMask", &self.dstStageMask)
		.field("dstAccessMask", &self.dstAccessMask)
		.field("srcQueueFamilyIndex", &self.srcQueueFamilyIndex)
		.field("dstQueueFamilyIndex", &self.dstQueueFamilyIndex)
		.field("tensor", &self.tensor)
		.finish()
	}
}
/// struct `VkTensorDependencyInfoARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorDependencyInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTensorDependencyInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensorMemoryBarrierCount: u32,
	pub pTensorMemoryBarriers: *const VkTensorMemoryBarrierARM,
}
impl Debug for VkTensorDependencyInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTensorDependencyInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tensorMemoryBarrierCount", &self.tensorMemoryBarrierCount)
		.field("pTensorMemoryBarriers", &self.pTensorMemoryBarriers)
		.finish()
	}
}
/// struct `VkPhysicalDeviceTensorFeaturesARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTensorFeaturesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceTensorFeaturesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub tensorNonPacked: VkBool32,
	pub shaderTensorAccess: VkBool32,
	pub shaderStorageTensorArrayDynamicIndexing: VkBool32,
	pub shaderStorageTensorArrayNonUniformIndexing: VkBool32,
	pub descriptorBindingStorageTensorUpdateAfterBind: VkBool32,
	pub tensors: VkBool32,
}
impl Debug for VkPhysicalDeviceTensorFeaturesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceTensorFeaturesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tensorNonPacked", &self.tensorNonPacked)
		.field("shaderTensorAccess", &self.shaderTensorAccess)
		.field("shaderStorageTensorArrayDynamicIndexing", &self.shaderStorageTensorArrayDynamicIndexing)
		.field("shaderStorageTensorArrayNonUniformIndexing", &self.shaderStorageTensorArrayNonUniformIndexing)
		.field("descriptorBindingStorageTensorUpdateAfterBind", &self.descriptorBindingStorageTensorUpdateAfterBind)
		.field("tensors", &self.tensors)
		.finish()
	}
}
/// struct `VkDeviceTensorMemoryRequirementsARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceTensorMemoryRequirementsARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDeviceTensorMemoryRequirementsARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pCreateInfo: *const VkTensorCreateInfoARM,
}
impl Debug for VkDeviceTensorMemoryRequirementsARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDeviceTensorMemoryRequirementsARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pCreateInfo", &self.pCreateInfo)
		.finish()
	}
}
/// struct `VkTensorCopyARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorCopyARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTensorCopyARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dimensionCount: u32,
	pub pSrcOffset: *const uint64_t,
	pub pDstOffset: *const uint64_t,
	pub pExtent: *const uint64_t,
}
impl Debug for VkTensorCopyARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTensorCopyARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dimensionCount", &self.dimensionCount)
		.field("pSrcOffset", &self.pSrcOffset)
		.field("pDstOffset", &self.pDstOffset)
		.field("pExtent", &self.pExtent)
		.finish()
	}
}
/// struct `VkCopyTensorInfoARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyTensorInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyTensorInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcTensor: VkTensorARM,
	pub dstTensor: VkTensorARM,
	pub regionCount: u32,
	pub pRegions: *const VkTensorCopyARM,
}
impl Debug for VkCopyTensorInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyTensorInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcTensor", &self.srcTensor)
		.field("dstTensor", &self.dstTensor)
		.field("regionCount", &self.regionCount)
		.field("pRegions", &self.pRegions)
		.finish()
	}
}
/// struct `VkMemoryDedicatedAllocateInfoTensorARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMemoryDedicatedAllocateInfoTensorARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMemoryDedicatedAllocateInfoTensorARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensor: VkTensorARM,
}
impl Debug for VkMemoryDedicatedAllocateInfoTensorARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMemoryDedicatedAllocateInfoTensorARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tensor", &self.tensor)
		.finish()
	}
}
/// struct `VkPhysicalDeviceExternalTensorInfoARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExternalTensorInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceExternalTensorInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkTensorCreateFlagsARM,
	pub pDescription: *const VkTensorDescriptionARM,
	pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
impl Debug for VkPhysicalDeviceExternalTensorInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceExternalTensorInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("pDescription", &self.pDescription)
		.field("handleType", &self.handleType)
		.finish()
	}
}
/// struct `VkExternalTensorPropertiesARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalTensorPropertiesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExternalTensorPropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub externalMemoryProperties: VkExternalMemoryProperties,
}
impl Debug for VkExternalTensorPropertiesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExternalTensorPropertiesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("externalMemoryProperties", &self.externalMemoryProperties)
		.finish()
	}
}
/// struct `VkExternalMemoryTensorCreateInfoARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalMemoryTensorCreateInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExternalMemoryTensorCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes: VkExternalMemoryHandleTypeFlags,
}
impl Debug for VkExternalMemoryTensorCreateInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExternalMemoryTensorCreateInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("handleTypes", &self.handleTypes)
		.finish()
	}
}
/// struct `VkPhysicalDeviceDescriptorBufferTensorFeaturesARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDescriptorBufferTensorFeaturesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorBufferTensorFeaturesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub descriptorBufferTensorDescriptors: VkBool32,
}
impl Debug for VkPhysicalDeviceDescriptorBufferTensorFeaturesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDescriptorBufferTensorFeaturesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("descriptorBufferTensorDescriptors", &self.descriptorBufferTensorDescriptors)
		.finish()
	}
}
/// struct `VkPhysicalDeviceDescriptorBufferTensorPropertiesARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDescriptorBufferTensorPropertiesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorBufferTensorPropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub tensorCaptureReplayDescriptorDataSize: usize,
	pub tensorViewCaptureReplayDescriptorDataSize: usize,
	pub tensorDescriptorSize: usize,
}
impl Debug for VkPhysicalDeviceDescriptorBufferTensorPropertiesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDescriptorBufferTensorPropertiesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tensorCaptureReplayDescriptorDataSize", &self.tensorCaptureReplayDescriptorDataSize)
		.field("tensorViewCaptureReplayDescriptorDataSize", &self.tensorViewCaptureReplayDescriptorDataSize)
		.field("tensorDescriptorSize", &self.tensorDescriptorSize)
		.finish()
	}
}
/// struct `VkDescriptorGetTensorInfoARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorGetTensorInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDescriptorGetTensorInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensorView: VkTensorViewARM,
}
impl Debug for VkDescriptorGetTensorInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDescriptorGetTensorInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tensorView", &self.tensorView)
		.finish()
	}
}
/// struct `VkTensorCaptureDescriptorDataInfoARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorCaptureDescriptorDataInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTensorCaptureDescriptorDataInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensor: VkTensorARM,
}
impl Debug for VkTensorCaptureDescriptorDataInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTensorCaptureDescriptorDataInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tensor", &self.tensor)
		.finish()
	}
}
/// struct `VkTensorViewCaptureDescriptorDataInfoARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorViewCaptureDescriptorDataInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTensorViewCaptureDescriptorDataInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensorView: VkTensorViewARM,
}
impl Debug for VkTensorViewCaptureDescriptorDataInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTensorViewCaptureDescriptorDataInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tensorView", &self.tensorView)
		.finish()
	}
}
/// struct `VkFrameBoundaryTensorsARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkFrameBoundaryTensorsARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkFrameBoundaryTensorsARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub tensorCount: u32,
	pub pTensors: *const VkTensorARM,
}
impl Debug for VkFrameBoundaryTensorsARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkFrameBoundaryTensorsARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tensorCount", &self.tensorCount)
		.field("pTensors", &self.pTensors)
		.finish()
	}
}
/// function prototype `PFN_vkCreateTensorARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateTensorARM.html>
type PFN_vkCreateTensorARM = extern "system" fn(device: VkDevice, pCreateInfo: *const VkTensorCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pTensor: *mut VkTensorARM) -> VkResult;
/// function prototype `PFN_vkDestroyTensorARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyTensorARM.html>
type PFN_vkDestroyTensorARM = extern "system" fn(device: VkDevice, tensor: VkTensorARM, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCreateTensorViewARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateTensorViewARM.html>
type PFN_vkCreateTensorViewARM = extern "system" fn(device: VkDevice, pCreateInfo: *const VkTensorViewCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pView: *mut VkTensorViewARM) -> VkResult;
/// function prototype `PFN_vkDestroyTensorViewARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyTensorViewARM.html>
type PFN_vkDestroyTensorViewARM = extern "system" fn(device: VkDevice, tensorView: VkTensorViewARM, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkGetTensorMemoryRequirementsARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetTensorMemoryRequirementsARM.html>
type PFN_vkGetTensorMemoryRequirementsARM = extern "system" fn(device: VkDevice, pInfo: *const VkTensorMemoryRequirementsInfoARM, pMemoryRequirements: *mut VkMemoryRequirements2);
/// function prototype `PFN_vkBindTensorMemoryARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindTensorMemoryARM.html>
type PFN_vkBindTensorMemoryARM = extern "system" fn(device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindTensorMemoryInfoARM) -> VkResult;
/// function prototype `PFN_vkGetDeviceTensorMemoryRequirementsARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceTensorMemoryRequirementsARM.html>
type PFN_vkGetDeviceTensorMemoryRequirementsARM = extern "system" fn(device: VkDevice, pInfo: *const VkDeviceTensorMemoryRequirementsARM, pMemoryRequirements: *mut VkMemoryRequirements2);
/// function prototype `PFN_vkCmdCopyTensorARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyTensorARM.html>
type PFN_vkCmdCopyTensorARM = extern "system" fn(commandBuffer: VkCommandBuffer, pCopyTensorInfo: *const VkCopyTensorInfoARM);
/// function prototype `PFN_vkGetPhysicalDeviceExternalTensorPropertiesARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalTensorPropertiesARM.html>
type PFN_vkGetPhysicalDeviceExternalTensorPropertiesARM = extern "system" fn(physicalDevice: VkPhysicalDevice, pExternalTensorInfo: *const VkPhysicalDeviceExternalTensorInfoARM, pExternalTensorProperties: *mut VkExternalTensorPropertiesARM);
/// function prototype `PFN_vkGetTensorOpaqueCaptureDescriptorDataARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetTensorOpaqueCaptureDescriptorDataARM.html>
type PFN_vkGetTensorOpaqueCaptureDescriptorDataARM = extern "system" fn(device: VkDevice, pInfo: *const VkTensorCaptureDescriptorDataInfoARM, pData: *mut c_void) -> VkResult;
/// function prototype `PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM` from VK_ARM_tensors
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetTensorViewOpaqueCaptureDescriptorDataARM.html>
type PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM = extern "system" fn(device: VkDevice, pInfo: *const VkTensorViewCaptureDescriptorDataInfoARM, pData: *mut c_void) -> VkResult;
/// The dummy function for `vkCreateTensorARM` from `VK_ARM_tensors`
extern "system" fn dummy_vkCreateTensorARM(_: VkDevice, _: *const VkTensorCreateInfoARM, _: *const VkAllocationCallbacks, _: *mut VkTensorARM) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateTensorARM"))
}
/// trait for `VK_ARM_tensors`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_ARM_tensors.html>
pub trait VK_ARM_tensors: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateTensorARM.html>
	fn vkCreateTensorARM(&self, device: VkDevice, pCreateInfo: *const VkTensorCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pTensor: *mut VkTensorARM) -> Result<()>;
}
/// struct for `VK_ARM_tensors`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_tensors {
	vk_create_tensor_arm: PFN_vkCreateTensorARM,
}
impl VK_ARM_tensors for Vulkan_ARM_tensors {
	fn vkCreateTensorARM(&self, device: VkDevice, pCreateInfo: *const VkTensorCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pTensor: *mut VkTensorARM) -> Result<()> {
		convert_result("vkCreateTensorARM", catch_unwind(||((self.vk_create_tensor_arm)(device, pCreateInfo, pAllocator, pTensor))))
	}
}
impl Default for Vulkan_ARM_tensors {
	fn default() -> Self {
		Self {
			vk_create_tensor_arm: dummy_vkCreateTensorARM,
		}
	}
}
impl Vulkan_ARM_tensors {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_tensor_arm: {let proc = get_instance_proc_address(instance, "vkCreateTensorARM"); if proc == null() {dummy_vkCreateTensorARM} else {unsafe {transmute(proc)}}},
		}
	}
}
/// constant `VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT` from VK_EXT_shader_module_identifier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT.html>
pub const VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT: u32 = 32u32;
/// struct `VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT` from VK_EXT_shader_module_identifier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderModuleIdentifier: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderModuleIdentifier", &self.shaderModuleIdentifier)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT` from VK_EXT_shader_module_identifier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderModuleIdentifierAlgorithmUUID: [u8; VK_UUID_SIZE as usize],
}
impl Debug for VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderModuleIdentifierAlgorithmUUID", &self.shaderModuleIdentifierAlgorithmUUID)
		.finish()
	}
}
/// struct `VkPipelineShaderStageModuleIdentifierCreateInfoEXT` from VK_EXT_shader_module_identifier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineShaderStageModuleIdentifierCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineShaderStageModuleIdentifierCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub identifierSize: u32,
	pub pIdentifier: *const uint8_t,
}
impl Debug for VkPipelineShaderStageModuleIdentifierCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineShaderStageModuleIdentifierCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("identifierSize", &self.identifierSize)
		.field("pIdentifier", &self.pIdentifier)
		.finish()
	}
}
/// struct `VkShaderModuleIdentifierEXT` from VK_EXT_shader_module_identifier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderModuleIdentifierEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkShaderModuleIdentifierEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub identifierSize: u32,
	pub identifier: [u8; VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT as usize],
}
impl Debug for VkShaderModuleIdentifierEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkShaderModuleIdentifierEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("identifierSize", &self.identifierSize)
		.field("identifier", &self.identifier)
		.finish()
	}
}
/// function prototype `PFN_vkGetShaderModuleIdentifierEXT` from VK_EXT_shader_module_identifier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetShaderModuleIdentifierEXT.html>
type PFN_vkGetShaderModuleIdentifierEXT = extern "system" fn(device: VkDevice, shaderModule: VkShaderModule, pIdentifier: *mut VkShaderModuleIdentifierEXT);
/// function prototype `PFN_vkGetShaderModuleCreateInfoIdentifierEXT` from VK_EXT_shader_module_identifier
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetShaderModuleCreateInfoIdentifierEXT.html>
type PFN_vkGetShaderModuleCreateInfoIdentifierEXT = extern "system" fn(device: VkDevice, pCreateInfo: *const VkShaderModuleCreateInfo, pIdentifier: *mut VkShaderModuleIdentifierEXT);
/// The dummy function for `vkGetShaderModuleIdentifierEXT` from `VK_EXT_shader_module_identifier`
extern "system" fn dummy_vkGetShaderModuleIdentifierEXT(_: VkDevice, _: VkShaderModule, _: *mut VkShaderModuleIdentifierEXT) {
	panic_any(VkError::NullFunctionPointer("vkGetShaderModuleIdentifierEXT"))
}
/// trait for `VK_EXT_shader_module_identifier`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_shader_module_identifier.html>
pub trait VK_EXT_shader_module_identifier: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetShaderModuleIdentifierEXT.html>
	fn vkGetShaderModuleIdentifierEXT(&self, device: VkDevice, shaderModule: VkShaderModule, pIdentifier: *mut VkShaderModuleIdentifierEXT) -> Result<()>;
}
/// struct for `VK_EXT_shader_module_identifier`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_module_identifier {
	vk_get_shader_module_identifier_ext: PFN_vkGetShaderModuleIdentifierEXT,
}
impl VK_EXT_shader_module_identifier for Vulkan_EXT_shader_module_identifier {
	fn vkGetShaderModuleIdentifierEXT(&self, device: VkDevice, shaderModule: VkShaderModule, pIdentifier: *mut VkShaderModuleIdentifierEXT) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_shader_module_identifier_ext)(device, shaderModule, pIdentifier))))
	}
}
impl Default for Vulkan_EXT_shader_module_identifier {
	fn default() -> Self {
		Self {
			vk_get_shader_module_identifier_ext: dummy_vkGetShaderModuleIdentifierEXT,
		}
	}
}
impl Vulkan_EXT_shader_module_identifier {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_shader_module_identifier_ext: {let proc = get_instance_proc_address(instance, "vkGetShaderModuleIdentifierEXT"); if proc == null() {dummy_vkGetShaderModuleIdentifierEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// trait for `VK_EXT_rasterization_order_attachment_access`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_rasterization_order_attachment_access.html>
pub trait VK_EXT_rasterization_order_attachment_access: Debug {}
/// struct for `VK_EXT_rasterization_order_attachment_access`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_rasterization_order_attachment_access {}
impl VK_EXT_rasterization_order_attachment_access for Vulkan_EXT_rasterization_order_attachment_access {}
impl Default for Vulkan_EXT_rasterization_order_attachment_access {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_rasterization_order_attachment_access {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkOpticalFlowGridSizeFlagsNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowGridSizeFlagsNV.html>
pub type VkOpticalFlowGridSizeFlagsNV = VkFlags;
/// type definition `VkOpticalFlowUsageFlagsNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowUsageFlagsNV.html>
pub type VkOpticalFlowUsageFlagsNV = VkFlags;
/// type definition `VkOpticalFlowSessionCreateFlagsNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowSessionCreateFlagsNV.html>
pub type VkOpticalFlowSessionCreateFlagsNV = VkFlags;
/// type definition `VkOpticalFlowExecuteFlagsNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowExecuteFlagsNV.html>
pub type VkOpticalFlowExecuteFlagsNV = VkFlags;
/// Non-dispatchable handle `VkOpticalFlowSessionNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowSessionNV.html
#[cfg(target_pointer_width = "32")] pub type VkOpticalFlowSessionNV = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkOpticalFlowSessionNV_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkOpticalFlowSessionNV = *const VkOpticalFlowSessionNV_T;
/// enum `VkOpticalFlowPerformanceLevelNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowPerformanceLevelNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOpticalFlowPerformanceLevelNV {
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV = 0,
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV = 1,
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV = 2,
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV = 3,
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkOpticalFlowSessionBindingPointNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowSessionBindingPointNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOpticalFlowSessionBindingPointNV {
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV = 0,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV = 1,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV = 2,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV = 3,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV = 4,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV = 5,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV = 6,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV = 7,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV = 8,
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkOpticalFlowGridSizeFlagBitsNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowGridSizeFlagBitsNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOpticalFlowGridSizeFlagBitsNV {
	VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV = 0,
	VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV = 0x00000001,
	VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV = 0x00000002,
	VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV = 0x00000004,
	VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV = 0x00000008,
	VK_OPTICAL_FLOW_GRID_SIZE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkOpticalFlowUsageFlagBitsNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowUsageFlagBitsNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOpticalFlowUsageFlagBitsNV {
	VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV = 0,
	VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV = 0x00000001,
	VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV = 0x00000002,
	VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV = 0x00000004,
	VK_OPTICAL_FLOW_USAGE_COST_BIT_NV = 0x00000008,
	VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV = 0x00000010,
	VK_OPTICAL_FLOW_USAGE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkOpticalFlowSessionCreateFlagBitsNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowSessionCreateFlagBitsNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOpticalFlowSessionCreateFlagBitsNV {
	VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV = 0x00000001,
	VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV = 0x00000002,
	VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV = 0x00000004,
	VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV = 0x00000008,
	VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV = 0x00000010,
	VK_OPTICAL_FLOW_SESSION_CREATE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkOpticalFlowExecuteFlagBitsNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowExecuteFlagBitsNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOpticalFlowExecuteFlagBitsNV {
	VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV = 0x00000001,
	VK_OPTICAL_FLOW_EXECUTE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
/// struct `VkPhysicalDeviceOpticalFlowFeaturesNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceOpticalFlowFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceOpticalFlowFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub opticalFlow: VkBool32,
}
impl Debug for VkPhysicalDeviceOpticalFlowFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceOpticalFlowFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("opticalFlow", &self.opticalFlow)
		.finish()
	}
}
/// struct `VkPhysicalDeviceOpticalFlowPropertiesNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceOpticalFlowPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceOpticalFlowPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub supportedOutputGridSizes: VkOpticalFlowGridSizeFlagsNV,
	pub supportedHintGridSizes: VkOpticalFlowGridSizeFlagsNV,
	pub hintSupported: VkBool32,
	pub costSupported: VkBool32,
	pub bidirectionalFlowSupported: VkBool32,
	pub globalFlowSupported: VkBool32,
	pub minWidth: u32,
	pub minHeight: u32,
	pub maxWidth: u32,
	pub maxHeight: u32,
	pub maxNumRegionsOfInterest: u32,
}
impl Debug for VkPhysicalDeviceOpticalFlowPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceOpticalFlowPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("supportedOutputGridSizes", &self.supportedOutputGridSizes)
		.field("supportedHintGridSizes", &self.supportedHintGridSizes)
		.field("hintSupported", &self.hintSupported)
		.field("costSupported", &self.costSupported)
		.field("bidirectionalFlowSupported", &self.bidirectionalFlowSupported)
		.field("globalFlowSupported", &self.globalFlowSupported)
		.field("minWidth", &self.minWidth)
		.field("minHeight", &self.minHeight)
		.field("maxWidth", &self.maxWidth)
		.field("maxHeight", &self.maxHeight)
		.field("maxNumRegionsOfInterest", &self.maxNumRegionsOfInterest)
		.finish()
	}
}
/// struct `VkOpticalFlowImageFormatInfoNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowImageFormatInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkOpticalFlowImageFormatInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub usage: VkOpticalFlowUsageFlagsNV,
}
impl Debug for VkOpticalFlowImageFormatInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkOpticalFlowImageFormatInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("usage", &self.usage)
		.finish()
	}
}
/// struct `VkOpticalFlowImageFormatPropertiesNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowImageFormatPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkOpticalFlowImageFormatPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub format: VkFormat,
}
impl Debug for VkOpticalFlowImageFormatPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkOpticalFlowImageFormatPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("format", &self.format)
		.finish()
	}
}
/// struct `VkOpticalFlowSessionCreateInfoNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowSessionCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkOpticalFlowSessionCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub width: u32,
	pub height: u32,
	pub imageFormat: VkFormat,
	pub flowVectorFormat: VkFormat,
	pub costFormat: VkFormat,
	pub outputGridSize: VkOpticalFlowGridSizeFlagsNV,
	pub hintGridSize: VkOpticalFlowGridSizeFlagsNV,
	pub performanceLevel: VkOpticalFlowPerformanceLevelNV,
	pub flags: VkOpticalFlowSessionCreateFlagsNV,
}
impl Debug for VkOpticalFlowSessionCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkOpticalFlowSessionCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("width", &self.width)
		.field("height", &self.height)
		.field("imageFormat", &self.imageFormat)
		.field("flowVectorFormat", &self.flowVectorFormat)
		.field("costFormat", &self.costFormat)
		.field("outputGridSize", &self.outputGridSize)
		.field("hintGridSize", &self.hintGridSize)
		.field("performanceLevel", &self.performanceLevel)
		.field("flags", &self.flags)
		.finish()
	}
}
/// struct `VkOpticalFlowSessionCreatePrivateDataInfoNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowSessionCreatePrivateDataInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkOpticalFlowSessionCreatePrivateDataInfoNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub id: u32,
	pub size: u32,
	pub pPrivateData: *const c_void,
}
impl Debug for VkOpticalFlowSessionCreatePrivateDataInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkOpticalFlowSessionCreatePrivateDataInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("id", &self.id)
		.field("size", &self.size)
		.field("pPrivateData", &self.pPrivateData)
		.finish()
	}
}
/// struct `VkOpticalFlowExecuteInfoNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowExecuteInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkOpticalFlowExecuteInfoNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkOpticalFlowExecuteFlagsNV,
	pub regionCount: u32,
	pub pRegions: *const VkRect2D,
}
impl Debug for VkOpticalFlowExecuteInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkOpticalFlowExecuteInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("regionCount", &self.regionCount)
		.field("pRegions", &self.pRegions)
		.finish()
	}
}
/// function prototype `PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceOpticalFlowImageFormatsNV.html>
type PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV = extern "system" fn(physicalDevice: VkPhysicalDevice, pOpticalFlowImageFormatInfo: *const VkOpticalFlowImageFormatInfoNV, pFormatCount: *mut uint32_t, pImageFormatProperties: *mut VkOpticalFlowImageFormatPropertiesNV) -> VkResult;
/// function prototype `PFN_vkCreateOpticalFlowSessionNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateOpticalFlowSessionNV.html>
type PFN_vkCreateOpticalFlowSessionNV = extern "system" fn(device: VkDevice, pCreateInfo: *const VkOpticalFlowSessionCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pSession: *mut VkOpticalFlowSessionNV) -> VkResult;
/// function prototype `PFN_vkDestroyOpticalFlowSessionNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyOpticalFlowSessionNV.html>
type PFN_vkDestroyOpticalFlowSessionNV = extern "system" fn(device: VkDevice, session: VkOpticalFlowSessionNV, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkBindOpticalFlowSessionImageNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindOpticalFlowSessionImageNV.html>
type PFN_vkBindOpticalFlowSessionImageNV = extern "system" fn(device: VkDevice, session: VkOpticalFlowSessionNV, bindingPoint: VkOpticalFlowSessionBindingPointNV, view: VkImageView, layout: VkImageLayout) -> VkResult;
/// function prototype `PFN_vkCmdOpticalFlowExecuteNV` from VK_NV_optical_flow
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdOpticalFlowExecuteNV.html>
type PFN_vkCmdOpticalFlowExecuteNV = extern "system" fn(commandBuffer: VkCommandBuffer, session: VkOpticalFlowSessionNV, pExecuteInfo: *const VkOpticalFlowExecuteInfoNV);
/// The dummy function for `vkGetPhysicalDeviceOpticalFlowImageFormatsNV` from `VK_NV_optical_flow`
extern "system" fn dummy_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(_: VkPhysicalDevice, _: *const VkOpticalFlowImageFormatInfoNV, _: *mut uint32_t, _: *mut VkOpticalFlowImageFormatPropertiesNV) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceOpticalFlowImageFormatsNV"))
}
/// trait for `VK_NV_optical_flow`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_optical_flow.html>
pub trait VK_NV_optical_flow: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceOpticalFlowImageFormatsNV.html>
	fn vkGetPhysicalDeviceOpticalFlowImageFormatsNV(&self, physicalDevice: VkPhysicalDevice, pOpticalFlowImageFormatInfo: *const VkOpticalFlowImageFormatInfoNV, pFormatCount: *mut uint32_t, pImageFormatProperties: *mut VkOpticalFlowImageFormatPropertiesNV) -> Result<()>;
}
/// struct for `VK_NV_optical_flow`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_optical_flow {
	vk_get_physical_device_optical_flow_image_formats_nv: PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV,
}
impl VK_NV_optical_flow for Vulkan_NV_optical_flow {
	fn vkGetPhysicalDeviceOpticalFlowImageFormatsNV(&self, physicalDevice: VkPhysicalDevice, pOpticalFlowImageFormatInfo: *const VkOpticalFlowImageFormatInfoNV, pFormatCount: *mut uint32_t, pImageFormatProperties: *mut VkOpticalFlowImageFormatPropertiesNV) -> Result<()> {
		convert_result("vkGetPhysicalDeviceOpticalFlowImageFormatsNV", catch_unwind(||((self.vk_get_physical_device_optical_flow_image_formats_nv)(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties))))
	}
}
impl Default for Vulkan_NV_optical_flow {
	fn default() -> Self {
		Self {
			vk_get_physical_device_optical_flow_image_formats_nv: dummy_vkGetPhysicalDeviceOpticalFlowImageFormatsNV,
		}
	}
}
impl Vulkan_NV_optical_flow {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_optical_flow_image_formats_nv: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV"); if proc == null() {dummy_vkGetPhysicalDeviceOpticalFlowImageFormatsNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceLegacyDitheringFeaturesEXT` from VK_EXT_legacy_dithering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLegacyDitheringFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceLegacyDitheringFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub legacyDithering: VkBool32,
}
impl Debug for VkPhysicalDeviceLegacyDitheringFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceLegacyDitheringFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("legacyDithering", &self.legacyDithering)
		.finish()
	}
}
/// trait for `VK_EXT_legacy_dithering`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_legacy_dithering.html>
pub trait VK_EXT_legacy_dithering: Debug {}
/// struct for `VK_EXT_legacy_dithering`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_legacy_dithering {}
impl VK_EXT_legacy_dithering for Vulkan_EXT_legacy_dithering {}
impl Default for Vulkan_EXT_legacy_dithering {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_legacy_dithering {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkPhysicalDevicePipelineProtectedAccessFeaturesEXT` from VK_EXT_pipeline_protected_access
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePipelineProtectedAccessFeaturesEXT.html>
pub type VkPhysicalDevicePipelineProtectedAccessFeaturesEXT = VkPhysicalDevicePipelineProtectedAccessFeatures;
/// trait for `VK_EXT_pipeline_protected_access`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_pipeline_protected_access.html>
pub trait VK_EXT_pipeline_protected_access: Debug {}
/// struct for `VK_EXT_pipeline_protected_access`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_pipeline_protected_access {}
impl VK_EXT_pipeline_protected_access for Vulkan_EXT_pipeline_protected_access {}
impl Default for Vulkan_EXT_pipeline_protected_access {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_pipeline_protected_access {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkAntiLagModeAMD` from VK_AMD_anti_lag
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAntiLagModeAMD.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAntiLagModeAMD {
	VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD = 0,
	VK_ANTI_LAG_MODE_ON_AMD = 1,
	VK_ANTI_LAG_MODE_OFF_AMD = 2,
	VK_ANTI_LAG_MODE_MAX_ENUM_AMD = 0x7fffffff,
}
/// enum `VkAntiLagStageAMD` from VK_AMD_anti_lag
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAntiLagStageAMD.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAntiLagStageAMD {
	VK_ANTI_LAG_STAGE_INPUT_AMD = 0,
	VK_ANTI_LAG_STAGE_PRESENT_AMD = 1,
	VK_ANTI_LAG_STAGE_MAX_ENUM_AMD = 0x7fffffff,
}
/// struct `VkPhysicalDeviceAntiLagFeaturesAMD` from VK_AMD_anti_lag
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceAntiLagFeaturesAMD.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceAntiLagFeaturesAMD {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub antiLag: VkBool32,
}
impl Debug for VkPhysicalDeviceAntiLagFeaturesAMD {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceAntiLagFeaturesAMD")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("antiLag", &self.antiLag)
		.finish()
	}
}
/// struct `VkAntiLagPresentationInfoAMD` from VK_AMD_anti_lag
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAntiLagPresentationInfoAMD.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAntiLagPresentationInfoAMD {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub stage: VkAntiLagStageAMD,
	pub frameIndex: u64,
}
impl Debug for VkAntiLagPresentationInfoAMD {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAntiLagPresentationInfoAMD")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stage", &self.stage)
		.field("frameIndex", &self.frameIndex)
		.finish()
	}
}
/// struct `VkAntiLagDataAMD` from VK_AMD_anti_lag
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAntiLagDataAMD.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAntiLagDataAMD {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub mode: VkAntiLagModeAMD,
	pub maxFPS: u32,
	pub pPresentationInfo: *const VkAntiLagPresentationInfoAMD,
}
impl Debug for VkAntiLagDataAMD {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAntiLagDataAMD")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("mode", &self.mode)
		.field("maxFPS", &self.maxFPS)
		.field("pPresentationInfo", &self.pPresentationInfo)
		.finish()
	}
}
/// function prototype `PFN_vkAntiLagUpdateAMD` from VK_AMD_anti_lag
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkAntiLagUpdateAMD.html>
type PFN_vkAntiLagUpdateAMD = extern "system" fn(device: VkDevice, pData: *const VkAntiLagDataAMD);
/// The dummy function for `vkAntiLagUpdateAMD` from `VK_AMD_anti_lag`
extern "system" fn dummy_vkAntiLagUpdateAMD(_: VkDevice, _: *const VkAntiLagDataAMD) {
	panic_any(VkError::NullFunctionPointer("vkAntiLagUpdateAMD"))
}
/// trait for `VK_AMD_anti_lag`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_AMD_anti_lag.html>
pub trait VK_AMD_anti_lag: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkAntiLagUpdateAMD.html>
	fn vkAntiLagUpdateAMD(&self, device: VkDevice, pData: *const VkAntiLagDataAMD) -> Result<()>;
}
/// struct for `VK_AMD_anti_lag`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_AMD_anti_lag {
	vk_anti_lag_update_amd: PFN_vkAntiLagUpdateAMD,
}
impl VK_AMD_anti_lag for Vulkan_AMD_anti_lag {
	fn vkAntiLagUpdateAMD(&self, device: VkDevice, pData: *const VkAntiLagDataAMD) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_anti_lag_update_amd)(device, pData))))
	}
}
impl Default for Vulkan_AMD_anti_lag {
	fn default() -> Self {
		Self {
			vk_anti_lag_update_amd: dummy_vkAntiLagUpdateAMD,
		}
	}
}
impl Vulkan_AMD_anti_lag {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_anti_lag_update_amd: {let proc = get_instance_proc_address(instance, "vkAntiLagUpdateAMD"); if proc == null() {dummy_vkAntiLagUpdateAMD} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkShaderCreateFlagsEXT` from VK_EXT_shader_object
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderCreateFlagsEXT.html>
pub type VkShaderCreateFlagsEXT = VkFlags;
/// type definition `VkShaderRequiredSubgroupSizeCreateInfoEXT` from VK_EXT_shader_object
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderRequiredSubgroupSizeCreateInfoEXT.html>
pub type VkShaderRequiredSubgroupSizeCreateInfoEXT = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;
/// Non-dispatchable handle `VkShaderEXT` from VK_EXT_shader_object
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderEXT.html
#[cfg(target_pointer_width = "32")] pub type VkShaderEXT = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkShaderEXT_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkShaderEXT = *const VkShaderEXT_T;
/// enum `VkShaderCodeTypeEXT` from VK_EXT_shader_object
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderCodeTypeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkShaderCodeTypeEXT {
	VK_SHADER_CODE_TYPE_BINARY_EXT = 0,
	VK_SHADER_CODE_TYPE_SPIRV_EXT = 1,
	VK_SHADER_CODE_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkDepthClampModeEXT` from VK_EXT_shader_object
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDepthClampModeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDepthClampModeEXT {
	VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT = 0,
	VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT = 1,
	VK_DEPTH_CLAMP_MODE_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkShaderCreateFlagBitsEXT` from VK_EXT_shader_object
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderCreateFlagBitsEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkShaderCreateFlagBitsEXT {
	VK_SHADER_CREATE_LINK_STAGE_BIT_EXT = 0x00000001,
	VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 0x00000002,
	VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = 0x00000004,
	VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT = 0x00000008,
	VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT = 0x00000010,
	VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT = 0x00000020,
	VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00000040,
	VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT = 0x00000080,
	VK_SHADER_CREATE_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkPhysicalDeviceShaderObjectFeaturesEXT` from VK_EXT_shader_object
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderObjectFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderObjectFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderObject: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderObjectFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderObjectFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderObject", &self.shaderObject)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShaderObjectPropertiesEXT` from VK_EXT_shader_object
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderObjectPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderObjectPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderBinaryUUID: [u8; VK_UUID_SIZE as usize],
	pub shaderBinaryVersion: u32,
}
impl Debug for VkPhysicalDeviceShaderObjectPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderObjectPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderBinaryUUID", &self.shaderBinaryUUID)
		.field("shaderBinaryVersion", &self.shaderBinaryVersion)
		.finish()
	}
}
/// struct `VkShaderCreateInfoEXT` from VK_EXT_shader_object
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkShaderCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkShaderCreateFlagsEXT,
	pub stage: VkShaderStageFlagBits,
	pub nextStage: VkShaderStageFlags,
	pub codeType: VkShaderCodeTypeEXT,
	pub codeSize: usize,
	pub pCode: *const c_void,
	pub pName: *const i8,
	pub setLayoutCount: u32,
	pub pSetLayouts: *const VkDescriptorSetLayout,
	pub pushConstantRangeCount: u32,
	pub pPushConstantRanges: *const VkPushConstantRange,
	pub pSpecializationInfo: *const VkSpecializationInfo,
}
impl Debug for VkShaderCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkShaderCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("stage", &self.stage)
		.field("nextStage", &self.nextStage)
		.field("codeType", &self.codeType)
		.field("codeSize", &self.codeSize)
		.field("pCode", &self.pCode)
		.field("pName", &self.pName)
		.field("setLayoutCount", &self.setLayoutCount)
		.field("pSetLayouts", &self.pSetLayouts)
		.field("pushConstantRangeCount", &self.pushConstantRangeCount)
		.field("pPushConstantRanges", &self.pPushConstantRanges)
		.field("pSpecializationInfo", &self.pSpecializationInfo)
		.finish()
	}
}
/// struct `VkDepthClampRangeEXT` from VK_EXT_shader_object
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDepthClampRangeEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDepthClampRangeEXT {
	pub minDepthClamp: f32,
	pub maxDepthClamp: f32,
}
impl Debug for VkDepthClampRangeEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDepthClampRangeEXT")
		.field("minDepthClamp", &self.minDepthClamp)
		.field("maxDepthClamp", &self.maxDepthClamp)
		.finish()
	}
}
/// function prototype `PFN_vkCreateShadersEXT` from VK_EXT_shader_object
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateShadersEXT.html>
type PFN_vkCreateShadersEXT = extern "system" fn(device: VkDevice, createInfoCount: u32, pCreateInfos: *const VkShaderCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pShaders: *mut VkShaderEXT) -> VkResult;
/// function prototype `PFN_vkDestroyShaderEXT` from VK_EXT_shader_object
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyShaderEXT.html>
type PFN_vkDestroyShaderEXT = extern "system" fn(device: VkDevice, shader: VkShaderEXT, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkGetShaderBinaryDataEXT` from VK_EXT_shader_object
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetShaderBinaryDataEXT.html>
type PFN_vkGetShaderBinaryDataEXT = extern "system" fn(device: VkDevice, shader: VkShaderEXT, pDataSize: *mut size_t, pData: *mut c_void) -> VkResult;
/// function prototype `PFN_vkCmdBindShadersEXT` from VK_EXT_shader_object
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindShadersEXT.html>
type PFN_vkCmdBindShadersEXT = extern "system" fn(commandBuffer: VkCommandBuffer, stageCount: u32, pStages: *const VkShaderStageFlagBits, pShaders: *const VkShaderEXT);
/// function prototype `PFN_vkCmdSetDepthClampRangeEXT` from VK_EXT_shader_object
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthClampRangeEXT.html>
type PFN_vkCmdSetDepthClampRangeEXT = extern "system" fn(commandBuffer: VkCommandBuffer, depthClampMode: VkDepthClampModeEXT, pDepthClampRange: *const VkDepthClampRangeEXT);
/// The dummy function for `vkCreateShadersEXT` from `VK_EXT_shader_object`
extern "system" fn dummy_vkCreateShadersEXT(_: VkDevice, _: u32, _: *const VkShaderCreateInfoEXT, _: *const VkAllocationCallbacks, _: *mut VkShaderEXT) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateShadersEXT"))
}
/// trait for `VK_EXT_shader_object`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_shader_object.html>
pub trait VK_EXT_shader_object: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateShadersEXT.html>
	fn vkCreateShadersEXT(&self, device: VkDevice, createInfoCount: u32, pCreateInfos: *const VkShaderCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pShaders: *mut VkShaderEXT) -> Result<()>;
}
/// struct for `VK_EXT_shader_object`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_object {
	vk_create_shaders_ext: PFN_vkCreateShadersEXT,
}
impl VK_EXT_shader_object for Vulkan_EXT_shader_object {
	fn vkCreateShadersEXT(&self, device: VkDevice, createInfoCount: u32, pCreateInfos: *const VkShaderCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pShaders: *mut VkShaderEXT) -> Result<()> {
		convert_result("vkCreateShadersEXT", catch_unwind(||((self.vk_create_shaders_ext)(device, createInfoCount, pCreateInfos, pAllocator, pShaders))))
	}
}
impl Default for Vulkan_EXT_shader_object {
	fn default() -> Self {
		Self {
			vk_create_shaders_ext: dummy_vkCreateShadersEXT,
		}
	}
}
impl Vulkan_EXT_shader_object {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_shaders_ext: {let proc = get_instance_proc_address(instance, "vkCreateShadersEXT"); if proc == null() {dummy_vkCreateShadersEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceTilePropertiesFeaturesQCOM` from VK_QCOM_tile_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTilePropertiesFeaturesQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceTilePropertiesFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub tileProperties: VkBool32,
}
impl Debug for VkPhysicalDeviceTilePropertiesFeaturesQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceTilePropertiesFeaturesQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tileProperties", &self.tileProperties)
		.finish()
	}
}
/// struct `VkTilePropertiesQCOM` from VK_QCOM_tile_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTilePropertiesQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTilePropertiesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub tileSize: VkExtent3D,
	pub apronSize: VkExtent2D,
	pub origin: VkOffset2D,
}
impl Debug for VkTilePropertiesQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTilePropertiesQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tileSize", &self.tileSize)
		.field("apronSize", &self.apronSize)
		.field("origin", &self.origin)
		.finish()
	}
}
/// function prototype `PFN_vkGetFramebufferTilePropertiesQCOM` from VK_QCOM_tile_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetFramebufferTilePropertiesQCOM.html>
type PFN_vkGetFramebufferTilePropertiesQCOM = extern "system" fn(device: VkDevice, framebuffer: VkFramebuffer, pPropertiesCount: *mut uint32_t, pProperties: *mut VkTilePropertiesQCOM) -> VkResult;
/// function prototype `PFN_vkGetDynamicRenderingTilePropertiesQCOM` from VK_QCOM_tile_properties
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDynamicRenderingTilePropertiesQCOM.html>
type PFN_vkGetDynamicRenderingTilePropertiesQCOM = extern "system" fn(device: VkDevice, pRenderingInfo: *const VkRenderingInfo, pProperties: *mut VkTilePropertiesQCOM) -> VkResult;
/// The dummy function for `vkGetFramebufferTilePropertiesQCOM` from `VK_QCOM_tile_properties`
extern "system" fn dummy_vkGetFramebufferTilePropertiesQCOM(_: VkDevice, _: VkFramebuffer, _: *mut uint32_t, _: *mut VkTilePropertiesQCOM) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetFramebufferTilePropertiesQCOM"))
}
/// trait for `VK_QCOM_tile_properties`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QCOM_tile_properties.html>
pub trait VK_QCOM_tile_properties: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetFramebufferTilePropertiesQCOM.html>
	fn vkGetFramebufferTilePropertiesQCOM(&self, device: VkDevice, framebuffer: VkFramebuffer, pPropertiesCount: *mut uint32_t, pProperties: *mut VkTilePropertiesQCOM) -> Result<()>;
}
/// struct for `VK_QCOM_tile_properties`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_tile_properties {
	vk_get_framebuffer_tile_properties_qcom: PFN_vkGetFramebufferTilePropertiesQCOM,
}
impl VK_QCOM_tile_properties for Vulkan_QCOM_tile_properties {
	fn vkGetFramebufferTilePropertiesQCOM(&self, device: VkDevice, framebuffer: VkFramebuffer, pPropertiesCount: *mut uint32_t, pProperties: *mut VkTilePropertiesQCOM) -> Result<()> {
		convert_result("vkGetFramebufferTilePropertiesQCOM", catch_unwind(||((self.vk_get_framebuffer_tile_properties_qcom)(device, framebuffer, pPropertiesCount, pProperties))))
	}
}
impl Default for Vulkan_QCOM_tile_properties {
	fn default() -> Self {
		Self {
			vk_get_framebuffer_tile_properties_qcom: dummy_vkGetFramebufferTilePropertiesQCOM,
		}
	}
}
impl Vulkan_QCOM_tile_properties {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_framebuffer_tile_properties_qcom: {let proc = get_instance_proc_address(instance, "vkGetFramebufferTilePropertiesQCOM"); if proc == null() {dummy_vkGetFramebufferTilePropertiesQCOM} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceAmigoProfilingFeaturesSEC` from VK_SEC_amigo_profiling
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceAmigoProfilingFeaturesSEC.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceAmigoProfilingFeaturesSEC {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub amigoProfiling: VkBool32,
}
impl Debug for VkPhysicalDeviceAmigoProfilingFeaturesSEC {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceAmigoProfilingFeaturesSEC")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("amigoProfiling", &self.amigoProfiling)
		.finish()
	}
}
/// struct `VkAmigoProfilingSubmitInfoSEC` from VK_SEC_amigo_profiling
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAmigoProfilingSubmitInfoSEC.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAmigoProfilingSubmitInfoSEC {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub firstDrawTimestamp: u64,
	pub swapBufferTimestamp: u64,
}
impl Debug for VkAmigoProfilingSubmitInfoSEC {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAmigoProfilingSubmitInfoSEC")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("firstDrawTimestamp", &self.firstDrawTimestamp)
		.field("swapBufferTimestamp", &self.swapBufferTimestamp)
		.finish()
	}
}
/// trait for `VK_SEC_amigo_profiling`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_SEC_amigo_profiling.html>
pub trait VK_SEC_amigo_profiling: Debug {}
/// struct for `VK_SEC_amigo_profiling`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_SEC_amigo_profiling {}
impl VK_SEC_amigo_profiling for Vulkan_SEC_amigo_profiling {}
impl Default for Vulkan_SEC_amigo_profiling {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_SEC_amigo_profiling {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM` from VK_QCOM_multiview_per_view_viewports
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub multiviewPerViewViewports: VkBool32,
}
impl Debug for VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("multiviewPerViewViewports", &self.multiviewPerViewViewports)
		.finish()
	}
}
/// trait for `VK_QCOM_multiview_per_view_viewports`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QCOM_multiview_per_view_viewports.html>
pub trait VK_QCOM_multiview_per_view_viewports: Debug {}
/// struct for `VK_QCOM_multiview_per_view_viewports`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_multiview_per_view_viewports {}
impl VK_QCOM_multiview_per_view_viewports for Vulkan_QCOM_multiview_per_view_viewports {}
impl Default for Vulkan_QCOM_multiview_per_view_viewports {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_multiview_per_view_viewports {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkRayTracingInvocationReorderModeNV` from VK_NV_ray_tracing_invocation_reorder
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRayTracingInvocationReorderModeNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkRayTracingInvocationReorderModeNV {
	VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV = 0,
	VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV = 1,
	VK_RAY_TRACING_INVOCATION_REORDER_MODE_MAX_ENUM_NV = 0x7fffffff,
}
/// struct `VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV` from VK_NV_ray_tracing_invocation_reorder
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rayTracingInvocationReorderReorderingHint: VkRayTracingInvocationReorderModeNV,
}
impl Debug for VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("rayTracingInvocationReorderReorderingHint", &self.rayTracingInvocationReorderReorderingHint)
		.finish()
	}
}
/// struct `VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV` from VK_NV_ray_tracing_invocation_reorder
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rayTracingInvocationReorder: VkBool32,
}
impl Debug for VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("rayTracingInvocationReorder", &self.rayTracingInvocationReorder)
		.finish()
	}
}
/// trait for `VK_NV_ray_tracing_invocation_reorder`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_ray_tracing_invocation_reorder.html>
pub trait VK_NV_ray_tracing_invocation_reorder: Debug {}
/// struct for `VK_NV_ray_tracing_invocation_reorder`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_ray_tracing_invocation_reorder {}
impl VK_NV_ray_tracing_invocation_reorder for Vulkan_NV_ray_tracing_invocation_reorder {}
impl Default for Vulkan_NV_ray_tracing_invocation_reorder {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_ray_tracing_invocation_reorder {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkCooperativeVectorMatrixLayoutNV` from VK_NV_cooperative_vector
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCooperativeVectorMatrixLayoutNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCooperativeVectorMatrixLayoutNV {
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV = 0,
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV = 1,
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV = 2,
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV = 3,
	VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_MAX_ENUM_NV = 0x7fffffff,
}
/// struct `VkPhysicalDeviceCooperativeVectorPropertiesNV` from VK_NV_cooperative_vector
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCooperativeVectorPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCooperativeVectorPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cooperativeVectorSupportedStages: VkShaderStageFlags,
	pub cooperativeVectorTrainingFloat16Accumulation: VkBool32,
	pub cooperativeVectorTrainingFloat32Accumulation: VkBool32,
	pub maxCooperativeVectorComponents: u32,
}
impl Debug for VkPhysicalDeviceCooperativeVectorPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCooperativeVectorPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("cooperativeVectorSupportedStages", &self.cooperativeVectorSupportedStages)
		.field("cooperativeVectorTrainingFloat16Accumulation", &self.cooperativeVectorTrainingFloat16Accumulation)
		.field("cooperativeVectorTrainingFloat32Accumulation", &self.cooperativeVectorTrainingFloat32Accumulation)
		.field("maxCooperativeVectorComponents", &self.maxCooperativeVectorComponents)
		.finish()
	}
}
/// struct `VkPhysicalDeviceCooperativeVectorFeaturesNV` from VK_NV_cooperative_vector
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCooperativeVectorFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCooperativeVectorFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cooperativeVector: VkBool32,
	pub cooperativeVectorTraining: VkBool32,
}
impl Debug for VkPhysicalDeviceCooperativeVectorFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCooperativeVectorFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("cooperativeVector", &self.cooperativeVector)
		.field("cooperativeVectorTraining", &self.cooperativeVectorTraining)
		.finish()
	}
}
/// struct `VkCooperativeVectorPropertiesNV` from VK_NV_cooperative_vector
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCooperativeVectorPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCooperativeVectorPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub inputType: VkComponentTypeKHR,
	pub inputInterpretation: VkComponentTypeKHR,
	pub matrixInterpretation: VkComponentTypeKHR,
	pub biasInterpretation: VkComponentTypeKHR,
	pub resultType: VkComponentTypeKHR,
	pub transpose: VkBool32,
}
impl Debug for VkCooperativeVectorPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCooperativeVectorPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("inputType", &self.inputType)
		.field("inputInterpretation", &self.inputInterpretation)
		.field("matrixInterpretation", &self.matrixInterpretation)
		.field("biasInterpretation", &self.biasInterpretation)
		.field("resultType", &self.resultType)
		.field("transpose", &self.transpose)
		.finish()
	}
}
/// struct `VkConvertCooperativeVectorMatrixInfoNV` from VK_NV_cooperative_vector
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkConvertCooperativeVectorMatrixInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkConvertCooperativeVectorMatrixInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub srcSize: usize,
	pub srcData: VkDeviceOrHostAddressConstKHR,
	pub pDstSize: *mut size_t,
	pub dstData: VkDeviceOrHostAddressKHR,
	pub srcComponentType: VkComponentTypeKHR,
	pub dstComponentType: VkComponentTypeKHR,
	pub numRows: u32,
	pub numColumns: u32,
	pub srcLayout: VkCooperativeVectorMatrixLayoutNV,
	pub srcStride: usize,
	pub dstLayout: VkCooperativeVectorMatrixLayoutNV,
	pub dstStride: usize,
}
impl Debug for VkConvertCooperativeVectorMatrixInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkConvertCooperativeVectorMatrixInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("srcSize", &self.srcSize)
		.field("srcData", &self.srcData)
		.field("pDstSize", &self.pDstSize)
		.field("dstData", &self.dstData)
		.field("srcComponentType", &self.srcComponentType)
		.field("dstComponentType", &self.dstComponentType)
		.field("numRows", &self.numRows)
		.field("numColumns", &self.numColumns)
		.field("srcLayout", &self.srcLayout)
		.field("srcStride", &self.srcStride)
		.field("dstLayout", &self.dstLayout)
		.field("dstStride", &self.dstStride)
		.finish()
	}
}
/// function prototype `PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV` from VK_NV_cooperative_vector
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeVectorPropertiesNV.html>
type PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeVectorPropertiesNV) -> VkResult;
/// function prototype `PFN_vkConvertCooperativeVectorMatrixNV` from VK_NV_cooperative_vector
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkConvertCooperativeVectorMatrixNV.html>
type PFN_vkConvertCooperativeVectorMatrixNV = extern "system" fn(device: VkDevice, pInfo: *const VkConvertCooperativeVectorMatrixInfoNV) -> VkResult;
/// function prototype `PFN_vkCmdConvertCooperativeVectorMatrixNV` from VK_NV_cooperative_vector
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdConvertCooperativeVectorMatrixNV.html>
type PFN_vkCmdConvertCooperativeVectorMatrixNV = extern "system" fn(commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *const VkConvertCooperativeVectorMatrixInfoNV);
/// The dummy function for `vkGetPhysicalDeviceCooperativeVectorPropertiesNV` from `VK_NV_cooperative_vector`
extern "system" fn dummy_vkGetPhysicalDeviceCooperativeVectorPropertiesNV(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkCooperativeVectorPropertiesNV) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceCooperativeVectorPropertiesNV"))
}
/// trait for `VK_NV_cooperative_vector`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_cooperative_vector.html>
pub trait VK_NV_cooperative_vector: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeVectorPropertiesNV.html>
	fn vkGetPhysicalDeviceCooperativeVectorPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeVectorPropertiesNV) -> Result<()>;
}
/// struct for `VK_NV_cooperative_vector`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_cooperative_vector {
	vk_get_physical_device_cooperative_vector_properties_nv: PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV,
}
impl VK_NV_cooperative_vector for Vulkan_NV_cooperative_vector {
	fn vkGetPhysicalDeviceCooperativeVectorPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeVectorPropertiesNV) -> Result<()> {
		convert_result("vkGetPhysicalDeviceCooperativeVectorPropertiesNV", catch_unwind(||((self.vk_get_physical_device_cooperative_vector_properties_nv)(physicalDevice, pPropertyCount, pProperties))))
	}
}
impl Default for Vulkan_NV_cooperative_vector {
	fn default() -> Self {
		Self {
			vk_get_physical_device_cooperative_vector_properties_nv: dummy_vkGetPhysicalDeviceCooperativeVectorPropertiesNV,
		}
	}
}
impl Vulkan_NV_cooperative_vector {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_cooperative_vector_properties_nv: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceCooperativeVectorPropertiesNV"); if proc == null() {dummy_vkGetPhysicalDeviceCooperativeVectorPropertiesNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV` from VK_NV_extended_sparse_address_space
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub extendedSparseAddressSpace: VkBool32,
}
impl Debug for VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("extendedSparseAddressSpace", &self.extendedSparseAddressSpace)
		.finish()
	}
}
/// struct `VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV` from VK_NV_extended_sparse_address_space
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub extendedSparseAddressSpaceSize: VkDeviceSize,
	pub extendedSparseImageUsageFlags: VkImageUsageFlags,
	pub extendedSparseBufferUsageFlags: VkBufferUsageFlags,
}
impl Debug for VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("extendedSparseAddressSpaceSize", &self.extendedSparseAddressSpaceSize)
		.field("extendedSparseImageUsageFlags", &self.extendedSparseImageUsageFlags)
		.field("extendedSparseBufferUsageFlags", &self.extendedSparseBufferUsageFlags)
		.finish()
	}
}
/// trait for `VK_NV_extended_sparse_address_space`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_extended_sparse_address_space.html>
pub trait VK_NV_extended_sparse_address_space: Debug {}
/// struct for `VK_NV_extended_sparse_address_space`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_extended_sparse_address_space {}
impl VK_NV_extended_sparse_address_space for Vulkan_NV_extended_sparse_address_space {}
impl Default for Vulkan_NV_extended_sparse_address_space {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_extended_sparse_address_space {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// trait for `VK_EXT_mutable_descriptor_type`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_mutable_descriptor_type.html>
pub trait VK_EXT_mutable_descriptor_type: Debug {}
/// struct for `VK_EXT_mutable_descriptor_type`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_mutable_descriptor_type {}
impl VK_EXT_mutable_descriptor_type for Vulkan_EXT_mutable_descriptor_type {}
impl Default for Vulkan_EXT_mutable_descriptor_type {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_mutable_descriptor_type {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT` from VK_EXT_legacy_vertex_attributes
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub legacyVertexAttributes: VkBool32,
}
impl Debug for VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("legacyVertexAttributes", &self.legacyVertexAttributes)
		.finish()
	}
}
/// struct `VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT` from VK_EXT_legacy_vertex_attributes
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub nativeUnalignedPerformance: VkBool32,
}
impl Debug for VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("nativeUnalignedPerformance", &self.nativeUnalignedPerformance)
		.finish()
	}
}
/// trait for `VK_EXT_legacy_vertex_attributes`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_legacy_vertex_attributes.html>
pub trait VK_EXT_legacy_vertex_attributes: Debug {}
/// struct for `VK_EXT_legacy_vertex_attributes`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_legacy_vertex_attributes {}
impl VK_EXT_legacy_vertex_attributes for Vulkan_EXT_legacy_vertex_attributes {}
impl Default for Vulkan_EXT_legacy_vertex_attributes {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_legacy_vertex_attributes {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkLayerSettingTypeEXT` from VK_EXT_layer_settings
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkLayerSettingTypeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkLayerSettingTypeEXT {
	VK_LAYER_SETTING_TYPE_BOOL32_EXT = 0,
	VK_LAYER_SETTING_TYPE_INT32_EXT = 1,
	VK_LAYER_SETTING_TYPE_INT64_EXT = 2,
	VK_LAYER_SETTING_TYPE_UINT32_EXT = 3,
	VK_LAYER_SETTING_TYPE_UINT64_EXT = 4,
	VK_LAYER_SETTING_TYPE_FLOAT32_EXT = 5,
	VK_LAYER_SETTING_TYPE_FLOAT64_EXT = 6,
	VK_LAYER_SETTING_TYPE_STRING_EXT = 7,
	VK_LAYER_SETTING_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
/// struct `VkLayerSettingEXT` from VK_EXT_layer_settings
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkLayerSettingEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkLayerSettingEXT {
	pub pLayerName: *const i8,
	pub pSettingName: *const i8,
	pub type_: VkLayerSettingTypeEXT,
	pub valueCount: u32,
	pub pValues: *const c_void,
}
impl Debug for VkLayerSettingEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkLayerSettingEXT")
		.field("pLayerName", &self.pLayerName)
		.field("pSettingName", &self.pSettingName)
		.field("type_", &self.type_)
		.field("valueCount", &self.valueCount)
		.field("pValues", &self.pValues)
		.finish()
	}
}
/// struct `VkLayerSettingsCreateInfoEXT` from VK_EXT_layer_settings
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkLayerSettingsCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkLayerSettingsCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub settingCount: u32,
	pub pSettings: *const VkLayerSettingEXT,
}
impl Debug for VkLayerSettingsCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkLayerSettingsCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("settingCount", &self.settingCount)
		.field("pSettings", &self.pSettings)
		.finish()
	}
}
/// trait for `VK_EXT_layer_settings`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_layer_settings.html>
pub trait VK_EXT_layer_settings: Debug {}
/// struct for `VK_EXT_layer_settings`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_layer_settings {}
impl VK_EXT_layer_settings for Vulkan_EXT_layer_settings {}
impl Default for Vulkan_EXT_layer_settings {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_layer_settings {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM` from VK_ARM_shader_core_builtins
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderCoreBuiltins: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderCoreBuiltins", &self.shaderCoreBuiltins)
		.finish()
	}
}
/// struct `VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM` from VK_ARM_shader_core_builtins
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderCoreMask: u64,
	pub shaderCoreCount: u32,
	pub shaderWarpsPerCore: u32,
}
impl Debug for VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderCoreMask", &self.shaderCoreMask)
		.field("shaderCoreCount", &self.shaderCoreCount)
		.field("shaderWarpsPerCore", &self.shaderWarpsPerCore)
		.finish()
	}
}
/// trait for `VK_ARM_shader_core_builtins`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_ARM_shader_core_builtins.html>
pub trait VK_ARM_shader_core_builtins: Debug {}
/// struct for `VK_ARM_shader_core_builtins`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_shader_core_builtins {}
impl VK_ARM_shader_core_builtins for Vulkan_ARM_shader_core_builtins {}
impl Default for Vulkan_ARM_shader_core_builtins {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_ARM_shader_core_builtins {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT` from VK_EXT_pipeline_library_group_handles
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineLibraryGroupHandles: VkBool32,
}
impl Debug for VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelineLibraryGroupHandles", &self.pipelineLibraryGroupHandles)
		.finish()
	}
}
/// trait for `VK_EXT_pipeline_library_group_handles`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_pipeline_library_group_handles.html>
pub trait VK_EXT_pipeline_library_group_handles: Debug {}
/// struct for `VK_EXT_pipeline_library_group_handles`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_pipeline_library_group_handles {}
impl VK_EXT_pipeline_library_group_handles for Vulkan_EXT_pipeline_library_group_handles {}
impl Default for Vulkan_EXT_pipeline_library_group_handles {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_pipeline_library_group_handles {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT` from VK_EXT_dynamic_rendering_unused_attachments
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub dynamicRenderingUnusedAttachments: VkBool32,
}
impl Debug for VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dynamicRenderingUnusedAttachments", &self.dynamicRenderingUnusedAttachments)
		.finish()
	}
}
/// trait for `VK_EXT_dynamic_rendering_unused_attachments`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_dynamic_rendering_unused_attachments.html>
pub trait VK_EXT_dynamic_rendering_unused_attachments: Debug {}
/// struct for `VK_EXT_dynamic_rendering_unused_attachments`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_dynamic_rendering_unused_attachments {}
impl VK_EXT_dynamic_rendering_unused_attachments for Vulkan_EXT_dynamic_rendering_unused_attachments {}
impl Default for Vulkan_EXT_dynamic_rendering_unused_attachments {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_dynamic_rendering_unused_attachments {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkLatencyMarkerNV` from VK_NV_low_latency2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkLatencyMarkerNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkLatencyMarkerNV {
	VK_LATENCY_MARKER_SIMULATION_START_NV = 0,
	VK_LATENCY_MARKER_SIMULATION_END_NV = 1,
	VK_LATENCY_MARKER_RENDERSUBMIT_START_NV = 2,
	VK_LATENCY_MARKER_RENDERSUBMIT_END_NV = 3,
	VK_LATENCY_MARKER_PRESENT_START_NV = 4,
	VK_LATENCY_MARKER_PRESENT_END_NV = 5,
	VK_LATENCY_MARKER_INPUT_SAMPLE_NV = 6,
	VK_LATENCY_MARKER_TRIGGER_FLASH_NV = 7,
	VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV = 8,
	VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV = 9,
	VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV = 10,
	VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV = 11,
	VK_LATENCY_MARKER_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkOutOfBandQueueTypeNV` from VK_NV_low_latency2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOutOfBandQueueTypeNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkOutOfBandQueueTypeNV {
	VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV = 0,
	VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV = 1,
	VK_OUT_OF_BAND_QUEUE_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
/// struct `VkLatencySleepModeInfoNV` from VK_NV_low_latency2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkLatencySleepModeInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkLatencySleepModeInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub lowLatencyMode: VkBool32,
	pub lowLatencyBoost: VkBool32,
	pub minimumIntervalUs: u32,
}
impl Debug for VkLatencySleepModeInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkLatencySleepModeInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("lowLatencyMode", &self.lowLatencyMode)
		.field("lowLatencyBoost", &self.lowLatencyBoost)
		.field("minimumIntervalUs", &self.minimumIntervalUs)
		.finish()
	}
}
/// struct `VkLatencySleepInfoNV` from VK_NV_low_latency2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkLatencySleepInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkLatencySleepInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub signalSemaphore: VkSemaphore,
	pub value: u64,
}
impl Debug for VkLatencySleepInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkLatencySleepInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("signalSemaphore", &self.signalSemaphore)
		.field("value", &self.value)
		.finish()
	}
}
/// struct `VkSetLatencyMarkerInfoNV` from VK_NV_low_latency2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSetLatencyMarkerInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSetLatencyMarkerInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub presentID: u64,
	pub marker: VkLatencyMarkerNV,
}
impl Debug for VkSetLatencyMarkerInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSetLatencyMarkerInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentID", &self.presentID)
		.field("marker", &self.marker)
		.finish()
	}
}
/// struct `VkLatencyTimingsFrameReportNV` from VK_NV_low_latency2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkLatencyTimingsFrameReportNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkLatencyTimingsFrameReportNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub presentID: u64,
	pub inputSampleTimeUs: u64,
	pub simStartTimeUs: u64,
	pub simEndTimeUs: u64,
	pub renderSubmitStartTimeUs: u64,
	pub renderSubmitEndTimeUs: u64,
	pub presentStartTimeUs: u64,
	pub presentEndTimeUs: u64,
	pub driverStartTimeUs: u64,
	pub driverEndTimeUs: u64,
	pub osRenderQueueStartTimeUs: u64,
	pub osRenderQueueEndTimeUs: u64,
	pub gpuRenderStartTimeUs: u64,
	pub gpuRenderEndTimeUs: u64,
}
impl Debug for VkLatencyTimingsFrameReportNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkLatencyTimingsFrameReportNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentID", &self.presentID)
		.field("inputSampleTimeUs", &self.inputSampleTimeUs)
		.field("simStartTimeUs", &self.simStartTimeUs)
		.field("simEndTimeUs", &self.simEndTimeUs)
		.field("renderSubmitStartTimeUs", &self.renderSubmitStartTimeUs)
		.field("renderSubmitEndTimeUs", &self.renderSubmitEndTimeUs)
		.field("presentStartTimeUs", &self.presentStartTimeUs)
		.field("presentEndTimeUs", &self.presentEndTimeUs)
		.field("driverStartTimeUs", &self.driverStartTimeUs)
		.field("driverEndTimeUs", &self.driverEndTimeUs)
		.field("osRenderQueueStartTimeUs", &self.osRenderQueueStartTimeUs)
		.field("osRenderQueueEndTimeUs", &self.osRenderQueueEndTimeUs)
		.field("gpuRenderStartTimeUs", &self.gpuRenderStartTimeUs)
		.field("gpuRenderEndTimeUs", &self.gpuRenderEndTimeUs)
		.finish()
	}
}
/// struct `VkGetLatencyMarkerInfoNV` from VK_NV_low_latency2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGetLatencyMarkerInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkGetLatencyMarkerInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub timingCount: u32,
	pub pTimings: *mut VkLatencyTimingsFrameReportNV,
}
impl Debug for VkGetLatencyMarkerInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkGetLatencyMarkerInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("timingCount", &self.timingCount)
		.field("pTimings", &self.pTimings)
		.finish()
	}
}
/// struct `VkLatencySubmissionPresentIdNV` from VK_NV_low_latency2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkLatencySubmissionPresentIdNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkLatencySubmissionPresentIdNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub presentID: u64,
}
impl Debug for VkLatencySubmissionPresentIdNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkLatencySubmissionPresentIdNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentID", &self.presentID)
		.finish()
	}
}
/// struct `VkSwapchainLatencyCreateInfoNV` from VK_NV_low_latency2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainLatencyCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSwapchainLatencyCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub latencyModeEnable: VkBool32,
}
impl Debug for VkSwapchainLatencyCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSwapchainLatencyCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("latencyModeEnable", &self.latencyModeEnable)
		.finish()
	}
}
/// struct `VkOutOfBandQueueTypeInfoNV` from VK_NV_low_latency2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkOutOfBandQueueTypeInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkOutOfBandQueueTypeInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub queueType: VkOutOfBandQueueTypeNV,
}
impl Debug for VkOutOfBandQueueTypeInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkOutOfBandQueueTypeInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("queueType", &self.queueType)
		.finish()
	}
}
/// struct `VkLatencySurfaceCapabilitiesNV` from VK_NV_low_latency2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkLatencySurfaceCapabilitiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkLatencySurfaceCapabilitiesNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub presentModeCount: u32,
	pub pPresentModes: *mut VkPresentModeKHR,
}
impl Debug for VkLatencySurfaceCapabilitiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkLatencySurfaceCapabilitiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentModeCount", &self.presentModeCount)
		.field("pPresentModes", &self.pPresentModes)
		.finish()
	}
}
/// function prototype `PFN_vkSetLatencySleepModeNV` from VK_NV_low_latency2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetLatencySleepModeNV.html>
type PFN_vkSetLatencySleepModeNV = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pSleepModeInfo: *const VkLatencySleepModeInfoNV) -> VkResult;
/// function prototype `PFN_vkLatencySleepNV` from VK_NV_low_latency2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkLatencySleepNV.html>
type PFN_vkLatencySleepNV = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pSleepInfo: *const VkLatencySleepInfoNV) -> VkResult;
/// function prototype `PFN_vkSetLatencyMarkerNV` from VK_NV_low_latency2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetLatencyMarkerNV.html>
type PFN_vkSetLatencyMarkerNV = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pLatencyMarkerInfo: *const VkSetLatencyMarkerInfoNV);
/// function prototype `PFN_vkGetLatencyTimingsNV` from VK_NV_low_latency2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetLatencyTimingsNV.html>
type PFN_vkGetLatencyTimingsNV = extern "system" fn(device: VkDevice, swapchain: VkSwapchainKHR, pLatencyMarkerInfo: *mut VkGetLatencyMarkerInfoNV);
/// function prototype `PFN_vkQueueNotifyOutOfBandNV` from VK_NV_low_latency2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueNotifyOutOfBandNV.html>
type PFN_vkQueueNotifyOutOfBandNV = extern "system" fn(queue: VkQueue, pQueueTypeInfo: *const VkOutOfBandQueueTypeInfoNV);
/// The dummy function for `vkSetLatencySleepModeNV` from `VK_NV_low_latency2`
extern "system" fn dummy_vkSetLatencySleepModeNV(_: VkDevice, _: VkSwapchainKHR, _: *const VkLatencySleepModeInfoNV) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkSetLatencySleepModeNV"))
}
/// trait for `VK_NV_low_latency2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_low_latency2.html>
pub trait VK_NV_low_latency2: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetLatencySleepModeNV.html>
	fn vkSetLatencySleepModeNV(&self, device: VkDevice, swapchain: VkSwapchainKHR, pSleepModeInfo: *const VkLatencySleepModeInfoNV) -> Result<()>;
}
/// struct for `VK_NV_low_latency2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_low_latency2 {
	vk_set_latency_sleep_mode_nv: PFN_vkSetLatencySleepModeNV,
}
impl VK_NV_low_latency2 for Vulkan_NV_low_latency2 {
	fn vkSetLatencySleepModeNV(&self, device: VkDevice, swapchain: VkSwapchainKHR, pSleepModeInfo: *const VkLatencySleepModeInfoNV) -> Result<()> {
		convert_result("vkSetLatencySleepModeNV", catch_unwind(||((self.vk_set_latency_sleep_mode_nv)(device, swapchain, pSleepModeInfo))))
	}
}
impl Default for Vulkan_NV_low_latency2 {
	fn default() -> Self {
		Self {
			vk_set_latency_sleep_mode_nv: dummy_vkSetLatencySleepModeNV,
		}
	}
}
impl Vulkan_NV_low_latency2 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_set_latency_sleep_mode_nv: {let proc = get_instance_proc_address(instance, "vkSetLatencySleepModeNV"); if proc == null() {dummy_vkSetLatencySleepModeNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// constant `VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM.html>
pub const VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM: u32 = 128u32;
/// type definition `VkDataGraphPipelineSessionCreateFlagsARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineSessionCreateFlagsARM.html>
pub type VkDataGraphPipelineSessionCreateFlagsARM = VkFlags64;
/// type definition `VkDataGraphPipelineSessionCreateFlagBitsARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineSessionCreateFlagBitsARM.html>
pub type VkDataGraphPipelineSessionCreateFlagBitsARM = VkFlags64;
/// type definition `VkDataGraphPipelineDispatchFlagsARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineDispatchFlagsARM.html>
pub type VkDataGraphPipelineDispatchFlagsARM = VkFlags64;
/// type definition `VkDataGraphPipelineDispatchFlagBitsARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineDispatchFlagBitsARM.html>
pub type VkDataGraphPipelineDispatchFlagBitsARM = VkFlags64;
/// Non-dispatchable handle `VkDataGraphPipelineSessionARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineSessionARM.html
#[cfg(target_pointer_width = "32")] pub type VkDataGraphPipelineSessionARM = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkDataGraphPipelineSessionARM_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkDataGraphPipelineSessionARM = *const VkDataGraphPipelineSessionARM_T;
/// enum `VkDataGraphPipelineSessionBindPointARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineSessionBindPointARM.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDataGraphPipelineSessionBindPointARM {
	VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM = 0,
	VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_MAX_ENUM_ARM = 0x7fffffff,
}
/// enum `VkDataGraphPipelineSessionBindPointTypeARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineSessionBindPointTypeARM.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDataGraphPipelineSessionBindPointTypeARM {
	VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM = 0,
	VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MAX_ENUM_ARM = 0x7fffffff,
}
/// enum `VkDataGraphPipelinePropertyARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelinePropertyARM.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDataGraphPipelinePropertyARM {
	VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM = 0,
	VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM = 1,
	VK_DATA_GRAPH_PIPELINE_PROPERTY_MAX_ENUM_ARM = 0x7fffffff,
}
/// enum `VkPhysicalDeviceDataGraphProcessingEngineTypeARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDataGraphProcessingEngineTypeARM.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPhysicalDeviceDataGraphProcessingEngineTypeARM {
	VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM = 0,
	VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_MAX_ENUM_ARM = 0x7fffffff,
}
/// enum `VkPhysicalDeviceDataGraphOperationTypeARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDataGraphOperationTypeARM.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPhysicalDeviceDataGraphOperationTypeARM {
	VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM = 0,
	VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_MAX_ENUM_ARM = 0x7fffffff,
}
/// struct `VkPhysicalDeviceDataGraphFeaturesARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDataGraphFeaturesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDataGraphFeaturesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub dataGraph: VkBool32,
	pub dataGraphUpdateAfterBind: VkBool32,
	pub dataGraphSpecializationConstants: VkBool32,
	pub dataGraphDescriptorBuffer: VkBool32,
	pub dataGraphShaderModule: VkBool32,
}
impl Debug for VkPhysicalDeviceDataGraphFeaturesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDataGraphFeaturesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dataGraph", &self.dataGraph)
		.field("dataGraphUpdateAfterBind", &self.dataGraphUpdateAfterBind)
		.field("dataGraphSpecializationConstants", &self.dataGraphSpecializationConstants)
		.field("dataGraphDescriptorBuffer", &self.dataGraphDescriptorBuffer)
		.field("dataGraphShaderModule", &self.dataGraphShaderModule)
		.finish()
	}
}
/// struct `VkDataGraphPipelineConstantARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineConstantARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDataGraphPipelineConstantARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub id: u32,
	pub pConstantData: *const c_void,
}
impl Debug for VkDataGraphPipelineConstantARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDataGraphPipelineConstantARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("id", &self.id)
		.field("pConstantData", &self.pConstantData)
		.finish()
	}
}
/// struct `VkDataGraphPipelineResourceInfoARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineResourceInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDataGraphPipelineResourceInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub descriptorSet: u32,
	pub binding: u32,
	pub arrayElement: u32,
}
impl Debug for VkDataGraphPipelineResourceInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDataGraphPipelineResourceInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("descriptorSet", &self.descriptorSet)
		.field("binding", &self.binding)
		.field("arrayElement", &self.arrayElement)
		.finish()
	}
}
/// struct `VkDataGraphPipelineCompilerControlCreateInfoARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineCompilerControlCreateInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDataGraphPipelineCompilerControlCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pVendorOptions: *const i8,
}
impl Debug for VkDataGraphPipelineCompilerControlCreateInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDataGraphPipelineCompilerControlCreateInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pVendorOptions", &self.pVendorOptions)
		.finish()
	}
}
/// struct `VkDataGraphPipelineCreateInfoARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineCreateInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDataGraphPipelineCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCreateFlags2KHR,
	pub layout: VkPipelineLayout,
	pub resourceInfoCount: u32,
	pub pResourceInfos: *const VkDataGraphPipelineResourceInfoARM,
}
impl Debug for VkDataGraphPipelineCreateInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDataGraphPipelineCreateInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("layout", &self.layout)
		.field("resourceInfoCount", &self.resourceInfoCount)
		.field("pResourceInfos", &self.pResourceInfos)
		.finish()
	}
}
/// struct `VkDataGraphPipelineShaderModuleCreateInfoARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineShaderModuleCreateInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDataGraphPipelineShaderModuleCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub module: VkShaderModule,
	pub pName: *const i8,
	pub pSpecializationInfo: *const VkSpecializationInfo,
	pub constantCount: u32,
	pub pConstants: *const VkDataGraphPipelineConstantARM,
}
impl Debug for VkDataGraphPipelineShaderModuleCreateInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDataGraphPipelineShaderModuleCreateInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("module", &self.module)
		.field("pName", &self.pName)
		.field("pSpecializationInfo", &self.pSpecializationInfo)
		.field("constantCount", &self.constantCount)
		.field("pConstants", &self.pConstants)
		.finish()
	}
}
/// struct `VkDataGraphPipelineSessionCreateInfoARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineSessionCreateInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDataGraphPipelineSessionCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkDataGraphPipelineSessionCreateFlagsARM,
	pub dataGraphPipeline: VkPipeline,
}
impl Debug for VkDataGraphPipelineSessionCreateInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDataGraphPipelineSessionCreateInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("dataGraphPipeline", &self.dataGraphPipeline)
		.finish()
	}
}
/// struct `VkDataGraphPipelineSessionBindPointRequirementsInfoARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineSessionBindPointRequirementsInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDataGraphPipelineSessionBindPointRequirementsInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub session: VkDataGraphPipelineSessionARM,
}
impl Debug for VkDataGraphPipelineSessionBindPointRequirementsInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDataGraphPipelineSessionBindPointRequirementsInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("session", &self.session)
		.finish()
	}
}
/// struct `VkDataGraphPipelineSessionBindPointRequirementARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineSessionBindPointRequirementARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDataGraphPipelineSessionBindPointRequirementARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub bindPoint: VkDataGraphPipelineSessionBindPointARM,
	pub bindPointType: VkDataGraphPipelineSessionBindPointTypeARM,
	pub numObjects: u32,
}
impl Debug for VkDataGraphPipelineSessionBindPointRequirementARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDataGraphPipelineSessionBindPointRequirementARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("bindPoint", &self.bindPoint)
		.field("bindPointType", &self.bindPointType)
		.field("numObjects", &self.numObjects)
		.finish()
	}
}
/// struct `VkDataGraphPipelineSessionMemoryRequirementsInfoARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineSessionMemoryRequirementsInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDataGraphPipelineSessionMemoryRequirementsInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub session: VkDataGraphPipelineSessionARM,
	pub bindPoint: VkDataGraphPipelineSessionBindPointARM,
	pub objectIndex: u32,
}
impl Debug for VkDataGraphPipelineSessionMemoryRequirementsInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDataGraphPipelineSessionMemoryRequirementsInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("session", &self.session)
		.field("bindPoint", &self.bindPoint)
		.field("objectIndex", &self.objectIndex)
		.finish()
	}
}
/// struct `VkBindDataGraphPipelineSessionMemoryInfoARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindDataGraphPipelineSessionMemoryInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindDataGraphPipelineSessionMemoryInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub session: VkDataGraphPipelineSessionARM,
	pub bindPoint: VkDataGraphPipelineSessionBindPointARM,
	pub objectIndex: u32,
	pub memory: VkDeviceMemory,
	pub memoryOffset: VkDeviceSize,
}
impl Debug for VkBindDataGraphPipelineSessionMemoryInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindDataGraphPipelineSessionMemoryInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("session", &self.session)
		.field("bindPoint", &self.bindPoint)
		.field("objectIndex", &self.objectIndex)
		.field("memory", &self.memory)
		.field("memoryOffset", &self.memoryOffset)
		.finish()
	}
}
/// struct `VkDataGraphPipelineInfoARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDataGraphPipelineInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dataGraphPipeline: VkPipeline,
}
impl Debug for VkDataGraphPipelineInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDataGraphPipelineInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dataGraphPipeline", &self.dataGraphPipeline)
		.finish()
	}
}
/// struct `VkDataGraphPipelinePropertyQueryResultARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelinePropertyQueryResultARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDataGraphPipelinePropertyQueryResultARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub property: VkDataGraphPipelinePropertyARM,
	pub isText: VkBool32,
	pub dataSize: usize,
	pub pData: *mut c_void,
}
impl Debug for VkDataGraphPipelinePropertyQueryResultARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDataGraphPipelinePropertyQueryResultARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("property", &self.property)
		.field("isText", &self.isText)
		.field("dataSize", &self.dataSize)
		.field("pData", &self.pData)
		.finish()
	}
}
/// struct `VkDataGraphPipelineIdentifierCreateInfoARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineIdentifierCreateInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDataGraphPipelineIdentifierCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub identifierSize: u32,
	pub pIdentifier: *const uint8_t,
}
impl Debug for VkDataGraphPipelineIdentifierCreateInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDataGraphPipelineIdentifierCreateInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("identifierSize", &self.identifierSize)
		.field("pIdentifier", &self.pIdentifier)
		.finish()
	}
}
/// struct `VkDataGraphPipelineDispatchInfoARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineDispatchInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDataGraphPipelineDispatchInfoARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkDataGraphPipelineDispatchFlagsARM,
}
impl Debug for VkDataGraphPipelineDispatchInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDataGraphPipelineDispatchInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.finish()
	}
}
/// struct `VkPhysicalDeviceDataGraphProcessingEngineARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDataGraphProcessingEngineARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDataGraphProcessingEngineARM {
	pub type_: VkPhysicalDeviceDataGraphProcessingEngineTypeARM,
	pub isForeign: VkBool32,
}
impl Debug for VkPhysicalDeviceDataGraphProcessingEngineARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDataGraphProcessingEngineARM")
		.field("type_", &self.type_)
		.field("isForeign", &self.isForeign)
		.finish()
	}
}
/// struct `VkPhysicalDeviceDataGraphOperationSupportARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDataGraphOperationSupportARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDataGraphOperationSupportARM {
	pub operationType: VkPhysicalDeviceDataGraphOperationTypeARM,
	pub name: [i8; VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM as usize],
	pub version: u32,
}
impl Debug for VkPhysicalDeviceDataGraphOperationSupportARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDataGraphOperationSupportARM")
		.field("operationType", &self.operationType)
		.field("name", &format_args!("{}", maybe_string(&self.name)))
		.field("version", &self.version)
		.finish()
	}
}
/// struct `VkQueueFamilyDataGraphPropertiesARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueFamilyDataGraphPropertiesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkQueueFamilyDataGraphPropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub engine: VkPhysicalDeviceDataGraphProcessingEngineARM,
	pub operation: VkPhysicalDeviceDataGraphOperationSupportARM,
}
impl Debug for VkQueueFamilyDataGraphPropertiesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkQueueFamilyDataGraphPropertiesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("engine", &self.engine)
		.field("operation", &self.operation)
		.finish()
	}
}
/// struct `VkDataGraphProcessingEngineCreateInfoARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphProcessingEngineCreateInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDataGraphProcessingEngineCreateInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub processingEngineCount: u32,
	pub pProcessingEngines: *mut VkPhysicalDeviceDataGraphProcessingEngineARM,
}
impl Debug for VkDataGraphProcessingEngineCreateInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDataGraphProcessingEngineCreateInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("processingEngineCount", &self.processingEngineCount)
		.field("pProcessingEngines", &self.pProcessingEngines)
		.finish()
	}
}
/// struct `VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub queueFamilyIndex: u32,
	pub engineType: VkPhysicalDeviceDataGraphProcessingEngineTypeARM,
}
impl Debug for VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("queueFamilyIndex", &self.queueFamilyIndex)
		.field("engineType", &self.engineType)
		.finish()
	}
}
/// struct `VkQueueFamilyDataGraphProcessingEnginePropertiesARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueueFamilyDataGraphProcessingEnginePropertiesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkQueueFamilyDataGraphProcessingEnginePropertiesARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub foreignSemaphoreHandleTypes: VkExternalSemaphoreHandleTypeFlags,
	pub foreignMemoryHandleTypes: VkExternalMemoryHandleTypeFlags,
}
impl Debug for VkQueueFamilyDataGraphProcessingEnginePropertiesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkQueueFamilyDataGraphProcessingEnginePropertiesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("foreignSemaphoreHandleTypes", &self.foreignSemaphoreHandleTypes)
		.field("foreignMemoryHandleTypes", &self.foreignMemoryHandleTypes)
		.finish()
	}
}
/// struct `VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dimension: u32,
	pub zeroCount: u32,
	pub groupSize: u32,
}
impl Debug for VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dimension", &self.dimension)
		.field("zeroCount", &self.zeroCount)
		.field("groupSize", &self.groupSize)
		.finish()
	}
}
/// function prototype `PFN_vkCreateDataGraphPipelinesARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDataGraphPipelinesARM.html>
type PFN_vkCreateDataGraphPipelinesARM = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkDataGraphPipelineCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult;
/// function prototype `PFN_vkCreateDataGraphPipelineSessionARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDataGraphPipelineSessionARM.html>
type PFN_vkCreateDataGraphPipelineSessionARM = extern "system" fn(device: VkDevice, pCreateInfo: *const VkDataGraphPipelineSessionCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pSession: *mut VkDataGraphPipelineSessionARM) -> VkResult;
/// function prototype `PFN_vkGetDataGraphPipelineSessionBindPointRequirementsARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDataGraphPipelineSessionBindPointRequirementsARM.html>
type PFN_vkGetDataGraphPipelineSessionBindPointRequirementsARM = extern "system" fn(device: VkDevice, pInfo: *const VkDataGraphPipelineSessionBindPointRequirementsInfoARM, pBindPointRequirementCount: *mut uint32_t, pBindPointRequirements: *mut VkDataGraphPipelineSessionBindPointRequirementARM) -> VkResult;
/// function prototype `PFN_vkGetDataGraphPipelineSessionMemoryRequirementsARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDataGraphPipelineSessionMemoryRequirementsARM.html>
type PFN_vkGetDataGraphPipelineSessionMemoryRequirementsARM = extern "system" fn(device: VkDevice, pInfo: *const VkDataGraphPipelineSessionMemoryRequirementsInfoARM, pMemoryRequirements: *mut VkMemoryRequirements2);
/// function prototype `PFN_vkBindDataGraphPipelineSessionMemoryARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindDataGraphPipelineSessionMemoryARM.html>
type PFN_vkBindDataGraphPipelineSessionMemoryARM = extern "system" fn(device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindDataGraphPipelineSessionMemoryInfoARM) -> VkResult;
/// function prototype `PFN_vkDestroyDataGraphPipelineSessionARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDataGraphPipelineSessionARM.html>
type PFN_vkDestroyDataGraphPipelineSessionARM = extern "system" fn(device: VkDevice, session: VkDataGraphPipelineSessionARM, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCmdDispatchDataGraphARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchDataGraphARM.html>
type PFN_vkCmdDispatchDataGraphARM = extern "system" fn(commandBuffer: VkCommandBuffer, session: VkDataGraphPipelineSessionARM, pInfo: *const VkDataGraphPipelineDispatchInfoARM);
/// function prototype `PFN_vkGetDataGraphPipelineAvailablePropertiesARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDataGraphPipelineAvailablePropertiesARM.html>
type PFN_vkGetDataGraphPipelineAvailablePropertiesARM = extern "system" fn(device: VkDevice, pPipelineInfo: *const VkDataGraphPipelineInfoARM, pPropertiesCount: *mut uint32_t, pProperties: *mut VkDataGraphPipelinePropertyARM) -> VkResult;
/// function prototype `PFN_vkGetDataGraphPipelinePropertiesARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDataGraphPipelinePropertiesARM.html>
type PFN_vkGetDataGraphPipelinePropertiesARM = extern "system" fn(device: VkDevice, pPipelineInfo: *const VkDataGraphPipelineInfoARM, propertiesCount: u32, pProperties: *mut VkDataGraphPipelinePropertyQueryResultARM) -> VkResult;
/// function prototype `PFN_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM.html>
type PFN_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM = extern "system" fn(physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, pQueueFamilyDataGraphPropertyCount: *mut uint32_t, pQueueFamilyDataGraphProperties: *mut VkQueueFamilyDataGraphPropertiesARM) -> VkResult;
/// function prototype `PFN_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM` from VK_ARM_data_graph
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM.html>
type PFN_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM = extern "system" fn(physicalDevice: VkPhysicalDevice, pQueueFamilyDataGraphProcessingEngineInfo: *const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM, pQueueFamilyDataGraphProcessingEngineProperties: *mut VkQueueFamilyDataGraphProcessingEnginePropertiesARM);
/// The dummy function for `vkCreateDataGraphPipelinesARM` from `VK_ARM_data_graph`
extern "system" fn dummy_vkCreateDataGraphPipelinesARM(_: VkDevice, _: VkDeferredOperationKHR, _: VkPipelineCache, _: u32, _: *const VkDataGraphPipelineCreateInfoARM, _: *const VkAllocationCallbacks, _: *mut VkPipeline) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateDataGraphPipelinesARM"))
}
/// trait for `VK_ARM_data_graph`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_ARM_data_graph.html>
pub trait VK_ARM_data_graph: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDataGraphPipelinesARM.html>
	fn vkCreateDataGraphPipelinesARM(&self, device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkDataGraphPipelineCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> Result<()>;
}
/// struct for `VK_ARM_data_graph`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_data_graph {
	vk_create_data_graph_pipelines_arm: PFN_vkCreateDataGraphPipelinesARM,
}
impl VK_ARM_data_graph for Vulkan_ARM_data_graph {
	fn vkCreateDataGraphPipelinesARM(&self, device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkDataGraphPipelineCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> Result<()> {
		convert_result("vkCreateDataGraphPipelinesARM", catch_unwind(||((self.vk_create_data_graph_pipelines_arm)(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines))))
	}
}
impl Default for Vulkan_ARM_data_graph {
	fn default() -> Self {
		Self {
			vk_create_data_graph_pipelines_arm: dummy_vkCreateDataGraphPipelinesARM,
		}
	}
}
impl Vulkan_ARM_data_graph {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_data_graph_pipelines_arm: {let proc = get_instance_proc_address(instance, "vkCreateDataGraphPipelinesARM"); if proc == null() {dummy_vkCreateDataGraphPipelinesARM} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM` from VK_QCOM_multiview_per_view_render_areas
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub multiviewPerViewRenderAreas: VkBool32,
}
impl Debug for VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("multiviewPerViewRenderAreas", &self.multiviewPerViewRenderAreas)
		.finish()
	}
}
/// struct `VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM` from VK_QCOM_multiview_per_view_render_areas
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub perViewRenderAreaCount: u32,
	pub pPerViewRenderAreas: *const VkRect2D,
}
impl Debug for VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("perViewRenderAreaCount", &self.perViewRenderAreaCount)
		.field("pPerViewRenderAreas", &self.pPerViewRenderAreas)
		.finish()
	}
}
/// trait for `VK_QCOM_multiview_per_view_render_areas`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QCOM_multiview_per_view_render_areas.html>
pub trait VK_QCOM_multiview_per_view_render_areas: Debug {}
/// struct for `VK_QCOM_multiview_per_view_render_areas`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_multiview_per_view_render_areas {}
impl VK_QCOM_multiview_per_view_render_areas for Vulkan_QCOM_multiview_per_view_render_areas {}
impl Default for Vulkan_QCOM_multiview_per_view_render_areas {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_multiview_per_view_render_areas {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDevicePerStageDescriptorSetFeaturesNV` from VK_NV_per_stage_descriptor_set
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePerStageDescriptorSetFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePerStageDescriptorSetFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub perStageDescriptorSet: VkBool32,
	pub dynamicPipelineLayout: VkBool32,
}
impl Debug for VkPhysicalDevicePerStageDescriptorSetFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePerStageDescriptorSetFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("perStageDescriptorSet", &self.perStageDescriptorSet)
		.field("dynamicPipelineLayout", &self.dynamicPipelineLayout)
		.finish()
	}
}
/// trait for `VK_NV_per_stage_descriptor_set`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_per_stage_descriptor_set.html>
pub trait VK_NV_per_stage_descriptor_set: Debug {}
/// struct for `VK_NV_per_stage_descriptor_set`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_per_stage_descriptor_set {}
impl VK_NV_per_stage_descriptor_set for Vulkan_NV_per_stage_descriptor_set {}
impl Default for Vulkan_NV_per_stage_descriptor_set {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_per_stage_descriptor_set {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkBlockMatchWindowCompareModeQCOM` from VK_QCOM_image_processing2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBlockMatchWindowCompareModeQCOM.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBlockMatchWindowCompareModeQCOM {
	VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM = 0,
	VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM = 1,
	VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_ENUM_QCOM = 0x7fffffff,
}
/// struct `VkPhysicalDeviceImageProcessing2FeaturesQCOM` from VK_QCOM_image_processing2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImageProcessing2FeaturesQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceImageProcessing2FeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub textureBlockMatch2: VkBool32,
}
impl Debug for VkPhysicalDeviceImageProcessing2FeaturesQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceImageProcessing2FeaturesQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("textureBlockMatch2", &self.textureBlockMatch2)
		.finish()
	}
}
/// struct `VkPhysicalDeviceImageProcessing2PropertiesQCOM` from VK_QCOM_image_processing2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImageProcessing2PropertiesQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceImageProcessing2PropertiesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxBlockMatchWindow: VkExtent2D,
}
impl Debug for VkPhysicalDeviceImageProcessing2PropertiesQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceImageProcessing2PropertiesQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxBlockMatchWindow", &self.maxBlockMatchWindow)
		.finish()
	}
}
/// struct `VkSamplerBlockMatchWindowCreateInfoQCOM` from VK_QCOM_image_processing2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerBlockMatchWindowCreateInfoQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSamplerBlockMatchWindowCreateInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub windowExtent: VkExtent2D,
	pub windowCompareMode: VkBlockMatchWindowCompareModeQCOM,
}
impl Debug for VkSamplerBlockMatchWindowCreateInfoQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSamplerBlockMatchWindowCreateInfoQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("windowExtent", &self.windowExtent)
		.field("windowCompareMode", &self.windowCompareMode)
		.finish()
	}
}
/// trait for `VK_QCOM_image_processing2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QCOM_image_processing2.html>
pub trait VK_QCOM_image_processing2: Debug {}
/// struct for `VK_QCOM_image_processing2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_image_processing2 {}
impl VK_QCOM_image_processing2 for Vulkan_QCOM_image_processing2 {}
impl Default for Vulkan_QCOM_image_processing2 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_image_processing2 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// enum `VkCubicFilterWeightsQCOM` from VK_QCOM_filter_cubic_weights
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCubicFilterWeightsQCOM.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkCubicFilterWeightsQCOM {
	VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM = 0,
	VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM = 1,
	VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM = 2,
	VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM = 3,
	VK_CUBIC_FILTER_WEIGHTS_MAX_ENUM_QCOM = 0x7fffffff,
}
/// struct `VkPhysicalDeviceCubicWeightsFeaturesQCOM` from VK_QCOM_filter_cubic_weights
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCubicWeightsFeaturesQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCubicWeightsFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub selectableCubicWeights: VkBool32,
}
impl Debug for VkPhysicalDeviceCubicWeightsFeaturesQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCubicWeightsFeaturesQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("selectableCubicWeights", &self.selectableCubicWeights)
		.finish()
	}
}
/// struct `VkSamplerCubicWeightsCreateInfoQCOM` from VK_QCOM_filter_cubic_weights
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerCubicWeightsCreateInfoQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSamplerCubicWeightsCreateInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub cubicWeights: VkCubicFilterWeightsQCOM,
}
impl Debug for VkSamplerCubicWeightsCreateInfoQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSamplerCubicWeightsCreateInfoQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("cubicWeights", &self.cubicWeights)
		.finish()
	}
}
/// struct `VkBlitImageCubicWeightsInfoQCOM` from VK_QCOM_filter_cubic_weights
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBlitImageCubicWeightsInfoQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBlitImageCubicWeightsInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub cubicWeights: VkCubicFilterWeightsQCOM,
}
impl Debug for VkBlitImageCubicWeightsInfoQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBlitImageCubicWeightsInfoQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("cubicWeights", &self.cubicWeights)
		.finish()
	}
}
/// trait for `VK_QCOM_filter_cubic_weights`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QCOM_filter_cubic_weights.html>
pub trait VK_QCOM_filter_cubic_weights: Debug {}
/// struct for `VK_QCOM_filter_cubic_weights`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_filter_cubic_weights {}
impl VK_QCOM_filter_cubic_weights for Vulkan_QCOM_filter_cubic_weights {}
impl Default for Vulkan_QCOM_filter_cubic_weights {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_filter_cubic_weights {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceYcbcrDegammaFeaturesQCOM` from VK_QCOM_ycbcr_degamma
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceYcbcrDegammaFeaturesQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceYcbcrDegammaFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub ycbcrDegamma: VkBool32,
}
impl Debug for VkPhysicalDeviceYcbcrDegammaFeaturesQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceYcbcrDegammaFeaturesQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("ycbcrDegamma", &self.ycbcrDegamma)
		.finish()
	}
}
/// struct `VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM` from VK_QCOM_ycbcr_degamma
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub enableYDegamma: VkBool32,
	pub enableCbCrDegamma: VkBool32,
}
impl Debug for VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("enableYDegamma", &self.enableYDegamma)
		.field("enableCbCrDegamma", &self.enableCbCrDegamma)
		.finish()
	}
}
/// trait for `VK_QCOM_ycbcr_degamma`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QCOM_ycbcr_degamma.html>
pub trait VK_QCOM_ycbcr_degamma: Debug {}
/// struct for `VK_QCOM_ycbcr_degamma`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_ycbcr_degamma {}
impl VK_QCOM_ycbcr_degamma for Vulkan_QCOM_ycbcr_degamma {}
impl Default for Vulkan_QCOM_ycbcr_degamma {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_ycbcr_degamma {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceCubicClampFeaturesQCOM` from VK_QCOM_filter_cubic_clamp
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCubicClampFeaturesQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCubicClampFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cubicRangeClamp: VkBool32,
}
impl Debug for VkPhysicalDeviceCubicClampFeaturesQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCubicClampFeaturesQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("cubicRangeClamp", &self.cubicRangeClamp)
		.finish()
	}
}
/// trait for `VK_QCOM_filter_cubic_clamp`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QCOM_filter_cubic_clamp.html>
pub trait VK_QCOM_filter_cubic_clamp: Debug {}
/// struct for `VK_QCOM_filter_cubic_clamp`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_filter_cubic_clamp {}
impl VK_QCOM_filter_cubic_clamp for Vulkan_QCOM_filter_cubic_clamp {}
impl Default for Vulkan_QCOM_filter_cubic_clamp {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_QCOM_filter_cubic_clamp {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT` from VK_EXT_attachment_feedback_loop_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub attachmentFeedbackLoopDynamicState: VkBool32,
}
impl Debug for VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("attachmentFeedbackLoopDynamicState", &self.attachmentFeedbackLoopDynamicState)
		.finish()
	}
}
/// function prototype `PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT` from VK_EXT_attachment_feedback_loop_dynamic_state
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetAttachmentFeedbackLoopEnableEXT.html>
type PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT = extern "system" fn(commandBuffer: VkCommandBuffer, aspectMask: VkImageAspectFlags);
/// The dummy function for `vkCmdSetAttachmentFeedbackLoopEnableEXT` from `VK_EXT_attachment_feedback_loop_dynamic_state`
extern "system" fn dummy_vkCmdSetAttachmentFeedbackLoopEnableEXT(_: VkCommandBuffer, _: VkImageAspectFlags) {
	panic_any(VkError::NullFunctionPointer("vkCmdSetAttachmentFeedbackLoopEnableEXT"))
}
/// trait for `VK_EXT_attachment_feedback_loop_dynamic_state`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_attachment_feedback_loop_dynamic_state.html>
pub trait VK_EXT_attachment_feedback_loop_dynamic_state: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetAttachmentFeedbackLoopEnableEXT.html>
	fn vkCmdSetAttachmentFeedbackLoopEnableEXT(&self, commandBuffer: VkCommandBuffer, aspectMask: VkImageAspectFlags) -> Result<()>;
}
/// struct for `VK_EXT_attachment_feedback_loop_dynamic_state`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_attachment_feedback_loop_dynamic_state {
	vk_cmd_set_attachment_feedback_loop_enable_ext: PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT,
}
impl VK_EXT_attachment_feedback_loop_dynamic_state for Vulkan_EXT_attachment_feedback_loop_dynamic_state {
	fn vkCmdSetAttachmentFeedbackLoopEnableEXT(&self, commandBuffer: VkCommandBuffer, aspectMask: VkImageAspectFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_set_attachment_feedback_loop_enable_ext)(commandBuffer, aspectMask))))
	}
}
impl Default for Vulkan_EXT_attachment_feedback_loop_dynamic_state {
	fn default() -> Self {
		Self {
			vk_cmd_set_attachment_feedback_loop_enable_ext: dummy_vkCmdSetAttachmentFeedbackLoopEnableEXT,
		}
	}
}
impl Vulkan_EXT_attachment_feedback_loop_dynamic_state {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_set_attachment_feedback_loop_enable_ext: {let proc = get_instance_proc_address(instance, "vkCmdSetAttachmentFeedbackLoopEnableEXT"); if proc == null() {dummy_vkCmdSetAttachmentFeedbackLoopEnableEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// enum `VkLayeredDriverUnderlyingApiMSFT` from VK_MSFT_layered_driver
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkLayeredDriverUnderlyingApiMSFT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkLayeredDriverUnderlyingApiMSFT {
	VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT = 0,
	VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT = 1,
	VK_LAYERED_DRIVER_UNDERLYING_API_MAX_ENUM_MSFT = 0x7fffffff,
}
/// struct `VkPhysicalDeviceLayeredDriverPropertiesMSFT` from VK_MSFT_layered_driver
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceLayeredDriverPropertiesMSFT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceLayeredDriverPropertiesMSFT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub underlyingAPI: VkLayeredDriverUnderlyingApiMSFT,
}
impl Debug for VkPhysicalDeviceLayeredDriverPropertiesMSFT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceLayeredDriverPropertiesMSFT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("underlyingAPI", &self.underlyingAPI)
		.finish()
	}
}
/// trait for `VK_MSFT_layered_driver`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MSFT_layered_driver.html>
pub trait VK_MSFT_layered_driver: Debug {}
/// struct for `VK_MSFT_layered_driver`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_MSFT_layered_driver {}
impl VK_MSFT_layered_driver for Vulkan_MSFT_layered_driver {}
impl Default for Vulkan_MSFT_layered_driver {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_MSFT_layered_driver {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV` from VK_NV_descriptor_pool_overallocation
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub descriptorPoolOverallocation: VkBool32,
}
impl Debug for VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("descriptorPoolOverallocation", &self.descriptorPoolOverallocation)
		.finish()
	}
}
/// trait for `VK_NV_descriptor_pool_overallocation`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_descriptor_pool_overallocation.html>
pub trait VK_NV_descriptor_pool_overallocation: Debug {}
/// struct for `VK_NV_descriptor_pool_overallocation`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_descriptor_pool_overallocation {}
impl VK_NV_descriptor_pool_overallocation for Vulkan_NV_descriptor_pool_overallocation {}
impl Default for Vulkan_NV_descriptor_pool_overallocation {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_descriptor_pool_overallocation {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceTileMemoryHeapFeaturesQCOM` from VK_QCOM_tile_memory_heap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTileMemoryHeapFeaturesQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceTileMemoryHeapFeaturesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub tileMemoryHeap: VkBool32,
}
impl Debug for VkPhysicalDeviceTileMemoryHeapFeaturesQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceTileMemoryHeapFeaturesQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("tileMemoryHeap", &self.tileMemoryHeap)
		.finish()
	}
}
/// struct `VkPhysicalDeviceTileMemoryHeapPropertiesQCOM` from VK_QCOM_tile_memory_heap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceTileMemoryHeapPropertiesQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceTileMemoryHeapPropertiesQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub queueSubmitBoundary: VkBool32,
	pub tileBufferTransfers: VkBool32,
}
impl Debug for VkPhysicalDeviceTileMemoryHeapPropertiesQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceTileMemoryHeapPropertiesQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("queueSubmitBoundary", &self.queueSubmitBoundary)
		.field("tileBufferTransfers", &self.tileBufferTransfers)
		.finish()
	}
}
/// struct `VkTileMemoryRequirementsQCOM` from VK_QCOM_tile_memory_heap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTileMemoryRequirementsQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTileMemoryRequirementsQCOM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub size: VkDeviceSize,
	pub alignment: VkDeviceSize,
}
impl Debug for VkTileMemoryRequirementsQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTileMemoryRequirementsQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("size", &self.size)
		.field("alignment", &self.alignment)
		.finish()
	}
}
/// struct `VkTileMemoryBindInfoQCOM` from VK_QCOM_tile_memory_heap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTileMemoryBindInfoQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTileMemoryBindInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub memory: VkDeviceMemory,
}
impl Debug for VkTileMemoryBindInfoQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTileMemoryBindInfoQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("memory", &self.memory)
		.finish()
	}
}
/// struct `VkTileMemorySizeInfoQCOM` from VK_QCOM_tile_memory_heap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTileMemorySizeInfoQCOM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTileMemorySizeInfoQCOM {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub size: VkDeviceSize,
}
impl Debug for VkTileMemorySizeInfoQCOM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTileMemorySizeInfoQCOM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("size", &self.size)
		.finish()
	}
}
/// function prototype `PFN_vkCmdBindTileMemoryQCOM` from VK_QCOM_tile_memory_heap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindTileMemoryQCOM.html>
type PFN_vkCmdBindTileMemoryQCOM = extern "system" fn(commandBuffer: VkCommandBuffer, pTileMemoryBindInfo: *const VkTileMemoryBindInfoQCOM);
/// The dummy function for `vkCmdBindTileMemoryQCOM` from `VK_QCOM_tile_memory_heap`
extern "system" fn dummy_vkCmdBindTileMemoryQCOM(_: VkCommandBuffer, _: *const VkTileMemoryBindInfoQCOM) {
	panic_any(VkError::NullFunctionPointer("vkCmdBindTileMemoryQCOM"))
}
/// trait for `VK_QCOM_tile_memory_heap`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_QCOM_tile_memory_heap.html>
pub trait VK_QCOM_tile_memory_heap: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindTileMemoryQCOM.html>
	fn vkCmdBindTileMemoryQCOM(&self, commandBuffer: VkCommandBuffer, pTileMemoryBindInfo: *const VkTileMemoryBindInfoQCOM) -> Result<()>;
}
/// struct for `VK_QCOM_tile_memory_heap`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_QCOM_tile_memory_heap {
	vk_cmd_bind_tile_memory_qcom: PFN_vkCmdBindTileMemoryQCOM,
}
impl VK_QCOM_tile_memory_heap for Vulkan_QCOM_tile_memory_heap {
	fn vkCmdBindTileMemoryQCOM(&self, commandBuffer: VkCommandBuffer, pTileMemoryBindInfo: *const VkTileMemoryBindInfoQCOM) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_bind_tile_memory_qcom)(commandBuffer, pTileMemoryBindInfo))))
	}
}
impl Default for Vulkan_QCOM_tile_memory_heap {
	fn default() -> Self {
		Self {
			vk_cmd_bind_tile_memory_qcom: dummy_vkCmdBindTileMemoryQCOM,
		}
	}
}
impl Vulkan_QCOM_tile_memory_heap {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_bind_tile_memory_qcom: {let proc = get_instance_proc_address(instance, "vkCmdBindTileMemoryQCOM"); if proc == null() {dummy_vkCmdBindTileMemoryQCOM} else {unsafe {transmute(proc)}}},
		}
	}
}
/// enum `VkDisplaySurfaceStereoTypeNV` from VK_NV_display_stereo
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplaySurfaceStereoTypeNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkDisplaySurfaceStereoTypeNV {
	VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV = 0,
	VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV = 1,
	VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV = 2,
	VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV = 3,
	VK_DISPLAY_SURFACE_STEREO_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
/// struct `VkDisplaySurfaceStereoCreateInfoNV` from VK_NV_display_stereo
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplaySurfaceStereoCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplaySurfaceStereoCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub stereoType: VkDisplaySurfaceStereoTypeNV,
}
impl Debug for VkDisplaySurfaceStereoCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplaySurfaceStereoCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("stereoType", &self.stereoType)
		.finish()
	}
}
/// struct `VkDisplayModeStereoPropertiesNV` from VK_NV_display_stereo
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayModeStereoPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDisplayModeStereoPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub hdmi3DSupported: VkBool32,
}
impl Debug for VkDisplayModeStereoPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDisplayModeStereoPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("hdmi3DSupported", &self.hdmi3DSupported)
		.finish()
	}
}
/// trait for `VK_NV_display_stereo`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_display_stereo.html>
pub trait VK_NV_display_stereo: Debug {}
/// struct for `VK_NV_display_stereo`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_display_stereo {}
impl VK_NV_display_stereo for Vulkan_NV_display_stereo {}
impl Default for Vulkan_NV_display_stereo {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_display_stereo {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceRawAccessChainsFeaturesNV` from VK_NV_raw_access_chains
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRawAccessChainsFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRawAccessChainsFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderRawAccessChains: VkBool32,
}
impl Debug for VkPhysicalDeviceRawAccessChainsFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRawAccessChainsFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderRawAccessChains", &self.shaderRawAccessChains)
		.finish()
	}
}
/// trait for `VK_NV_raw_access_chains`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_raw_access_chains.html>
pub trait VK_NV_raw_access_chains: Debug {}
/// struct for `VK_NV_raw_access_chains`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_raw_access_chains {}
impl VK_NV_raw_access_chains for Vulkan_NV_raw_access_chains {}
impl Default for Vulkan_NV_raw_access_chains {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_raw_access_chains {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// Normal handle `VkExternalComputeQueueNV` from VK_NV_external_compute_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalComputeQueueNV.html>
#[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkExternalComputeQueueNV_T {_unused: u32,}
pub type VkExternalComputeQueueNV = *const VkExternalComputeQueueNV_T;
/// struct `VkExternalComputeQueueDeviceCreateInfoNV` from VK_NV_external_compute_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalComputeQueueDeviceCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExternalComputeQueueDeviceCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub reservedExternalQueues: u32,
}
impl Debug for VkExternalComputeQueueDeviceCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExternalComputeQueueDeviceCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("reservedExternalQueues", &self.reservedExternalQueues)
		.finish()
	}
}
/// struct `VkExternalComputeQueueCreateInfoNV` from VK_NV_external_compute_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalComputeQueueCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExternalComputeQueueCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub preferredQueue: VkQueue,
}
impl Debug for VkExternalComputeQueueCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExternalComputeQueueCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("preferredQueue", &self.preferredQueue)
		.finish()
	}
}
/// struct `VkExternalComputeQueueDataParamsNV` from VK_NV_external_compute_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalComputeQueueDataParamsNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkExternalComputeQueueDataParamsNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub deviceIndex: u32,
}
impl Debug for VkExternalComputeQueueDataParamsNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkExternalComputeQueueDataParamsNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceIndex", &self.deviceIndex)
		.finish()
	}
}
/// struct `VkPhysicalDeviceExternalComputeQueuePropertiesNV` from VK_NV_external_compute_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExternalComputeQueuePropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceExternalComputeQueuePropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub externalDataSize: u32,
	pub maxExternalQueues: u32,
}
impl Debug for VkPhysicalDeviceExternalComputeQueuePropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceExternalComputeQueuePropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("externalDataSize", &self.externalDataSize)
		.field("maxExternalQueues", &self.maxExternalQueues)
		.finish()
	}
}
/// function prototype `PFN_vkCreateExternalComputeQueueNV` from VK_NV_external_compute_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateExternalComputeQueueNV.html>
type PFN_vkCreateExternalComputeQueueNV = extern "system" fn(device: VkDevice, pCreateInfo: *const VkExternalComputeQueueCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pExternalQueue: *mut VkExternalComputeQueueNV) -> VkResult;
/// function prototype `PFN_vkDestroyExternalComputeQueueNV` from VK_NV_external_compute_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyExternalComputeQueueNV.html>
type PFN_vkDestroyExternalComputeQueueNV = extern "system" fn(device: VkDevice, externalQueue: VkExternalComputeQueueNV, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkGetExternalComputeQueueDataNV` from VK_NV_external_compute_queue
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetExternalComputeQueueDataNV.html>
type PFN_vkGetExternalComputeQueueDataNV = extern "system" fn(externalQueue: VkExternalComputeQueueNV, params: *mut VkExternalComputeQueueDataParamsNV, pData: *mut c_void);
/// The dummy function for `vkCreateExternalComputeQueueNV` from `VK_NV_external_compute_queue`
extern "system" fn dummy_vkCreateExternalComputeQueueNV(_: VkDevice, _: *const VkExternalComputeQueueCreateInfoNV, _: *const VkAllocationCallbacks, _: *mut VkExternalComputeQueueNV) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateExternalComputeQueueNV"))
}
/// trait for `VK_NV_external_compute_queue`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_external_compute_queue.html>
pub trait VK_NV_external_compute_queue: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateExternalComputeQueueNV.html>
	fn vkCreateExternalComputeQueueNV(&self, device: VkDevice, pCreateInfo: *const VkExternalComputeQueueCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pExternalQueue: *mut VkExternalComputeQueueNV) -> Result<()>;
}
/// struct for `VK_NV_external_compute_queue`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_external_compute_queue {
	vk_create_external_compute_queue_nv: PFN_vkCreateExternalComputeQueueNV,
}
impl VK_NV_external_compute_queue for Vulkan_NV_external_compute_queue {
	fn vkCreateExternalComputeQueueNV(&self, device: VkDevice, pCreateInfo: *const VkExternalComputeQueueCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pExternalQueue: *mut VkExternalComputeQueueNV) -> Result<()> {
		convert_result("vkCreateExternalComputeQueueNV", catch_unwind(||((self.vk_create_external_compute_queue_nv)(device, pCreateInfo, pAllocator, pExternalQueue))))
	}
}
impl Default for Vulkan_NV_external_compute_queue {
	fn default() -> Self {
		Self {
			vk_create_external_compute_queue_nv: dummy_vkCreateExternalComputeQueueNV,
		}
	}
}
impl Vulkan_NV_external_compute_queue {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_external_compute_queue_nv: {let proc = get_instance_proc_address(instance, "vkCreateExternalComputeQueueNV"); if proc == null() {dummy_vkCreateExternalComputeQueueNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceCommandBufferInheritanceFeaturesNV` from VK_NV_command_buffer_inheritance
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCommandBufferInheritanceFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCommandBufferInheritanceFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub commandBufferInheritance: VkBool32,
}
impl Debug for VkPhysicalDeviceCommandBufferInheritanceFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCommandBufferInheritanceFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("commandBufferInheritance", &self.commandBufferInheritance)
		.finish()
	}
}
/// trait for `VK_NV_command_buffer_inheritance`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_command_buffer_inheritance.html>
pub trait VK_NV_command_buffer_inheritance: Debug {}
/// struct for `VK_NV_command_buffer_inheritance`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_command_buffer_inheritance {}
impl VK_NV_command_buffer_inheritance for Vulkan_NV_command_buffer_inheritance {}
impl Default for Vulkan_NV_command_buffer_inheritance {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_command_buffer_inheritance {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV` from VK_NV_shader_atomic_float16_vector
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderFloat16VectorAtomics: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderFloat16VectorAtomics", &self.shaderFloat16VectorAtomics)
		.finish()
	}
}
/// trait for `VK_NV_shader_atomic_float16_vector`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_shader_atomic_float16_vector.html>
pub trait VK_NV_shader_atomic_float16_vector: Debug {}
/// struct for `VK_NV_shader_atomic_float16_vector`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_shader_atomic_float16_vector {}
impl VK_NV_shader_atomic_float16_vector for Vulkan_NV_shader_atomic_float16_vector {}
impl Default for Vulkan_NV_shader_atomic_float16_vector {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_shader_atomic_float16_vector {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT` from VK_EXT_shader_replicated_composites
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderReplicatedComposites: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderReplicatedComposites", &self.shaderReplicatedComposites)
		.finish()
	}
}
/// trait for `VK_EXT_shader_replicated_composites`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_shader_replicated_composites.html>
pub trait VK_EXT_shader_replicated_composites: Debug {}
/// struct for `VK_EXT_shader_replicated_composites`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_replicated_composites {}
impl VK_EXT_shader_replicated_composites for Vulkan_EXT_shader_replicated_composites {}
impl Default for Vulkan_EXT_shader_replicated_composites {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_replicated_composites {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceShaderFloat8FeaturesEXT` from VK_EXT_shader_float8
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceShaderFloat8FeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceShaderFloat8FeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderFloat8: VkBool32,
	pub shaderFloat8CooperativeMatrix: VkBool32,
}
impl Debug for VkPhysicalDeviceShaderFloat8FeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceShaderFloat8FeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderFloat8", &self.shaderFloat8)
		.field("shaderFloat8CooperativeMatrix", &self.shaderFloat8CooperativeMatrix)
		.finish()
	}
}
/// trait for `VK_EXT_shader_float8`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_shader_float8.html>
pub trait VK_EXT_shader_float8: Debug {}
/// struct for `VK_EXT_shader_float8`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_shader_float8 {}
impl VK_EXT_shader_float8 for Vulkan_EXT_shader_float8 {}
impl Default for Vulkan_EXT_shader_float8 {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_shader_float8 {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceRayTracingValidationFeaturesNV` from VK_NV_ray_tracing_validation
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRayTracingValidationFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingValidationFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rayTracingValidation: VkBool32,
}
impl Debug for VkPhysicalDeviceRayTracingValidationFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRayTracingValidationFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("rayTracingValidation", &self.rayTracingValidation)
		.finish()
	}
}
/// trait for `VK_NV_ray_tracing_validation`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_ray_tracing_validation.html>
pub trait VK_NV_ray_tracing_validation: Debug {}
/// struct for `VK_NV_ray_tracing_validation`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_ray_tracing_validation {}
impl VK_NV_ray_tracing_validation for Vulkan_NV_ray_tracing_validation {}
impl Default for Vulkan_NV_ray_tracing_validation {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_ray_tracing_validation {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkClusterAccelerationStructureAddressResolutionFlagsNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureAddressResolutionFlagsNV.html>
pub type VkClusterAccelerationStructureAddressResolutionFlagsNV = VkFlags;
/// type definition `VkClusterAccelerationStructureClusterFlagsNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureClusterFlagsNV.html>
pub type VkClusterAccelerationStructureClusterFlagsNV = VkFlags;
/// type definition `VkClusterAccelerationStructureGeometryFlagsNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureGeometryFlagsNV.html>
pub type VkClusterAccelerationStructureGeometryFlagsNV = VkFlags;
/// type definition `VkClusterAccelerationStructureIndexFormatFlagsNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureIndexFormatFlagsNV.html>
pub type VkClusterAccelerationStructureIndexFormatFlagsNV = VkFlags;
/// enum `VkClusterAccelerationStructureTypeNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureTypeNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkClusterAccelerationStructureTypeNV {
	VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV = 0,
	VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV = 1,
	VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV = 2,
	VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkClusterAccelerationStructureOpTypeNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureOpTypeNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkClusterAccelerationStructureOpTypeNV {
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV = 0,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV = 1,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV = 2,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV = 3,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV = 4,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV = 5,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkClusterAccelerationStructureOpModeNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureOpModeNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkClusterAccelerationStructureOpModeNV {
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV = 0,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV = 1,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV = 2,
	VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkClusterAccelerationStructureAddressResolutionFlagBitsNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureAddressResolutionFlagBitsNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkClusterAccelerationStructureAddressResolutionFlagBitsNV {
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_NONE_NV = 0,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV = 0x00000001,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV = 0x00000002,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV = 0x00000004,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV = 0x00000008,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV = 0x00000010,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV = 0x00000020,
	VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkClusterAccelerationStructureClusterFlagBitsNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureClusterFlagBitsNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkClusterAccelerationStructureClusterFlagBitsNV {
	VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV = 0x00000001,
	VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkClusterAccelerationStructureGeometryFlagBitsNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureGeometryFlagBitsNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkClusterAccelerationStructureGeometryFlagBitsNV {
	VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV = 0x00000001,
	VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV = 0x00000002,
	VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV = 0x00000004,
	VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkClusterAccelerationStructureIndexFormatFlagBitsNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureIndexFormatFlagBitsNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkClusterAccelerationStructureIndexFormatFlagBitsNV {
	VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV = 0x00000001,
	VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV = 0x00000002,
	VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV = 0x00000004,
	VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
/// union `VkClusterAccelerationStructureOpInputNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureOpInputNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkClusterAccelerationStructureOpInputNV {
	pub pClustersBottomLevel: *mut VkClusterAccelerationStructureClustersBottomLevelInputNV,
	pub pTriangleClusters: *mut VkClusterAccelerationStructureTriangleClusterInputNV,
	pub pMoveObjects: *mut VkClusterAccelerationStructureMoveObjectsInputNV,
}
impl Debug for VkClusterAccelerationStructureOpInputNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClusterAccelerationStructureOpInputNV")
		.field("pClustersBottomLevel", unsafe {&self.pClustersBottomLevel})
		.field("pTriangleClusters", unsafe {&self.pTriangleClusters})
		.field("pMoveObjects", unsafe {&self.pMoveObjects})
		.finish()
	}
}
/// struct `VkPhysicalDeviceClusterAccelerationStructureFeaturesNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceClusterAccelerationStructureFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceClusterAccelerationStructureFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub clusterAccelerationStructure: VkBool32,
}
impl Debug for VkPhysicalDeviceClusterAccelerationStructureFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceClusterAccelerationStructureFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("clusterAccelerationStructure", &self.clusterAccelerationStructure)
		.finish()
	}
}
/// struct `VkPhysicalDeviceClusterAccelerationStructurePropertiesNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceClusterAccelerationStructurePropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceClusterAccelerationStructurePropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxVerticesPerCluster: u32,
	pub maxTrianglesPerCluster: u32,
	pub clusterScratchByteAlignment: u32,
	pub clusterByteAlignment: u32,
	pub clusterTemplateByteAlignment: u32,
	pub clusterBottomLevelByteAlignment: u32,
	pub clusterTemplateBoundsByteAlignment: u32,
	pub maxClusterGeometryIndex: u32,
}
impl Debug for VkPhysicalDeviceClusterAccelerationStructurePropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceClusterAccelerationStructurePropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxVerticesPerCluster", &self.maxVerticesPerCluster)
		.field("maxTrianglesPerCluster", &self.maxTrianglesPerCluster)
		.field("clusterScratchByteAlignment", &self.clusterScratchByteAlignment)
		.field("clusterByteAlignment", &self.clusterByteAlignment)
		.field("clusterTemplateByteAlignment", &self.clusterTemplateByteAlignment)
		.field("clusterBottomLevelByteAlignment", &self.clusterBottomLevelByteAlignment)
		.field("clusterTemplateBoundsByteAlignment", &self.clusterTemplateBoundsByteAlignment)
		.field("maxClusterGeometryIndex", &self.maxClusterGeometryIndex)
		.finish()
	}
}
/// struct `VkClusterAccelerationStructureClustersBottomLevelInputNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureClustersBottomLevelInputNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkClusterAccelerationStructureClustersBottomLevelInputNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxTotalClusterCount: u32,
	pub maxClusterCountPerAccelerationStructure: u32,
}
impl Debug for VkClusterAccelerationStructureClustersBottomLevelInputNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClusterAccelerationStructureClustersBottomLevelInputNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxTotalClusterCount", &self.maxTotalClusterCount)
		.field("maxClusterCountPerAccelerationStructure", &self.maxClusterCountPerAccelerationStructure)
		.finish()
	}
}
/// struct `VkClusterAccelerationStructureTriangleClusterInputNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureTriangleClusterInputNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkClusterAccelerationStructureTriangleClusterInputNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub vertexFormat: VkFormat,
	pub maxGeometryIndexValue: u32,
	pub maxClusterUniqueGeometryCount: u32,
	pub maxClusterTriangleCount: u32,
	pub maxClusterVertexCount: u32,
	pub maxTotalTriangleCount: u32,
	pub maxTotalVertexCount: u32,
	pub minPositionTruncateBitCount: u32,
}
impl Debug for VkClusterAccelerationStructureTriangleClusterInputNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClusterAccelerationStructureTriangleClusterInputNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("vertexFormat", &self.vertexFormat)
		.field("maxGeometryIndexValue", &self.maxGeometryIndexValue)
		.field("maxClusterUniqueGeometryCount", &self.maxClusterUniqueGeometryCount)
		.field("maxClusterTriangleCount", &self.maxClusterTriangleCount)
		.field("maxClusterVertexCount", &self.maxClusterVertexCount)
		.field("maxTotalTriangleCount", &self.maxTotalTriangleCount)
		.field("maxTotalVertexCount", &self.maxTotalVertexCount)
		.field("minPositionTruncateBitCount", &self.minPositionTruncateBitCount)
		.finish()
	}
}
/// struct `VkClusterAccelerationStructureMoveObjectsInputNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureMoveObjectsInputNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkClusterAccelerationStructureMoveObjectsInputNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub type_: VkClusterAccelerationStructureTypeNV,
	pub noMoveOverlap: VkBool32,
	pub maxMovedBytes: VkDeviceSize,
}
impl Debug for VkClusterAccelerationStructureMoveObjectsInputNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClusterAccelerationStructureMoveObjectsInputNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("type_", &self.type_)
		.field("noMoveOverlap", &self.noMoveOverlap)
		.field("maxMovedBytes", &self.maxMovedBytes)
		.finish()
	}
}
/// struct `VkClusterAccelerationStructureInputInfoNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureInputInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkClusterAccelerationStructureInputInfoNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxAccelerationStructureCount: u32,
	pub flags: VkBuildAccelerationStructureFlagsKHR,
	pub opType: VkClusterAccelerationStructureOpTypeNV,
	pub opMode: VkClusterAccelerationStructureOpModeNV,
	pub opInput: VkClusterAccelerationStructureOpInputNV,
}
impl Debug for VkClusterAccelerationStructureInputInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClusterAccelerationStructureInputInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxAccelerationStructureCount", &self.maxAccelerationStructureCount)
		.field("flags", &self.flags)
		.field("opType", &self.opType)
		.field("opMode", &self.opMode)
		.field("opInput", &self.opInput)
		.finish()
	}
}
/// struct `VkStridedDeviceAddressRegionKHR` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkStridedDeviceAddressRegionKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkStridedDeviceAddressRegionKHR {
	pub deviceAddress: VkDeviceAddress,
	pub stride: VkDeviceSize,
	pub size: VkDeviceSize,
}
impl Debug for VkStridedDeviceAddressRegionKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkStridedDeviceAddressRegionKHR")
		.field("deviceAddress", &self.deviceAddress)
		.field("stride", &self.stride)
		.field("size", &self.size)
		.finish()
	}
}
/// struct `VkClusterAccelerationStructureCommandsInfoNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureCommandsInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkClusterAccelerationStructureCommandsInfoNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub input: VkClusterAccelerationStructureInputInfoNV,
	pub dstImplicitData: VkDeviceAddress,
	pub scratchData: VkDeviceAddress,
	pub dstAddressesArray: VkStridedDeviceAddressRegionKHR,
	pub dstSizesArray: VkStridedDeviceAddressRegionKHR,
	pub srcInfosArray: VkStridedDeviceAddressRegionKHR,
	pub srcInfosCount: VkDeviceAddress,
	pub addressResolutionFlags: VkClusterAccelerationStructureAddressResolutionFlagsNV,
}
impl Debug for VkClusterAccelerationStructureCommandsInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClusterAccelerationStructureCommandsInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("input", &self.input)
		.field("dstImplicitData", &self.dstImplicitData)
		.field("scratchData", &self.scratchData)
		.field("dstAddressesArray", &self.dstAddressesArray)
		.field("dstSizesArray", &self.dstSizesArray)
		.field("srcInfosArray", &self.srcInfosArray)
		.field("srcInfosCount", &self.srcInfosCount)
		.field("addressResolutionFlags", &self.addressResolutionFlags)
		.finish()
	}
}
/// struct `VkStridedDeviceAddressNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkStridedDeviceAddressNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkStridedDeviceAddressNV {
	pub startAddress: VkDeviceAddress,
	pub strideInBytes: VkDeviceSize,
}
impl Debug for VkStridedDeviceAddressNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkStridedDeviceAddressNV")
		.field("startAddress", &self.startAddress)
		.field("strideInBytes", &self.strideInBytes)
		.finish()
	}
}
/// struct `VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV {
	/// Bitfield: geometryIndex: u32 in 24 bits
	/// Bitfield: reserved: u32 in 5 bits
	/// Bitfield: geometryFlags: u32 in 3 bits
	bitfield1: u32,
}
impl VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV {
	pub fn get_geometryIndex(&self) -> u32 {
		(self.bitfield1 >> 0) & 0xffffff
	}
	pub fn set_geometryIndex(&mut self, value: u32) {
		self.bitfield1 = (value & 0xffffff) << 0;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 24) & 0x1f
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1f) << 24;
	}
	pub fn get_geometryFlags(&self) -> u32 {
		(self.bitfield1 >> 29) & 0x7
	}
	pub fn set_geometryFlags(&mut self, value: u32) {
		self.bitfield1 = (value & 0x7) << 29;
	}
}
impl Debug for VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV")
		.field("geometryIndex", &self.get_geometryIndex())
		.field("reserved", &self.get_reserved())
		.field("geometryFlags", &self.get_geometryFlags())
		.finish()
	}
}
/// struct `VkClusterAccelerationStructureMoveObjectsInfoNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureMoveObjectsInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkClusterAccelerationStructureMoveObjectsInfoNV {
	pub srcAccelerationStructure: VkDeviceAddress,
}
impl Debug for VkClusterAccelerationStructureMoveObjectsInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClusterAccelerationStructureMoveObjectsInfoNV")
		.field("srcAccelerationStructure", &self.srcAccelerationStructure)
		.finish()
	}
}
/// struct `VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV {
	pub clusterReferencesCount: u32,
	pub clusterReferencesStride: u32,
	pub clusterReferences: VkDeviceAddress,
}
impl Debug for VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV")
		.field("clusterReferencesCount", &self.clusterReferencesCount)
		.field("clusterReferencesStride", &self.clusterReferencesStride)
		.field("clusterReferences", &self.clusterReferences)
		.finish()
	}
}
/// struct `VkClusterAccelerationStructureBuildTriangleClusterInfoNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureBuildTriangleClusterInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkClusterAccelerationStructureBuildTriangleClusterInfoNV {
	pub clusterID: u32,
	pub clusterFlags: VkClusterAccelerationStructureClusterFlagsNV,
	/// Bitfield: triangleCount: u32 in 9 bits
	/// Bitfield: vertexCount: u32 in 9 bits
	/// Bitfield: positionTruncateBitCount: u32 in 6 bits
	/// Bitfield: indexType: u32 in 4 bits
	/// Bitfield: opacityMicromapIndexType: u32 in 4 bits
	bitfield1: u32,
	pub baseGeometryIndexAndGeometryFlags: VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV,
	pub indexBufferStride: u16,
	pub vertexBufferStride: u16,
	pub geometryIndexAndFlagsBufferStride: u16,
	pub opacityMicromapIndexBufferStride: u16,
	pub indexBuffer: VkDeviceAddress,
	pub vertexBuffer: VkDeviceAddress,
	pub geometryIndexAndFlagsBuffer: VkDeviceAddress,
	pub opacityMicromapArray: VkDeviceAddress,
	pub opacityMicromapIndexBuffer: VkDeviceAddress,
}
impl VkClusterAccelerationStructureBuildTriangleClusterInfoNV {
	pub fn get_triangleCount(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1ff
	}
	pub fn set_triangleCount(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1ff) << 0;
	}
	pub fn get_vertexCount(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1ff
	}
	pub fn set_vertexCount(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1ff) << 9;
	}
	pub fn get_positionTruncateBitCount(&self) -> u32 {
		(self.bitfield1 >> 18) & 0x3f
	}
	pub fn set_positionTruncateBitCount(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3f) << 18;
	}
	pub fn get_indexType(&self) -> u32 {
		(self.bitfield1 >> 24) & 0xf
	}
	pub fn set_indexType(&mut self, value: u32) {
		self.bitfield1 = (value & 0xf) << 24;
	}
	pub fn get_opacityMicromapIndexType(&self) -> u32 {
		(self.bitfield1 >> 28) & 0xf
	}
	pub fn set_opacityMicromapIndexType(&mut self, value: u32) {
		self.bitfield1 = (value & 0xf) << 28;
	}
}
impl Debug for VkClusterAccelerationStructureBuildTriangleClusterInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClusterAccelerationStructureBuildTriangleClusterInfoNV")
		.field("clusterID", &self.clusterID)
		.field("clusterFlags", &self.clusterFlags)
		.field("triangleCount", &self.get_triangleCount())
		.field("vertexCount", &self.get_vertexCount())
		.field("positionTruncateBitCount", &self.get_positionTruncateBitCount())
		.field("indexType", &self.get_indexType())
		.field("opacityMicromapIndexType", &self.get_opacityMicromapIndexType())
		.field("baseGeometryIndexAndGeometryFlags", &self.baseGeometryIndexAndGeometryFlags)
		.field("indexBufferStride", &self.indexBufferStride)
		.field("vertexBufferStride", &self.vertexBufferStride)
		.field("geometryIndexAndFlagsBufferStride", &self.geometryIndexAndFlagsBufferStride)
		.field("opacityMicromapIndexBufferStride", &self.opacityMicromapIndexBufferStride)
		.field("indexBuffer", &self.indexBuffer)
		.field("vertexBuffer", &self.vertexBuffer)
		.field("geometryIndexAndFlagsBuffer", &self.geometryIndexAndFlagsBuffer)
		.field("opacityMicromapArray", &self.opacityMicromapArray)
		.field("opacityMicromapIndexBuffer", &self.opacityMicromapIndexBuffer)
		.finish()
	}
}
/// struct `VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV {
	pub clusterID: u32,
	pub clusterFlags: VkClusterAccelerationStructureClusterFlagsNV,
	/// Bitfield: triangleCount: u32 in 9 bits
	/// Bitfield: vertexCount: u32 in 9 bits
	/// Bitfield: positionTruncateBitCount: u32 in 6 bits
	/// Bitfield: indexType: u32 in 4 bits
	/// Bitfield: opacityMicromapIndexType: u32 in 4 bits
	bitfield1: u32,
	pub baseGeometryIndexAndGeometryFlags: VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV,
	pub indexBufferStride: u16,
	pub vertexBufferStride: u16,
	pub geometryIndexAndFlagsBufferStride: u16,
	pub opacityMicromapIndexBufferStride: u16,
	pub indexBuffer: VkDeviceAddress,
	pub vertexBuffer: VkDeviceAddress,
	pub geometryIndexAndFlagsBuffer: VkDeviceAddress,
	pub opacityMicromapArray: VkDeviceAddress,
	pub opacityMicromapIndexBuffer: VkDeviceAddress,
	pub instantiationBoundingBoxLimit: VkDeviceAddress,
}
impl VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV {
	pub fn get_triangleCount(&self) -> u32 {
		(self.bitfield1 >> 0) & 0x1ff
	}
	pub fn set_triangleCount(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1ff) << 0;
	}
	pub fn get_vertexCount(&self) -> u32 {
		(self.bitfield1 >> 9) & 0x1ff
	}
	pub fn set_vertexCount(&mut self, value: u32) {
		self.bitfield1 = (value & 0x1ff) << 9;
	}
	pub fn get_positionTruncateBitCount(&self) -> u32 {
		(self.bitfield1 >> 18) & 0x3f
	}
	pub fn set_positionTruncateBitCount(&mut self, value: u32) {
		self.bitfield1 = (value & 0x3f) << 18;
	}
	pub fn get_indexType(&self) -> u32 {
		(self.bitfield1 >> 24) & 0xf
	}
	pub fn set_indexType(&mut self, value: u32) {
		self.bitfield1 = (value & 0xf) << 24;
	}
	pub fn get_opacityMicromapIndexType(&self) -> u32 {
		(self.bitfield1 >> 28) & 0xf
	}
	pub fn set_opacityMicromapIndexType(&mut self, value: u32) {
		self.bitfield1 = (value & 0xf) << 28;
	}
}
impl Debug for VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV")
		.field("clusterID", &self.clusterID)
		.field("clusterFlags", &self.clusterFlags)
		.field("triangleCount", &self.get_triangleCount())
		.field("vertexCount", &self.get_vertexCount())
		.field("positionTruncateBitCount", &self.get_positionTruncateBitCount())
		.field("indexType", &self.get_indexType())
		.field("opacityMicromapIndexType", &self.get_opacityMicromapIndexType())
		.field("baseGeometryIndexAndGeometryFlags", &self.baseGeometryIndexAndGeometryFlags)
		.field("indexBufferStride", &self.indexBufferStride)
		.field("vertexBufferStride", &self.vertexBufferStride)
		.field("geometryIndexAndFlagsBufferStride", &self.geometryIndexAndFlagsBufferStride)
		.field("opacityMicromapIndexBufferStride", &self.opacityMicromapIndexBufferStride)
		.field("indexBuffer", &self.indexBuffer)
		.field("vertexBuffer", &self.vertexBuffer)
		.field("geometryIndexAndFlagsBuffer", &self.geometryIndexAndFlagsBuffer)
		.field("opacityMicromapArray", &self.opacityMicromapArray)
		.field("opacityMicromapIndexBuffer", &self.opacityMicromapIndexBuffer)
		.field("instantiationBoundingBoxLimit", &self.instantiationBoundingBoxLimit)
		.finish()
	}
}
/// struct `VkClusterAccelerationStructureInstantiateClusterInfoNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureInstantiateClusterInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkClusterAccelerationStructureInstantiateClusterInfoNV {
	pub clusterIdOffset: u32,
	/// Bitfield: geometryIndexOffset: u32 in 24 bits
	/// Bitfield: reserved: u32 in 8 bits
	bitfield1: u32,
	pub clusterTemplateAddress: VkDeviceAddress,
	pub vertexBuffer: VkStridedDeviceAddressNV,
}
impl VkClusterAccelerationStructureInstantiateClusterInfoNV {
	pub fn get_geometryIndexOffset(&self) -> u32 {
		(self.bitfield1 >> 0) & 0xffffff
	}
	pub fn set_geometryIndexOffset(&mut self, value: u32) {
		self.bitfield1 = (value & 0xffffff) << 0;
	}
	pub fn get_reserved(&self) -> u32 {
		(self.bitfield1 >> 24) & 0xff
	}
	pub fn set_reserved(&mut self, value: u32) {
		self.bitfield1 = (value & 0xff) << 24;
	}
}
impl Debug for VkClusterAccelerationStructureInstantiateClusterInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClusterAccelerationStructureInstantiateClusterInfoNV")
		.field("clusterIdOffset", &self.clusterIdOffset)
		.field("geometryIndexOffset", &self.get_geometryIndexOffset())
		.field("reserved", &self.get_reserved())
		.field("clusterTemplateAddress", &self.clusterTemplateAddress)
		.field("vertexBuffer", &self.vertexBuffer)
		.finish()
	}
}
/// struct `VkClusterAccelerationStructureGetTemplateIndicesInfoNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkClusterAccelerationStructureGetTemplateIndicesInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkClusterAccelerationStructureGetTemplateIndicesInfoNV {
	pub clusterTemplateAddress: VkDeviceAddress,
}
impl Debug for VkClusterAccelerationStructureGetTemplateIndicesInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkClusterAccelerationStructureGetTemplateIndicesInfoNV")
		.field("clusterTemplateAddress", &self.clusterTemplateAddress)
		.finish()
	}
}
/// struct `VkAccelerationStructureBuildSizesInfoKHR` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildSizesInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureBuildSizesInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub accelerationStructureSize: VkDeviceSize,
	pub updateScratchSize: VkDeviceSize,
	pub buildScratchSize: VkDeviceSize,
}
impl Debug for VkAccelerationStructureBuildSizesInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureBuildSizesInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("accelerationStructureSize", &self.accelerationStructureSize)
		.field("updateScratchSize", &self.updateScratchSize)
		.field("buildScratchSize", &self.buildScratchSize)
		.finish()
	}
}
/// struct `VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub allowClusterAccelerationStructure: VkBool32,
}
impl Debug for VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("allowClusterAccelerationStructure", &self.allowClusterAccelerationStructure)
		.finish()
	}
}
/// function prototype `PFN_vkGetClusterAccelerationStructureBuildSizesNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetClusterAccelerationStructureBuildSizesNV.html>
type PFN_vkGetClusterAccelerationStructureBuildSizesNV = extern "system" fn(device: VkDevice, pInfo: *const VkClusterAccelerationStructureInputInfoNV, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR);
/// function prototype `PFN_vkCmdBuildClusterAccelerationStructureIndirectNV` from VK_NV_cluster_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildClusterAccelerationStructureIndirectNV.html>
type PFN_vkCmdBuildClusterAccelerationStructureIndirectNV = extern "system" fn(commandBuffer: VkCommandBuffer, pCommandInfos: *const VkClusterAccelerationStructureCommandsInfoNV);
/// The dummy function for `vkGetClusterAccelerationStructureBuildSizesNV` from `VK_NV_cluster_acceleration_structure`
extern "system" fn dummy_vkGetClusterAccelerationStructureBuildSizesNV(_: VkDevice, _: *const VkClusterAccelerationStructureInputInfoNV, _: *mut VkAccelerationStructureBuildSizesInfoKHR) {
	panic_any(VkError::NullFunctionPointer("vkGetClusterAccelerationStructureBuildSizesNV"))
}
/// trait for `VK_NV_cluster_acceleration_structure`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_cluster_acceleration_structure.html>
pub trait VK_NV_cluster_acceleration_structure: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetClusterAccelerationStructureBuildSizesNV.html>
	fn vkGetClusterAccelerationStructureBuildSizesNV(&self, device: VkDevice, pInfo: *const VkClusterAccelerationStructureInputInfoNV, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR) -> Result<()>;
}
/// struct for `VK_NV_cluster_acceleration_structure`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_cluster_acceleration_structure {
	vk_get_cluster_acceleration_structure_build_sizes_nv: PFN_vkGetClusterAccelerationStructureBuildSizesNV,
}
impl VK_NV_cluster_acceleration_structure for Vulkan_NV_cluster_acceleration_structure {
	fn vkGetClusterAccelerationStructureBuildSizesNV(&self, device: VkDevice, pInfo: *const VkClusterAccelerationStructureInputInfoNV, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_cluster_acceleration_structure_build_sizes_nv)(device, pInfo, pSizeInfo))))
	}
}
impl Default for Vulkan_NV_cluster_acceleration_structure {
	fn default() -> Self {
		Self {
			vk_get_cluster_acceleration_structure_build_sizes_nv: dummy_vkGetClusterAccelerationStructureBuildSizesNV,
		}
	}
}
impl Vulkan_NV_cluster_acceleration_structure {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_cluster_acceleration_structure_build_sizes_nv: {let proc = get_instance_proc_address(instance, "vkGetClusterAccelerationStructureBuildSizesNV"); if proc == null() {dummy_vkGetClusterAccelerationStructureBuildSizesNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// constant `VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV` from VK_NV_partitioned_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV.html>
pub const VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV: u32 = !0u32;
/// type definition `VkPartitionedAccelerationStructureInstanceFlagsNV` from VK_NV_partitioned_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPartitionedAccelerationStructureInstanceFlagsNV.html>
pub type VkPartitionedAccelerationStructureInstanceFlagsNV = VkFlags;
/// enum `VkPartitionedAccelerationStructureOpTypeNV` from VK_NV_partitioned_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPartitionedAccelerationStructureOpTypeNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPartitionedAccelerationStructureOpTypeNV {
	VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV = 0,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV = 1,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV = 2,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_MAX_ENUM_NV = 0x7fffffff,
}
/// enum `VkPartitionedAccelerationStructureInstanceFlagBitsNV` from VK_NV_partitioned_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPartitionedAccelerationStructureInstanceFlagBitsNV.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkPartitionedAccelerationStructureInstanceFlagBitsNV {
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV = 0x00000001,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV = 0x00000002,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV = 0x00000004,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV = 0x00000008,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV = 0x00000010,
	VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff,
}
/// struct `VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV` from VK_NV_partitioned_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub partitionedAccelerationStructure: VkBool32,
}
impl Debug for VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("partitionedAccelerationStructure", &self.partitionedAccelerationStructure)
		.finish()
	}
}
/// struct `VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV` from VK_NV_partitioned_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxPartitionCount: u32,
}
impl Debug for VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxPartitionCount", &self.maxPartitionCount)
		.finish()
	}
}
/// struct `VkPartitionedAccelerationStructureFlagsNV` from VK_NV_partitioned_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPartitionedAccelerationStructureFlagsNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPartitionedAccelerationStructureFlagsNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub enablePartitionTranslation: VkBool32,
}
impl Debug for VkPartitionedAccelerationStructureFlagsNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPartitionedAccelerationStructureFlagsNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("enablePartitionTranslation", &self.enablePartitionTranslation)
		.finish()
	}
}
/// struct `VkBuildPartitionedAccelerationStructureIndirectCommandNV` from VK_NV_partitioned_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBuildPartitionedAccelerationStructureIndirectCommandNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBuildPartitionedAccelerationStructureIndirectCommandNV {
	pub opType: VkPartitionedAccelerationStructureOpTypeNV,
	pub argCount: u32,
	pub argData: VkStridedDeviceAddressNV,
}
impl Debug for VkBuildPartitionedAccelerationStructureIndirectCommandNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBuildPartitionedAccelerationStructureIndirectCommandNV")
		.field("opType", &self.opType)
		.field("argCount", &self.argCount)
		.field("argData", &self.argData)
		.finish()
	}
}
/// struct `VkPartitionedAccelerationStructureWriteInstanceDataNV` from VK_NV_partitioned_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPartitionedAccelerationStructureWriteInstanceDataNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPartitionedAccelerationStructureWriteInstanceDataNV {
	pub transform: VkTransformMatrixKHR,
	pub explicitAABB: [f32; 6 as usize],
	pub instanceID: u32,
	pub instanceMask: u32,
	pub instanceContributionToHitGroupIndex: u32,
	pub instanceFlags: VkPartitionedAccelerationStructureInstanceFlagsNV,
	pub instanceIndex: u32,
	pub partitionIndex: u32,
	pub accelerationStructure: VkDeviceAddress,
}
impl Debug for VkPartitionedAccelerationStructureWriteInstanceDataNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPartitionedAccelerationStructureWriteInstanceDataNV")
		.field("transform", &self.transform)
		.field("explicitAABB", &self.explicitAABB)
		.field("instanceID", &self.instanceID)
		.field("instanceMask", &self.instanceMask)
		.field("instanceContributionToHitGroupIndex", &self.instanceContributionToHitGroupIndex)
		.field("instanceFlags", &self.instanceFlags)
		.field("instanceIndex", &self.instanceIndex)
		.field("partitionIndex", &self.partitionIndex)
		.field("accelerationStructure", &self.accelerationStructure)
		.finish()
	}
}
/// struct `VkPartitionedAccelerationStructureUpdateInstanceDataNV` from VK_NV_partitioned_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPartitionedAccelerationStructureUpdateInstanceDataNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPartitionedAccelerationStructureUpdateInstanceDataNV {
	pub instanceIndex: u32,
	pub instanceContributionToHitGroupIndex: u32,
	pub accelerationStructure: VkDeviceAddress,
}
impl Debug for VkPartitionedAccelerationStructureUpdateInstanceDataNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPartitionedAccelerationStructureUpdateInstanceDataNV")
		.field("instanceIndex", &self.instanceIndex)
		.field("instanceContributionToHitGroupIndex", &self.instanceContributionToHitGroupIndex)
		.field("accelerationStructure", &self.accelerationStructure)
		.finish()
	}
}
/// struct `VkPartitionedAccelerationStructureWritePartitionTranslationDataNV` from VK_NV_partitioned_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPartitionedAccelerationStructureWritePartitionTranslationDataNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPartitionedAccelerationStructureWritePartitionTranslationDataNV {
	pub partitionIndex: u32,
	pub partitionTranslation: [f32; 3 as usize],
}
impl Debug for VkPartitionedAccelerationStructureWritePartitionTranslationDataNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPartitionedAccelerationStructureWritePartitionTranslationDataNV")
		.field("partitionIndex", &self.partitionIndex)
		.field("partitionTranslation", &self.partitionTranslation)
		.finish()
	}
}
/// struct `VkWriteDescriptorSetPartitionedAccelerationStructureNV` from VK_NV_partitioned_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetPartitionedAccelerationStructureNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkWriteDescriptorSetPartitionedAccelerationStructureNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub accelerationStructureCount: u32,
	pub pAccelerationStructures: *const VkDeviceAddress,
}
impl Debug for VkWriteDescriptorSetPartitionedAccelerationStructureNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkWriteDescriptorSetPartitionedAccelerationStructureNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("accelerationStructureCount", &self.accelerationStructureCount)
		.field("pAccelerationStructures", &self.pAccelerationStructures)
		.finish()
	}
}
/// struct `VkPartitionedAccelerationStructureInstancesInputNV` from VK_NV_partitioned_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPartitionedAccelerationStructureInstancesInputNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPartitionedAccelerationStructureInstancesInputNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub flags: VkBuildAccelerationStructureFlagsKHR,
	pub instanceCount: u32,
	pub maxInstancePerPartitionCount: u32,
	pub partitionCount: u32,
	pub maxInstanceInGlobalPartitionCount: u32,
}
impl Debug for VkPartitionedAccelerationStructureInstancesInputNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPartitionedAccelerationStructureInstancesInputNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("instanceCount", &self.instanceCount)
		.field("maxInstancePerPartitionCount", &self.maxInstancePerPartitionCount)
		.field("partitionCount", &self.partitionCount)
		.field("maxInstanceInGlobalPartitionCount", &self.maxInstanceInGlobalPartitionCount)
		.finish()
	}
}
/// struct `VkBuildPartitionedAccelerationStructureInfoNV` from VK_NV_partitioned_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBuildPartitionedAccelerationStructureInfoNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBuildPartitionedAccelerationStructureInfoNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub input: VkPartitionedAccelerationStructureInstancesInputNV,
	pub srcAccelerationStructureData: VkDeviceAddress,
	pub dstAccelerationStructureData: VkDeviceAddress,
	pub scratchData: VkDeviceAddress,
	pub srcInfos: VkDeviceAddress,
	pub srcInfosCount: VkDeviceAddress,
}
impl Debug for VkBuildPartitionedAccelerationStructureInfoNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBuildPartitionedAccelerationStructureInfoNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("input", &self.input)
		.field("srcAccelerationStructureData", &self.srcAccelerationStructureData)
		.field("dstAccelerationStructureData", &self.dstAccelerationStructureData)
		.field("scratchData", &self.scratchData)
		.field("srcInfos", &self.srcInfos)
		.field("srcInfosCount", &self.srcInfosCount)
		.finish()
	}
}
/// function prototype `PFN_vkGetPartitionedAccelerationStructuresBuildSizesNV` from VK_NV_partitioned_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPartitionedAccelerationStructuresBuildSizesNV.html>
type PFN_vkGetPartitionedAccelerationStructuresBuildSizesNV = extern "system" fn(device: VkDevice, pInfo: *const VkPartitionedAccelerationStructureInstancesInputNV, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR);
/// function prototype `PFN_vkCmdBuildPartitionedAccelerationStructuresNV` from VK_NV_partitioned_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildPartitionedAccelerationStructuresNV.html>
type PFN_vkCmdBuildPartitionedAccelerationStructuresNV = extern "system" fn(commandBuffer: VkCommandBuffer, pBuildInfo: *const VkBuildPartitionedAccelerationStructureInfoNV);
/// The dummy function for `vkGetPartitionedAccelerationStructuresBuildSizesNV` from `VK_NV_partitioned_acceleration_structure`
extern "system" fn dummy_vkGetPartitionedAccelerationStructuresBuildSizesNV(_: VkDevice, _: *const VkPartitionedAccelerationStructureInstancesInputNV, _: *mut VkAccelerationStructureBuildSizesInfoKHR) {
	panic_any(VkError::NullFunctionPointer("vkGetPartitionedAccelerationStructuresBuildSizesNV"))
}
/// trait for `VK_NV_partitioned_acceleration_structure`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_partitioned_acceleration_structure.html>
pub trait VK_NV_partitioned_acceleration_structure: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPartitionedAccelerationStructuresBuildSizesNV.html>
	fn vkGetPartitionedAccelerationStructuresBuildSizesNV(&self, device: VkDevice, pInfo: *const VkPartitionedAccelerationStructureInstancesInputNV, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR) -> Result<()>;
}
/// struct for `VK_NV_partitioned_acceleration_structure`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_partitioned_acceleration_structure {
	vk_get_partitioned_acceleration_structures_build_sizes_nv: PFN_vkGetPartitionedAccelerationStructuresBuildSizesNV,
}
impl VK_NV_partitioned_acceleration_structure for Vulkan_NV_partitioned_acceleration_structure {
	fn vkGetPartitionedAccelerationStructuresBuildSizesNV(&self, device: VkDevice, pInfo: *const VkPartitionedAccelerationStructureInstancesInputNV, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_partitioned_acceleration_structures_build_sizes_nv)(device, pInfo, pSizeInfo))))
	}
}
impl Default for Vulkan_NV_partitioned_acceleration_structure {
	fn default() -> Self {
		Self {
			vk_get_partitioned_acceleration_structures_build_sizes_nv: dummy_vkGetPartitionedAccelerationStructuresBuildSizesNV,
		}
	}
}
impl Vulkan_NV_partitioned_acceleration_structure {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_partitioned_acceleration_structures_build_sizes_nv: {let proc = get_instance_proc_address(instance, "vkGetPartitionedAccelerationStructuresBuildSizesNV"); if proc == null() {dummy_vkGetPartitionedAccelerationStructuresBuildSizesNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// type definition `VkIndirectCommandsInputModeFlagsEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsInputModeFlagsEXT.html>
pub type VkIndirectCommandsInputModeFlagsEXT = VkFlags;
/// type definition `VkIndirectCommandsLayoutUsageFlagsEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsLayoutUsageFlagsEXT.html>
pub type VkIndirectCommandsLayoutUsageFlagsEXT = VkFlags;
/// Non-dispatchable handle `VkIndirectExecutionSetEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectExecutionSetEXT.html
#[cfg(target_pointer_width = "32")] pub type VkIndirectExecutionSetEXT = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkIndirectExecutionSetEXT_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkIndirectExecutionSetEXT = *const VkIndirectExecutionSetEXT_T;
/// Non-dispatchable handle `VkIndirectCommandsLayoutEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsLayoutEXT.html
#[cfg(target_pointer_width = "32")] pub type VkIndirectCommandsLayoutEXT = u64;
#[cfg(target_pointer_width = "64")] #[repr(C)] #[derive(Debug, Clone, Copy)] pub struct VkIndirectCommandsLayoutEXT_T {_unused: u32,}
#[cfg(target_pointer_width = "64")] pub type VkIndirectCommandsLayoutEXT = *const VkIndirectCommandsLayoutEXT_T;
/// enum `VkIndirectExecutionSetInfoTypeEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectExecutionSetInfoTypeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkIndirectExecutionSetInfoTypeEXT {
	VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT = 0,
	VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT = 1,
	VK_INDIRECT_EXECUTION_SET_INFO_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkIndirectCommandsTokenTypeEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsTokenTypeEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkIndirectCommandsTokenTypeEXT {
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT = 0,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT = 1,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT = 2,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT = 3,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT = 4,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT = 5,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT = 6,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT = 7,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT = 8,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT = 9,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT = 1000202002,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT = 1000202003,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT = 1000328000,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT = 1000328001,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT = 1000386004,
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkIndirectCommandsInputModeFlagBitsEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsInputModeFlagBitsEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkIndirectCommandsInputModeFlagBitsEXT {
	VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT = 0x00000001,
	VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT = 0x00000002,
	VK_INDIRECT_COMMANDS_INPUT_MODE_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
/// enum `VkIndirectCommandsLayoutUsageFlagBitsEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsLayoutUsageFlagBitsEXT.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkIndirectCommandsLayoutUsageFlagBitsEXT {
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT = 0x00000001,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT = 0x00000002,
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff,
}
/// union `VkIndirectExecutionSetInfoEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectExecutionSetInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkIndirectExecutionSetInfoEXT {
	pub pPipelineInfo: *const VkIndirectExecutionSetPipelineInfoEXT,
	pub pShaderInfo: *const VkIndirectExecutionSetShaderInfoEXT,
}
impl Debug for VkIndirectExecutionSetInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectExecutionSetInfoEXT")
		.field("pPipelineInfo", unsafe {&self.pPipelineInfo})
		.field("pShaderInfo", unsafe {&self.pShaderInfo})
		.finish()
	}
}
/// union `VkIndirectCommandsTokenDataEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsTokenDataEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkIndirectCommandsTokenDataEXT {
	pub pPushConstant: *const VkIndirectCommandsPushConstantTokenEXT,
	pub pVertexBuffer: *const VkIndirectCommandsVertexBufferTokenEXT,
	pub pIndexBuffer: *const VkIndirectCommandsIndexBufferTokenEXT,
	pub pExecutionSet: *const VkIndirectCommandsExecutionSetTokenEXT,
}
impl Debug for VkIndirectCommandsTokenDataEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectCommandsTokenDataEXT")
		.field("pPushConstant", unsafe {&self.pPushConstant})
		.field("pVertexBuffer", unsafe {&self.pVertexBuffer})
		.field("pIndexBuffer", unsafe {&self.pIndexBuffer})
		.field("pExecutionSet", unsafe {&self.pExecutionSet})
		.finish()
	}
}
/// struct `VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub deviceGeneratedCommands: VkBool32,
	pub dynamicGeneratedPipelineLayout: VkBool32,
}
impl Debug for VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("deviceGeneratedCommands", &self.deviceGeneratedCommands)
		.field("dynamicGeneratedPipelineLayout", &self.dynamicGeneratedPipelineLayout)
		.finish()
	}
}
/// struct `VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxIndirectPipelineCount: u32,
	pub maxIndirectShaderObjectCount: u32,
	pub maxIndirectSequenceCount: u32,
	pub maxIndirectCommandsTokenCount: u32,
	pub maxIndirectCommandsTokenOffset: u32,
	pub maxIndirectCommandsIndirectStride: u32,
	pub supportedIndirectCommandsInputModes: VkIndirectCommandsInputModeFlagsEXT,
	pub supportedIndirectCommandsShaderStages: VkShaderStageFlags,
	pub supportedIndirectCommandsShaderStagesPipelineBinding: VkShaderStageFlags,
	pub supportedIndirectCommandsShaderStagesShaderBinding: VkShaderStageFlags,
	pub deviceGeneratedCommandsTransformFeedback: VkBool32,
	pub deviceGeneratedCommandsMultiDrawIndirectCount: VkBool32,
}
impl Debug for VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxIndirectPipelineCount", &self.maxIndirectPipelineCount)
		.field("maxIndirectShaderObjectCount", &self.maxIndirectShaderObjectCount)
		.field("maxIndirectSequenceCount", &self.maxIndirectSequenceCount)
		.field("maxIndirectCommandsTokenCount", &self.maxIndirectCommandsTokenCount)
		.field("maxIndirectCommandsTokenOffset", &self.maxIndirectCommandsTokenOffset)
		.field("maxIndirectCommandsIndirectStride", &self.maxIndirectCommandsIndirectStride)
		.field("supportedIndirectCommandsInputModes", &self.supportedIndirectCommandsInputModes)
		.field("supportedIndirectCommandsShaderStages", &self.supportedIndirectCommandsShaderStages)
		.field("supportedIndirectCommandsShaderStagesPipelineBinding", &self.supportedIndirectCommandsShaderStagesPipelineBinding)
		.field("supportedIndirectCommandsShaderStagesShaderBinding", &self.supportedIndirectCommandsShaderStagesShaderBinding)
		.field("deviceGeneratedCommandsTransformFeedback", &self.deviceGeneratedCommandsTransformFeedback)
		.field("deviceGeneratedCommandsMultiDrawIndirectCount", &self.deviceGeneratedCommandsMultiDrawIndirectCount)
		.finish()
	}
}
/// struct `VkGeneratedCommandsMemoryRequirementsInfoEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeneratedCommandsMemoryRequirementsInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkGeneratedCommandsMemoryRequirementsInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub indirectExecutionSet: VkIndirectExecutionSetEXT,
	pub indirectCommandsLayout: VkIndirectCommandsLayoutEXT,
	pub maxSequenceCount: u32,
	pub maxDrawCount: u32,
}
impl Debug for VkGeneratedCommandsMemoryRequirementsInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkGeneratedCommandsMemoryRequirementsInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("indirectExecutionSet", &self.indirectExecutionSet)
		.field("indirectCommandsLayout", &self.indirectCommandsLayout)
		.field("maxSequenceCount", &self.maxSequenceCount)
		.field("maxDrawCount", &self.maxDrawCount)
		.finish()
	}
}
/// struct `VkIndirectExecutionSetPipelineInfoEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectExecutionSetPipelineInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkIndirectExecutionSetPipelineInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub initialPipeline: VkPipeline,
	pub maxPipelineCount: u32,
}
impl Debug for VkIndirectExecutionSetPipelineInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectExecutionSetPipelineInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("initialPipeline", &self.initialPipeline)
		.field("maxPipelineCount", &self.maxPipelineCount)
		.finish()
	}
}
/// struct `VkIndirectExecutionSetShaderLayoutInfoEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectExecutionSetShaderLayoutInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkIndirectExecutionSetShaderLayoutInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub setLayoutCount: u32,
	pub pSetLayouts: *const VkDescriptorSetLayout,
}
impl Debug for VkIndirectExecutionSetShaderLayoutInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectExecutionSetShaderLayoutInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("setLayoutCount", &self.setLayoutCount)
		.field("pSetLayouts", &self.pSetLayouts)
		.finish()
	}
}
/// struct `VkIndirectExecutionSetShaderInfoEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectExecutionSetShaderInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkIndirectExecutionSetShaderInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub shaderCount: u32,
	pub pInitialShaders: *const VkShaderEXT,
	pub pSetLayoutInfos: *const VkIndirectExecutionSetShaderLayoutInfoEXT,
	pub maxShaderCount: u32,
	pub pushConstantRangeCount: u32,
	pub pPushConstantRanges: *const VkPushConstantRange,
}
impl Debug for VkIndirectExecutionSetShaderInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectExecutionSetShaderInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderCount", &self.shaderCount)
		.field("pInitialShaders", &self.pInitialShaders)
		.field("pSetLayoutInfos", &self.pSetLayoutInfos)
		.field("maxShaderCount", &self.maxShaderCount)
		.field("pushConstantRangeCount", &self.pushConstantRangeCount)
		.field("pPushConstantRanges", &self.pPushConstantRanges)
		.finish()
	}
}
/// struct `VkIndirectExecutionSetCreateInfoEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectExecutionSetCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkIndirectExecutionSetCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkIndirectExecutionSetInfoTypeEXT,
	pub info: VkIndirectExecutionSetInfoEXT,
}
impl Debug for VkIndirectExecutionSetCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectExecutionSetCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("type_", &self.type_)
		.field("info", &self.info)
		.finish()
	}
}
/// struct `VkGeneratedCommandsInfoEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeneratedCommandsInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkGeneratedCommandsInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub shaderStages: VkShaderStageFlags,
	pub indirectExecutionSet: VkIndirectExecutionSetEXT,
	pub indirectCommandsLayout: VkIndirectCommandsLayoutEXT,
	pub indirectAddress: VkDeviceAddress,
	pub indirectAddressSize: VkDeviceSize,
	pub preprocessAddress: VkDeviceAddress,
	pub preprocessSize: VkDeviceSize,
	pub maxSequenceCount: u32,
	pub sequenceCountAddress: VkDeviceAddress,
	pub maxDrawCount: u32,
}
impl Debug for VkGeneratedCommandsInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkGeneratedCommandsInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderStages", &self.shaderStages)
		.field("indirectExecutionSet", &self.indirectExecutionSet)
		.field("indirectCommandsLayout", &self.indirectCommandsLayout)
		.field("indirectAddress", &self.indirectAddress)
		.field("indirectAddressSize", &self.indirectAddressSize)
		.field("preprocessAddress", &self.preprocessAddress)
		.field("preprocessSize", &self.preprocessSize)
		.field("maxSequenceCount", &self.maxSequenceCount)
		.field("sequenceCountAddress", &self.sequenceCountAddress)
		.field("maxDrawCount", &self.maxDrawCount)
		.finish()
	}
}
/// struct `VkWriteIndirectExecutionSetPipelineEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteIndirectExecutionSetPipelineEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkWriteIndirectExecutionSetPipelineEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub index: u32,
	pub pipeline: VkPipeline,
}
impl Debug for VkWriteIndirectExecutionSetPipelineEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkWriteIndirectExecutionSetPipelineEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("index", &self.index)
		.field("pipeline", &self.pipeline)
		.finish()
	}
}
/// struct `VkIndirectCommandsPushConstantTokenEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsPushConstantTokenEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkIndirectCommandsPushConstantTokenEXT {
	pub updateRange: VkPushConstantRange,
}
impl Debug for VkIndirectCommandsPushConstantTokenEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectCommandsPushConstantTokenEXT")
		.field("updateRange", &self.updateRange)
		.finish()
	}
}
/// struct `VkIndirectCommandsVertexBufferTokenEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsVertexBufferTokenEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkIndirectCommandsVertexBufferTokenEXT {
	pub vertexBindingUnit: u32,
}
impl Debug for VkIndirectCommandsVertexBufferTokenEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectCommandsVertexBufferTokenEXT")
		.field("vertexBindingUnit", &self.vertexBindingUnit)
		.finish()
	}
}
/// struct `VkIndirectCommandsIndexBufferTokenEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsIndexBufferTokenEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkIndirectCommandsIndexBufferTokenEXT {
	pub mode: VkIndirectCommandsInputModeFlagBitsEXT,
}
impl Debug for VkIndirectCommandsIndexBufferTokenEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectCommandsIndexBufferTokenEXT")
		.field("mode", &self.mode)
		.finish()
	}
}
/// struct `VkIndirectCommandsExecutionSetTokenEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsExecutionSetTokenEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkIndirectCommandsExecutionSetTokenEXT {
	pub type_: VkIndirectExecutionSetInfoTypeEXT,
	pub shaderStages: VkShaderStageFlags,
}
impl Debug for VkIndirectCommandsExecutionSetTokenEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectCommandsExecutionSetTokenEXT")
		.field("type_", &self.type_)
		.field("shaderStages", &self.shaderStages)
		.finish()
	}
}
/// struct `VkIndirectCommandsLayoutTokenEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsLayoutTokenEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkIndirectCommandsLayoutTokenEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkIndirectCommandsTokenTypeEXT,
	pub data: VkIndirectCommandsTokenDataEXT,
	pub offset: u32,
}
impl Debug for VkIndirectCommandsLayoutTokenEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectCommandsLayoutTokenEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("type_", &self.type_)
		.field("data", &self.data)
		.field("offset", &self.offset)
		.finish()
	}
}
/// struct `VkIndirectCommandsLayoutCreateInfoEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsLayoutCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkIndirectCommandsLayoutCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkIndirectCommandsLayoutUsageFlagsEXT,
	pub shaderStages: VkShaderStageFlags,
	pub indirectStride: u32,
	pub pipelineLayout: VkPipelineLayout,
	pub tokenCount: u32,
	pub pTokens: *const VkIndirectCommandsLayoutTokenEXT,
}
impl Debug for VkIndirectCommandsLayoutCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkIndirectCommandsLayoutCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("shaderStages", &self.shaderStages)
		.field("indirectStride", &self.indirectStride)
		.field("pipelineLayout", &self.pipelineLayout)
		.field("tokenCount", &self.tokenCount)
		.field("pTokens", &self.pTokens)
		.finish()
	}
}
/// struct `VkDrawIndirectCountIndirectCommandEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDrawIndirectCountIndirectCommandEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDrawIndirectCountIndirectCommandEXT {
	pub bufferAddress: VkDeviceAddress,
	pub stride: u32,
	pub commandCount: u32,
}
impl Debug for VkDrawIndirectCountIndirectCommandEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDrawIndirectCountIndirectCommandEXT")
		.field("bufferAddress", &self.bufferAddress)
		.field("stride", &self.stride)
		.field("commandCount", &self.commandCount)
		.finish()
	}
}
/// struct `VkBindVertexBufferIndirectCommandEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindVertexBufferIndirectCommandEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindVertexBufferIndirectCommandEXT {
	pub bufferAddress: VkDeviceAddress,
	pub size: u32,
	pub stride: u32,
}
impl Debug for VkBindVertexBufferIndirectCommandEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindVertexBufferIndirectCommandEXT")
		.field("bufferAddress", &self.bufferAddress)
		.field("size", &self.size)
		.field("stride", &self.stride)
		.finish()
	}
}
/// struct `VkBindIndexBufferIndirectCommandEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBindIndexBufferIndirectCommandEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkBindIndexBufferIndirectCommandEXT {
	pub bufferAddress: VkDeviceAddress,
	pub size: u32,
	pub indexType: VkIndexType,
}
impl Debug for VkBindIndexBufferIndirectCommandEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkBindIndexBufferIndirectCommandEXT")
		.field("bufferAddress", &self.bufferAddress)
		.field("size", &self.size)
		.field("indexType", &self.indexType)
		.finish()
	}
}
/// struct `VkGeneratedCommandsPipelineInfoEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeneratedCommandsPipelineInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkGeneratedCommandsPipelineInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipeline: VkPipeline,
}
impl Debug for VkGeneratedCommandsPipelineInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkGeneratedCommandsPipelineInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipeline", &self.pipeline)
		.finish()
	}
}
/// struct `VkGeneratedCommandsShaderInfoEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkGeneratedCommandsShaderInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkGeneratedCommandsShaderInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderCount: u32,
	pub pShaders: *const VkShaderEXT,
}
impl Debug for VkGeneratedCommandsShaderInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkGeneratedCommandsShaderInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderCount", &self.shaderCount)
		.field("pShaders", &self.pShaders)
		.finish()
	}
}
/// struct `VkWriteIndirectExecutionSetShaderEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteIndirectExecutionSetShaderEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkWriteIndirectExecutionSetShaderEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub index: u32,
	pub shader: VkShaderEXT,
}
impl Debug for VkWriteIndirectExecutionSetShaderEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkWriteIndirectExecutionSetShaderEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("index", &self.index)
		.field("shader", &self.shader)
		.finish()
	}
}
/// function prototype `PFN_vkGetGeneratedCommandsMemoryRequirementsEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetGeneratedCommandsMemoryRequirementsEXT.html>
type PFN_vkGetGeneratedCommandsMemoryRequirementsEXT = extern "system" fn(device: VkDevice, pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoEXT, pMemoryRequirements: *mut VkMemoryRequirements2);
/// function prototype `PFN_vkCmdPreprocessGeneratedCommandsEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPreprocessGeneratedCommandsEXT.html>
type PFN_vkCmdPreprocessGeneratedCommandsEXT = extern "system" fn(commandBuffer: VkCommandBuffer, pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoEXT, stateCommandBuffer: VkCommandBuffer);
/// function prototype `PFN_vkCmdExecuteGeneratedCommandsEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdExecuteGeneratedCommandsEXT.html>
type PFN_vkCmdExecuteGeneratedCommandsEXT = extern "system" fn(commandBuffer: VkCommandBuffer, isPreprocessed: VkBool32, pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoEXT);
/// function prototype `PFN_vkCreateIndirectCommandsLayoutEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateIndirectCommandsLayoutEXT.html>
type PFN_vkCreateIndirectCommandsLayoutEXT = extern "system" fn(device: VkDevice, pCreateInfo: *const VkIndirectCommandsLayoutCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pIndirectCommandsLayout: *mut VkIndirectCommandsLayoutEXT) -> VkResult;
/// function prototype `PFN_vkDestroyIndirectCommandsLayoutEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyIndirectCommandsLayoutEXT.html>
type PFN_vkDestroyIndirectCommandsLayoutEXT = extern "system" fn(device: VkDevice, indirectCommandsLayout: VkIndirectCommandsLayoutEXT, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCreateIndirectExecutionSetEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateIndirectExecutionSetEXT.html>
type PFN_vkCreateIndirectExecutionSetEXT = extern "system" fn(device: VkDevice, pCreateInfo: *const VkIndirectExecutionSetCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pIndirectExecutionSet: *mut VkIndirectExecutionSetEXT) -> VkResult;
/// function prototype `PFN_vkDestroyIndirectExecutionSetEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyIndirectExecutionSetEXT.html>
type PFN_vkDestroyIndirectExecutionSetEXT = extern "system" fn(device: VkDevice, indirectExecutionSet: VkIndirectExecutionSetEXT, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkUpdateIndirectExecutionSetPipelineEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateIndirectExecutionSetPipelineEXT.html>
type PFN_vkUpdateIndirectExecutionSetPipelineEXT = extern "system" fn(device: VkDevice, indirectExecutionSet: VkIndirectExecutionSetEXT, executionSetWriteCount: u32, pExecutionSetWrites: *const VkWriteIndirectExecutionSetPipelineEXT);
/// function prototype `PFN_vkUpdateIndirectExecutionSetShaderEXT` from VK_EXT_device_generated_commands
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateIndirectExecutionSetShaderEXT.html>
type PFN_vkUpdateIndirectExecutionSetShaderEXT = extern "system" fn(device: VkDevice, indirectExecutionSet: VkIndirectExecutionSetEXT, executionSetWriteCount: u32, pExecutionSetWrites: *const VkWriteIndirectExecutionSetShaderEXT);
/// The dummy function for `vkGetGeneratedCommandsMemoryRequirementsEXT` from `VK_EXT_device_generated_commands`
extern "system" fn dummy_vkGetGeneratedCommandsMemoryRequirementsEXT(_: VkDevice, _: *const VkGeneratedCommandsMemoryRequirementsInfoEXT, _: *mut VkMemoryRequirements2) {
	panic_any(VkError::NullFunctionPointer("vkGetGeneratedCommandsMemoryRequirementsEXT"))
}
/// trait for `VK_EXT_device_generated_commands`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_device_generated_commands.html>
pub trait VK_EXT_device_generated_commands: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetGeneratedCommandsMemoryRequirementsEXT.html>
	fn vkGetGeneratedCommandsMemoryRequirementsEXT(&self, device: VkDevice, pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoEXT, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()>;
}
/// struct for `VK_EXT_device_generated_commands`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_device_generated_commands {
	vk_get_generated_commands_memory_requirements_ext: PFN_vkGetGeneratedCommandsMemoryRequirementsEXT,
}
impl VK_EXT_device_generated_commands for Vulkan_EXT_device_generated_commands {
	fn vkGetGeneratedCommandsMemoryRequirementsEXT(&self, device: VkDevice, pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoEXT, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_get_generated_commands_memory_requirements_ext)(device, pInfo, pMemoryRequirements))))
	}
}
impl Default for Vulkan_EXT_device_generated_commands {
	fn default() -> Self {
		Self {
			vk_get_generated_commands_memory_requirements_ext: dummy_vkGetGeneratedCommandsMemoryRequirementsEXT,
		}
	}
}
impl Vulkan_EXT_device_generated_commands {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_generated_commands_memory_requirements_ext: {let proc = get_instance_proc_address(instance, "vkGetGeneratedCommandsMemoryRequirementsEXT"); if proc == null() {dummy_vkGetGeneratedCommandsMemoryRequirementsEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceImageAlignmentControlFeaturesMESA` from VK_MESA_image_alignment_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImageAlignmentControlFeaturesMESA.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceImageAlignmentControlFeaturesMESA {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub imageAlignmentControl: VkBool32,
}
impl Debug for VkPhysicalDeviceImageAlignmentControlFeaturesMESA {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceImageAlignmentControlFeaturesMESA")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("imageAlignmentControl", &self.imageAlignmentControl)
		.finish()
	}
}
/// struct `VkPhysicalDeviceImageAlignmentControlPropertiesMESA` from VK_MESA_image_alignment_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceImageAlignmentControlPropertiesMESA.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceImageAlignmentControlPropertiesMESA {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub supportedImageAlignmentMask: u32,
}
impl Debug for VkPhysicalDeviceImageAlignmentControlPropertiesMESA {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceImageAlignmentControlPropertiesMESA")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("supportedImageAlignmentMask", &self.supportedImageAlignmentMask)
		.finish()
	}
}
/// struct `VkImageAlignmentControlCreateInfoMESA` from VK_MESA_image_alignment_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageAlignmentControlCreateInfoMESA.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkImageAlignmentControlCreateInfoMESA {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maximumRequestedAlignment: u32,
}
impl Debug for VkImageAlignmentControlCreateInfoMESA {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkImageAlignmentControlCreateInfoMESA")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maximumRequestedAlignment", &self.maximumRequestedAlignment)
		.finish()
	}
}
/// trait for `VK_MESA_image_alignment_control`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_MESA_image_alignment_control.html>
pub trait VK_MESA_image_alignment_control: Debug {}
/// struct for `VK_MESA_image_alignment_control`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_MESA_image_alignment_control {}
impl VK_MESA_image_alignment_control for Vulkan_MESA_image_alignment_control {}
impl Default for Vulkan_MESA_image_alignment_control {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_MESA_image_alignment_control {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceDepthClampControlFeaturesEXT` from VK_EXT_depth_clamp_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceDepthClampControlFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceDepthClampControlFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub depthClampControl: VkBool32,
}
impl Debug for VkPhysicalDeviceDepthClampControlFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceDepthClampControlFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("depthClampControl", &self.depthClampControl)
		.finish()
	}
}
/// struct `VkPipelineViewportDepthClampControlCreateInfoEXT` from VK_EXT_depth_clamp_control
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineViewportDepthClampControlCreateInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineViewportDepthClampControlCreateInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub depthClampMode: VkDepthClampModeEXT,
	pub pDepthClampRange: *const VkDepthClampRangeEXT,
}
impl Debug for VkPipelineViewportDepthClampControlCreateInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineViewportDepthClampControlCreateInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("depthClampMode", &self.depthClampMode)
		.field("pDepthClampRange", &self.pDepthClampRange)
		.finish()
	}
}
/// trait for `VK_EXT_depth_clamp_control`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_depth_clamp_control.html>
pub trait VK_EXT_depth_clamp_control: Debug {}
/// struct for `VK_EXT_depth_clamp_control`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_depth_clamp_control {}
impl VK_EXT_depth_clamp_control for Vulkan_EXT_depth_clamp_control {}
impl Default for Vulkan_EXT_depth_clamp_control {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_depth_clamp_control {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceHdrVividFeaturesHUAWEI` from VK_HUAWEI_hdr_vivid
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceHdrVividFeaturesHUAWEI.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceHdrVividFeaturesHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub hdrVivid: VkBool32,
}
impl Debug for VkPhysicalDeviceHdrVividFeaturesHUAWEI {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceHdrVividFeaturesHUAWEI")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("hdrVivid", &self.hdrVivid)
		.finish()
	}
}
/// struct `VkHdrVividDynamicMetadataHUAWEI` from VK_HUAWEI_hdr_vivid
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkHdrVividDynamicMetadataHUAWEI.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkHdrVividDynamicMetadataHUAWEI {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub dynamicMetadataSize: usize,
	pub pDynamicMetadata: *const c_void,
}
impl Debug for VkHdrVividDynamicMetadataHUAWEI {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkHdrVividDynamicMetadataHUAWEI")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("dynamicMetadataSize", &self.dynamicMetadataSize)
		.field("pDynamicMetadata", &self.pDynamicMetadata)
		.finish()
	}
}
/// trait for `VK_HUAWEI_hdr_vivid`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_HUAWEI_hdr_vivid.html>
pub trait VK_HUAWEI_hdr_vivid: Debug {}
/// struct for `VK_HUAWEI_hdr_vivid`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_HUAWEI_hdr_vivid {}
impl VK_HUAWEI_hdr_vivid for Vulkan_HUAWEI_hdr_vivid {}
impl Default for Vulkan_HUAWEI_hdr_vivid {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_HUAWEI_hdr_vivid {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkCooperativeMatrixFlexibleDimensionsPropertiesNV` from VK_NV_cooperative_matrix2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCooperativeMatrixFlexibleDimensionsPropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCooperativeMatrixFlexibleDimensionsPropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub MGranularity: u32,
	pub NGranularity: u32,
	pub KGranularity: u32,
	pub AType: VkComponentTypeKHR,
	pub BType: VkComponentTypeKHR,
	pub CType: VkComponentTypeKHR,
	pub ResultType: VkComponentTypeKHR,
	pub saturatingAccumulation: VkBool32,
	pub scope: VkScopeKHR,
	pub workgroupInvocations: u32,
}
impl Debug for VkCooperativeMatrixFlexibleDimensionsPropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCooperativeMatrixFlexibleDimensionsPropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("MGranularity", &self.MGranularity)
		.field("NGranularity", &self.NGranularity)
		.field("KGranularity", &self.KGranularity)
		.field("AType", &self.AType)
		.field("BType", &self.BType)
		.field("CType", &self.CType)
		.field("ResultType", &self.ResultType)
		.field("saturatingAccumulation", &self.saturatingAccumulation)
		.field("scope", &self.scope)
		.field("workgroupInvocations", &self.workgroupInvocations)
		.finish()
	}
}
/// struct `VkPhysicalDeviceCooperativeMatrix2FeaturesNV` from VK_NV_cooperative_matrix2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCooperativeMatrix2FeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCooperativeMatrix2FeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cooperativeMatrixWorkgroupScope: VkBool32,
	pub cooperativeMatrixFlexibleDimensions: VkBool32,
	pub cooperativeMatrixReductions: VkBool32,
	pub cooperativeMatrixConversions: VkBool32,
	pub cooperativeMatrixPerElementOperations: VkBool32,
	pub cooperativeMatrixTensorAddressing: VkBool32,
	pub cooperativeMatrixBlockLoads: VkBool32,
}
impl Debug for VkPhysicalDeviceCooperativeMatrix2FeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCooperativeMatrix2FeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("cooperativeMatrixWorkgroupScope", &self.cooperativeMatrixWorkgroupScope)
		.field("cooperativeMatrixFlexibleDimensions", &self.cooperativeMatrixFlexibleDimensions)
		.field("cooperativeMatrixReductions", &self.cooperativeMatrixReductions)
		.field("cooperativeMatrixConversions", &self.cooperativeMatrixConversions)
		.field("cooperativeMatrixPerElementOperations", &self.cooperativeMatrixPerElementOperations)
		.field("cooperativeMatrixTensorAddressing", &self.cooperativeMatrixTensorAddressing)
		.field("cooperativeMatrixBlockLoads", &self.cooperativeMatrixBlockLoads)
		.finish()
	}
}
/// struct `VkPhysicalDeviceCooperativeMatrix2PropertiesNV` from VK_NV_cooperative_matrix2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceCooperativeMatrix2PropertiesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceCooperativeMatrix2PropertiesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub cooperativeMatrixWorkgroupScopeMaxWorkgroupSize: u32,
	pub cooperativeMatrixFlexibleDimensionsMaxDimension: u32,
	pub cooperativeMatrixWorkgroupScopeReservedSharedMemory: u32,
}
impl Debug for VkPhysicalDeviceCooperativeMatrix2PropertiesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceCooperativeMatrix2PropertiesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("cooperativeMatrixWorkgroupScopeMaxWorkgroupSize", &self.cooperativeMatrixWorkgroupScopeMaxWorkgroupSize)
		.field("cooperativeMatrixFlexibleDimensionsMaxDimension", &self.cooperativeMatrixFlexibleDimensionsMaxDimension)
		.field("cooperativeMatrixWorkgroupScopeReservedSharedMemory", &self.cooperativeMatrixWorkgroupScopeReservedSharedMemory)
		.finish()
	}
}
/// function prototype `PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV` from VK_NV_cooperative_matrix2
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV.html>
type PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV = extern "system" fn(physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixFlexibleDimensionsPropertiesNV) -> VkResult;
/// The dummy function for `vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV` from `VK_NV_cooperative_matrix2`
extern "system" fn dummy_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(_: VkPhysicalDevice, _: *mut uint32_t, _: *mut VkCooperativeMatrixFlexibleDimensionsPropertiesNV) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV"))
}
/// trait for `VK_NV_cooperative_matrix2`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_cooperative_matrix2.html>
pub trait VK_NV_cooperative_matrix2: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV.html>
	fn vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixFlexibleDimensionsPropertiesNV) -> Result<()>;
}
/// struct for `VK_NV_cooperative_matrix2`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_cooperative_matrix2 {
	vk_get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv: PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV,
}
impl VK_NV_cooperative_matrix2 for Vulkan_NV_cooperative_matrix2 {
	fn vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixFlexibleDimensionsPropertiesNV) -> Result<()> {
		convert_result("vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV", catch_unwind(||((self.vk_get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv)(physicalDevice, pPropertyCount, pProperties))))
	}
}
impl Default for Vulkan_NV_cooperative_matrix2 {
	fn default() -> Self {
		Self {
			vk_get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv: dummy_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV,
		}
	}
}
impl Vulkan_NV_cooperative_matrix2 {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv: {let proc = get_instance_proc_address(instance, "vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV"); if proc == null() {dummy_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDevicePipelineOpacityMicromapFeaturesARM` from VK_ARM_pipeline_opacity_micromap
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePipelineOpacityMicromapFeaturesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePipelineOpacityMicromapFeaturesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineOpacityMicromap: VkBool32,
}
impl Debug for VkPhysicalDevicePipelineOpacityMicromapFeaturesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePipelineOpacityMicromapFeaturesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelineOpacityMicromap", &self.pipelineOpacityMicromap)
		.finish()
	}
}
/// trait for `VK_ARM_pipeline_opacity_micromap`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_ARM_pipeline_opacity_micromap.html>
pub trait VK_ARM_pipeline_opacity_micromap: Debug {}
/// struct for `VK_ARM_pipeline_opacity_micromap`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_pipeline_opacity_micromap {}
impl VK_ARM_pipeline_opacity_micromap for Vulkan_ARM_pipeline_opacity_micromap {}
impl Default for Vulkan_ARM_pipeline_opacity_micromap {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_ARM_pipeline_opacity_micromap {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT` from VK_EXT_vertex_attribute_robustness
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub vertexAttributeRobustness: VkBool32,
}
impl Debug for VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("vertexAttributeRobustness", &self.vertexAttributeRobustness)
		.finish()
	}
}
/// trait for `VK_EXT_vertex_attribute_robustness`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_vertex_attribute_robustness.html>
pub trait VK_EXT_vertex_attribute_robustness: Debug {}
/// struct for `VK_EXT_vertex_attribute_robustness`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_vertex_attribute_robustness {}
impl VK_EXT_vertex_attribute_robustness for Vulkan_EXT_vertex_attribute_robustness {}
impl Default for Vulkan_EXT_vertex_attribute_robustness {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_vertex_attribute_robustness {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceFormatPackFeaturesARM` from VK_ARM_format_pack
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFormatPackFeaturesARM.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFormatPackFeaturesARM {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub formatPack: VkBool32,
}
impl Debug for VkPhysicalDeviceFormatPackFeaturesARM {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFormatPackFeaturesARM")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("formatPack", &self.formatPack)
		.finish()
	}
}
/// trait for `VK_ARM_format_pack`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_ARM_format_pack.html>
pub trait VK_ARM_format_pack: Debug {}
/// struct for `VK_ARM_format_pack`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_ARM_format_pack {}
impl VK_ARM_format_pack for Vulkan_ARM_format_pack {}
impl Default for Vulkan_ARM_format_pack {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_ARM_format_pack {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE` from VK_VALVE_fragment_density_map_layered
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub fragmentDensityMapLayered: VkBool32,
}
impl Debug for VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("fragmentDensityMapLayered", &self.fragmentDensityMapLayered)
		.finish()
	}
}
/// struct `VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE` from VK_VALVE_fragment_density_map_layered
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxFragmentDensityMapLayers: u32,
}
impl Debug for VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxFragmentDensityMapLayers", &self.maxFragmentDensityMapLayers)
		.finish()
	}
}
/// struct `VkPipelineFragmentDensityMapLayeredCreateInfoVALVE` from VK_VALVE_fragment_density_map_layered
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineFragmentDensityMapLayeredCreateInfoVALVE.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPipelineFragmentDensityMapLayeredCreateInfoVALVE {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maxFragmentDensityMapLayers: u32,
}
impl Debug for VkPipelineFragmentDensityMapLayeredCreateInfoVALVE {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPipelineFragmentDensityMapLayeredCreateInfoVALVE")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxFragmentDensityMapLayers", &self.maxFragmentDensityMapLayers)
		.finish()
	}
}
/// trait for `VK_VALVE_fragment_density_map_layered`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_VALVE_fragment_density_map_layered.html>
pub trait VK_VALVE_fragment_density_map_layered: Debug {}
/// struct for `VK_VALVE_fragment_density_map_layered`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_VALVE_fragment_density_map_layered {}
impl VK_VALVE_fragment_density_map_layered for Vulkan_VALVE_fragment_density_map_layered {}
impl Default for Vulkan_VALVE_fragment_density_map_layered {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_VALVE_fragment_density_map_layered {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkSetPresentConfigNV` from VK_NV_present_metering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkSetPresentConfigNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkSetPresentConfigNV {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub numFramesPerBatch: u32,
	pub presentConfigFeedback: u32,
}
impl Debug for VkSetPresentConfigNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkSetPresentConfigNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("numFramesPerBatch", &self.numFramesPerBatch)
		.field("presentConfigFeedback", &self.presentConfigFeedback)
		.finish()
	}
}
/// struct `VkPhysicalDevicePresentMeteringFeaturesNV` from VK_NV_present_metering
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePresentMeteringFeaturesNV.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePresentMeteringFeaturesNV {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub presentMetering: VkBool32,
}
impl Debug for VkPhysicalDevicePresentMeteringFeaturesNV {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePresentMeteringFeaturesNV")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("presentMetering", &self.presentMetering)
		.finish()
	}
}
/// trait for `VK_NV_present_metering`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_NV_present_metering.html>
pub trait VK_NV_present_metering: Debug {}
/// struct for `VK_NV_present_metering`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_NV_present_metering {}
impl VK_NV_present_metering for Vulkan_NV_present_metering {}
impl Default for Vulkan_NV_present_metering {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_NV_present_metering {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkRenderingEndInfoEXT` from VK_EXT_fragment_density_map_offset
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderingEndInfoEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRenderingEndInfoEXT {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
}
impl Debug for VkRenderingEndInfoEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRenderingEndInfoEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.finish()
	}
}
/// function prototype `PFN_vkCmdEndRendering2EXT` from VK_EXT_fragment_density_map_offset
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRendering2EXT.html>
type PFN_vkCmdEndRendering2EXT = extern "system" fn(commandBuffer: VkCommandBuffer, pRenderingEndInfo: *const VkRenderingEndInfoEXT);
/// The dummy function for `vkCmdEndRendering2EXT` from `VK_EXT_fragment_density_map_offset`
extern "system" fn dummy_vkCmdEndRendering2EXT(_: VkCommandBuffer, _: *const VkRenderingEndInfoEXT) {
	panic_any(VkError::NullFunctionPointer("vkCmdEndRendering2EXT"))
}
/// trait for `VK_EXT_fragment_density_map_offset`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_fragment_density_map_offset.html>
pub trait VK_EXT_fragment_density_map_offset: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRendering2EXT.html>
	fn vkCmdEndRendering2EXT(&self, commandBuffer: VkCommandBuffer, pRenderingEndInfo: *const VkRenderingEndInfoEXT) -> Result<()>;
}
/// struct for `VK_EXT_fragment_density_map_offset`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_fragment_density_map_offset {
	vk_cmd_end_rendering2_ext: PFN_vkCmdEndRendering2EXT,
}
impl VK_EXT_fragment_density_map_offset for Vulkan_EXT_fragment_density_map_offset {
	fn vkCmdEndRendering2EXT(&self, commandBuffer: VkCommandBuffer, pRenderingEndInfo: *const VkRenderingEndInfoEXT) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_end_rendering2_ext)(commandBuffer, pRenderingEndInfo))))
	}
}
impl Default for Vulkan_EXT_fragment_density_map_offset {
	fn default() -> Self {
		Self {
			vk_cmd_end_rendering2_ext: dummy_vkCmdEndRendering2EXT,
		}
	}
}
impl Vulkan_EXT_fragment_density_map_offset {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_end_rendering2_ext: {let proc = get_instance_proc_address(instance, "vkCmdEndRendering2EXT"); if proc == null() {dummy_vkCmdEndRendering2EXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT` from VK_EXT_zero_initialize_device_memory
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub zeroInitializeDeviceMemory: VkBool32,
}
impl Debug for VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("zeroInitializeDeviceMemory", &self.zeroInitializeDeviceMemory)
		.finish()
	}
}
/// trait for `VK_EXT_zero_initialize_device_memory`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_zero_initialize_device_memory.html>
pub trait VK_EXT_zero_initialize_device_memory: Debug {}
/// struct for `VK_EXT_zero_initialize_device_memory`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_zero_initialize_device_memory {}
impl VK_EXT_zero_initialize_device_memory for Vulkan_EXT_zero_initialize_device_memory {}
impl Default for Vulkan_EXT_zero_initialize_device_memory {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_EXT_zero_initialize_device_memory {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC` from VK_SEC_pipeline_cache_incremental_mode
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub pipelineCacheIncrementalMode: VkBool32,
}
impl Debug for VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pipelineCacheIncrementalMode", &self.pipelineCacheIncrementalMode)
		.finish()
	}
}
/// trait for `VK_SEC_pipeline_cache_incremental_mode`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_SEC_pipeline_cache_incremental_mode.html>
pub trait VK_SEC_pipeline_cache_incremental_mode: Debug {}
/// struct for `VK_SEC_pipeline_cache_incremental_mode`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_SEC_pipeline_cache_incremental_mode {}
impl VK_SEC_pipeline_cache_incremental_mode for Vulkan_SEC_pipeline_cache_incremental_mode {}
impl Default for Vulkan_SEC_pipeline_cache_incremental_mode {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_SEC_pipeline_cache_incremental_mode {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// type definition `VkAccelerationStructureCreateFlagsKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureCreateFlagsKHR.html>
pub type VkAccelerationStructureCreateFlagsKHR = VkFlags;
/// enum `VkBuildAccelerationStructureModeKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkBuildAccelerationStructureModeKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkBuildAccelerationStructureModeKHR {
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = 0,
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = 1,
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR = 0x7fffffff,
}
/// enum `VkAccelerationStructureCreateFlagBitsKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureCreateFlagBitsKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkAccelerationStructureCreateFlagBitsKHR {
	VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 0x00000001,
	VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000008,
	VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV = 0x00000004,
	VK_ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff,
}
/// union `VkAccelerationStructureGeometryDataKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryDataKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub union VkAccelerationStructureGeometryDataKHR {
	pub triangles: VkAccelerationStructureGeometryTrianglesDataKHR,
	pub aabbs: VkAccelerationStructureGeometryAabbsDataKHR,
	pub instances: VkAccelerationStructureGeometryInstancesDataKHR,
}
impl Debug for VkAccelerationStructureGeometryDataKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureGeometryDataKHR")
		.field("triangles", unsafe {&self.triangles})
		.field("aabbs", unsafe {&self.aabbs})
		.field("instances", unsafe {&self.instances})
		.finish()
	}
}
/// struct `VkAccelerationStructureBuildRangeInfoKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildRangeInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureBuildRangeInfoKHR {
	pub primitiveCount: u32,
	pub primitiveOffset: u32,
	pub firstVertex: u32,
	pub transformOffset: u32,
}
impl Debug for VkAccelerationStructureBuildRangeInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureBuildRangeInfoKHR")
		.field("primitiveCount", &self.primitiveCount)
		.field("primitiveOffset", &self.primitiveOffset)
		.field("firstVertex", &self.firstVertex)
		.field("transformOffset", &self.transformOffset)
		.finish()
	}
}
/// struct `VkAccelerationStructureGeometryTrianglesDataKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryTrianglesDataKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureGeometryTrianglesDataKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub vertexFormat: VkFormat,
	pub vertexData: VkDeviceOrHostAddressConstKHR,
	pub vertexStride: VkDeviceSize,
	pub maxVertex: u32,
	pub indexType: VkIndexType,
	pub indexData: VkDeviceOrHostAddressConstKHR,
	pub transformData: VkDeviceOrHostAddressConstKHR,
}
impl Debug for VkAccelerationStructureGeometryTrianglesDataKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureGeometryTrianglesDataKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("vertexFormat", &self.vertexFormat)
		.field("vertexData", &self.vertexData)
		.field("vertexStride", &self.vertexStride)
		.field("maxVertex", &self.maxVertex)
		.field("indexType", &self.indexType)
		.field("indexData", &self.indexData)
		.field("transformData", &self.transformData)
		.finish()
	}
}
/// struct `VkAccelerationStructureGeometryAabbsDataKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryAabbsDataKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureGeometryAabbsDataKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub data: VkDeviceOrHostAddressConstKHR,
	pub stride: VkDeviceSize,
}
impl Debug for VkAccelerationStructureGeometryAabbsDataKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureGeometryAabbsDataKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("data", &self.data)
		.field("stride", &self.stride)
		.finish()
	}
}
/// struct `VkAccelerationStructureGeometryInstancesDataKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryInstancesDataKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureGeometryInstancesDataKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub arrayOfPointers: VkBool32,
	pub data: VkDeviceOrHostAddressConstKHR,
}
impl Debug for VkAccelerationStructureGeometryInstancesDataKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureGeometryInstancesDataKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("arrayOfPointers", &self.arrayOfPointers)
		.field("data", &self.data)
		.finish()
	}
}
/// struct `VkAccelerationStructureGeometryKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureGeometryKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureGeometryKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub geometryType: VkGeometryTypeKHR,
	pub geometry: VkAccelerationStructureGeometryDataKHR,
	pub flags: VkGeometryFlagsKHR,
}
impl Debug for VkAccelerationStructureGeometryKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureGeometryKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("geometryType", &self.geometryType)
		.field("geometry", &self.geometry)
		.field("flags", &self.flags)
		.finish()
	}
}
/// struct `VkAccelerationStructureBuildGeometryInfoKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureBuildGeometryInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureBuildGeometryInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkAccelerationStructureTypeKHR,
	pub flags: VkBuildAccelerationStructureFlagsKHR,
	pub mode: VkBuildAccelerationStructureModeKHR,
	pub srcAccelerationStructure: VkAccelerationStructureKHR,
	pub dstAccelerationStructure: VkAccelerationStructureKHR,
	pub geometryCount: u32,
	pub pGeometries: *const VkAccelerationStructureGeometryKHR,
	pub ppGeometries: *const *const VkAccelerationStructureGeometryKHR,
	pub scratchData: VkDeviceOrHostAddressKHR,
}
impl Debug for VkAccelerationStructureBuildGeometryInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureBuildGeometryInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("type_", &self.type_)
		.field("flags", &self.flags)
		.field("mode", &self.mode)
		.field("srcAccelerationStructure", &self.srcAccelerationStructure)
		.field("dstAccelerationStructure", &self.dstAccelerationStructure)
		.field("geometryCount", &self.geometryCount)
		.field("pGeometries", &self.pGeometries)
		.field("ppGeometries", &self.ppGeometries)
		.field("scratchData", &self.scratchData)
		.finish()
	}
}
/// struct `VkAccelerationStructureCreateInfoKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub createFlags: VkAccelerationStructureCreateFlagsKHR,
	pub buffer: VkBuffer,
	pub offset: VkDeviceSize,
	pub size: VkDeviceSize,
	pub type_: VkAccelerationStructureTypeKHR,
	pub deviceAddress: VkDeviceAddress,
}
impl Debug for VkAccelerationStructureCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("createFlags", &self.createFlags)
		.field("buffer", &self.buffer)
		.field("offset", &self.offset)
		.field("size", &self.size)
		.field("type_", &self.type_)
		.field("deviceAddress", &self.deviceAddress)
		.finish()
	}
}
/// struct `VkWriteDescriptorSetAccelerationStructureKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkWriteDescriptorSetAccelerationStructureKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkWriteDescriptorSetAccelerationStructureKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub accelerationStructureCount: u32,
	pub pAccelerationStructures: *const VkAccelerationStructureKHR,
}
impl Debug for VkWriteDescriptorSetAccelerationStructureKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkWriteDescriptorSetAccelerationStructureKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("accelerationStructureCount", &self.accelerationStructureCount)
		.field("pAccelerationStructures", &self.pAccelerationStructures)
		.finish()
	}
}
/// struct `VkPhysicalDeviceAccelerationStructureFeaturesKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceAccelerationStructureFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceAccelerationStructureFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub accelerationStructure: VkBool32,
	pub accelerationStructureCaptureReplay: VkBool32,
	pub accelerationStructureIndirectBuild: VkBool32,
	pub accelerationStructureHostCommands: VkBool32,
	pub descriptorBindingAccelerationStructureUpdateAfterBind: VkBool32,
}
impl Debug for VkPhysicalDeviceAccelerationStructureFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceAccelerationStructureFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("accelerationStructure", &self.accelerationStructure)
		.field("accelerationStructureCaptureReplay", &self.accelerationStructureCaptureReplay)
		.field("accelerationStructureIndirectBuild", &self.accelerationStructureIndirectBuild)
		.field("accelerationStructureHostCommands", &self.accelerationStructureHostCommands)
		.field("descriptorBindingAccelerationStructureUpdateAfterBind", &self.descriptorBindingAccelerationStructureUpdateAfterBind)
		.finish()
	}
}
/// struct `VkPhysicalDeviceAccelerationStructurePropertiesKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceAccelerationStructurePropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceAccelerationStructurePropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxGeometryCount: u64,
	pub maxInstanceCount: u64,
	pub maxPrimitiveCount: u64,
	pub maxPerStageDescriptorAccelerationStructures: u32,
	pub maxPerStageDescriptorUpdateAfterBindAccelerationStructures: u32,
	pub maxDescriptorSetAccelerationStructures: u32,
	pub maxDescriptorSetUpdateAfterBindAccelerationStructures: u32,
	pub minAccelerationStructureScratchOffsetAlignment: u32,
}
impl Debug for VkPhysicalDeviceAccelerationStructurePropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceAccelerationStructurePropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxGeometryCount", &self.maxGeometryCount)
		.field("maxInstanceCount", &self.maxInstanceCount)
		.field("maxPrimitiveCount", &self.maxPrimitiveCount)
		.field("maxPerStageDescriptorAccelerationStructures", &self.maxPerStageDescriptorAccelerationStructures)
		.field("maxPerStageDescriptorUpdateAfterBindAccelerationStructures", &self.maxPerStageDescriptorUpdateAfterBindAccelerationStructures)
		.field("maxDescriptorSetAccelerationStructures", &self.maxDescriptorSetAccelerationStructures)
		.field("maxDescriptorSetUpdateAfterBindAccelerationStructures", &self.maxDescriptorSetUpdateAfterBindAccelerationStructures)
		.field("minAccelerationStructureScratchOffsetAlignment", &self.minAccelerationStructureScratchOffsetAlignment)
		.finish()
	}
}
/// struct `VkAccelerationStructureDeviceAddressInfoKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureDeviceAddressInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureDeviceAddressInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub accelerationStructure: VkAccelerationStructureKHR,
}
impl Debug for VkAccelerationStructureDeviceAddressInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureDeviceAddressInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("accelerationStructure", &self.accelerationStructure)
		.finish()
	}
}
/// struct `VkAccelerationStructureVersionInfoKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureVersionInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkAccelerationStructureVersionInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub pVersionData: *const uint8_t,
}
impl Debug for VkAccelerationStructureVersionInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkAccelerationStructureVersionInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("pVersionData", &self.pVersionData)
		.finish()
	}
}
/// struct `VkCopyAccelerationStructureToMemoryInfoKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyAccelerationStructureToMemoryInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyAccelerationStructureToMemoryInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub src: VkAccelerationStructureKHR,
	pub dst: VkDeviceOrHostAddressKHR,
	pub mode: VkCopyAccelerationStructureModeKHR,
}
impl Debug for VkCopyAccelerationStructureToMemoryInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyAccelerationStructureToMemoryInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("src", &self.src)
		.field("dst", &self.dst)
		.field("mode", &self.mode)
		.finish()
	}
}
/// struct `VkCopyMemoryToAccelerationStructureInfoKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyMemoryToAccelerationStructureInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyMemoryToAccelerationStructureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub src: VkDeviceOrHostAddressConstKHR,
	pub dst: VkAccelerationStructureKHR,
	pub mode: VkCopyAccelerationStructureModeKHR,
}
impl Debug for VkCopyMemoryToAccelerationStructureInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyMemoryToAccelerationStructureInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("src", &self.src)
		.field("dst", &self.dst)
		.field("mode", &self.mode)
		.finish()
	}
}
/// struct `VkCopyAccelerationStructureInfoKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkCopyAccelerationStructureInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkCopyAccelerationStructureInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub src: VkAccelerationStructureKHR,
	pub dst: VkAccelerationStructureKHR,
	pub mode: VkCopyAccelerationStructureModeKHR,
}
impl Debug for VkCopyAccelerationStructureInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkCopyAccelerationStructureInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("src", &self.src)
		.field("dst", &self.dst)
		.field("mode", &self.mode)
		.finish()
	}
}
/// function prototype `PFN_vkCreateAccelerationStructureKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAccelerationStructureKHR.html>
type PFN_vkCreateAccelerationStructureKHR = extern "system" fn(device: VkDevice, pCreateInfo: *const VkAccelerationStructureCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pAccelerationStructure: *mut VkAccelerationStructureKHR) -> VkResult;
/// function prototype `PFN_vkDestroyAccelerationStructureKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyAccelerationStructureKHR.html>
type PFN_vkDestroyAccelerationStructureKHR = extern "system" fn(device: VkDevice, accelerationStructure: VkAccelerationStructureKHR, pAllocator: *const VkAllocationCallbacks);
/// function prototype `PFN_vkCmdBuildAccelerationStructuresKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildAccelerationStructuresKHR.html>
type PFN_vkCmdBuildAccelerationStructuresKHR = extern "system" fn(commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *const VkAccelerationStructureBuildGeometryInfoKHR, ppBuildRangeInfos: *const *const VkAccelerationStructureBuildRangeInfoKHR);
/// function prototype `PFN_vkCmdBuildAccelerationStructuresIndirectKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildAccelerationStructuresIndirectKHR.html>
type PFN_vkCmdBuildAccelerationStructuresIndirectKHR = extern "system" fn(commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *const VkAccelerationStructureBuildGeometryInfoKHR, pIndirectDeviceAddresses: *const VkDeviceAddress, pIndirectStrides: *const uint32_t, ppMaxPrimitiveCounts: *const *const uint32_t);
/// function prototype `PFN_vkBuildAccelerationStructuresKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkBuildAccelerationStructuresKHR.html>
type PFN_vkBuildAccelerationStructuresKHR = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, infoCount: u32, pInfos: *const VkAccelerationStructureBuildGeometryInfoKHR, ppBuildRangeInfos: *const *const VkAccelerationStructureBuildRangeInfoKHR) -> VkResult;
/// function prototype `PFN_vkCopyAccelerationStructureKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyAccelerationStructureKHR.html>
type PFN_vkCopyAccelerationStructureKHR = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *const VkCopyAccelerationStructureInfoKHR) -> VkResult;
/// function prototype `PFN_vkCopyAccelerationStructureToMemoryKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyAccelerationStructureToMemoryKHR.html>
type PFN_vkCopyAccelerationStructureToMemoryKHR = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *const VkCopyAccelerationStructureToMemoryInfoKHR) -> VkResult;
/// function prototype `PFN_vkCopyMemoryToAccelerationStructureKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToAccelerationStructureKHR.html>
type PFN_vkCopyMemoryToAccelerationStructureKHR = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *const VkCopyMemoryToAccelerationStructureInfoKHR) -> VkResult;
/// function prototype `PFN_vkWriteAccelerationStructuresPropertiesKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkWriteAccelerationStructuresPropertiesKHR.html>
type PFN_vkWriteAccelerationStructuresPropertiesKHR = extern "system" fn(device: VkDevice, accelerationStructureCount: u32, pAccelerationStructures: *const VkAccelerationStructureKHR, queryType: VkQueryType, dataSize: usize, pData: *mut c_void, stride: usize) -> VkResult;
/// function prototype `PFN_vkCmdCopyAccelerationStructureKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyAccelerationStructureKHR.html>
type PFN_vkCmdCopyAccelerationStructureKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pInfo: *const VkCopyAccelerationStructureInfoKHR);
/// function prototype `PFN_vkCmdCopyAccelerationStructureToMemoryKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyAccelerationStructureToMemoryKHR.html>
type PFN_vkCmdCopyAccelerationStructureToMemoryKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pInfo: *const VkCopyAccelerationStructureToMemoryInfoKHR);
/// function prototype `PFN_vkCmdCopyMemoryToAccelerationStructureKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMemoryToAccelerationStructureKHR.html>
type PFN_vkCmdCopyMemoryToAccelerationStructureKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pInfo: *const VkCopyMemoryToAccelerationStructureInfoKHR);
/// function prototype `PFN_vkGetAccelerationStructureDeviceAddressKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureDeviceAddressKHR.html>
type PFN_vkGetAccelerationStructureDeviceAddressKHR = extern "system" fn(device: VkDevice, pInfo: *const VkAccelerationStructureDeviceAddressInfoKHR) -> VkDeviceAddress;
/// function prototype `PFN_vkCmdWriteAccelerationStructuresPropertiesKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteAccelerationStructuresPropertiesKHR.html>
type PFN_vkCmdWriteAccelerationStructuresPropertiesKHR = extern "system" fn(commandBuffer: VkCommandBuffer, accelerationStructureCount: u32, pAccelerationStructures: *const VkAccelerationStructureKHR, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: u32);
/// function prototype `PFN_vkGetDeviceAccelerationStructureCompatibilityKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceAccelerationStructureCompatibilityKHR.html>
type PFN_vkGetDeviceAccelerationStructureCompatibilityKHR = extern "system" fn(device: VkDevice, pVersionInfo: *const VkAccelerationStructureVersionInfoKHR, pCompatibility: *mut VkAccelerationStructureCompatibilityKHR);
/// function prototype `PFN_vkGetAccelerationStructureBuildSizesKHR` from VK_KHR_acceleration_structure
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureBuildSizesKHR.html>
type PFN_vkGetAccelerationStructureBuildSizesKHR = extern "system" fn(device: VkDevice, buildType: VkAccelerationStructureBuildTypeKHR, pBuildInfo: *const VkAccelerationStructureBuildGeometryInfoKHR, pMaxPrimitiveCounts: *const uint32_t, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR);
/// The dummy function for `vkCreateAccelerationStructureKHR` from `VK_KHR_acceleration_structure`
extern "system" fn dummy_vkCreateAccelerationStructureKHR(_: VkDevice, _: *const VkAccelerationStructureCreateInfoKHR, _: *const VkAllocationCallbacks, _: *mut VkAccelerationStructureKHR) -> VkResult {
	panic_any(VkError::NullFunctionPointer("vkCreateAccelerationStructureKHR"))
}
/// trait for `VK_KHR_acceleration_structure`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_acceleration_structure.html>
pub trait VK_KHR_acceleration_structure: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAccelerationStructureKHR.html>
	fn vkCreateAccelerationStructureKHR(&self, device: VkDevice, pCreateInfo: *const VkAccelerationStructureCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pAccelerationStructure: *mut VkAccelerationStructureKHR) -> Result<()>;
}
/// struct for `VK_KHR_acceleration_structure`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_acceleration_structure {
	vk_create_acceleration_structure_khr: PFN_vkCreateAccelerationStructureKHR,
}
impl VK_KHR_acceleration_structure for Vulkan_KHR_acceleration_structure {
	fn vkCreateAccelerationStructureKHR(&self, device: VkDevice, pCreateInfo: *const VkAccelerationStructureCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pAccelerationStructure: *mut VkAccelerationStructureKHR) -> Result<()> {
		convert_result("vkCreateAccelerationStructureKHR", catch_unwind(||((self.vk_create_acceleration_structure_khr)(device, pCreateInfo, pAllocator, pAccelerationStructure))))
	}
}
impl Default for Vulkan_KHR_acceleration_structure {
	fn default() -> Self {
		Self {
			vk_create_acceleration_structure_khr: dummy_vkCreateAccelerationStructureKHR,
		}
	}
}
impl Vulkan_KHR_acceleration_structure {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_create_acceleration_structure_khr: {let proc = get_instance_proc_address(instance, "vkCreateAccelerationStructureKHR"); if proc == null() {dummy_vkCreateAccelerationStructureKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// enum `VkShaderGroupShaderKHR` from VK_KHR_ray_tracing_pipeline
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderGroupShaderKHR.html>
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VkShaderGroupShaderKHR {
	VK_SHADER_GROUP_SHADER_GENERAL_KHR = 0,
	VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = 1,
	VK_SHADER_GROUP_SHADER_ANY_HIT_KHR = 2,
	VK_SHADER_GROUP_SHADER_INTERSECTION_KHR = 3,
	VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR = 0x7fffffff,
}
/// struct `VkRayTracingShaderGroupCreateInfoKHR` from VK_KHR_ray_tracing_pipeline
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRayTracingShaderGroupCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRayTracingShaderGroupCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub type_: VkRayTracingShaderGroupTypeKHR,
	pub generalShader: u32,
	pub closestHitShader: u32,
	pub anyHitShader: u32,
	pub intersectionShader: u32,
	pub pShaderGroupCaptureReplayHandle: *const c_void,
}
impl Debug for VkRayTracingShaderGroupCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRayTracingShaderGroupCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("type_", &self.type_)
		.field("generalShader", &self.generalShader)
		.field("closestHitShader", &self.closestHitShader)
		.field("anyHitShader", &self.anyHitShader)
		.field("intersectionShader", &self.intersectionShader)
		.field("pShaderGroupCaptureReplayHandle", &self.pShaderGroupCaptureReplayHandle)
		.finish()
	}
}
/// struct `VkRayTracingPipelineInterfaceCreateInfoKHR` from VK_KHR_ray_tracing_pipeline
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRayTracingPipelineInterfaceCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRayTracingPipelineInterfaceCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub maxPipelineRayPayloadSize: u32,
	pub maxPipelineRayHitAttributeSize: u32,
}
impl Debug for VkRayTracingPipelineInterfaceCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRayTracingPipelineInterfaceCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxPipelineRayPayloadSize", &self.maxPipelineRayPayloadSize)
		.field("maxPipelineRayHitAttributeSize", &self.maxPipelineRayHitAttributeSize)
		.finish()
	}
}
/// struct `VkRayTracingPipelineCreateInfoKHR` from VK_KHR_ray_tracing_pipeline
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkRayTracingPipelineCreateInfoKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkRayTracingPipelineCreateInfoKHR {
	pub sType: VkStructureType,
	pub pNext: *const c_void,
	pub flags: VkPipelineCreateFlags,
	pub stageCount: u32,
	pub pStages: *const VkPipelineShaderStageCreateInfo,
	pub groupCount: u32,
	pub pGroups: *const VkRayTracingShaderGroupCreateInfoKHR,
	pub maxPipelineRayRecursionDepth: u32,
	pub pLibraryInfo: *const VkPipelineLibraryCreateInfoKHR,
	pub pLibraryInterface: *const VkRayTracingPipelineInterfaceCreateInfoKHR,
	pub pDynamicState: *const VkPipelineDynamicStateCreateInfo,
	pub layout: VkPipelineLayout,
	pub basePipelineHandle: VkPipeline,
	pub basePipelineIndex: i32,
}
impl Debug for VkRayTracingPipelineCreateInfoKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkRayTracingPipelineCreateInfoKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("flags", &self.flags)
		.field("stageCount", &self.stageCount)
		.field("pStages", &self.pStages)
		.field("groupCount", &self.groupCount)
		.field("pGroups", &self.pGroups)
		.field("maxPipelineRayRecursionDepth", &self.maxPipelineRayRecursionDepth)
		.field("pLibraryInfo", &self.pLibraryInfo)
		.field("pLibraryInterface", &self.pLibraryInterface)
		.field("pDynamicState", &self.pDynamicState)
		.field("layout", &self.layout)
		.field("basePipelineHandle", &self.basePipelineHandle)
		.field("basePipelineIndex", &self.basePipelineIndex)
		.finish()
	}
}
/// struct `VkPhysicalDeviceRayTracingPipelineFeaturesKHR` from VK_KHR_ray_tracing_pipeline
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingPipelineFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rayTracingPipeline: VkBool32,
	pub rayTracingPipelineShaderGroupHandleCaptureReplay: VkBool32,
	pub rayTracingPipelineShaderGroupHandleCaptureReplayMixed: VkBool32,
	pub rayTracingPipelineTraceRaysIndirect: VkBool32,
	pub rayTraversalPrimitiveCulling: VkBool32,
}
impl Debug for VkPhysicalDeviceRayTracingPipelineFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRayTracingPipelineFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("rayTracingPipeline", &self.rayTracingPipeline)
		.field("rayTracingPipelineShaderGroupHandleCaptureReplay", &self.rayTracingPipelineShaderGroupHandleCaptureReplay)
		.field("rayTracingPipelineShaderGroupHandleCaptureReplayMixed", &self.rayTracingPipelineShaderGroupHandleCaptureReplayMixed)
		.field("rayTracingPipelineTraceRaysIndirect", &self.rayTracingPipelineTraceRaysIndirect)
		.field("rayTraversalPrimitiveCulling", &self.rayTraversalPrimitiveCulling)
		.finish()
	}
}
/// struct `VkPhysicalDeviceRayTracingPipelinePropertiesKHR` from VK_KHR_ray_tracing_pipeline
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRayTracingPipelinePropertiesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRayTracingPipelinePropertiesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub shaderGroupHandleSize: u32,
	pub maxRayRecursionDepth: u32,
	pub maxShaderGroupStride: u32,
	pub shaderGroupBaseAlignment: u32,
	pub shaderGroupHandleCaptureReplaySize: u32,
	pub maxRayDispatchInvocationCount: u32,
	pub shaderGroupHandleAlignment: u32,
	pub maxRayHitAttributeSize: u32,
}
impl Debug for VkPhysicalDeviceRayTracingPipelinePropertiesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRayTracingPipelinePropertiesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("shaderGroupHandleSize", &self.shaderGroupHandleSize)
		.field("maxRayRecursionDepth", &self.maxRayRecursionDepth)
		.field("maxShaderGroupStride", &self.maxShaderGroupStride)
		.field("shaderGroupBaseAlignment", &self.shaderGroupBaseAlignment)
		.field("shaderGroupHandleCaptureReplaySize", &self.shaderGroupHandleCaptureReplaySize)
		.field("maxRayDispatchInvocationCount", &self.maxRayDispatchInvocationCount)
		.field("shaderGroupHandleAlignment", &self.shaderGroupHandleAlignment)
		.field("maxRayHitAttributeSize", &self.maxRayHitAttributeSize)
		.finish()
	}
}
/// struct `VkTraceRaysIndirectCommandKHR` from VK_KHR_ray_tracing_pipeline
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkTraceRaysIndirectCommandKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkTraceRaysIndirectCommandKHR {
	pub width: u32,
	pub height: u32,
	pub depth: u32,
}
impl Debug for VkTraceRaysIndirectCommandKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkTraceRaysIndirectCommandKHR")
		.field("width", &self.width)
		.field("height", &self.height)
		.field("depth", &self.depth)
		.finish()
	}
}
/// function prototype `PFN_vkCmdTraceRaysKHR` from VK_KHR_ray_tracing_pipeline
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdTraceRaysKHR.html>
type PFN_vkCmdTraceRaysKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, width: u32, height: u32, depth: u32);
/// function prototype `PFN_vkCreateRayTracingPipelinesKHR` from VK_KHR_ray_tracing_pipeline
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesKHR.html>
type PFN_vkCreateRayTracingPipelinesKHR = extern "system" fn(device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkRayTracingPipelineCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> VkResult;
/// function prototype `PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR` from VK_KHR_ray_tracing_pipeline
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.html>
type PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = extern "system" fn(device: VkDevice, pipeline: VkPipeline, firstGroup: u32, groupCount: u32, dataSize: usize, pData: *mut c_void) -> VkResult;
/// function prototype `PFN_vkCmdTraceRaysIndirectKHR` from VK_KHR_ray_tracing_pipeline
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdTraceRaysIndirectKHR.html>
type PFN_vkCmdTraceRaysIndirectKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, indirectDeviceAddress: VkDeviceAddress);
/// function prototype `PFN_vkGetRayTracingShaderGroupStackSizeKHR` from VK_KHR_ray_tracing_pipeline
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingShaderGroupStackSizeKHR.html>
type PFN_vkGetRayTracingShaderGroupStackSizeKHR = extern "system" fn(device: VkDevice, pipeline: VkPipeline, group: u32, groupShader: VkShaderGroupShaderKHR) -> VkDeviceSize;
/// function prototype `PFN_vkCmdSetRayTracingPipelineStackSizeKHR` from VK_KHR_ray_tracing_pipeline
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRayTracingPipelineStackSizeKHR.html>
type PFN_vkCmdSetRayTracingPipelineStackSizeKHR = extern "system" fn(commandBuffer: VkCommandBuffer, pipelineStackSize: u32);
/// The dummy function for `vkCmdTraceRaysKHR` from `VK_KHR_ray_tracing_pipeline`
extern "system" fn dummy_vkCmdTraceRaysKHR(_: VkCommandBuffer, _: *const VkStridedDeviceAddressRegionKHR, _: *const VkStridedDeviceAddressRegionKHR, _: *const VkStridedDeviceAddressRegionKHR, _: *const VkStridedDeviceAddressRegionKHR, _: u32, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdTraceRaysKHR"))
}
/// trait for `VK_KHR_ray_tracing_pipeline`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_ray_tracing_pipeline.html>
pub trait VK_KHR_ray_tracing_pipeline: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdTraceRaysKHR.html>
	fn vkCmdTraceRaysKHR(&self, commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, width: u32, height: u32, depth: u32) -> Result<()>;
}
/// struct for `VK_KHR_ray_tracing_pipeline`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_ray_tracing_pipeline {
	vk_cmd_trace_rays_khr: PFN_vkCmdTraceRaysKHR,
}
impl VK_KHR_ray_tracing_pipeline for Vulkan_KHR_ray_tracing_pipeline {
	fn vkCmdTraceRaysKHR(&self, commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, width: u32, height: u32, depth: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_trace_rays_khr)(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth))))
	}
}
impl Default for Vulkan_KHR_ray_tracing_pipeline {
	fn default() -> Self {
		Self {
			vk_cmd_trace_rays_khr: dummy_vkCmdTraceRaysKHR,
		}
	}
}
impl Vulkan_KHR_ray_tracing_pipeline {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_trace_rays_khr: {let proc = get_instance_proc_address(instance, "vkCmdTraceRaysKHR"); if proc == null() {dummy_vkCmdTraceRaysKHR} else {unsafe {transmute(proc)}}},
		}
	}
}
/// struct `VkPhysicalDeviceRayQueryFeaturesKHR` from VK_KHR_ray_query
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceRayQueryFeaturesKHR.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceRayQueryFeaturesKHR {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub rayQuery: VkBool32,
}
impl Debug for VkPhysicalDeviceRayQueryFeaturesKHR {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceRayQueryFeaturesKHR")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("rayQuery", &self.rayQuery)
		.finish()
	}
}
/// trait for `VK_KHR_ray_query`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_KHR_ray_query.html>
pub trait VK_KHR_ray_query: Debug {}
/// struct for `VK_KHR_ray_query`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_KHR_ray_query {}
impl VK_KHR_ray_query for Vulkan_KHR_ray_query {}
impl Default for Vulkan_KHR_ray_query {
	fn default() -> Self {
		Self {}
	}
}
impl Vulkan_KHR_ray_query {
	pub fn new(_instance: VkInstance, _get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {}
	}
}
/// struct `VkPhysicalDeviceMeshShaderFeaturesEXT` from VK_EXT_mesh_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMeshShaderFeaturesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMeshShaderFeaturesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub taskShader: VkBool32,
	pub meshShader: VkBool32,
	pub multiviewMeshShader: VkBool32,
	pub primitiveFragmentShadingRateMeshShader: VkBool32,
	pub meshShaderQueries: VkBool32,
}
impl Debug for VkPhysicalDeviceMeshShaderFeaturesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMeshShaderFeaturesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("taskShader", &self.taskShader)
		.field("meshShader", &self.meshShader)
		.field("multiviewMeshShader", &self.multiviewMeshShader)
		.field("primitiveFragmentShadingRateMeshShader", &self.primitiveFragmentShadingRateMeshShader)
		.field("meshShaderQueries", &self.meshShaderQueries)
		.finish()
	}
}
/// struct `VkPhysicalDeviceMeshShaderPropertiesEXT` from VK_EXT_mesh_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceMeshShaderPropertiesEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkPhysicalDeviceMeshShaderPropertiesEXT {
	pub sType: VkStructureType,
	pub pNext: *mut c_void,
	pub maxTaskWorkGroupTotalCount: u32,
	pub maxTaskWorkGroupCount: [u32; 3 as usize],
	pub maxTaskWorkGroupInvocations: u32,
	pub maxTaskWorkGroupSize: [u32; 3 as usize],
	pub maxTaskPayloadSize: u32,
	pub maxTaskSharedMemorySize: u32,
	pub maxTaskPayloadAndSharedMemorySize: u32,
	pub maxMeshWorkGroupTotalCount: u32,
	pub maxMeshWorkGroupCount: [u32; 3 as usize],
	pub maxMeshWorkGroupInvocations: u32,
	pub maxMeshWorkGroupSize: [u32; 3 as usize],
	pub maxMeshSharedMemorySize: u32,
	pub maxMeshPayloadAndSharedMemorySize: u32,
	pub maxMeshOutputMemorySize: u32,
	pub maxMeshPayloadAndOutputMemorySize: u32,
	pub maxMeshOutputComponents: u32,
	pub maxMeshOutputVertices: u32,
	pub maxMeshOutputPrimitives: u32,
	pub maxMeshOutputLayers: u32,
	pub maxMeshMultiviewViewCount: u32,
	pub meshOutputPerVertexGranularity: u32,
	pub meshOutputPerPrimitiveGranularity: u32,
	pub maxPreferredTaskWorkGroupInvocations: u32,
	pub maxPreferredMeshWorkGroupInvocations: u32,
	pub prefersLocalInvocationVertexOutput: VkBool32,
	pub prefersLocalInvocationPrimitiveOutput: VkBool32,
	pub prefersCompactVertexOutput: VkBool32,
	pub prefersCompactPrimitiveOutput: VkBool32,
}
impl Debug for VkPhysicalDeviceMeshShaderPropertiesEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkPhysicalDeviceMeshShaderPropertiesEXT")
		.field("sType", &self.sType)
		.field("pNext", &self.pNext)
		.field("maxTaskWorkGroupTotalCount", &self.maxTaskWorkGroupTotalCount)
		.field("maxTaskWorkGroupCount", &self.maxTaskWorkGroupCount)
		.field("maxTaskWorkGroupInvocations", &self.maxTaskWorkGroupInvocations)
		.field("maxTaskWorkGroupSize", &self.maxTaskWorkGroupSize)
		.field("maxTaskPayloadSize", &self.maxTaskPayloadSize)
		.field("maxTaskSharedMemorySize", &self.maxTaskSharedMemorySize)
		.field("maxTaskPayloadAndSharedMemorySize", &self.maxTaskPayloadAndSharedMemorySize)
		.field("maxMeshWorkGroupTotalCount", &self.maxMeshWorkGroupTotalCount)
		.field("maxMeshWorkGroupCount", &self.maxMeshWorkGroupCount)
		.field("maxMeshWorkGroupInvocations", &self.maxMeshWorkGroupInvocations)
		.field("maxMeshWorkGroupSize", &self.maxMeshWorkGroupSize)
		.field("maxMeshSharedMemorySize", &self.maxMeshSharedMemorySize)
		.field("maxMeshPayloadAndSharedMemorySize", &self.maxMeshPayloadAndSharedMemorySize)
		.field("maxMeshOutputMemorySize", &self.maxMeshOutputMemorySize)
		.field("maxMeshPayloadAndOutputMemorySize", &self.maxMeshPayloadAndOutputMemorySize)
		.field("maxMeshOutputComponents", &self.maxMeshOutputComponents)
		.field("maxMeshOutputVertices", &self.maxMeshOutputVertices)
		.field("maxMeshOutputPrimitives", &self.maxMeshOutputPrimitives)
		.field("maxMeshOutputLayers", &self.maxMeshOutputLayers)
		.field("maxMeshMultiviewViewCount", &self.maxMeshMultiviewViewCount)
		.field("meshOutputPerVertexGranularity", &self.meshOutputPerVertexGranularity)
		.field("meshOutputPerPrimitiveGranularity", &self.meshOutputPerPrimitiveGranularity)
		.field("maxPreferredTaskWorkGroupInvocations", &self.maxPreferredTaskWorkGroupInvocations)
		.field("maxPreferredMeshWorkGroupInvocations", &self.maxPreferredMeshWorkGroupInvocations)
		.field("prefersLocalInvocationVertexOutput", &self.prefersLocalInvocationVertexOutput)
		.field("prefersLocalInvocationPrimitiveOutput", &self.prefersLocalInvocationPrimitiveOutput)
		.field("prefersCompactVertexOutput", &self.prefersCompactVertexOutput)
		.field("prefersCompactPrimitiveOutput", &self.prefersCompactPrimitiveOutput)
		.finish()
	}
}
/// struct `VkDrawMeshTasksIndirectCommandEXT` from VK_EXT_mesh_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VkDrawMeshTasksIndirectCommandEXT.html>
#[repr(C)]
#[derive(Clone, Copy)]
pub struct VkDrawMeshTasksIndirectCommandEXT {
	pub groupCountX: u32,
	pub groupCountY: u32,
	pub groupCountZ: u32,
}
impl Debug for VkDrawMeshTasksIndirectCommandEXT {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		f.debug_struct("VkDrawMeshTasksIndirectCommandEXT")
		.field("groupCountX", &self.groupCountX)
		.field("groupCountY", &self.groupCountY)
		.field("groupCountZ", &self.groupCountZ)
		.finish()
	}
}
/// function prototype `PFN_vkCmdDrawMeshTasksEXT` from VK_EXT_mesh_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMeshTasksEXT.html>
type PFN_vkCmdDrawMeshTasksEXT = extern "system" fn(commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32);
/// function prototype `PFN_vkCmdDrawMeshTasksIndirectEXT` from VK_EXT_mesh_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMeshTasksIndirectEXT.html>
type PFN_vkCmdDrawMeshTasksIndirectEXT = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32);
/// function prototype `PFN_vkCmdDrawMeshTasksIndirectCountEXT` from VK_EXT_mesh_shader
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMeshTasksIndirectCountEXT.html>
type PFN_vkCmdDrawMeshTasksIndirectCountEXT = extern "system" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32);
/// The dummy function for `vkCmdDrawMeshTasksEXT` from `VK_EXT_mesh_shader`
extern "system" fn dummy_vkCmdDrawMeshTasksEXT(_: VkCommandBuffer, _: u32, _: u32, _: u32) {
	panic_any(VkError::NullFunctionPointer("vkCmdDrawMeshTasksEXT"))
}
/// trait for `VK_EXT_mesh_shader`
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_mesh_shader.html>
pub trait VK_EXT_mesh_shader: Debug {
/// - Reference: <https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMeshTasksEXT.html>
	fn vkCmdDrawMeshTasksEXT(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> Result<()>;
}
/// struct for `VK_EXT_mesh_shader`
#[derive(Debug, Clone, Copy)]
pub struct Vulkan_EXT_mesh_shader {
	vk_cmd_draw_mesh_tasks_ext: PFN_vkCmdDrawMeshTasksEXT,
}
impl VK_EXT_mesh_shader for Vulkan_EXT_mesh_shader {
	fn vkCmdDrawMeshTasksEXT(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_cmd_draw_mesh_tasks_ext)(commandBuffer, groupCountX, groupCountY, groupCountZ))))
	}
}
impl Default for Vulkan_EXT_mesh_shader {
	fn default() -> Self {
		Self {
			vk_cmd_draw_mesh_tasks_ext: dummy_vkCmdDrawMeshTasksEXT,
		}
	}
}
impl Vulkan_EXT_mesh_shader {
	pub fn new(instance: VkInstance, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		Self {
			vk_cmd_draw_mesh_tasks_ext: {let proc = get_instance_proc_address(instance, "vkCmdDrawMeshTasksEXT"); if proc == null() {dummy_vkCmdDrawMeshTasksEXT} else {unsafe {transmute(proc)}}},
		}
	}
}
/// The all-in-one struct for your Vulkan APIs
#[derive(Default, Debug, Clone)]
pub struct VkCore {
	/// The Vulkan instance
	pub instance: VkInstance,
	/// The Vulkan extension strings
	pub extensions: BTreeSet<String>,
	/// Create the all-in-one struct for your Vulkan APIs by a `get_instance_proc_address()` function
	/// You have to provide the `VkApplicationInfo` struct to specify your application info
	/// You can use `vk_make_version()`/`vk_make_api_version()` from this crate
	/// Subset of VK_VERSION_1_0
	pub vk_version_1_0: Vulkan_VERSION_1_0,
	/// Subset of VK_VERSION_1_1
	pub vk_version_1_1: Vulkan_VERSION_1_1,
	/// Subset of VK_VERSION_1_2
	pub vk_version_1_2: Vulkan_VERSION_1_2,
	/// Subset of VK_VERSION_1_3
	pub vk_version_1_3: Vulkan_VERSION_1_3,
	/// Subset of VK_VERSION_1_4
	pub vk_version_1_4: Vulkan_VERSION_1_4,
	/// Subset of VK_KHR_surface
	pub vk_khr_surface: Vulkan_KHR_surface,
	/// Subset of VK_KHR_swapchain
	pub vk_khr_swapchain: Vulkan_KHR_swapchain,
	/// Subset of VK_KHR_display
	pub vk_khr_display: Vulkan_KHR_display,
	/// Subset of VK_KHR_display_swapchain
	pub vk_khr_display_swapchain: Vulkan_KHR_display_swapchain,
	/// Subset of VK_KHR_sampler_mirror_clamp_to_edge
	pub vk_khr_sampler_mirror_clamp_to_edge: Vulkan_KHR_sampler_mirror_clamp_to_edge,
	/// Subset of VK_KHR_video_queue
	pub vk_khr_video_queue: Vulkan_KHR_video_queue,
	/// Subset of VK_KHR_video_decode_queue
	pub vk_khr_video_decode_queue: Vulkan_KHR_video_decode_queue,
	/// Subset of VK_KHR_video_encode_h264
	pub vk_khr_video_encode_h264: Vulkan_KHR_video_encode_h264,
	/// Subset of vulkan_video_codec_h264std
	pub vulkan_video_codec_h264std: Vulkan_video_codec_h264std,
	/// Subset of vulkan_video_codecs_common
	pub vulkan_video_codecs_common: Vulkan_video_codecs_common,
	/// Subset of vulkan_video_codec_h264std_encode
	pub vulkan_video_codec_h264std_encode: Vulkan_video_codec_h264std_encode,
	/// Subset of VK_KHR_video_encode_h265
	pub vk_khr_video_encode_h265: Vulkan_KHR_video_encode_h265,
	/// Subset of vulkan_video_codec_h265std
	pub vulkan_video_codec_h265std: Vulkan_video_codec_h265std,
	/// Subset of vulkan_video_codec_h265std_encode
	pub vulkan_video_codec_h265std_encode: Vulkan_video_codec_h265std_encode,
	/// Subset of VK_KHR_video_decode_h264
	pub vk_khr_video_decode_h264: Vulkan_KHR_video_decode_h264,
	/// Subset of vulkan_video_codec_h264std_decode
	pub vulkan_video_codec_h264std_decode: Vulkan_video_codec_h264std_decode,
	/// Subset of VK_KHR_dynamic_rendering
	pub vk_khr_dynamic_rendering: Vulkan_KHR_dynamic_rendering,
	/// Subset of VK_KHR_multiview
	pub vk_khr_multiview: Vulkan_KHR_multiview,
	/// Subset of VK_KHR_get_physical_device_properties2
	pub vk_khr_get_physical_device_properties2: Vulkan_KHR_get_physical_device_properties2,
	/// Subset of VK_KHR_device_group
	pub vk_khr_device_group: Vulkan_KHR_device_group,
	/// Subset of VK_KHR_shader_draw_parameters
	pub vk_khr_shader_draw_parameters: Vulkan_KHR_shader_draw_parameters,
	/// Subset of VK_KHR_maintenance1
	pub vk_khr_maintenance1: Vulkan_KHR_maintenance1,
	/// Subset of VK_KHR_device_group_creation
	pub vk_khr_device_group_creation: Vulkan_KHR_device_group_creation,
	/// Subset of VK_KHR_external_memory_capabilities
	pub vk_khr_external_memory_capabilities: Vulkan_KHR_external_memory_capabilities,
	/// Subset of VK_KHR_external_memory
	pub vk_khr_external_memory: Vulkan_KHR_external_memory,
	/// Subset of VK_KHR_external_memory_fd
	pub vk_khr_external_memory_fd: Vulkan_KHR_external_memory_fd,
	/// Subset of VK_KHR_external_semaphore_capabilities
	pub vk_khr_external_semaphore_capabilities: Vulkan_KHR_external_semaphore_capabilities,
	/// Subset of VK_KHR_external_semaphore
	pub vk_khr_external_semaphore: Vulkan_KHR_external_semaphore,
	/// Subset of VK_KHR_external_semaphore_fd
	pub vk_khr_external_semaphore_fd: Vulkan_KHR_external_semaphore_fd,
	/// Subset of VK_KHR_push_descriptor
	pub vk_khr_push_descriptor: Vulkan_KHR_push_descriptor,
	/// Subset of VK_KHR_shader_float16_int8
	pub vk_khr_shader_float16_int8: Vulkan_KHR_shader_float16_int8,
	/// Subset of VK_KHR_16bit_storage
	pub vk_khr_16bit_storage: Vulkan_KHR_16bit_storage,
	/// Subset of VK_KHR_incremental_present
	pub vk_khr_incremental_present: Vulkan_KHR_incremental_present,
	/// Subset of VK_KHR_descriptor_update_template
	pub vk_khr_descriptor_update_template: Vulkan_KHR_descriptor_update_template,
	/// Subset of VK_KHR_imageless_framebuffer
	pub vk_khr_imageless_framebuffer: Vulkan_KHR_imageless_framebuffer,
	/// Subset of VK_KHR_create_renderpass2
	pub vk_khr_create_renderpass2: Vulkan_KHR_create_renderpass2,
	/// Subset of VK_KHR_shared_presentable_image
	pub vk_khr_shared_presentable_image: Vulkan_KHR_shared_presentable_image,
	/// Subset of VK_KHR_external_fence_capabilities
	pub vk_khr_external_fence_capabilities: Vulkan_KHR_external_fence_capabilities,
	/// Subset of VK_KHR_external_fence
	pub vk_khr_external_fence: Vulkan_KHR_external_fence,
	/// Subset of VK_KHR_external_fence_fd
	pub vk_khr_external_fence_fd: Vulkan_KHR_external_fence_fd,
	/// Subset of VK_KHR_performance_query
	pub vk_khr_performance_query: Vulkan_KHR_performance_query,
	/// Subset of VK_KHR_maintenance2
	pub vk_khr_maintenance2: Vulkan_KHR_maintenance2,
	/// Subset of VK_KHR_get_surface_capabilities2
	pub vk_khr_get_surface_capabilities2: Vulkan_KHR_get_surface_capabilities2,
	/// Subset of VK_KHR_variable_pointers
	pub vk_khr_variable_pointers: Vulkan_KHR_variable_pointers,
	/// Subset of VK_KHR_get_display_properties2
	pub vk_khr_get_display_properties2: Vulkan_KHR_get_display_properties2,
	/// Subset of VK_KHR_dedicated_allocation
	pub vk_khr_dedicated_allocation: Vulkan_KHR_dedicated_allocation,
	/// Subset of VK_KHR_storage_buffer_storage_class
	pub vk_khr_storage_buffer_storage_class: Vulkan_KHR_storage_buffer_storage_class,
	/// Subset of VK_KHR_shader_bfloat16
	pub vk_khr_shader_bfloat16: Vulkan_KHR_shader_bfloat16,
	/// Subset of VK_KHR_relaxed_block_layout
	pub vk_khr_relaxed_block_layout: Vulkan_KHR_relaxed_block_layout,
	/// Subset of VK_KHR_get_memory_requirements2
	pub vk_khr_get_memory_requirements2: Vulkan_KHR_get_memory_requirements2,
	/// Subset of VK_KHR_image_format_list
	pub vk_khr_image_format_list: Vulkan_KHR_image_format_list,
	/// Subset of VK_KHR_sampler_ycbcr_conversion
	pub vk_khr_sampler_ycbcr_conversion: Vulkan_KHR_sampler_ycbcr_conversion,
	/// Subset of VK_KHR_bind_memory2
	pub vk_khr_bind_memory2: Vulkan_KHR_bind_memory2,
	/// Subset of VK_KHR_maintenance3
	pub vk_khr_maintenance3: Vulkan_KHR_maintenance3,
	/// Subset of VK_KHR_draw_indirect_count
	pub vk_khr_draw_indirect_count: Vulkan_KHR_draw_indirect_count,
	/// Subset of VK_KHR_shader_subgroup_extended_types
	pub vk_khr_shader_subgroup_extended_types: Vulkan_KHR_shader_subgroup_extended_types,
	/// Subset of VK_KHR_8bit_storage
	pub vk_khr_8bit_storage: Vulkan_KHR_8bit_storage,
	/// Subset of VK_KHR_shader_atomic_int64
	pub vk_khr_shader_atomic_int64: Vulkan_KHR_shader_atomic_int64,
	/// Subset of VK_KHR_shader_clock
	pub vk_khr_shader_clock: Vulkan_KHR_shader_clock,
	/// Subset of VK_KHR_video_decode_h265
	pub vk_khr_video_decode_h265: Vulkan_KHR_video_decode_h265,
	/// Subset of vulkan_video_codec_h265std_decode
	pub vulkan_video_codec_h265std_decode: Vulkan_video_codec_h265std_decode,
	/// Subset of VK_KHR_global_priority
	pub vk_khr_global_priority: Vulkan_KHR_global_priority,
	/// Subset of VK_KHR_driver_properties
	pub vk_khr_driver_properties: Vulkan_KHR_driver_properties,
	/// Subset of VK_KHR_shader_float_controls
	pub vk_khr_shader_float_controls: Vulkan_KHR_shader_float_controls,
	/// Subset of VK_KHR_depth_stencil_resolve
	pub vk_khr_depth_stencil_resolve: Vulkan_KHR_depth_stencil_resolve,
	/// Subset of VK_KHR_swapchain_mutable_format
	pub vk_khr_swapchain_mutable_format: Vulkan_KHR_swapchain_mutable_format,
	/// Subset of VK_KHR_timeline_semaphore
	pub vk_khr_timeline_semaphore: Vulkan_KHR_timeline_semaphore,
	/// Subset of VK_KHR_vulkan_memory_model
	pub vk_khr_vulkan_memory_model: Vulkan_KHR_vulkan_memory_model,
	/// Subset of VK_KHR_shader_terminate_invocation
	pub vk_khr_shader_terminate_invocation: Vulkan_KHR_shader_terminate_invocation,
	/// Subset of VK_KHR_fragment_shading_rate
	pub vk_khr_fragment_shading_rate: Vulkan_KHR_fragment_shading_rate,
	/// Subset of VK_KHR_dynamic_rendering_local_read
	pub vk_khr_dynamic_rendering_local_read: Vulkan_KHR_dynamic_rendering_local_read,
	/// Subset of VK_KHR_shader_quad_control
	pub vk_khr_shader_quad_control: Vulkan_KHR_shader_quad_control,
	/// Subset of VK_KHR_spirv_1_4
	pub vk_khr_spirv_1_4: Vulkan_KHR_spirv_1_4,
	/// Subset of VK_KHR_surface_protected_capabilities
	pub vk_khr_surface_protected_capabilities: Vulkan_KHR_surface_protected_capabilities,
	/// Subset of VK_KHR_separate_depth_stencil_layouts
	pub vk_khr_separate_depth_stencil_layouts: Vulkan_KHR_separate_depth_stencil_layouts,
	/// Subset of VK_KHR_present_wait
	pub vk_khr_present_wait: Vulkan_KHR_present_wait,
	/// Subset of VK_KHR_uniform_buffer_standard_layout
	pub vk_khr_uniform_buffer_standard_layout: Vulkan_KHR_uniform_buffer_standard_layout,
	/// Subset of VK_KHR_buffer_device_address
	pub vk_khr_buffer_device_address: Vulkan_KHR_buffer_device_address,
	/// Subset of VK_KHR_deferred_host_operations
	pub vk_khr_deferred_host_operations: Vulkan_KHR_deferred_host_operations,
	/// Subset of VK_KHR_pipeline_executable_properties
	pub vk_khr_pipeline_executable_properties: Vulkan_KHR_pipeline_executable_properties,
	/// Subset of VK_KHR_map_memory2
	pub vk_khr_map_memory2: Vulkan_KHR_map_memory2,
	/// Subset of VK_KHR_shader_integer_dot_product
	pub vk_khr_shader_integer_dot_product: Vulkan_KHR_shader_integer_dot_product,
	/// Subset of VK_KHR_pipeline_library
	pub vk_khr_pipeline_library: Vulkan_KHR_pipeline_library,
	/// Subset of VK_KHR_shader_non_semantic_info
	pub vk_khr_shader_non_semantic_info: Vulkan_KHR_shader_non_semantic_info,
	/// Subset of VK_KHR_present_id
	pub vk_khr_present_id: Vulkan_KHR_present_id,
	/// Subset of VK_KHR_video_encode_queue
	pub vk_khr_video_encode_queue: Vulkan_KHR_video_encode_queue,
	/// Subset of VK_KHR_synchronization2
	pub vk_khr_synchronization2: Vulkan_KHR_synchronization2,
	/// Subset of VK_KHR_fragment_shader_barycentric
	pub vk_khr_fragment_shader_barycentric: Vulkan_KHR_fragment_shader_barycentric,
	/// Subset of VK_KHR_shader_subgroup_uniform_control_flow
	pub vk_khr_shader_subgroup_uniform_control_flow: Vulkan_KHR_shader_subgroup_uniform_control_flow,
	/// Subset of VK_KHR_zero_initialize_workgroup_memory
	pub vk_khr_zero_initialize_workgroup_memory: Vulkan_KHR_zero_initialize_workgroup_memory,
	/// Subset of VK_KHR_workgroup_memory_explicit_layout
	pub vk_khr_workgroup_memory_explicit_layout: Vulkan_KHR_workgroup_memory_explicit_layout,
	/// Subset of VK_KHR_copy_commands2
	pub vk_khr_copy_commands2: Vulkan_KHR_copy_commands2,
	/// Subset of VK_KHR_format_feature_flags2
	pub vk_khr_format_feature_flags2: Vulkan_KHR_format_feature_flags2,
	/// Subset of VK_KHR_ray_tracing_maintenance1
	pub vk_khr_ray_tracing_maintenance1: Vulkan_KHR_ray_tracing_maintenance1,
	/// Subset of VK_KHR_portability_enumeration
	pub vk_khr_portability_enumeration: Vulkan_KHR_portability_enumeration,
	/// Subset of VK_KHR_maintenance4
	pub vk_khr_maintenance4: Vulkan_KHR_maintenance4,
	/// Subset of VK_KHR_shader_subgroup_rotate
	pub vk_khr_shader_subgroup_rotate: Vulkan_KHR_shader_subgroup_rotate,
	/// Subset of VK_KHR_shader_maximal_reconvergence
	pub vk_khr_shader_maximal_reconvergence: Vulkan_KHR_shader_maximal_reconvergence,
	/// Subset of VK_KHR_maintenance5
	pub vk_khr_maintenance5: Vulkan_KHR_maintenance5,
	/// Subset of VK_KHR_present_id2
	pub vk_khr_present_id2: Vulkan_KHR_present_id2,
	/// Subset of VK_KHR_present_wait2
	pub vk_khr_present_wait2: Vulkan_KHR_present_wait2,
	/// Subset of VK_KHR_ray_tracing_position_fetch
	pub vk_khr_ray_tracing_position_fetch: Vulkan_KHR_ray_tracing_position_fetch,
	/// Subset of VK_KHR_pipeline_binary
	pub vk_khr_pipeline_binary: Vulkan_KHR_pipeline_binary,
	/// Subset of VK_KHR_surface_maintenance1
	pub vk_khr_surface_maintenance1: Vulkan_KHR_surface_maintenance1,
	/// Subset of VK_KHR_swapchain_maintenance1
	pub vk_khr_swapchain_maintenance1: Vulkan_KHR_swapchain_maintenance1,
	/// Subset of VK_KHR_cooperative_matrix
	pub vk_khr_cooperative_matrix: Vulkan_KHR_cooperative_matrix,
	/// Subset of VK_KHR_compute_shader_derivatives
	pub vk_khr_compute_shader_derivatives: Vulkan_KHR_compute_shader_derivatives,
	/// Subset of VK_KHR_video_decode_av1
	pub vk_khr_video_decode_av1: Vulkan_KHR_video_decode_av1,
	/// Subset of vulkan_video_codec_av1std
	pub vulkan_video_codec_av1std: Vulkan_video_codec_av1std,
	/// Subset of vulkan_video_codec_av1std_decode
	pub vulkan_video_codec_av1std_decode: Vulkan_video_codec_av1std_decode,
	/// Subset of VK_KHR_video_encode_av1
	pub vk_khr_video_encode_av1: Vulkan_KHR_video_encode_av1,
	/// Subset of vulkan_video_codec_av1std_encode
	pub vulkan_video_codec_av1std_encode: Vulkan_video_codec_av1std_encode,
	/// Subset of VK_KHR_video_decode_vp9
	pub vk_khr_video_decode_vp9: Vulkan_KHR_video_decode_vp9,
	/// Subset of vulkan_video_codec_vp9std
	pub vulkan_video_codec_vp9std: Vulkan_video_codec_vp9std,
	/// Subset of vulkan_video_codec_vp9std_decode
	pub vulkan_video_codec_vp9std_decode: Vulkan_video_codec_vp9std_decode,
	/// Subset of VK_KHR_video_maintenance1
	pub vk_khr_video_maintenance1: Vulkan_KHR_video_maintenance1,
	/// Subset of VK_KHR_vertex_attribute_divisor
	pub vk_khr_vertex_attribute_divisor: Vulkan_KHR_vertex_attribute_divisor,
	/// Subset of VK_KHR_load_store_op_none
	pub vk_khr_load_store_op_none: Vulkan_KHR_load_store_op_none,
	/// Subset of VK_KHR_unified_image_layouts
	pub vk_khr_unified_image_layouts: Vulkan_KHR_unified_image_layouts,
	/// Subset of VK_KHR_shader_float_controls2
	pub vk_khr_shader_float_controls2: Vulkan_KHR_shader_float_controls2,
	/// Subset of VK_KHR_index_type_uint8
	pub vk_khr_index_type_uint8: Vulkan_KHR_index_type_uint8,
	/// Subset of VK_KHR_line_rasterization
	pub vk_khr_line_rasterization: Vulkan_KHR_line_rasterization,
	/// Subset of VK_KHR_calibrated_timestamps
	pub vk_khr_calibrated_timestamps: Vulkan_KHR_calibrated_timestamps,
	/// Subset of VK_KHR_shader_expect_assume
	pub vk_khr_shader_expect_assume: Vulkan_KHR_shader_expect_assume,
	/// Subset of VK_KHR_maintenance6
	pub vk_khr_maintenance6: Vulkan_KHR_maintenance6,
	/// Subset of VK_KHR_video_encode_intra_refresh
	pub vk_khr_video_encode_intra_refresh: Vulkan_KHR_video_encode_intra_refresh,
	/// Subset of VK_KHR_video_encode_quantization_map
	pub vk_khr_video_encode_quantization_map: Vulkan_KHR_video_encode_quantization_map,
	/// Subset of VK_KHR_shader_relaxed_extended_instruction
	pub vk_khr_shader_relaxed_extended_instruction: Vulkan_KHR_shader_relaxed_extended_instruction,
	/// Subset of VK_KHR_maintenance7
	pub vk_khr_maintenance7: Vulkan_KHR_maintenance7,
	/// Subset of VK_KHR_maintenance8
	pub vk_khr_maintenance8: Vulkan_KHR_maintenance8,
	/// Subset of VK_KHR_maintenance9
	pub vk_khr_maintenance9: Vulkan_KHR_maintenance9,
	/// Subset of VK_KHR_video_maintenance2
	pub vk_khr_video_maintenance2: Vulkan_KHR_video_maintenance2,
	/// Subset of VK_KHR_depth_clamp_zero_one
	pub vk_khr_depth_clamp_zero_one: Vulkan_KHR_depth_clamp_zero_one,
	/// Subset of VK_KHR_robustness2
	pub vk_khr_robustness2: Vulkan_KHR_robustness2,
	/// Subset of VK_KHR_present_mode_fifo_latest_ready
	pub vk_khr_present_mode_fifo_latest_ready: Vulkan_KHR_present_mode_fifo_latest_ready,
	/// Subset of VK_EXT_debug_report
	pub vk_ext_debug_report: Vulkan_EXT_debug_report,
	/// Subset of VK_NV_glsl_shader
	pub vk_nv_glsl_shader: Vulkan_NV_glsl_shader,
	/// Subset of VK_EXT_depth_range_unrestricted
	pub vk_ext_depth_range_unrestricted: Vulkan_EXT_depth_range_unrestricted,
	/// Subset of VK_IMG_filter_cubic
	pub vk_img_filter_cubic: Vulkan_IMG_filter_cubic,
	/// Subset of VK_AMD_rasterization_order
	pub vk_amd_rasterization_order: Vulkan_AMD_rasterization_order,
	/// Subset of VK_AMD_shader_trinary_minmax
	pub vk_amd_shader_trinary_minmax: Vulkan_AMD_shader_trinary_minmax,
	/// Subset of VK_AMD_shader_explicit_vertex_parameter
	pub vk_amd_shader_explicit_vertex_parameter: Vulkan_AMD_shader_explicit_vertex_parameter,
	/// Subset of VK_EXT_debug_marker
	pub vk_ext_debug_marker: Vulkan_EXT_debug_marker,
	/// Subset of VK_AMD_gcn_shader
	pub vk_amd_gcn_shader: Vulkan_AMD_gcn_shader,
	/// Subset of VK_NV_dedicated_allocation
	pub vk_nv_dedicated_allocation: Vulkan_NV_dedicated_allocation,
	/// Subset of VK_EXT_transform_feedback
	pub vk_ext_transform_feedback: Vulkan_EXT_transform_feedback,
	/// Subset of VK_NVX_binary_import
	pub vk_nvx_binary_import: Vulkan_NVX_binary_import,
	/// Subset of VK_NVX_image_view_handle
	pub vk_nvx_image_view_handle: Vulkan_NVX_image_view_handle,
	/// Subset of VK_AMD_draw_indirect_count
	pub vk_amd_draw_indirect_count: Vulkan_AMD_draw_indirect_count,
	/// Subset of VK_AMD_negative_viewport_height
	pub vk_amd_negative_viewport_height: Vulkan_AMD_negative_viewport_height,
	/// Subset of VK_AMD_gpu_shader_half_float
	pub vk_amd_gpu_shader_half_float: Vulkan_AMD_gpu_shader_half_float,
	/// Subset of VK_AMD_shader_ballot
	pub vk_amd_shader_ballot: Vulkan_AMD_shader_ballot,
	/// Subset of VK_AMD_texture_gather_bias_lod
	pub vk_amd_texture_gather_bias_lod: Vulkan_AMD_texture_gather_bias_lod,
	/// Subset of VK_AMD_shader_info
	pub vk_amd_shader_info: Vulkan_AMD_shader_info,
	/// Subset of VK_AMD_shader_image_load_store_lod
	pub vk_amd_shader_image_load_store_lod: Vulkan_AMD_shader_image_load_store_lod,
	/// Subset of VK_NV_corner_sampled_image
	pub vk_nv_corner_sampled_image: Vulkan_NV_corner_sampled_image,
	/// Subset of VK_IMG_format_pvrtc
	pub vk_img_format_pvrtc: Vulkan_IMG_format_pvrtc,
	/// Subset of VK_NV_external_memory_capabilities
	pub vk_nv_external_memory_capabilities: Vulkan_NV_external_memory_capabilities,
	/// Subset of VK_NV_external_memory
	pub vk_nv_external_memory: Vulkan_NV_external_memory,
	/// Subset of VK_EXT_validation_flags
	pub vk_ext_validation_flags: Vulkan_EXT_validation_flags,
	/// Subset of VK_EXT_shader_subgroup_ballot
	pub vk_ext_shader_subgroup_ballot: Vulkan_EXT_shader_subgroup_ballot,
	/// Subset of VK_EXT_shader_subgroup_vote
	pub vk_ext_shader_subgroup_vote: Vulkan_EXT_shader_subgroup_vote,
	/// Subset of VK_EXT_texture_compression_astc_hdr
	pub vk_ext_texture_compression_astc_hdr: Vulkan_EXT_texture_compression_astc_hdr,
	/// Subset of VK_EXT_astc_decode_mode
	pub vk_ext_astc_decode_mode: Vulkan_EXT_astc_decode_mode,
	/// Subset of VK_EXT_pipeline_robustness
	pub vk_ext_pipeline_robustness: Vulkan_EXT_pipeline_robustness,
	/// Subset of VK_EXT_conditional_rendering
	pub vk_ext_conditional_rendering: Vulkan_EXT_conditional_rendering,
	/// Subset of VK_NV_clip_space_w_scaling
	pub vk_nv_clip_space_w_scaling: Vulkan_NV_clip_space_w_scaling,
	/// Subset of VK_EXT_direct_mode_display
	pub vk_ext_direct_mode_display: Vulkan_EXT_direct_mode_display,
	/// Subset of VK_EXT_display_surface_counter
	pub vk_ext_display_surface_counter: Vulkan_EXT_display_surface_counter,
	/// Subset of VK_EXT_display_control
	pub vk_ext_display_control: Vulkan_EXT_display_control,
	/// Subset of VK_GOOGLE_display_timing
	pub vk_google_display_timing: Vulkan_GOOGLE_display_timing,
	/// Subset of VK_NV_sample_mask_override_coverage
	pub vk_nv_sample_mask_override_coverage: Vulkan_NV_sample_mask_override_coverage,
	/// Subset of VK_NV_geometry_shader_passthrough
	pub vk_nv_geometry_shader_passthrough: Vulkan_NV_geometry_shader_passthrough,
	/// Subset of VK_NV_viewport_array2
	pub vk_nv_viewport_array2: Vulkan_NV_viewport_array2,
	/// Subset of VK_NVX_multiview_per_view_attributes
	pub vk_nvx_multiview_per_view_attributes: Vulkan_NVX_multiview_per_view_attributes,
	/// Subset of VK_NV_viewport_swizzle
	pub vk_nv_viewport_swizzle: Vulkan_NV_viewport_swizzle,
	/// Subset of VK_EXT_discard_rectangles
	pub vk_ext_discard_rectangles: Vulkan_EXT_discard_rectangles,
	/// Subset of VK_EXT_conservative_rasterization
	pub vk_ext_conservative_rasterization: Vulkan_EXT_conservative_rasterization,
	/// Subset of VK_EXT_depth_clip_enable
	pub vk_ext_depth_clip_enable: Vulkan_EXT_depth_clip_enable,
	/// Subset of VK_EXT_swapchain_colorspace
	pub vk_ext_swapchain_colorspace: Vulkan_EXT_swapchain_colorspace,
	/// Subset of VK_EXT_hdr_metadata
	pub vk_ext_hdr_metadata: Vulkan_EXT_hdr_metadata,
	/// Subset of VK_IMG_relaxed_line_rasterization
	pub vk_img_relaxed_line_rasterization: Vulkan_IMG_relaxed_line_rasterization,
	/// Subset of VK_EXT_external_memory_dma_buf
	pub vk_ext_external_memory_dma_buf: Vulkan_EXT_external_memory_dma_buf,
	/// Subset of VK_EXT_queue_family_foreign
	pub vk_ext_queue_family_foreign: Vulkan_EXT_queue_family_foreign,
	/// Subset of VK_EXT_debug_utils
	pub vk_ext_debug_utils: Vulkan_EXT_debug_utils,
	/// Subset of VK_EXT_sampler_filter_minmax
	pub vk_ext_sampler_filter_minmax: Vulkan_EXT_sampler_filter_minmax,
	/// Subset of VK_AMD_gpu_shader_int16
	pub vk_amd_gpu_shader_int16: Vulkan_AMD_gpu_shader_int16,
	/// Subset of VK_AMD_mixed_attachment_samples
	pub vk_amd_mixed_attachment_samples: Vulkan_AMD_mixed_attachment_samples,
	/// Subset of VK_AMD_shader_fragment_mask
	pub vk_amd_shader_fragment_mask: Vulkan_AMD_shader_fragment_mask,
	/// Subset of VK_EXT_inline_uniform_block
	pub vk_ext_inline_uniform_block: Vulkan_EXT_inline_uniform_block,
	/// Subset of VK_EXT_shader_stencil_export
	pub vk_ext_shader_stencil_export: Vulkan_EXT_shader_stencil_export,
	/// Subset of VK_EXT_sample_locations
	pub vk_ext_sample_locations: Vulkan_EXT_sample_locations,
	/// Subset of VK_EXT_blend_operation_advanced
	pub vk_ext_blend_operation_advanced: Vulkan_EXT_blend_operation_advanced,
	/// Subset of VK_NV_fragment_coverage_to_color
	pub vk_nv_fragment_coverage_to_color: Vulkan_NV_fragment_coverage_to_color,
	/// Subset of VK_NV_framebuffer_mixed_samples
	pub vk_nv_framebuffer_mixed_samples: Vulkan_NV_framebuffer_mixed_samples,
	/// Subset of VK_NV_fill_rectangle
	pub vk_nv_fill_rectangle: Vulkan_NV_fill_rectangle,
	/// Subset of VK_NV_shader_sm_builtins
	pub vk_nv_shader_sm_builtins: Vulkan_NV_shader_sm_builtins,
	/// Subset of VK_EXT_post_depth_coverage
	pub vk_ext_post_depth_coverage: Vulkan_EXT_post_depth_coverage,
	/// Subset of VK_EXT_image_drm_format_modifier
	pub vk_ext_image_drm_format_modifier: Vulkan_EXT_image_drm_format_modifier,
	/// Subset of VK_EXT_validation_cache
	pub vk_ext_validation_cache: Vulkan_EXT_validation_cache,
	/// Subset of VK_EXT_descriptor_indexing
	pub vk_ext_descriptor_indexing: Vulkan_EXT_descriptor_indexing,
	/// Subset of VK_EXT_shader_viewport_index_layer
	pub vk_ext_shader_viewport_index_layer: Vulkan_EXT_shader_viewport_index_layer,
	/// Subset of VK_NV_shading_rate_image
	pub vk_nv_shading_rate_image: Vulkan_NV_shading_rate_image,
	/// Subset of VK_NV_ray_tracing
	pub vk_nv_ray_tracing: Vulkan_NV_ray_tracing,
	/// Subset of VK_NV_representative_fragment_test
	pub vk_nv_representative_fragment_test: Vulkan_NV_representative_fragment_test,
	/// Subset of VK_EXT_filter_cubic
	pub vk_ext_filter_cubic: Vulkan_EXT_filter_cubic,
	/// Subset of VK_QCOM_render_pass_shader_resolve
	pub vk_qcom_render_pass_shader_resolve: Vulkan_QCOM_render_pass_shader_resolve,
	/// Subset of VK_EXT_global_priority
	pub vk_ext_global_priority: Vulkan_EXT_global_priority,
	/// Subset of VK_EXT_external_memory_host
	pub vk_ext_external_memory_host: Vulkan_EXT_external_memory_host,
	/// Subset of VK_AMD_buffer_marker
	pub vk_amd_buffer_marker: Vulkan_AMD_buffer_marker,
	/// Subset of VK_AMD_pipeline_compiler_control
	pub vk_amd_pipeline_compiler_control: Vulkan_AMD_pipeline_compiler_control,
	/// Subset of VK_EXT_calibrated_timestamps
	pub vk_ext_calibrated_timestamps: Vulkan_EXT_calibrated_timestamps,
	/// Subset of VK_AMD_shader_core_properties
	pub vk_amd_shader_core_properties: Vulkan_AMD_shader_core_properties,
	/// Subset of VK_AMD_memory_overallocation_behavior
	pub vk_amd_memory_overallocation_behavior: Vulkan_AMD_memory_overallocation_behavior,
	/// Subset of VK_EXT_vertex_attribute_divisor
	pub vk_ext_vertex_attribute_divisor: Vulkan_EXT_vertex_attribute_divisor,
	/// Subset of VK_EXT_pipeline_creation_feedback
	pub vk_ext_pipeline_creation_feedback: Vulkan_EXT_pipeline_creation_feedback,
	/// Subset of VK_NV_shader_subgroup_partitioned
	pub vk_nv_shader_subgroup_partitioned: Vulkan_NV_shader_subgroup_partitioned,
	/// Subset of VK_NV_compute_shader_derivatives
	pub vk_nv_compute_shader_derivatives: Vulkan_NV_compute_shader_derivatives,
	/// Subset of VK_NV_mesh_shader
	pub vk_nv_mesh_shader: Vulkan_NV_mesh_shader,
	/// Subset of VK_NV_fragment_shader_barycentric
	pub vk_nv_fragment_shader_barycentric: Vulkan_NV_fragment_shader_barycentric,
	/// Subset of VK_NV_shader_image_footprint
	pub vk_nv_shader_image_footprint: Vulkan_NV_shader_image_footprint,
	/// Subset of VK_NV_scissor_exclusive
	pub vk_nv_scissor_exclusive: Vulkan_NV_scissor_exclusive,
	/// Subset of VK_NV_device_diagnostic_checkpoints
	pub vk_nv_device_diagnostic_checkpoints: Vulkan_NV_device_diagnostic_checkpoints,
	/// Subset of VK_INTEL_shader_integer_functions2
	pub vk_intel_shader_integer_functions2: Vulkan_INTEL_shader_integer_functions2,
	/// Subset of VK_INTEL_performance_query
	pub vk_intel_performance_query: Vulkan_INTEL_performance_query,
	/// Subset of VK_EXT_pci_bus_info
	pub vk_ext_pci_bus_info: Vulkan_EXT_pci_bus_info,
	/// Subset of VK_AMD_display_native_hdr
	pub vk_amd_display_native_hdr: Vulkan_AMD_display_native_hdr,
	/// Subset of VK_EXT_fragment_density_map
	pub vk_ext_fragment_density_map: Vulkan_EXT_fragment_density_map,
	/// Subset of VK_EXT_scalar_block_layout
	pub vk_ext_scalar_block_layout: Vulkan_EXT_scalar_block_layout,
	/// Subset of VK_GOOGLE_hlsl_functionality1
	pub vk_google_hlsl_functionality1: Vulkan_GOOGLE_hlsl_functionality1,
	/// Subset of VK_GOOGLE_decorate_string
	pub vk_google_decorate_string: Vulkan_GOOGLE_decorate_string,
	/// Subset of VK_EXT_subgroup_size_control
	pub vk_ext_subgroup_size_control: Vulkan_EXT_subgroup_size_control,
	/// Subset of VK_AMD_shader_core_properties2
	pub vk_amd_shader_core_properties2: Vulkan_AMD_shader_core_properties2,
	/// Subset of VK_AMD_device_coherent_memory
	pub vk_amd_device_coherent_memory: Vulkan_AMD_device_coherent_memory,
	/// Subset of VK_EXT_shader_image_atomic_int64
	pub vk_ext_shader_image_atomic_int64: Vulkan_EXT_shader_image_atomic_int64,
	/// Subset of VK_EXT_memory_budget
	pub vk_ext_memory_budget: Vulkan_EXT_memory_budget,
	/// Subset of VK_EXT_memory_priority
	pub vk_ext_memory_priority: Vulkan_EXT_memory_priority,
	/// Subset of VK_NV_dedicated_allocation_image_aliasing
	pub vk_nv_dedicated_allocation_image_aliasing: Vulkan_NV_dedicated_allocation_image_aliasing,
	/// Subset of VK_EXT_buffer_device_address
	pub vk_ext_buffer_device_address: Vulkan_EXT_buffer_device_address,
	/// Subset of VK_EXT_tooling_info
	pub vk_ext_tooling_info: Vulkan_EXT_tooling_info,
	/// Subset of VK_EXT_separate_stencil_usage
	pub vk_ext_separate_stencil_usage: Vulkan_EXT_separate_stencil_usage,
	/// Subset of VK_EXT_validation_features
	pub vk_ext_validation_features: Vulkan_EXT_validation_features,
	/// Subset of VK_NV_cooperative_matrix
	pub vk_nv_cooperative_matrix: Vulkan_NV_cooperative_matrix,
	/// Subset of VK_NV_coverage_reduction_mode
	pub vk_nv_coverage_reduction_mode: Vulkan_NV_coverage_reduction_mode,
	/// Subset of VK_EXT_fragment_shader_interlock
	pub vk_ext_fragment_shader_interlock: Vulkan_EXT_fragment_shader_interlock,
	/// Subset of VK_EXT_ycbcr_image_arrays
	pub vk_ext_ycbcr_image_arrays: Vulkan_EXT_ycbcr_image_arrays,
	/// Subset of VK_EXT_provoking_vertex
	pub vk_ext_provoking_vertex: Vulkan_EXT_provoking_vertex,
	/// Subset of VK_EXT_headless_surface
	pub vk_ext_headless_surface: Vulkan_EXT_headless_surface,
	/// Subset of VK_EXT_line_rasterization
	pub vk_ext_line_rasterization: Vulkan_EXT_line_rasterization,
	/// Subset of VK_EXT_shader_atomic_float
	pub vk_ext_shader_atomic_float: Vulkan_EXT_shader_atomic_float,
	/// Subset of VK_EXT_host_query_reset
	pub vk_ext_host_query_reset: Vulkan_EXT_host_query_reset,
	/// Subset of VK_EXT_index_type_uint8
	pub vk_ext_index_type_uint8: Vulkan_EXT_index_type_uint8,
	/// Subset of VK_EXT_extended_dynamic_state
	pub vk_ext_extended_dynamic_state: Vulkan_EXT_extended_dynamic_state,
	/// Subset of VK_EXT_host_image_copy
	pub vk_ext_host_image_copy: Vulkan_EXT_host_image_copy,
	/// Subset of VK_EXT_map_memory_placed
	pub vk_ext_map_memory_placed: Vulkan_EXT_map_memory_placed,
	/// Subset of VK_EXT_shader_atomic_float2
	pub vk_ext_shader_atomic_float2: Vulkan_EXT_shader_atomic_float2,
	/// Subset of VK_EXT_surface_maintenance1
	pub vk_ext_surface_maintenance1: Vulkan_EXT_surface_maintenance1,
	/// Subset of VK_EXT_swapchain_maintenance1
	pub vk_ext_swapchain_maintenance1: Vulkan_EXT_swapchain_maintenance1,
	/// Subset of VK_EXT_shader_demote_to_helper_invocation
	pub vk_ext_shader_demote_to_helper_invocation: Vulkan_EXT_shader_demote_to_helper_invocation,
	/// Subset of VK_NV_device_generated_commands
	pub vk_nv_device_generated_commands: Vulkan_NV_device_generated_commands,
	/// Subset of VK_NV_inherited_viewport_scissor
	pub vk_nv_inherited_viewport_scissor: Vulkan_NV_inherited_viewport_scissor,
	/// Subset of VK_EXT_texel_buffer_alignment
	pub vk_ext_texel_buffer_alignment: Vulkan_EXT_texel_buffer_alignment,
	/// Subset of VK_QCOM_render_pass_transform
	pub vk_qcom_render_pass_transform: Vulkan_QCOM_render_pass_transform,
	/// Subset of VK_EXT_depth_bias_control
	pub vk_ext_depth_bias_control: Vulkan_EXT_depth_bias_control,
	/// Subset of VK_EXT_device_memory_report
	pub vk_ext_device_memory_report: Vulkan_EXT_device_memory_report,
	/// Subset of VK_EXT_acquire_drm_display
	pub vk_ext_acquire_drm_display: Vulkan_EXT_acquire_drm_display,
	/// Subset of VK_EXT_robustness2
	pub vk_ext_robustness2: Vulkan_EXT_robustness2,
	/// Subset of VK_EXT_custom_border_color
	pub vk_ext_custom_border_color: Vulkan_EXT_custom_border_color,
	/// Subset of VK_GOOGLE_user_type
	pub vk_google_user_type: Vulkan_GOOGLE_user_type,
	/// Subset of VK_NV_present_barrier
	pub vk_nv_present_barrier: Vulkan_NV_present_barrier,
	/// Subset of VK_EXT_private_data
	pub vk_ext_private_data: Vulkan_EXT_private_data,
	/// Subset of VK_EXT_pipeline_creation_cache_control
	pub vk_ext_pipeline_creation_cache_control: Vulkan_EXT_pipeline_creation_cache_control,
	/// Subset of VK_NV_device_diagnostics_config
	pub vk_nv_device_diagnostics_config: Vulkan_NV_device_diagnostics_config,
	/// Subset of VK_QCOM_render_pass_store_ops
	pub vk_qcom_render_pass_store_ops: Vulkan_QCOM_render_pass_store_ops,
	/// Subset of VK_QCOM_tile_shading
	pub vk_qcom_tile_shading: Vulkan_QCOM_tile_shading,
	/// Subset of VK_NV_low_latency
	pub vk_nv_low_latency: Vulkan_NV_low_latency,
	/// Subset of VK_EXT_descriptor_buffer
	pub vk_ext_descriptor_buffer: Vulkan_EXT_descriptor_buffer,
	/// Subset of VK_EXT_graphics_pipeline_library
	pub vk_ext_graphics_pipeline_library: Vulkan_EXT_graphics_pipeline_library,
	/// Subset of VK_AMD_shader_early_and_late_fragment_tests
	pub vk_amd_shader_early_and_late_fragment_tests: Vulkan_AMD_shader_early_and_late_fragment_tests,
	/// Subset of VK_NV_fragment_shading_rate_enums
	pub vk_nv_fragment_shading_rate_enums: Vulkan_NV_fragment_shading_rate_enums,
	/// Subset of VK_NV_ray_tracing_motion_blur
	pub vk_nv_ray_tracing_motion_blur: Vulkan_NV_ray_tracing_motion_blur,
	/// Subset of VK_EXT_ycbcr_2plane_444_formats
	pub vk_ext_ycbcr_2plane_444_formats: Vulkan_EXT_ycbcr_2plane_444_formats,
	/// Subset of VK_EXT_fragment_density_map2
	pub vk_ext_fragment_density_map2: Vulkan_EXT_fragment_density_map2,
	/// Subset of VK_QCOM_rotated_copy_commands
	pub vk_qcom_rotated_copy_commands: Vulkan_QCOM_rotated_copy_commands,
	/// Subset of VK_EXT_image_robustness
	pub vk_ext_image_robustness: Vulkan_EXT_image_robustness,
	/// Subset of VK_EXT_image_compression_control
	pub vk_ext_image_compression_control: Vulkan_EXT_image_compression_control,
	/// Subset of VK_EXT_attachment_feedback_loop_layout
	pub vk_ext_attachment_feedback_loop_layout: Vulkan_EXT_attachment_feedback_loop_layout,
	/// Subset of VK_EXT_4444_formats
	pub vk_ext_4444_formats: Vulkan_EXT_4444_formats,
	/// Subset of VK_EXT_device_fault
	pub vk_ext_device_fault: Vulkan_EXT_device_fault,
	/// Subset of VK_ARM_rasterization_order_attachment_access
	pub vk_arm_rasterization_order_attachment_access: Vulkan_ARM_rasterization_order_attachment_access,
	/// Subset of VK_EXT_rgba10x6_formats
	pub vk_ext_rgba10x6_formats: Vulkan_EXT_rgba10x6_formats,
	/// Subset of VK_VALVE_mutable_descriptor_type
	pub vk_valve_mutable_descriptor_type: Vulkan_VALVE_mutable_descriptor_type,
	/// Subset of VK_EXT_vertex_input_dynamic_state
	pub vk_ext_vertex_input_dynamic_state: Vulkan_EXT_vertex_input_dynamic_state,
	/// Subset of VK_EXT_physical_device_drm
	pub vk_ext_physical_device_drm: Vulkan_EXT_physical_device_drm,
	/// Subset of VK_EXT_device_address_binding_report
	pub vk_ext_device_address_binding_report: Vulkan_EXT_device_address_binding_report,
	/// Subset of VK_EXT_depth_clip_control
	pub vk_ext_depth_clip_control: Vulkan_EXT_depth_clip_control,
	/// Subset of VK_EXT_primitive_topology_list_restart
	pub vk_ext_primitive_topology_list_restart: Vulkan_EXT_primitive_topology_list_restart,
	/// Subset of VK_EXT_present_mode_fifo_latest_ready
	pub vk_ext_present_mode_fifo_latest_ready: Vulkan_EXT_present_mode_fifo_latest_ready,
	/// Subset of VK_HUAWEI_subpass_shading
	pub vk_huawei_subpass_shading: Vulkan_HUAWEI_subpass_shading,
	/// Subset of VK_HUAWEI_invocation_mask
	pub vk_huawei_invocation_mask: Vulkan_HUAWEI_invocation_mask,
	/// Subset of VK_NV_external_memory_rdma
	pub vk_nv_external_memory_rdma: Vulkan_NV_external_memory_rdma,
	/// Subset of VK_EXT_pipeline_properties
	pub vk_ext_pipeline_properties: Vulkan_EXT_pipeline_properties,
	/// Subset of VK_EXT_frame_boundary
	pub vk_ext_frame_boundary: Vulkan_EXT_frame_boundary,
	/// Subset of VK_EXT_multisampled_render_to_single_sampled
	pub vk_ext_multisampled_render_to_single_sampled: Vulkan_EXT_multisampled_render_to_single_sampled,
	/// Subset of VK_EXT_extended_dynamic_state2
	pub vk_ext_extended_dynamic_state2: Vulkan_EXT_extended_dynamic_state2,
	/// Subset of VK_EXT_color_write_enable
	pub vk_ext_color_write_enable: Vulkan_EXT_color_write_enable,
	/// Subset of VK_EXT_primitives_generated_query
	pub vk_ext_primitives_generated_query: Vulkan_EXT_primitives_generated_query,
	/// Subset of VK_EXT_global_priority_query
	pub vk_ext_global_priority_query: Vulkan_EXT_global_priority_query,
	/// Subset of VK_EXT_image_view_min_lod
	pub vk_ext_image_view_min_lod: Vulkan_EXT_image_view_min_lod,
	/// Subset of VK_EXT_multi_draw
	pub vk_ext_multi_draw: Vulkan_EXT_multi_draw,
	/// Subset of VK_EXT_image_2d_view_of_3d
	pub vk_ext_image_2d_view_of_3d: Vulkan_EXT_image_2d_view_of_3d,
	/// Subset of VK_EXT_shader_tile_image
	pub vk_ext_shader_tile_image: Vulkan_EXT_shader_tile_image,
	/// Subset of VK_EXT_opacity_micromap
	pub vk_ext_opacity_micromap: Vulkan_EXT_opacity_micromap,
	/// Subset of VK_EXT_load_store_op_none
	pub vk_ext_load_store_op_none: Vulkan_EXT_load_store_op_none,
	/// Subset of VK_HUAWEI_cluster_culling_shader
	pub vk_huawei_cluster_culling_shader: Vulkan_HUAWEI_cluster_culling_shader,
	/// Subset of VK_EXT_border_color_swizzle
	pub vk_ext_border_color_swizzle: Vulkan_EXT_border_color_swizzle,
	/// Subset of VK_EXT_pageable_device_local_memory
	pub vk_ext_pageable_device_local_memory: Vulkan_EXT_pageable_device_local_memory,
	/// Subset of VK_ARM_shader_core_properties
	pub vk_arm_shader_core_properties: Vulkan_ARM_shader_core_properties,
	/// Subset of VK_ARM_scheduling_controls
	pub vk_arm_scheduling_controls: Vulkan_ARM_scheduling_controls,
	/// Subset of VK_EXT_image_sliced_view_of_3d
	pub vk_ext_image_sliced_view_of_3d: Vulkan_EXT_image_sliced_view_of_3d,
	/// Subset of VK_VALVE_descriptor_set_host_mapping
	pub vk_valve_descriptor_set_host_mapping: Vulkan_VALVE_descriptor_set_host_mapping,
	/// Subset of VK_EXT_depth_clamp_zero_one
	pub vk_ext_depth_clamp_zero_one: Vulkan_EXT_depth_clamp_zero_one,
	/// Subset of VK_EXT_non_seamless_cube_map
	pub vk_ext_non_seamless_cube_map: Vulkan_EXT_non_seamless_cube_map,
	/// Subset of VK_ARM_render_pass_striped
	pub vk_arm_render_pass_striped: Vulkan_ARM_render_pass_striped,
	/// Subset of VK_QCOM_fragment_density_map_offset
	pub vk_qcom_fragment_density_map_offset: Vulkan_QCOM_fragment_density_map_offset,
	/// Subset of VK_NV_copy_memory_indirect
	pub vk_nv_copy_memory_indirect: Vulkan_NV_copy_memory_indirect,
	/// Subset of VK_NV_memory_decompression
	pub vk_nv_memory_decompression: Vulkan_NV_memory_decompression,
	/// Subset of VK_NV_device_generated_commands_compute
	pub vk_nv_device_generated_commands_compute: Vulkan_NV_device_generated_commands_compute,
	/// Subset of VK_NV_ray_tracing_linear_swept_spheres
	pub vk_nv_ray_tracing_linear_swept_spheres: Vulkan_NV_ray_tracing_linear_swept_spheres,
	/// Subset of VK_NV_linear_color_attachment
	pub vk_nv_linear_color_attachment: Vulkan_NV_linear_color_attachment,
	/// Subset of VK_GOOGLE_surfaceless_query
	pub vk_google_surfaceless_query: Vulkan_GOOGLE_surfaceless_query,
	/// Subset of VK_EXT_image_compression_control_swapchain
	pub vk_ext_image_compression_control_swapchain: Vulkan_EXT_image_compression_control_swapchain,
	/// Subset of VK_QCOM_image_processing
	pub vk_qcom_image_processing: Vulkan_QCOM_image_processing,
	/// Subset of VK_EXT_nested_command_buffer
	pub vk_ext_nested_command_buffer: Vulkan_EXT_nested_command_buffer,
	/// Subset of VK_EXT_external_memory_acquire_unmodified
	pub vk_ext_external_memory_acquire_unmodified: Vulkan_EXT_external_memory_acquire_unmodified,
	/// Subset of VK_EXT_extended_dynamic_state3
	pub vk_ext_extended_dynamic_state3: Vulkan_EXT_extended_dynamic_state3,
	/// Subset of VK_EXT_subpass_merge_feedback
	pub vk_ext_subpass_merge_feedback: Vulkan_EXT_subpass_merge_feedback,
	/// Subset of VK_LUNARG_direct_driver_loading
	pub vk_lunarg_direct_driver_loading: Vulkan_LUNARG_direct_driver_loading,
	/// Subset of VK_ARM_tensors
	pub vk_arm_tensors: Vulkan_ARM_tensors,
	/// Subset of VK_EXT_shader_module_identifier
	pub vk_ext_shader_module_identifier: Vulkan_EXT_shader_module_identifier,
	/// Subset of VK_EXT_rasterization_order_attachment_access
	pub vk_ext_rasterization_order_attachment_access: Vulkan_EXT_rasterization_order_attachment_access,
	/// Subset of VK_NV_optical_flow
	pub vk_nv_optical_flow: Vulkan_NV_optical_flow,
	/// Subset of VK_EXT_legacy_dithering
	pub vk_ext_legacy_dithering: Vulkan_EXT_legacy_dithering,
	/// Subset of VK_EXT_pipeline_protected_access
	pub vk_ext_pipeline_protected_access: Vulkan_EXT_pipeline_protected_access,
	/// Subset of VK_AMD_anti_lag
	pub vk_amd_anti_lag: Vulkan_AMD_anti_lag,
	/// Subset of VK_EXT_shader_object
	pub vk_ext_shader_object: Vulkan_EXT_shader_object,
	/// Subset of VK_QCOM_tile_properties
	pub vk_qcom_tile_properties: Vulkan_QCOM_tile_properties,
	/// Subset of VK_SEC_amigo_profiling
	pub vk_sec_amigo_profiling: Vulkan_SEC_amigo_profiling,
	/// Subset of VK_QCOM_multiview_per_view_viewports
	pub vk_qcom_multiview_per_view_viewports: Vulkan_QCOM_multiview_per_view_viewports,
	/// Subset of VK_NV_ray_tracing_invocation_reorder
	pub vk_nv_ray_tracing_invocation_reorder: Vulkan_NV_ray_tracing_invocation_reorder,
	/// Subset of VK_NV_cooperative_vector
	pub vk_nv_cooperative_vector: Vulkan_NV_cooperative_vector,
	/// Subset of VK_NV_extended_sparse_address_space
	pub vk_nv_extended_sparse_address_space: Vulkan_NV_extended_sparse_address_space,
	/// Subset of VK_EXT_mutable_descriptor_type
	pub vk_ext_mutable_descriptor_type: Vulkan_EXT_mutable_descriptor_type,
	/// Subset of VK_EXT_legacy_vertex_attributes
	pub vk_ext_legacy_vertex_attributes: Vulkan_EXT_legacy_vertex_attributes,
	/// Subset of VK_EXT_layer_settings
	pub vk_ext_layer_settings: Vulkan_EXT_layer_settings,
	/// Subset of VK_ARM_shader_core_builtins
	pub vk_arm_shader_core_builtins: Vulkan_ARM_shader_core_builtins,
	/// Subset of VK_EXT_pipeline_library_group_handles
	pub vk_ext_pipeline_library_group_handles: Vulkan_EXT_pipeline_library_group_handles,
	/// Subset of VK_EXT_dynamic_rendering_unused_attachments
	pub vk_ext_dynamic_rendering_unused_attachments: Vulkan_EXT_dynamic_rendering_unused_attachments,
	/// Subset of VK_NV_low_latency2
	pub vk_nv_low_latency2: Vulkan_NV_low_latency2,
	/// Subset of VK_ARM_data_graph
	pub vk_arm_data_graph: Vulkan_ARM_data_graph,
	/// Subset of VK_QCOM_multiview_per_view_render_areas
	pub vk_qcom_multiview_per_view_render_areas: Vulkan_QCOM_multiview_per_view_render_areas,
	/// Subset of VK_NV_per_stage_descriptor_set
	pub vk_nv_per_stage_descriptor_set: Vulkan_NV_per_stage_descriptor_set,
	/// Subset of VK_QCOM_image_processing2
	pub vk_qcom_image_processing2: Vulkan_QCOM_image_processing2,
	/// Subset of VK_QCOM_filter_cubic_weights
	pub vk_qcom_filter_cubic_weights: Vulkan_QCOM_filter_cubic_weights,
	/// Subset of VK_QCOM_ycbcr_degamma
	pub vk_qcom_ycbcr_degamma: Vulkan_QCOM_ycbcr_degamma,
	/// Subset of VK_QCOM_filter_cubic_clamp
	pub vk_qcom_filter_cubic_clamp: Vulkan_QCOM_filter_cubic_clamp,
	/// Subset of VK_EXT_attachment_feedback_loop_dynamic_state
	pub vk_ext_attachment_feedback_loop_dynamic_state: Vulkan_EXT_attachment_feedback_loop_dynamic_state,
	/// Subset of VK_MSFT_layered_driver
	pub vk_msft_layered_driver: Vulkan_MSFT_layered_driver,
	/// Subset of VK_NV_descriptor_pool_overallocation
	pub vk_nv_descriptor_pool_overallocation: Vulkan_NV_descriptor_pool_overallocation,
	/// Subset of VK_QCOM_tile_memory_heap
	pub vk_qcom_tile_memory_heap: Vulkan_QCOM_tile_memory_heap,
	/// Subset of VK_NV_display_stereo
	pub vk_nv_display_stereo: Vulkan_NV_display_stereo,
	/// Subset of VK_NV_raw_access_chains
	pub vk_nv_raw_access_chains: Vulkan_NV_raw_access_chains,
	/// Subset of VK_NV_external_compute_queue
	pub vk_nv_external_compute_queue: Vulkan_NV_external_compute_queue,
	/// Subset of VK_NV_command_buffer_inheritance
	pub vk_nv_command_buffer_inheritance: Vulkan_NV_command_buffer_inheritance,
	/// Subset of VK_NV_shader_atomic_float16_vector
	pub vk_nv_shader_atomic_float16_vector: Vulkan_NV_shader_atomic_float16_vector,
	/// Subset of VK_EXT_shader_replicated_composites
	pub vk_ext_shader_replicated_composites: Vulkan_EXT_shader_replicated_composites,
	/// Subset of VK_EXT_shader_float8
	pub vk_ext_shader_float8: Vulkan_EXT_shader_float8,
	/// Subset of VK_NV_ray_tracing_validation
	pub vk_nv_ray_tracing_validation: Vulkan_NV_ray_tracing_validation,
	/// Subset of VK_NV_cluster_acceleration_structure
	pub vk_nv_cluster_acceleration_structure: Vulkan_NV_cluster_acceleration_structure,
	/// Subset of VK_NV_partitioned_acceleration_structure
	pub vk_nv_partitioned_acceleration_structure: Vulkan_NV_partitioned_acceleration_structure,
	/// Subset of VK_EXT_device_generated_commands
	pub vk_ext_device_generated_commands: Vulkan_EXT_device_generated_commands,
	/// Subset of VK_MESA_image_alignment_control
	pub vk_mesa_image_alignment_control: Vulkan_MESA_image_alignment_control,
	/// Subset of VK_EXT_depth_clamp_control
	pub vk_ext_depth_clamp_control: Vulkan_EXT_depth_clamp_control,
	/// Subset of VK_HUAWEI_hdr_vivid
	pub vk_huawei_hdr_vivid: Vulkan_HUAWEI_hdr_vivid,
	/// Subset of VK_NV_cooperative_matrix2
	pub vk_nv_cooperative_matrix2: Vulkan_NV_cooperative_matrix2,
	/// Subset of VK_ARM_pipeline_opacity_micromap
	pub vk_arm_pipeline_opacity_micromap: Vulkan_ARM_pipeline_opacity_micromap,
	/// Subset of VK_EXT_vertex_attribute_robustness
	pub vk_ext_vertex_attribute_robustness: Vulkan_EXT_vertex_attribute_robustness,
	/// Subset of VK_ARM_format_pack
	pub vk_arm_format_pack: Vulkan_ARM_format_pack,
	/// Subset of VK_VALVE_fragment_density_map_layered
	pub vk_valve_fragment_density_map_layered: Vulkan_VALVE_fragment_density_map_layered,
	/// Subset of VK_NV_present_metering
	pub vk_nv_present_metering: Vulkan_NV_present_metering,
	/// Subset of VK_EXT_fragment_density_map_offset
	pub vk_ext_fragment_density_map_offset: Vulkan_EXT_fragment_density_map_offset,
	/// Subset of VK_EXT_zero_initialize_device_memory
	pub vk_ext_zero_initialize_device_memory: Vulkan_EXT_zero_initialize_device_memory,
	/// Subset of VK_SEC_pipeline_cache_incremental_mode
	pub vk_sec_pipeline_cache_incremental_mode: Vulkan_SEC_pipeline_cache_incremental_mode,
	/// Subset of VK_KHR_acceleration_structure
	pub vk_khr_acceleration_structure: Vulkan_KHR_acceleration_structure,
	/// Subset of VK_KHR_ray_tracing_pipeline
	pub vk_khr_ray_tracing_pipeline: Vulkan_KHR_ray_tracing_pipeline,
	/// Subset of VK_KHR_ray_query
	pub vk_khr_ray_query: Vulkan_KHR_ray_query,
	/// Subset of VK_EXT_mesh_shader
	pub vk_ext_mesh_shader: Vulkan_EXT_mesh_shader,
}
impl VK_VERSION_1_0 for VkCore {
	fn vkCreateInstance(&self, pCreateInfo: *const VkInstanceCreateInfo, pAllocator: *const VkAllocationCallbacks, pInstance: *mut VkInstance) -> Result<()> {
		convert_result("vkCreateInstance", catch_unwind(||((self.vk_version_1_0.vk_create_instance)(pCreateInfo, pAllocator, pInstance))))
	}
	fn vkDestroyInstance(&self, instance: VkInstance, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_instance)(instance, pAllocator))))
	}
	fn vkEnumeratePhysicalDevices(&self, instance: VkInstance, pPhysicalDeviceCount: *mut uint32_t, pPhysicalDevices: *mut VkPhysicalDevice) -> Result<()> {
		convert_result("vkEnumeratePhysicalDevices", catch_unwind(||((self.vk_version_1_0.vk_enumerate_physical_devices)(instance, pPhysicalDeviceCount, pPhysicalDevices))))
	}
	fn vkGetPhysicalDeviceFeatures(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_get_physical_device_features)(physicalDevice, pFeatures))))
	}
	fn vkGetPhysicalDeviceFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_get_physical_device_format_properties)(physicalDevice, format, pFormatProperties))))
	}
	fn vkGetPhysicalDeviceImageFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, pImageFormatProperties: *mut VkImageFormatProperties) -> Result<()> {
		convert_result("vkGetPhysicalDeviceImageFormatProperties", catch_unwind(||((self.vk_version_1_0.vk_get_physical_device_image_format_properties)(physicalDevice, format, type_, tiling, usage, flags, pImageFormatProperties))))
	}
	fn vkGetPhysicalDeviceProperties(&self, physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_get_physical_device_properties)(physicalDevice, pProperties))))
	}
	fn vkGetPhysicalDeviceQueueFamilyProperties(&self, physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_get_physical_device_queue_family_properties)(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties))))
	}
	fn vkGetPhysicalDeviceMemoryProperties(&self, physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_get_physical_device_memory_properties)(physicalDevice, pMemoryProperties))))
	}
	fn vkGetInstanceProcAddr(&self, instance: VkInstance, pName: *const i8) -> Result<PFN_vkVoidFunction> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_get_instance_proc_addr)(instance, pName))))
	}
	fn vkGetDeviceProcAddr(&self, device: VkDevice, pName: *const i8) -> Result<PFN_vkVoidFunction> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_get_device_proc_addr)(device, pName))))
	}
	fn vkCreateDevice(&self, physicalDevice: VkPhysicalDevice, pCreateInfo: *const VkDeviceCreateInfo, pAllocator: *const VkAllocationCallbacks, pDevice: *mut VkDevice) -> Result<()> {
		convert_result("vkCreateDevice", catch_unwind(||((self.vk_version_1_0.vk_create_device)(physicalDevice, pCreateInfo, pAllocator, pDevice))))
	}
	fn vkDestroyDevice(&self, device: VkDevice, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_device)(device, pAllocator))))
	}
	fn vkEnumerateInstanceExtensionProperties(&self, pLayerName: *const i8, pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> Result<()> {
		convert_result("vkEnumerateInstanceExtensionProperties", catch_unwind(||((self.vk_version_1_0.vk_enumerate_instance_extension_properties)(pLayerName, pPropertyCount, pProperties))))
	}
	fn vkEnumerateDeviceExtensionProperties(&self, physicalDevice: VkPhysicalDevice, pLayerName: *const i8, pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> Result<()> {
		convert_result("vkEnumerateDeviceExtensionProperties", catch_unwind(||((self.vk_version_1_0.vk_enumerate_device_extension_properties)(physicalDevice, pLayerName, pPropertyCount, pProperties))))
	}
	fn vkEnumerateInstanceLayerProperties(&self, pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> Result<()> {
		convert_result("vkEnumerateInstanceLayerProperties", catch_unwind(||((self.vk_version_1_0.vk_enumerate_instance_layer_properties)(pPropertyCount, pProperties))))
	}
	fn vkEnumerateDeviceLayerProperties(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> Result<()> {
		convert_result("vkEnumerateDeviceLayerProperties", catch_unwind(||((self.vk_version_1_0.vk_enumerate_device_layer_properties)(physicalDevice, pPropertyCount, pProperties))))
	}
	fn vkGetDeviceQueue(&self, device: VkDevice, queueFamilyIndex: u32, queueIndex: u32, pQueue: *mut VkQueue) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_get_device_queue)(device, queueFamilyIndex, queueIndex, pQueue))))
	}
	fn vkQueueSubmit(&self, queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo, fence: VkFence) -> Result<()> {
		convert_result("vkQueueSubmit", catch_unwind(||((self.vk_version_1_0.vk_queue_submit)(queue, submitCount, pSubmits, fence))))
	}
	fn vkQueueWaitIdle(&self, queue: VkQueue) -> Result<()> {
		convert_result("vkQueueWaitIdle", catch_unwind(||((self.vk_version_1_0.vk_queue_wait_idle)(queue))))
	}
	fn vkDeviceWaitIdle(&self, device: VkDevice) -> Result<()> {
		convert_result("vkDeviceWaitIdle", catch_unwind(||((self.vk_version_1_0.vk_device_wait_idle)(device))))
	}
	fn vkAllocateMemory(&self, device: VkDevice, pAllocateInfo: *const VkMemoryAllocateInfo, pAllocator: *const VkAllocationCallbacks, pMemory: *mut VkDeviceMemory) -> Result<()> {
		convert_result("vkAllocateMemory", catch_unwind(||((self.vk_version_1_0.vk_allocate_memory)(device, pAllocateInfo, pAllocator, pMemory))))
	}
	fn vkFreeMemory(&self, device: VkDevice, memory: VkDeviceMemory, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_free_memory)(device, memory, pAllocator))))
	}
	fn vkMapMemory(&self, device: VkDevice, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize, flags: VkMemoryMapFlags, ppData: *mut *mut c_void) -> Result<()> {
		convert_result("vkMapMemory", catch_unwind(||((self.vk_version_1_0.vk_map_memory)(device, memory, offset, size, flags, ppData))))
	}
	fn vkUnmapMemory(&self, device: VkDevice, memory: VkDeviceMemory) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_unmap_memory)(device, memory))))
	}
	fn vkFlushMappedMemoryRanges(&self, device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *const VkMappedMemoryRange) -> Result<()> {
		convert_result("vkFlushMappedMemoryRanges", catch_unwind(||((self.vk_version_1_0.vk_flush_mapped_memory_ranges)(device, memoryRangeCount, pMemoryRanges))))
	}
	fn vkInvalidateMappedMemoryRanges(&self, device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *const VkMappedMemoryRange) -> Result<()> {
		convert_result("vkInvalidateMappedMemoryRanges", catch_unwind(||((self.vk_version_1_0.vk_invalidate_mapped_memory_ranges)(device, memoryRangeCount, pMemoryRanges))))
	}
	fn vkGetDeviceMemoryCommitment(&self, device: VkDevice, memory: VkDeviceMemory, pCommittedMemoryInBytes: *mut VkDeviceSize) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_get_device_memory_commitment)(device, memory, pCommittedMemoryInBytes))))
	}
	fn vkBindBufferMemory(&self, device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> Result<()> {
		convert_result("vkBindBufferMemory", catch_unwind(||((self.vk_version_1_0.vk_bind_buffer_memory)(device, buffer, memory, memoryOffset))))
	}
	fn vkBindImageMemory(&self, device: VkDevice, image: VkImage, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) -> Result<()> {
		convert_result("vkBindImageMemory", catch_unwind(||((self.vk_version_1_0.vk_bind_image_memory)(device, image, memory, memoryOffset))))
	}
	fn vkGetBufferMemoryRequirements(&self, device: VkDevice, buffer: VkBuffer, pMemoryRequirements: *mut VkMemoryRequirements) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_get_buffer_memory_requirements)(device, buffer, pMemoryRequirements))))
	}
	fn vkGetImageMemoryRequirements(&self, device: VkDevice, image: VkImage, pMemoryRequirements: *mut VkMemoryRequirements) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_get_image_memory_requirements)(device, image, pMemoryRequirements))))
	}
	fn vkGetImageSparseMemoryRequirements(&self, device: VkDevice, image: VkImage, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_get_image_sparse_memory_requirements)(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements))))
	}
	fn vkGetPhysicalDeviceSparseImageFormatProperties(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_get_physical_device_sparse_image_format_properties)(physicalDevice, format, type_, samples, usage, tiling, pPropertyCount, pProperties))))
	}
	fn vkQueueBindSparse(&self, queue: VkQueue, bindInfoCount: u32, pBindInfo: *const VkBindSparseInfo, fence: VkFence) -> Result<()> {
		convert_result("vkQueueBindSparse", catch_unwind(||((self.vk_version_1_0.vk_queue_bind_sparse)(queue, bindInfoCount, pBindInfo, fence))))
	}
	fn vkCreateFence(&self, device: VkDevice, pCreateInfo: *const VkFenceCreateInfo, pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence) -> Result<()> {
		convert_result("vkCreateFence", catch_unwind(||((self.vk_version_1_0.vk_create_fence)(device, pCreateInfo, pAllocator, pFence))))
	}
	fn vkDestroyFence(&self, device: VkDevice, fence: VkFence, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_fence)(device, fence, pAllocator))))
	}
	fn vkResetFences(&self, device: VkDevice, fenceCount: u32, pFences: *const VkFence) -> Result<()> {
		convert_result("vkResetFences", catch_unwind(||((self.vk_version_1_0.vk_reset_fences)(device, fenceCount, pFences))))
	}
	fn vkGetFenceStatus(&self, device: VkDevice, fence: VkFence) -> Result<()> {
		convert_result("vkGetFenceStatus", catch_unwind(||((self.vk_version_1_0.vk_get_fence_status)(device, fence))))
	}
	fn vkWaitForFences(&self, device: VkDevice, fenceCount: u32, pFences: *const VkFence, waitAll: VkBool32, timeout: u64) -> Result<()> {
		convert_result("vkWaitForFences", catch_unwind(||((self.vk_version_1_0.vk_wait_for_fences)(device, fenceCount, pFences, waitAll, timeout))))
	}
	fn vkCreateSemaphore(&self, device: VkDevice, pCreateInfo: *const VkSemaphoreCreateInfo, pAllocator: *const VkAllocationCallbacks, pSemaphore: *mut VkSemaphore) -> Result<()> {
		convert_result("vkCreateSemaphore", catch_unwind(||((self.vk_version_1_0.vk_create_semaphore)(device, pCreateInfo, pAllocator, pSemaphore))))
	}
	fn vkDestroySemaphore(&self, device: VkDevice, semaphore: VkSemaphore, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_semaphore)(device, semaphore, pAllocator))))
	}
	fn vkCreateEvent(&self, device: VkDevice, pCreateInfo: *const VkEventCreateInfo, pAllocator: *const VkAllocationCallbacks, pEvent: *mut VkEvent) -> Result<()> {
		convert_result("vkCreateEvent", catch_unwind(||((self.vk_version_1_0.vk_create_event)(device, pCreateInfo, pAllocator, pEvent))))
	}
	fn vkDestroyEvent(&self, device: VkDevice, event: VkEvent, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_event)(device, event, pAllocator))))
	}
	fn vkGetEventStatus(&self, device: VkDevice, event: VkEvent) -> Result<()> {
		convert_result("vkGetEventStatus", catch_unwind(||((self.vk_version_1_0.vk_get_event_status)(device, event))))
	}
	fn vkSetEvent(&self, device: VkDevice, event: VkEvent) -> Result<()> {
		convert_result("vkSetEvent", catch_unwind(||((self.vk_version_1_0.vk_set_event)(device, event))))
	}
	fn vkResetEvent(&self, device: VkDevice, event: VkEvent) -> Result<()> {
		convert_result("vkResetEvent", catch_unwind(||((self.vk_version_1_0.vk_reset_event)(device, event))))
	}
	fn vkCreateQueryPool(&self, device: VkDevice, pCreateInfo: *const VkQueryPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pQueryPool: *mut VkQueryPool) -> Result<()> {
		convert_result("vkCreateQueryPool", catch_unwind(||((self.vk_version_1_0.vk_create_query_pool)(device, pCreateInfo, pAllocator, pQueryPool))))
	}
	fn vkDestroyQueryPool(&self, device: VkDevice, queryPool: VkQueryPool, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_query_pool)(device, queryPool, pAllocator))))
	}
	fn vkGetQueryPoolResults(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dataSize: usize, pData: *mut c_void, stride: VkDeviceSize, flags: VkQueryResultFlags) -> Result<()> {
		convert_result("vkGetQueryPoolResults", catch_unwind(||((self.vk_version_1_0.vk_get_query_pool_results)(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags))))
	}
	fn vkCreateBuffer(&self, device: VkDevice, pCreateInfo: *const VkBufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pBuffer: *mut VkBuffer) -> Result<()> {
		convert_result("vkCreateBuffer", catch_unwind(||((self.vk_version_1_0.vk_create_buffer)(device, pCreateInfo, pAllocator, pBuffer))))
	}
	fn vkDestroyBuffer(&self, device: VkDevice, buffer: VkBuffer, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_buffer)(device, buffer, pAllocator))))
	}
	fn vkCreateBufferView(&self, device: VkDevice, pCreateInfo: *const VkBufferViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkBufferView) -> Result<()> {
		convert_result("vkCreateBufferView", catch_unwind(||((self.vk_version_1_0.vk_create_buffer_view)(device, pCreateInfo, pAllocator, pView))))
	}
	fn vkDestroyBufferView(&self, device: VkDevice, bufferView: VkBufferView, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_buffer_view)(device, bufferView, pAllocator))))
	}
	fn vkCreateImage(&self, device: VkDevice, pCreateInfo: *const VkImageCreateInfo, pAllocator: *const VkAllocationCallbacks, pImage: *mut VkImage) -> Result<()> {
		convert_result("vkCreateImage", catch_unwind(||((self.vk_version_1_0.vk_create_image)(device, pCreateInfo, pAllocator, pImage))))
	}
	fn vkDestroyImage(&self, device: VkDevice, image: VkImage, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_image)(device, image, pAllocator))))
	}
	fn vkGetImageSubresourceLayout(&self, device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource, pLayout: *mut VkSubresourceLayout) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_get_image_subresource_layout)(device, image, pSubresource, pLayout))))
	}
	fn vkCreateImageView(&self, device: VkDevice, pCreateInfo: *const VkImageViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkImageView) -> Result<()> {
		convert_result("vkCreateImageView", catch_unwind(||((self.vk_version_1_0.vk_create_image_view)(device, pCreateInfo, pAllocator, pView))))
	}
	fn vkDestroyImageView(&self, device: VkDevice, imageView: VkImageView, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_image_view)(device, imageView, pAllocator))))
	}
	fn vkCreateShaderModule(&self, device: VkDevice, pCreateInfo: *const VkShaderModuleCreateInfo, pAllocator: *const VkAllocationCallbacks, pShaderModule: *mut VkShaderModule) -> Result<()> {
		convert_result("vkCreateShaderModule", catch_unwind(||((self.vk_version_1_0.vk_create_shader_module)(device, pCreateInfo, pAllocator, pShaderModule))))
	}
	fn vkDestroyShaderModule(&self, device: VkDevice, shaderModule: VkShaderModule, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_shader_module)(device, shaderModule, pAllocator))))
	}
	fn vkCreatePipelineCache(&self, device: VkDevice, pCreateInfo: *const VkPipelineCacheCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineCache: *mut VkPipelineCache) -> Result<()> {
		convert_result("vkCreatePipelineCache", catch_unwind(||((self.vk_version_1_0.vk_create_pipeline_cache)(device, pCreateInfo, pAllocator, pPipelineCache))))
	}
	fn vkDestroyPipelineCache(&self, device: VkDevice, pipelineCache: VkPipelineCache, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_pipeline_cache)(device, pipelineCache, pAllocator))))
	}
	fn vkGetPipelineCacheData(&self, device: VkDevice, pipelineCache: VkPipelineCache, pDataSize: *mut size_t, pData: *mut c_void) -> Result<()> {
		convert_result("vkGetPipelineCacheData", catch_unwind(||((self.vk_version_1_0.vk_get_pipeline_cache_data)(device, pipelineCache, pDataSize, pData))))
	}
	fn vkMergePipelineCaches(&self, device: VkDevice, dstCache: VkPipelineCache, srcCacheCount: u32, pSrcCaches: *const VkPipelineCache) -> Result<()> {
		convert_result("vkMergePipelineCaches", catch_unwind(||((self.vk_version_1_0.vk_merge_pipeline_caches)(device, dstCache, srcCacheCount, pSrcCaches))))
	}
	fn vkCreateGraphicsPipelines(&self, device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkGraphicsPipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> Result<()> {
		convert_result("vkCreateGraphicsPipelines", catch_unwind(||((self.vk_version_1_0.vk_create_graphics_pipelines)(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines))))
	}
	fn vkCreateComputePipelines(&self, device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkComputePipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> Result<()> {
		convert_result("vkCreateComputePipelines", catch_unwind(||((self.vk_version_1_0.vk_create_compute_pipelines)(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines))))
	}
	fn vkDestroyPipeline(&self, device: VkDevice, pipeline: VkPipeline, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_pipeline)(device, pipeline, pAllocator))))
	}
	fn vkCreatePipelineLayout(&self, device: VkDevice, pCreateInfo: *const VkPipelineLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineLayout: *mut VkPipelineLayout) -> Result<()> {
		convert_result("vkCreatePipelineLayout", catch_unwind(||((self.vk_version_1_0.vk_create_pipeline_layout)(device, pCreateInfo, pAllocator, pPipelineLayout))))
	}
	fn vkDestroyPipelineLayout(&self, device: VkDevice, pipelineLayout: VkPipelineLayout, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_pipeline_layout)(device, pipelineLayout, pAllocator))))
	}
	fn vkCreateSampler(&self, device: VkDevice, pCreateInfo: *const VkSamplerCreateInfo, pAllocator: *const VkAllocationCallbacks, pSampler: *mut VkSampler) -> Result<()> {
		convert_result("vkCreateSampler", catch_unwind(||((self.vk_version_1_0.vk_create_sampler)(device, pCreateInfo, pAllocator, pSampler))))
	}
	fn vkDestroySampler(&self, device: VkDevice, sampler: VkSampler, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_sampler)(device, sampler, pAllocator))))
	}
	fn vkCreateDescriptorSetLayout(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pSetLayout: *mut VkDescriptorSetLayout) -> Result<()> {
		convert_result("vkCreateDescriptorSetLayout", catch_unwind(||((self.vk_version_1_0.vk_create_descriptor_set_layout)(device, pCreateInfo, pAllocator, pSetLayout))))
	}
	fn vkDestroyDescriptorSetLayout(&self, device: VkDevice, descriptorSetLayout: VkDescriptorSetLayout, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_descriptor_set_layout)(device, descriptorSetLayout, pAllocator))))
	}
	fn vkCreateDescriptorPool(&self, device: VkDevice, pCreateInfo: *const VkDescriptorPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorPool: *mut VkDescriptorPool) -> Result<()> {
		convert_result("vkCreateDescriptorPool", catch_unwind(||((self.vk_version_1_0.vk_create_descriptor_pool)(device, pCreateInfo, pAllocator, pDescriptorPool))))
	}
	fn vkDestroyDescriptorPool(&self, device: VkDevice, descriptorPool: VkDescriptorPool, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_descriptor_pool)(device, descriptorPool, pAllocator))))
	}
	fn vkResetDescriptorPool(&self, device: VkDevice, descriptorPool: VkDescriptorPool, flags: VkDescriptorPoolResetFlags) -> Result<()> {
		convert_result("vkResetDescriptorPool", catch_unwind(||((self.vk_version_1_0.vk_reset_descriptor_pool)(device, descriptorPool, flags))))
	}
	fn vkAllocateDescriptorSets(&self, device: VkDevice, pAllocateInfo: *const VkDescriptorSetAllocateInfo, pDescriptorSets: *mut VkDescriptorSet) -> Result<()> {
		convert_result("vkAllocateDescriptorSets", catch_unwind(||((self.vk_version_1_0.vk_allocate_descriptor_sets)(device, pAllocateInfo, pDescriptorSets))))
	}
	fn vkFreeDescriptorSets(&self, device: VkDevice, descriptorPool: VkDescriptorPool, descriptorSetCount: u32, pDescriptorSets: *const VkDescriptorSet) -> Result<()> {
		convert_result("vkFreeDescriptorSets", catch_unwind(||((self.vk_version_1_0.vk_free_descriptor_sets)(device, descriptorPool, descriptorSetCount, pDescriptorSets))))
	}
	fn vkUpdateDescriptorSets(&self, device: VkDevice, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: *const VkCopyDescriptorSet) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_update_descriptor_sets)(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies))))
	}
	fn vkCreateFramebuffer(&self, device: VkDevice, pCreateInfo: *const VkFramebufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pFramebuffer: *mut VkFramebuffer) -> Result<()> {
		convert_result("vkCreateFramebuffer", catch_unwind(||((self.vk_version_1_0.vk_create_framebuffer)(device, pCreateInfo, pAllocator, pFramebuffer))))
	}
	fn vkDestroyFramebuffer(&self, device: VkDevice, framebuffer: VkFramebuffer, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_framebuffer)(device, framebuffer, pAllocator))))
	}
	fn vkCreateRenderPass(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> Result<()> {
		convert_result("vkCreateRenderPass", catch_unwind(||((self.vk_version_1_0.vk_create_render_pass)(device, pCreateInfo, pAllocator, pRenderPass))))
	}
	fn vkDestroyRenderPass(&self, device: VkDevice, renderPass: VkRenderPass, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_render_pass)(device, renderPass, pAllocator))))
	}
	fn vkGetRenderAreaGranularity(&self, device: VkDevice, renderPass: VkRenderPass, pGranularity: *mut VkExtent2D) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_get_render_area_granularity)(device, renderPass, pGranularity))))
	}
	fn vkCreateCommandPool(&self, device: VkDevice, pCreateInfo: *const VkCommandPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pCommandPool: *mut VkCommandPool) -> Result<()> {
		convert_result("vkCreateCommandPool", catch_unwind(||((self.vk_version_1_0.vk_create_command_pool)(device, pCreateInfo, pAllocator, pCommandPool))))
	}
	fn vkDestroyCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_destroy_command_pool)(device, commandPool, pAllocator))))
	}
	fn vkResetCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolResetFlags) -> Result<()> {
		convert_result("vkResetCommandPool", catch_unwind(||((self.vk_version_1_0.vk_reset_command_pool)(device, commandPool, flags))))
	}
	fn vkAllocateCommandBuffers(&self, device: VkDevice, pAllocateInfo: *const VkCommandBufferAllocateInfo, pCommandBuffers: *mut VkCommandBuffer) -> Result<()> {
		convert_result("vkAllocateCommandBuffers", catch_unwind(||((self.vk_version_1_0.vk_allocate_command_buffers)(device, pAllocateInfo, pCommandBuffers))))
	}
	fn vkFreeCommandBuffers(&self, device: VkDevice, commandPool: VkCommandPool, commandBufferCount: u32, pCommandBuffers: *const VkCommandBuffer) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_free_command_buffers)(device, commandPool, commandBufferCount, pCommandBuffers))))
	}
	fn vkBeginCommandBuffer(&self, commandBuffer: VkCommandBuffer, pBeginInfo: *const VkCommandBufferBeginInfo) -> Result<()> {
		convert_result("vkBeginCommandBuffer", catch_unwind(||((self.vk_version_1_0.vk_begin_command_buffer)(commandBuffer, pBeginInfo))))
	}
	fn vkEndCommandBuffer(&self, commandBuffer: VkCommandBuffer) -> Result<()> {
		convert_result("vkEndCommandBuffer", catch_unwind(||((self.vk_version_1_0.vk_end_command_buffer)(commandBuffer))))
	}
	fn vkResetCommandBuffer(&self, commandBuffer: VkCommandBuffer, flags: VkCommandBufferResetFlags) -> Result<()> {
		convert_result("vkResetCommandBuffer", catch_unwind(||((self.vk_version_1_0.vk_reset_command_buffer)(commandBuffer, flags))))
	}
	fn vkCmdBindPipeline(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_bind_pipeline)(commandBuffer, pipelineBindPoint, pipeline))))
	}
	fn vkCmdSetViewport(&self, commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: *const VkViewport) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_set_viewport)(commandBuffer, firstViewport, viewportCount, pViewports))))
	}
	fn vkCmdSetScissor(&self, commandBuffer: VkCommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: *const VkRect2D) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_set_scissor)(commandBuffer, firstScissor, scissorCount, pScissors))))
	}
	fn vkCmdSetLineWidth(&self, commandBuffer: VkCommandBuffer, lineWidth: f32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_set_line_width)(commandBuffer, lineWidth))))
	}
	fn vkCmdSetDepthBias(&self, commandBuffer: VkCommandBuffer, depthBiasConstantFactor: f32, depthBiasClamp: f32, depthBiasSlopeFactor: f32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_set_depth_bias)(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor))))
	}
	fn vkCmdSetBlendConstants(&self, commandBuffer: VkCommandBuffer, blendConstants: &[float; 4 as usize]) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_set_blend_constants)(commandBuffer, blendConstants))))
	}
	fn vkCmdSetDepthBounds(&self, commandBuffer: VkCommandBuffer, minDepthBounds: f32, maxDepthBounds: f32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_set_depth_bounds)(commandBuffer, minDepthBounds, maxDepthBounds))))
	}
	fn vkCmdSetStencilCompareMask(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, compareMask: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_set_stencil_compare_mask)(commandBuffer, faceMask, compareMask))))
	}
	fn vkCmdSetStencilWriteMask(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, writeMask: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_set_stencil_write_mask)(commandBuffer, faceMask, writeMask))))
	}
	fn vkCmdSetStencilReference(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, reference: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_set_stencil_reference)(commandBuffer, faceMask, reference))))
	}
	fn vkCmdBindDescriptorSets(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: *const VkDescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: *const uint32_t) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_bind_descriptor_sets)(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets))))
	}
	fn vkCmdBindIndexBuffer(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, indexType: VkIndexType) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_bind_index_buffer)(commandBuffer, buffer, offset, indexType))))
	}
	fn vkCmdBindVertexBuffers(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_bind_vertex_buffers)(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets))))
	}
	fn vkCmdDraw(&self, commandBuffer: VkCommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_draw)(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance))))
	}
	fn vkCmdDrawIndexed(&self, commandBuffer: VkCommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: i32, firstInstance: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_draw_indexed)(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance))))
	}
	fn vkCmdDrawIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_draw_indirect)(commandBuffer, buffer, offset, drawCount, stride))))
	}
	fn vkCmdDrawIndexedIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_draw_indexed_indirect)(commandBuffer, buffer, offset, drawCount, stride))))
	}
	fn vkCmdDispatch(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_dispatch)(commandBuffer, groupCountX, groupCountY, groupCountZ))))
	}
	fn vkCmdDispatchIndirect(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_dispatch_indirect)(commandBuffer, buffer, offset))))
	}
	fn vkCmdCopyBuffer(&self, commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstBuffer: VkBuffer, regionCount: u32, pRegions: *const VkBufferCopy) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_copy_buffer)(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions))))
	}
	fn vkCmdCopyImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageCopy) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_copy_image)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions))))
	}
	fn vkCmdBlitImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageBlit, filter: VkFilter) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_blit_image)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter))))
	}
	fn vkCmdCopyBufferToImage(&self, commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkBufferImageCopy) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_copy_buffer_to_image)(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions))))
	}
	fn vkCmdCopyImageToBuffer(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstBuffer: VkBuffer, regionCount: u32, pRegions: *const VkBufferImageCopy) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_copy_image_to_buffer)(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions))))
	}
	fn vkCmdUpdateBuffer(&self, commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, dataSize: VkDeviceSize, pData: *const c_void) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_update_buffer)(commandBuffer, dstBuffer, dstOffset, dataSize, pData))))
	}
	fn vkCmdFillBuffer(&self, commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, size: VkDeviceSize, data: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_fill_buffer)(commandBuffer, dstBuffer, dstOffset, size, data))))
	}
	fn vkCmdClearColorImage(&self, commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pColor: *const VkClearColorValue, rangeCount: u32, pRanges: *const VkImageSubresourceRange) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_clear_color_image)(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges))))
	}
	fn vkCmdClearDepthStencilImage(&self, commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pDepthStencil: *const VkClearDepthStencilValue, rangeCount: u32, pRanges: *const VkImageSubresourceRange) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_clear_depth_stencil_image)(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges))))
	}
	fn vkCmdClearAttachments(&self, commandBuffer: VkCommandBuffer, attachmentCount: u32, pAttachments: *const VkClearAttachment, rectCount: u32, pRects: *const VkClearRect) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_clear_attachments)(commandBuffer, attachmentCount, pAttachments, rectCount, pRects))))
	}
	fn vkCmdResolveImage(&self, commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *const VkImageResolve) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_resolve_image)(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions))))
	}
	fn vkCmdSetEvent(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_set_event)(commandBuffer, event, stageMask))))
	}
	fn vkCmdResetEvent(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_reset_event)(commandBuffer, event, stageMask))))
	}
	fn vkCmdWaitEvents(&self, commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const VkImageMemoryBarrier) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_wait_events)(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers))))
	}
	fn vkCmdPipelineBarrier(&self, commandBuffer: VkCommandBuffer, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, dependencyFlags: VkDependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *const VkImageMemoryBarrier) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_pipeline_barrier)(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers))))
	}
	fn vkCmdBeginQuery(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_begin_query)(commandBuffer, queryPool, query, flags))))
	}
	fn vkCmdEndQuery(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_end_query)(commandBuffer, queryPool, query))))
	}
	fn vkCmdResetQueryPool(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_reset_query_pool)(commandBuffer, queryPool, firstQuery, queryCount))))
	}
	fn vkCmdWriteTimestamp(&self, commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, queryPool: VkQueryPool, query: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_write_timestamp)(commandBuffer, pipelineStage, queryPool, query))))
	}
	fn vkCmdCopyQueryPoolResults(&self, commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, stride: VkDeviceSize, flags: VkQueryResultFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_copy_query_pool_results)(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags))))
	}
	fn vkCmdPushConstants(&self, commandBuffer: VkCommandBuffer, layout: VkPipelineLayout, stageFlags: VkShaderStageFlags, offset: u32, size: u32, pValues: *const c_void) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_push_constants)(commandBuffer, layout, stageFlags, offset, size, pValues))))
	}
	fn vkCmdBeginRenderPass(&self, commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, contents: VkSubpassContents) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_begin_render_pass)(commandBuffer, pRenderPassBegin, contents))))
	}
	fn vkCmdNextSubpass(&self, commandBuffer: VkCommandBuffer, contents: VkSubpassContents) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_next_subpass)(commandBuffer, contents))))
	}
	fn vkCmdEndRenderPass(&self, commandBuffer: VkCommandBuffer) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_end_render_pass)(commandBuffer))))
	}
	fn vkCmdExecuteCommands(&self, commandBuffer: VkCommandBuffer, commandBufferCount: u32, pCommandBuffers: *const VkCommandBuffer) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_0.vk_cmd_execute_commands)(commandBuffer, commandBufferCount, pCommandBuffers))))
	}
}
impl VK_VERSION_1_1 for VkCore {
	fn vkEnumerateInstanceVersion(&self, pApiVersion: *mut uint32_t) -> Result<()> {
		convert_result("vkEnumerateInstanceVersion", catch_unwind(||((self.vk_version_1_1.vk_enumerate_instance_version)(pApiVersion))))
	}
	fn vkBindBufferMemory2(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindBufferMemoryInfo) -> Result<()> {
		convert_result("vkBindBufferMemory2", catch_unwind(||((self.vk_version_1_1.vk_bind_buffer_memory2)(device, bindInfoCount, pBindInfos))))
	}
	fn vkBindImageMemory2(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindImageMemoryInfo) -> Result<()> {
		convert_result("vkBindImageMemory2", catch_unwind(||((self.vk_version_1_1.vk_bind_image_memory2)(device, bindInfoCount, pBindInfos))))
	}
	fn vkGetDeviceGroupPeerMemoryFeatures(&self, device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_get_device_group_peer_memory_features)(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures))))
	}
	fn vkCmdSetDeviceMask(&self, commandBuffer: VkCommandBuffer, deviceMask: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_cmd_set_device_mask)(commandBuffer, deviceMask))))
	}
	fn vkCmdDispatchBase(&self, commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_cmd_dispatch_base)(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ))))
	}
	fn vkEnumeratePhysicalDeviceGroups(&self, instance: VkInstance, pPhysicalDeviceGroupCount: *mut uint32_t, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties) -> Result<()> {
		convert_result("vkEnumeratePhysicalDeviceGroups", catch_unwind(||((self.vk_version_1_1.vk_enumerate_physical_device_groups)(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties))))
	}
	fn vkGetImageMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkImageMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_get_image_memory_requirements2)(device, pInfo, pMemoryRequirements))))
	}
	fn vkGetBufferMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_get_buffer_memory_requirements2)(device, pInfo, pMemoryRequirements))))
	}
	fn vkGetImageSparseMemoryRequirements2(&self, device: VkDevice, pInfo: *const VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_get_image_sparse_memory_requirements2)(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements))))
	}
	fn vkGetPhysicalDeviceFeatures2(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_get_physical_device_features2)(physicalDevice, pFeatures))))
	}
	fn vkGetPhysicalDeviceProperties2(&self, physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_get_physical_device_properties2)(physicalDevice, pProperties))))
	}
	fn vkGetPhysicalDeviceFormatProperties2(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_get_physical_device_format_properties2)(physicalDevice, format, pFormatProperties))))
	}
	fn vkGetPhysicalDeviceImageFormatProperties2(&self, physicalDevice: VkPhysicalDevice, pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *mut VkImageFormatProperties2) -> Result<()> {
		convert_result("vkGetPhysicalDeviceImageFormatProperties2", catch_unwind(||((self.vk_version_1_1.vk_get_physical_device_image_format_properties2)(physicalDevice, pImageFormatInfo, pImageFormatProperties))))
	}
	fn vkGetPhysicalDeviceQueueFamilyProperties2(&self, physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t, pQueueFamilyProperties: *mut VkQueueFamilyProperties2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_get_physical_device_queue_family_properties2)(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties))))
	}
	fn vkGetPhysicalDeviceMemoryProperties2(&self, physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_get_physical_device_memory_properties2)(physicalDevice, pMemoryProperties))))
	}
	fn vkGetPhysicalDeviceSparseImageFormatProperties2(&self, physicalDevice: VkPhysicalDevice, pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_get_physical_device_sparse_image_format_properties2)(physicalDevice, pFormatInfo, pPropertyCount, pProperties))))
	}
	fn vkTrimCommandPool(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_trim_command_pool)(device, commandPool, flags))))
	}
	fn vkGetDeviceQueue2(&self, device: VkDevice, pQueueInfo: *const VkDeviceQueueInfo2, pQueue: *mut VkQueue) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_get_device_queue2)(device, pQueueInfo, pQueue))))
	}
	fn vkCreateSamplerYcbcrConversion(&self, device: VkDevice, pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo, pAllocator: *const VkAllocationCallbacks, pYcbcrConversion: *mut VkSamplerYcbcrConversion) -> Result<()> {
		convert_result("vkCreateSamplerYcbcrConversion", catch_unwind(||((self.vk_version_1_1.vk_create_sampler_ycbcr_conversion)(device, pCreateInfo, pAllocator, pYcbcrConversion))))
	}
	fn vkDestroySamplerYcbcrConversion(&self, device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_destroy_sampler_ycbcr_conversion)(device, ycbcrConversion, pAllocator))))
	}
	fn vkCreateDescriptorUpdateTemplate(&self, device: VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate) -> Result<()> {
		convert_result("vkCreateDescriptorUpdateTemplate", catch_unwind(||((self.vk_version_1_1.vk_create_descriptor_update_template)(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate))))
	}
	fn vkDestroyDescriptorUpdateTemplate(&self, device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_destroy_descriptor_update_template)(device, descriptorUpdateTemplate, pAllocator))))
	}
	fn vkUpdateDescriptorSetWithTemplate(&self, device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: *const c_void) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_update_descriptor_set_with_template)(device, descriptorSet, descriptorUpdateTemplate, pData))))
	}
	fn vkGetPhysicalDeviceExternalBufferProperties(&self, physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut VkExternalBufferProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_get_physical_device_external_buffer_properties)(physicalDevice, pExternalBufferInfo, pExternalBufferProperties))))
	}
	fn vkGetPhysicalDeviceExternalFenceProperties(&self, physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut VkExternalFenceProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_get_physical_device_external_fence_properties)(physicalDevice, pExternalFenceInfo, pExternalFenceProperties))))
	}
	fn vkGetPhysicalDeviceExternalSemaphoreProperties(&self, physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_get_physical_device_external_semaphore_properties)(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties))))
	}
	fn vkGetDescriptorSetLayoutSupport(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pSupport: *mut VkDescriptorSetLayoutSupport) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_1.vk_get_descriptor_set_layout_support)(device, pCreateInfo, pSupport))))
	}
}
impl VK_VERSION_1_2 for VkCore {
	fn vkCmdDrawIndirectCount(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_2.vk_cmd_draw_indirect_count)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride))))
	}
	fn vkCmdDrawIndexedIndirectCount(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_2.vk_cmd_draw_indexed_indirect_count)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride))))
	}
	fn vkCreateRenderPass2(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo2, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> Result<()> {
		convert_result("vkCreateRenderPass2", catch_unwind(||((self.vk_version_1_2.vk_create_render_pass2)(device, pCreateInfo, pAllocator, pRenderPass))))
	}
	fn vkCmdBeginRenderPass2(&self, commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, pSubpassBeginInfo: *const VkSubpassBeginInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_2.vk_cmd_begin_render_pass2)(commandBuffer, pRenderPassBegin, pSubpassBeginInfo))))
	}
	fn vkCmdNextSubpass2(&self, commandBuffer: VkCommandBuffer, pSubpassBeginInfo: *const VkSubpassBeginInfo, pSubpassEndInfo: *const VkSubpassEndInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_2.vk_cmd_next_subpass2)(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo))))
	}
	fn vkCmdEndRenderPass2(&self, commandBuffer: VkCommandBuffer, pSubpassEndInfo: *const VkSubpassEndInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_2.vk_cmd_end_render_pass2)(commandBuffer, pSubpassEndInfo))))
	}
	fn vkResetQueryPool(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_2.vk_reset_query_pool)(device, queryPool, firstQuery, queryCount))))
	}
	fn vkGetSemaphoreCounterValue(&self, device: VkDevice, semaphore: VkSemaphore, pValue: *mut uint64_t) -> Result<()> {
		convert_result("vkGetSemaphoreCounterValue", catch_unwind(||((self.vk_version_1_2.vk_get_semaphore_counter_value)(device, semaphore, pValue))))
	}
	fn vkWaitSemaphores(&self, device: VkDevice, pWaitInfo: *const VkSemaphoreWaitInfo, timeout: u64) -> Result<()> {
		convert_result("vkWaitSemaphores", catch_unwind(||((self.vk_version_1_2.vk_wait_semaphores)(device, pWaitInfo, timeout))))
	}
	fn vkSignalSemaphore(&self, device: VkDevice, pSignalInfo: *const VkSemaphoreSignalInfo) -> Result<()> {
		convert_result("vkSignalSemaphore", catch_unwind(||((self.vk_version_1_2.vk_signal_semaphore)(device, pSignalInfo))))
	}
	fn vkGetBufferDeviceAddress(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> Result<VkDeviceAddress> {
		process_catch(catch_unwind(||((self.vk_version_1_2.vk_get_buffer_device_address)(device, pInfo))))
	}
	fn vkGetBufferOpaqueCaptureAddress(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> Result<u64> {
		process_catch(catch_unwind(||((self.vk_version_1_2.vk_get_buffer_opaque_capture_address)(device, pInfo))))
	}
	fn vkGetDeviceMemoryOpaqueCaptureAddress(&self, device: VkDevice, pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo) -> Result<u64> {
		process_catch(catch_unwind(||((self.vk_version_1_2.vk_get_device_memory_opaque_capture_address)(device, pInfo))))
	}
}
impl VK_VERSION_1_3 for VkCore {
	fn vkGetPhysicalDeviceToolProperties(&self, physicalDevice: VkPhysicalDevice, pToolCount: *mut uint32_t, pToolProperties: *mut VkPhysicalDeviceToolProperties) -> Result<()> {
		convert_result("vkGetPhysicalDeviceToolProperties", catch_unwind(||((self.vk_version_1_3.vk_get_physical_device_tool_properties)(physicalDevice, pToolCount, pToolProperties))))
	}
	fn vkCreatePrivateDataSlot(&self, device: VkDevice, pCreateInfo: *const VkPrivateDataSlotCreateInfo, pAllocator: *const VkAllocationCallbacks, pPrivateDataSlot: *mut VkPrivateDataSlot) -> Result<()> {
		convert_result("vkCreatePrivateDataSlot", catch_unwind(||((self.vk_version_1_3.vk_create_private_data_slot)(device, pCreateInfo, pAllocator, pPrivateDataSlot))))
	}
	fn vkDestroyPrivateDataSlot(&self, device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_destroy_private_data_slot)(device, privateDataSlot, pAllocator))))
	}
	fn vkSetPrivateData(&self, device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, data: u64) -> Result<()> {
		convert_result("vkSetPrivateData", catch_unwind(||((self.vk_version_1_3.vk_set_private_data)(device, objectType, objectHandle, privateDataSlot, data))))
	}
	fn vkGetPrivateData(&self, device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, pData: *mut uint64_t) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_get_private_data)(device, objectType, objectHandle, privateDataSlot, pData))))
	}
	fn vkCmdSetEvent2(&self, commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *const VkDependencyInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_set_event2)(commandBuffer, event, pDependencyInfo))))
	}
	fn vkCmdResetEvent2(&self, commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_reset_event2)(commandBuffer, event, stageMask))))
	}
	fn vkCmdWaitEvents2(&self, commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *const VkEvent, pDependencyInfos: *const VkDependencyInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_wait_events2)(commandBuffer, eventCount, pEvents, pDependencyInfos))))
	}
	fn vkCmdPipelineBarrier2(&self, commandBuffer: VkCommandBuffer, pDependencyInfo: *const VkDependencyInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_pipeline_barrier2)(commandBuffer, pDependencyInfo))))
	}
	fn vkCmdWriteTimestamp2(&self, commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_write_timestamp2)(commandBuffer, stage, queryPool, query))))
	}
	fn vkQueueSubmit2(&self, queue: VkQueue, submitCount: u32, pSubmits: *const VkSubmitInfo2, fence: VkFence) -> Result<()> {
		convert_result("vkQueueSubmit2", catch_unwind(||((self.vk_version_1_3.vk_queue_submit2)(queue, submitCount, pSubmits, fence))))
	}
	fn vkCmdCopyBuffer2(&self, commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_copy_buffer2)(commandBuffer, pCopyBufferInfo))))
	}
	fn vkCmdCopyImage2(&self, commandBuffer: VkCommandBuffer, pCopyImageInfo: *const VkCopyImageInfo2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_copy_image2)(commandBuffer, pCopyImageInfo))))
	}
	fn vkCmdCopyBufferToImage2(&self, commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: *const VkCopyBufferToImageInfo2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_copy_buffer_to_image2)(commandBuffer, pCopyBufferToImageInfo))))
	}
	fn vkCmdCopyImageToBuffer2(&self, commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: *const VkCopyImageToBufferInfo2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_copy_image_to_buffer2)(commandBuffer, pCopyImageToBufferInfo))))
	}
	fn vkCmdBlitImage2(&self, commandBuffer: VkCommandBuffer, pBlitImageInfo: *const VkBlitImageInfo2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_blit_image2)(commandBuffer, pBlitImageInfo))))
	}
	fn vkCmdResolveImage2(&self, commandBuffer: VkCommandBuffer, pResolveImageInfo: *const VkResolveImageInfo2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_resolve_image2)(commandBuffer, pResolveImageInfo))))
	}
	fn vkCmdBeginRendering(&self, commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_begin_rendering)(commandBuffer, pRenderingInfo))))
	}
	fn vkCmdEndRendering(&self, commandBuffer: VkCommandBuffer) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_end_rendering)(commandBuffer))))
	}
	fn vkCmdSetCullMode(&self, commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_set_cull_mode)(commandBuffer, cullMode))))
	}
	fn vkCmdSetFrontFace(&self, commandBuffer: VkCommandBuffer, frontFace: VkFrontFace) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_set_front_face)(commandBuffer, frontFace))))
	}
	fn vkCmdSetPrimitiveTopology(&self, commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_set_primitive_topology)(commandBuffer, primitiveTopology))))
	}
	fn vkCmdSetViewportWithCount(&self, commandBuffer: VkCommandBuffer, viewportCount: u32, pViewports: *const VkViewport) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_set_viewport_with_count)(commandBuffer, viewportCount, pViewports))))
	}
	fn vkCmdSetScissorWithCount(&self, commandBuffer: VkCommandBuffer, scissorCount: u32, pScissors: *const VkRect2D) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_set_scissor_with_count)(commandBuffer, scissorCount, pScissors))))
	}
	fn vkCmdBindVertexBuffers2(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize, pStrides: *const VkDeviceSize) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_bind_vertex_buffers2)(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides))))
	}
	fn vkCmdSetDepthTestEnable(&self, commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_set_depth_test_enable)(commandBuffer, depthTestEnable))))
	}
	fn vkCmdSetDepthWriteEnable(&self, commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_set_depth_write_enable)(commandBuffer, depthWriteEnable))))
	}
	fn vkCmdSetDepthCompareOp(&self, commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_set_depth_compare_op)(commandBuffer, depthCompareOp))))
	}
	fn vkCmdSetDepthBoundsTestEnable(&self, commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_set_depth_bounds_test_enable)(commandBuffer, depthBoundsTestEnable))))
	}
	fn vkCmdSetStencilTestEnable(&self, commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_set_stencil_test_enable)(commandBuffer, stencilTestEnable))))
	}
	fn vkCmdSetStencilOp(&self, commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_set_stencil_op)(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp))))
	}
	fn vkCmdSetRasterizerDiscardEnable(&self, commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_set_rasterizer_discard_enable)(commandBuffer, rasterizerDiscardEnable))))
	}
	fn vkCmdSetDepthBiasEnable(&self, commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_set_depth_bias_enable)(commandBuffer, depthBiasEnable))))
	}
	fn vkCmdSetPrimitiveRestartEnable(&self, commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_cmd_set_primitive_restart_enable)(commandBuffer, primitiveRestartEnable))))
	}
	fn vkGetDeviceBufferMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceBufferMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_get_device_buffer_memory_requirements)(device, pInfo, pMemoryRequirements))))
	}
	fn vkGetDeviceImageMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_get_device_image_memory_requirements)(device, pInfo, pMemoryRequirements))))
	}
	fn vkGetDeviceImageSparseMemoryRequirements(&self, device: VkDevice, pInfo: *const VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: *mut uint32_t, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_3.vk_get_device_image_sparse_memory_requirements)(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements))))
	}
}
impl VK_VERSION_1_4 for VkCore {
	fn vkCmdSetLineStipple(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_4.vk_cmd_set_line_stipple)(commandBuffer, lineStippleFactor, lineStipplePattern))))
	}
	fn vkMapMemory2(&self, device: VkDevice, pMemoryMapInfo: *const VkMemoryMapInfo, ppData: *mut *mut c_void) -> Result<()> {
		convert_result("vkMapMemory2", catch_unwind(||((self.vk_version_1_4.vk_map_memory2)(device, pMemoryMapInfo, ppData))))
	}
	fn vkUnmapMemory2(&self, device: VkDevice, pMemoryUnmapInfo: *const VkMemoryUnmapInfo) -> Result<()> {
		convert_result("vkUnmapMemory2", catch_unwind(||((self.vk_version_1_4.vk_unmap_memory2)(device, pMemoryUnmapInfo))))
	}
	fn vkCmdBindIndexBuffer2(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_4.vk_cmd_bind_index_buffer2)(commandBuffer, buffer, offset, size, indexType))))
	}
	fn vkGetRenderingAreaGranularity(&self, device: VkDevice, pRenderingAreaInfo: *const VkRenderingAreaInfo, pGranularity: *mut VkExtent2D) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_4.vk_get_rendering_area_granularity)(device, pRenderingAreaInfo, pGranularity))))
	}
	fn vkGetDeviceImageSubresourceLayout(&self, device: VkDevice, pInfo: *const VkDeviceImageSubresourceInfo, pLayout: *mut VkSubresourceLayout2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_4.vk_get_device_image_subresource_layout)(device, pInfo, pLayout))))
	}
	fn vkGetImageSubresourceLayout2(&self, device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource2, pLayout: *mut VkSubresourceLayout2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_4.vk_get_image_subresource_layout2)(device, image, pSubresource, pLayout))))
	}
	fn vkCmdPushDescriptorSet(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_4.vk_cmd_push_descriptor_set)(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites))))
	}
	fn vkCmdPushDescriptorSetWithTemplate(&self, commandBuffer: VkCommandBuffer, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: u32, pData: *const c_void) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_4.vk_cmd_push_descriptor_set_with_template)(commandBuffer, descriptorUpdateTemplate, layout, set, pData))))
	}
	fn vkCmdSetRenderingAttachmentLocations(&self, commandBuffer: VkCommandBuffer, pLocationInfo: *const VkRenderingAttachmentLocationInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_4.vk_cmd_set_rendering_attachment_locations)(commandBuffer, pLocationInfo))))
	}
	fn vkCmdSetRenderingInputAttachmentIndices(&self, commandBuffer: VkCommandBuffer, pInputAttachmentIndexInfo: *const VkRenderingInputAttachmentIndexInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_4.vk_cmd_set_rendering_input_attachment_indices)(commandBuffer, pInputAttachmentIndexInfo))))
	}
	fn vkCmdBindDescriptorSets2(&self, commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_4.vk_cmd_bind_descriptor_sets2)(commandBuffer, pBindDescriptorSetsInfo))))
	}
	fn vkCmdPushConstants2(&self, commandBuffer: VkCommandBuffer, pPushConstantsInfo: *const VkPushConstantsInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_4.vk_cmd_push_constants2)(commandBuffer, pPushConstantsInfo))))
	}
	fn vkCmdPushDescriptorSet2(&self, commandBuffer: VkCommandBuffer, pPushDescriptorSetInfo: *const VkPushDescriptorSetInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_4.vk_cmd_push_descriptor_set2)(commandBuffer, pPushDescriptorSetInfo))))
	}
	fn vkCmdPushDescriptorSetWithTemplate2(&self, commandBuffer: VkCommandBuffer, pPushDescriptorSetWithTemplateInfo: *const VkPushDescriptorSetWithTemplateInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_version_1_4.vk_cmd_push_descriptor_set_with_template2)(commandBuffer, pPushDescriptorSetWithTemplateInfo))))
	}
	fn vkCopyMemoryToImage(&self, device: VkDevice, pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo) -> Result<()> {
		convert_result("vkCopyMemoryToImage", catch_unwind(||((self.vk_version_1_4.vk_copy_memory_to_image)(device, pCopyMemoryToImageInfo))))
	}
	fn vkCopyImageToMemory(&self, device: VkDevice, pCopyImageToMemoryInfo: *const VkCopyImageToMemoryInfo) -> Result<()> {
		convert_result("vkCopyImageToMemory", catch_unwind(||((self.vk_version_1_4.vk_copy_image_to_memory)(device, pCopyImageToMemoryInfo))))
	}
	fn vkCopyImageToImage(&self, device: VkDevice, pCopyImageToImageInfo: *const VkCopyImageToImageInfo) -> Result<()> {
		convert_result("vkCopyImageToImage", catch_unwind(||((self.vk_version_1_4.vk_copy_image_to_image)(device, pCopyImageToImageInfo))))
	}
	fn vkTransitionImageLayout(&self, device: VkDevice, transitionCount: u32, pTransitions: *const VkHostImageLayoutTransitionInfo) -> Result<()> {
		convert_result("vkTransitionImageLayout", catch_unwind(||((self.vk_version_1_4.vk_transition_image_layout)(device, transitionCount, pTransitions))))
	}
}
impl VK_KHR_surface for VkCore {
	fn vkDestroySurfaceKHR(&self, instance: VkInstance, surface: VkSurfaceKHR, pAllocator: *const VkAllocationCallbacks) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_surface.vk_destroy_surface_khr)(instance, surface, pAllocator))))
	}
}
impl VK_KHR_swapchain for VkCore {
	fn vkCreateSwapchainKHR(&self, device: VkDevice, pCreateInfo: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchain: *mut VkSwapchainKHR) -> Result<()> {
		convert_result("vkCreateSwapchainKHR", catch_unwind(||((self.vk_khr_swapchain.vk_create_swapchain_khr)(device, pCreateInfo, pAllocator, pSwapchain))))
	}
}
impl VK_KHR_display for VkCore {
	fn vkGetPhysicalDeviceDisplayPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayPropertiesKHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceDisplayPropertiesKHR", catch_unwind(||((self.vk_khr_display.vk_get_physical_device_display_properties_khr)(physicalDevice, pPropertyCount, pProperties))))
	}
}
impl VK_KHR_display_swapchain for VkCore {
	fn vkCreateSharedSwapchainsKHR(&self, device: VkDevice, swapchainCount: u32, pCreateInfos: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchains: *mut VkSwapchainKHR) -> Result<()> {
		convert_result("vkCreateSharedSwapchainsKHR", catch_unwind(||((self.vk_khr_display_swapchain.vk_create_shared_swapchains_khr)(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains))))
	}
}
impl VK_KHR_sampler_mirror_clamp_to_edge for VkCore {}
impl VK_KHR_video_queue for VkCore {
	fn vkGetPhysicalDeviceVideoCapabilitiesKHR(&self, physicalDevice: VkPhysicalDevice, pVideoProfile: *const VkVideoProfileInfoKHR, pCapabilities: *mut VkVideoCapabilitiesKHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceVideoCapabilitiesKHR", catch_unwind(||((self.vk_khr_video_queue.vk_get_physical_device_video_capabilities_khr)(physicalDevice, pVideoProfile, pCapabilities))))
	}
}
impl VK_KHR_video_decode_queue for VkCore {
	fn vkCmdDecodeVideoKHR(&self, commandBuffer: VkCommandBuffer, pDecodeInfo: *const VkVideoDecodeInfoKHR) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_video_decode_queue.vk_cmd_decode_video_khr)(commandBuffer, pDecodeInfo))))
	}
}
impl VK_KHR_video_encode_h264 for VkCore {}
impl vulkan_video_codec_h264std for VkCore {}
impl vulkan_video_codecs_common for VkCore {}
impl vulkan_video_codec_h264std_encode for VkCore {}
impl VK_KHR_video_encode_h265 for VkCore {}
impl vulkan_video_codec_h265std for VkCore {}
impl vulkan_video_codec_h265std_encode for VkCore {}
impl VK_KHR_video_decode_h264 for VkCore {}
impl vulkan_video_codec_h264std_decode for VkCore {}
impl VK_KHR_dynamic_rendering for VkCore {
	fn vkCmdBeginRenderingKHR(&self, commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_dynamic_rendering.vk_cmd_begin_rendering_khr)(commandBuffer, pRenderingInfo))))
	}
}
impl VK_KHR_multiview for VkCore {}
impl VK_KHR_get_physical_device_properties2 for VkCore {
	fn vkGetPhysicalDeviceFeatures2KHR(&self, physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_get_physical_device_properties2.vk_get_physical_device_features2_khr)(physicalDevice, pFeatures))))
	}
}
impl VK_KHR_device_group for VkCore {
	fn vkGetDeviceGroupPeerMemoryFeaturesKHR(&self, device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_device_group.vk_get_device_group_peer_memory_features_khr)(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures))))
	}
}
impl VK_KHR_shader_draw_parameters for VkCore {}
impl VK_KHR_maintenance1 for VkCore {
	fn vkTrimCommandPoolKHR(&self, device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_maintenance1.vk_trim_command_pool_khr)(device, commandPool, flags))))
	}
}
impl VK_KHR_device_group_creation for VkCore {
	fn vkEnumeratePhysicalDeviceGroupsKHR(&self, instance: VkInstance, pPhysicalDeviceGroupCount: *mut uint32_t, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties) -> Result<()> {
		convert_result("vkEnumeratePhysicalDeviceGroupsKHR", catch_unwind(||((self.vk_khr_device_group_creation.vk_enumerate_physical_device_groups_khr)(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties))))
	}
}
impl VK_KHR_external_memory_capabilities for VkCore {
	fn vkGetPhysicalDeviceExternalBufferPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *mut VkExternalBufferProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_external_memory_capabilities.vk_get_physical_device_external_buffer_properties_khr)(physicalDevice, pExternalBufferInfo, pExternalBufferProperties))))
	}
}
impl VK_KHR_external_memory for VkCore {}
impl VK_KHR_external_memory_fd for VkCore {
	fn vkGetMemoryFdKHR(&self, device: VkDevice, pGetFdInfo: *const VkMemoryGetFdInfoKHR, pFd: *mut int) -> Result<()> {
		convert_result("vkGetMemoryFdKHR", catch_unwind(||((self.vk_khr_external_memory_fd.vk_get_memory_fd_khr)(device, pGetFdInfo, pFd))))
	}
}
impl VK_KHR_external_semaphore_capabilities for VkCore {
	fn vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_external_semaphore_capabilities.vk_get_physical_device_external_semaphore_properties_khr)(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties))))
	}
}
impl VK_KHR_external_semaphore for VkCore {}
impl VK_KHR_external_semaphore_fd for VkCore {
	fn vkImportSemaphoreFdKHR(&self, device: VkDevice, pImportSemaphoreFdInfo: *const VkImportSemaphoreFdInfoKHR) -> Result<()> {
		convert_result("vkImportSemaphoreFdKHR", catch_unwind(||((self.vk_khr_external_semaphore_fd.vk_import_semaphore_fd_khr)(device, pImportSemaphoreFdInfo))))
	}
}
impl VK_KHR_push_descriptor for VkCore {
	fn vkCmdPushDescriptorSetKHR(&self, commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *const VkWriteDescriptorSet) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_push_descriptor.vk_cmd_push_descriptor_set_khr)(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites))))
	}
}
impl VK_KHR_shader_float16_int8 for VkCore {}
impl VK_KHR_16bit_storage for VkCore {}
impl VK_KHR_incremental_present for VkCore {}
impl VK_KHR_descriptor_update_template for VkCore {
	fn vkCreateDescriptorUpdateTemplateKHR(&self, device: VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate) -> Result<()> {
		convert_result("vkCreateDescriptorUpdateTemplateKHR", catch_unwind(||((self.vk_khr_descriptor_update_template.vk_create_descriptor_update_template_khr)(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate))))
	}
}
impl VK_KHR_imageless_framebuffer for VkCore {}
impl VK_KHR_create_renderpass2 for VkCore {
	fn vkCreateRenderPass2KHR(&self, device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo2, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> Result<()> {
		convert_result("vkCreateRenderPass2KHR", catch_unwind(||((self.vk_khr_create_renderpass2.vk_create_render_pass2_khr)(device, pCreateInfo, pAllocator, pRenderPass))))
	}
}
impl VK_KHR_shared_presentable_image for VkCore {
	fn vkGetSwapchainStatusKHR(&self, device: VkDevice, swapchain: VkSwapchainKHR) -> Result<()> {
		convert_result("vkGetSwapchainStatusKHR", catch_unwind(||((self.vk_khr_shared_presentable_image.vk_get_swapchain_status_khr)(device, swapchain))))
	}
}
impl VK_KHR_external_fence_capabilities for VkCore {
	fn vkGetPhysicalDeviceExternalFencePropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *mut VkExternalFenceProperties) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_external_fence_capabilities.vk_get_physical_device_external_fence_properties_khr)(physicalDevice, pExternalFenceInfo, pExternalFenceProperties))))
	}
}
impl VK_KHR_external_fence for VkCore {}
impl VK_KHR_external_fence_fd for VkCore {
	fn vkImportFenceFdKHR(&self, device: VkDevice, pImportFenceFdInfo: *const VkImportFenceFdInfoKHR) -> Result<()> {
		convert_result("vkImportFenceFdKHR", catch_unwind(||((self.vk_khr_external_fence_fd.vk_import_fence_fd_khr)(device, pImportFenceFdInfo))))
	}
}
impl VK_KHR_performance_query for VkCore {
	fn vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(&self, physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, pCounterCount: *mut uint32_t, pCounters: *mut VkPerformanceCounterKHR, pCounterDescriptions: *mut VkPerformanceCounterDescriptionKHR) -> Result<()> {
		convert_result("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR", catch_unwind(||((self.vk_khr_performance_query.vk_enumerate_physical_device_queue_family_performance_query_counters_khr)(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions))))
	}
}
impl VK_KHR_maintenance2 for VkCore {}
impl VK_KHR_get_surface_capabilities2 for VkCore {
	fn vkGetPhysicalDeviceSurfaceCapabilities2KHR(&self, physicalDevice: VkPhysicalDevice, pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2KHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceSurfaceCapabilities2KHR", catch_unwind(||((self.vk_khr_get_surface_capabilities2.vk_get_physical_device_surface_capabilities2_khr)(physicalDevice, pSurfaceInfo, pSurfaceCapabilities))))
	}
}
impl VK_KHR_variable_pointers for VkCore {}
impl VK_KHR_get_display_properties2 for VkCore {
	fn vkGetPhysicalDeviceDisplayProperties2KHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkDisplayProperties2KHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceDisplayProperties2KHR", catch_unwind(||((self.vk_khr_get_display_properties2.vk_get_physical_device_display_properties2_khr)(physicalDevice, pPropertyCount, pProperties))))
	}
}
impl VK_KHR_dedicated_allocation for VkCore {}
impl VK_KHR_storage_buffer_storage_class for VkCore {}
impl VK_KHR_shader_bfloat16 for VkCore {}
impl VK_KHR_relaxed_block_layout for VkCore {}
impl VK_KHR_get_memory_requirements2 for VkCore {
	fn vkGetImageMemoryRequirements2KHR(&self, device: VkDevice, pInfo: *const VkImageMemoryRequirementsInfo2, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_get_memory_requirements2.vk_get_image_memory_requirements2_khr)(device, pInfo, pMemoryRequirements))))
	}
}
impl VK_KHR_image_format_list for VkCore {}
impl VK_KHR_sampler_ycbcr_conversion for VkCore {
	fn vkCreateSamplerYcbcrConversionKHR(&self, device: VkDevice, pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo, pAllocator: *const VkAllocationCallbacks, pYcbcrConversion: *mut VkSamplerYcbcrConversion) -> Result<()> {
		convert_result("vkCreateSamplerYcbcrConversionKHR", catch_unwind(||((self.vk_khr_sampler_ycbcr_conversion.vk_create_sampler_ycbcr_conversion_khr)(device, pCreateInfo, pAllocator, pYcbcrConversion))))
	}
}
impl VK_KHR_bind_memory2 for VkCore {
	fn vkBindBufferMemory2KHR(&self, device: VkDevice, bindInfoCount: u32, pBindInfos: *const VkBindBufferMemoryInfo) -> Result<()> {
		convert_result("vkBindBufferMemory2KHR", catch_unwind(||((self.vk_khr_bind_memory2.vk_bind_buffer_memory2_khr)(device, bindInfoCount, pBindInfos))))
	}
}
impl VK_KHR_maintenance3 for VkCore {
	fn vkGetDescriptorSetLayoutSupportKHR(&self, device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pSupport: *mut VkDescriptorSetLayoutSupport) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_maintenance3.vk_get_descriptor_set_layout_support_khr)(device, pCreateInfo, pSupport))))
	}
}
impl VK_KHR_draw_indirect_count for VkCore {
	fn vkCmdDrawIndirectCountKHR(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_draw_indirect_count.vk_cmd_draw_indirect_count_khr)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride))))
	}
}
impl VK_KHR_shader_subgroup_extended_types for VkCore {}
impl VK_KHR_8bit_storage for VkCore {}
impl VK_KHR_shader_atomic_int64 for VkCore {}
impl VK_KHR_shader_clock for VkCore {}
impl VK_KHR_video_decode_h265 for VkCore {}
impl vulkan_video_codec_h265std_decode for VkCore {}
impl VK_KHR_global_priority for VkCore {}
impl VK_KHR_driver_properties for VkCore {}
impl VK_KHR_shader_float_controls for VkCore {}
impl VK_KHR_depth_stencil_resolve for VkCore {}
impl VK_KHR_swapchain_mutable_format for VkCore {}
impl VK_KHR_timeline_semaphore for VkCore {
	fn vkGetSemaphoreCounterValueKHR(&self, device: VkDevice, semaphore: VkSemaphore, pValue: *mut uint64_t) -> Result<()> {
		convert_result("vkGetSemaphoreCounterValueKHR", catch_unwind(||((self.vk_khr_timeline_semaphore.vk_get_semaphore_counter_value_khr)(device, semaphore, pValue))))
	}
}
impl VK_KHR_vulkan_memory_model for VkCore {}
impl VK_KHR_shader_terminate_invocation for VkCore {}
impl VK_KHR_fragment_shading_rate for VkCore {
	fn vkGetPhysicalDeviceFragmentShadingRatesKHR(&self, physicalDevice: VkPhysicalDevice, pFragmentShadingRateCount: *mut uint32_t, pFragmentShadingRates: *mut VkPhysicalDeviceFragmentShadingRateKHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceFragmentShadingRatesKHR", catch_unwind(||((self.vk_khr_fragment_shading_rate.vk_get_physical_device_fragment_shading_rates_khr)(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates))))
	}
}
impl VK_KHR_dynamic_rendering_local_read for VkCore {
	fn vkCmdSetRenderingAttachmentLocationsKHR(&self, commandBuffer: VkCommandBuffer, pLocationInfo: *const VkRenderingAttachmentLocationInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_dynamic_rendering_local_read.vk_cmd_set_rendering_attachment_locations_khr)(commandBuffer, pLocationInfo))))
	}
}
impl VK_KHR_shader_quad_control for VkCore {}
impl VK_KHR_spirv_1_4 for VkCore {}
impl VK_KHR_surface_protected_capabilities for VkCore {}
impl VK_KHR_separate_depth_stencil_layouts for VkCore {}
impl VK_KHR_present_wait for VkCore {
	fn vkWaitForPresentKHR(&self, device: VkDevice, swapchain: VkSwapchainKHR, presentId: u64, timeout: u64) -> Result<()> {
		convert_result("vkWaitForPresentKHR", catch_unwind(||((self.vk_khr_present_wait.vk_wait_for_present_khr)(device, swapchain, presentId, timeout))))
	}
}
impl VK_KHR_uniform_buffer_standard_layout for VkCore {}
impl VK_KHR_buffer_device_address for VkCore {
	fn vkGetBufferDeviceAddressKHR(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> Result<VkDeviceAddress> {
		process_catch(catch_unwind(||((self.vk_khr_buffer_device_address.vk_get_buffer_device_address_khr)(device, pInfo))))
	}
}
impl VK_KHR_deferred_host_operations for VkCore {
	fn vkCreateDeferredOperationKHR(&self, device: VkDevice, pAllocator: *const VkAllocationCallbacks, pDeferredOperation: *mut VkDeferredOperationKHR) -> Result<()> {
		convert_result("vkCreateDeferredOperationKHR", catch_unwind(||((self.vk_khr_deferred_host_operations.vk_create_deferred_operation_khr)(device, pAllocator, pDeferredOperation))))
	}
}
impl VK_KHR_pipeline_executable_properties for VkCore {
	fn vkGetPipelineExecutablePropertiesKHR(&self, device: VkDevice, pPipelineInfo: *const VkPipelineInfoKHR, pExecutableCount: *mut uint32_t, pProperties: *mut VkPipelineExecutablePropertiesKHR) -> Result<()> {
		convert_result("vkGetPipelineExecutablePropertiesKHR", catch_unwind(||((self.vk_khr_pipeline_executable_properties.vk_get_pipeline_executable_properties_khr)(device, pPipelineInfo, pExecutableCount, pProperties))))
	}
}
impl VK_KHR_map_memory2 for VkCore {
	fn vkMapMemory2KHR(&self, device: VkDevice, pMemoryMapInfo: *const VkMemoryMapInfo, ppData: *mut *mut c_void) -> Result<()> {
		convert_result("vkMapMemory2KHR", catch_unwind(||((self.vk_khr_map_memory2.vk_map_memory2_khr)(device, pMemoryMapInfo, ppData))))
	}
}
impl VK_KHR_shader_integer_dot_product for VkCore {}
impl VK_KHR_pipeline_library for VkCore {}
impl VK_KHR_shader_non_semantic_info for VkCore {}
impl VK_KHR_present_id for VkCore {}
impl VK_KHR_video_encode_queue for VkCore {
	fn vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pQualityLevelInfo: *const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, pQualityLevelProperties: *mut VkVideoEncodeQualityLevelPropertiesKHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR", catch_unwind(||((self.vk_khr_video_encode_queue.vk_get_physical_device_video_encode_quality_level_properties_khr)(physicalDevice, pQualityLevelInfo, pQualityLevelProperties))))
	}
}
impl VK_KHR_synchronization2 for VkCore {
	fn vkCmdSetEvent2KHR(&self, commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *const VkDependencyInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_synchronization2.vk_cmd_set_event2_khr)(commandBuffer, event, pDependencyInfo))))
	}
}
impl VK_KHR_fragment_shader_barycentric for VkCore {}
impl VK_KHR_shader_subgroup_uniform_control_flow for VkCore {}
impl VK_KHR_zero_initialize_workgroup_memory for VkCore {}
impl VK_KHR_workgroup_memory_explicit_layout for VkCore {}
impl VK_KHR_copy_commands2 for VkCore {
	fn vkCmdCopyBuffer2KHR(&self, commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_copy_commands2.vk_cmd_copy_buffer2_khr)(commandBuffer, pCopyBufferInfo))))
	}
}
impl VK_KHR_format_feature_flags2 for VkCore {}
impl VK_KHR_ray_tracing_maintenance1 for VkCore {
	fn vkCmdTraceRaysIndirect2KHR(&self, commandBuffer: VkCommandBuffer, indirectDeviceAddress: VkDeviceAddress) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_ray_tracing_maintenance1.vk_cmd_trace_rays_indirect2_khr)(commandBuffer, indirectDeviceAddress))))
	}
}
impl VK_KHR_portability_enumeration for VkCore {}
impl VK_KHR_maintenance4 for VkCore {
	fn vkGetDeviceBufferMemoryRequirementsKHR(&self, device: VkDevice, pInfo: *const VkDeviceBufferMemoryRequirements, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_maintenance4.vk_get_device_buffer_memory_requirements_khr)(device, pInfo, pMemoryRequirements))))
	}
}
impl VK_KHR_shader_subgroup_rotate for VkCore {}
impl VK_KHR_shader_maximal_reconvergence for VkCore {}
impl VK_KHR_maintenance5 for VkCore {
	fn vkCmdBindIndexBuffer2KHR(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_maintenance5.vk_cmd_bind_index_buffer2_khr)(commandBuffer, buffer, offset, size, indexType))))
	}
}
impl VK_KHR_present_id2 for VkCore {}
impl VK_KHR_present_wait2 for VkCore {
	fn vkWaitForPresent2KHR(&self, device: VkDevice, swapchain: VkSwapchainKHR, pPresentWait2Info: *const VkPresentWait2InfoKHR) -> Result<()> {
		convert_result("vkWaitForPresent2KHR", catch_unwind(||((self.vk_khr_present_wait2.vk_wait_for_present2_khr)(device, swapchain, pPresentWait2Info))))
	}
}
impl VK_KHR_ray_tracing_position_fetch for VkCore {}
impl VK_KHR_pipeline_binary for VkCore {
	fn vkCreatePipelineBinariesKHR(&self, device: VkDevice, pCreateInfo: *const VkPipelineBinaryCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pBinaries: *mut VkPipelineBinaryHandlesInfoKHR) -> Result<()> {
		convert_result("vkCreatePipelineBinariesKHR", catch_unwind(||((self.vk_khr_pipeline_binary.vk_create_pipeline_binaries_khr)(device, pCreateInfo, pAllocator, pBinaries))))
	}
}
impl VK_KHR_surface_maintenance1 for VkCore {}
impl VK_KHR_swapchain_maintenance1 for VkCore {
	fn vkReleaseSwapchainImagesKHR(&self, device: VkDevice, pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR) -> Result<()> {
		convert_result("vkReleaseSwapchainImagesKHR", catch_unwind(||((self.vk_khr_swapchain_maintenance1.vk_release_swapchain_images_khr)(device, pReleaseInfo))))
	}
}
impl VK_KHR_cooperative_matrix for VkCore {
	fn vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixPropertiesKHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR", catch_unwind(||((self.vk_khr_cooperative_matrix.vk_get_physical_device_cooperative_matrix_properties_khr)(physicalDevice, pPropertyCount, pProperties))))
	}
}
impl VK_KHR_compute_shader_derivatives for VkCore {}
impl VK_KHR_video_decode_av1 for VkCore {}
impl vulkan_video_codec_av1std for VkCore {}
impl vulkan_video_codec_av1std_decode for VkCore {}
impl VK_KHR_video_encode_av1 for VkCore {}
impl vulkan_video_codec_av1std_encode for VkCore {}
impl VK_KHR_video_decode_vp9 for VkCore {}
impl vulkan_video_codec_vp9std for VkCore {}
impl vulkan_video_codec_vp9std_decode for VkCore {}
impl VK_KHR_video_maintenance1 for VkCore {}
impl VK_KHR_vertex_attribute_divisor for VkCore {}
impl VK_KHR_load_store_op_none for VkCore {}
impl VK_KHR_unified_image_layouts for VkCore {}
impl VK_KHR_shader_float_controls2 for VkCore {}
impl VK_KHR_index_type_uint8 for VkCore {}
impl VK_KHR_line_rasterization for VkCore {
	fn vkCmdSetLineStippleKHR(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_line_rasterization.vk_cmd_set_line_stipple_khr)(commandBuffer, lineStippleFactor, lineStipplePattern))))
	}
}
impl VK_KHR_calibrated_timestamps for VkCore {
	fn vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(&self, physicalDevice: VkPhysicalDevice, pTimeDomainCount: *mut uint32_t, pTimeDomains: *mut VkTimeDomainKHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceCalibrateableTimeDomainsKHR", catch_unwind(||((self.vk_khr_calibrated_timestamps.vk_get_physical_device_calibrateable_time_domains_khr)(physicalDevice, pTimeDomainCount, pTimeDomains))))
	}
}
impl VK_KHR_shader_expect_assume for VkCore {}
impl VK_KHR_maintenance6 for VkCore {
	fn vkCmdBindDescriptorSets2KHR(&self, commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_maintenance6.vk_cmd_bind_descriptor_sets2_khr)(commandBuffer, pBindDescriptorSetsInfo))))
	}
}
impl VK_KHR_video_encode_intra_refresh for VkCore {}
impl VK_KHR_video_encode_quantization_map for VkCore {}
impl VK_KHR_shader_relaxed_extended_instruction for VkCore {}
impl VK_KHR_maintenance7 for VkCore {}
impl VK_KHR_maintenance8 for VkCore {}
impl VK_KHR_maintenance9 for VkCore {}
impl VK_KHR_video_maintenance2 for VkCore {}
impl VK_KHR_depth_clamp_zero_one for VkCore {}
impl VK_KHR_robustness2 for VkCore {}
impl VK_KHR_present_mode_fifo_latest_ready for VkCore {}
impl VK_EXT_debug_report for VkCore {
	fn vkCreateDebugReportCallbackEXT(&self, instance: VkInstance, pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pCallback: *mut VkDebugReportCallbackEXT) -> Result<()> {
		convert_result("vkCreateDebugReportCallbackEXT", catch_unwind(||((self.vk_ext_debug_report.vk_create_debug_report_callback_ext)(instance, pCreateInfo, pAllocator, pCallback))))
	}
}
impl VK_NV_glsl_shader for VkCore {}
impl VK_EXT_depth_range_unrestricted for VkCore {}
impl VK_IMG_filter_cubic for VkCore {}
impl VK_AMD_rasterization_order for VkCore {}
impl VK_AMD_shader_trinary_minmax for VkCore {}
impl VK_AMD_shader_explicit_vertex_parameter for VkCore {}
impl VK_EXT_debug_marker for VkCore {
	fn vkDebugMarkerSetObjectTagEXT(&self, device: VkDevice, pTagInfo: *const VkDebugMarkerObjectTagInfoEXT) -> Result<()> {
		convert_result("vkDebugMarkerSetObjectTagEXT", catch_unwind(||((self.vk_ext_debug_marker.vk_debug_marker_set_object_tag_ext)(device, pTagInfo))))
	}
}
impl VK_AMD_gcn_shader for VkCore {}
impl VK_NV_dedicated_allocation for VkCore {}
impl VK_EXT_transform_feedback for VkCore {
	fn vkCmdBindTransformFeedbackBuffersEXT(&self, commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, pSizes: *const VkDeviceSize) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_transform_feedback.vk_cmd_bind_transform_feedback_buffers_ext)(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes))))
	}
}
impl VK_NVX_binary_import for VkCore {
	fn vkCreateCuModuleNVX(&self, device: VkDevice, pCreateInfo: *const VkCuModuleCreateInfoNVX, pAllocator: *const VkAllocationCallbacks, pModule: *mut VkCuModuleNVX) -> Result<()> {
		convert_result("vkCreateCuModuleNVX", catch_unwind(||((self.vk_nvx_binary_import.vk_create_cu_module_nvx)(device, pCreateInfo, pAllocator, pModule))))
	}
}
impl VK_NVX_image_view_handle for VkCore {
	fn vkGetImageViewHandleNVX(&self, device: VkDevice, pInfo: *const VkImageViewHandleInfoNVX) -> Result<u32> {
		process_catch(catch_unwind(||((self.vk_nvx_image_view_handle.vk_get_image_view_handle_nvx)(device, pInfo))))
	}
}
impl VK_AMD_draw_indirect_count for VkCore {
	fn vkCmdDrawIndirectCountAMD(&self, commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_amd_draw_indirect_count.vk_cmd_draw_indirect_count_amd)(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride))))
	}
}
impl VK_AMD_negative_viewport_height for VkCore {}
impl VK_AMD_gpu_shader_half_float for VkCore {}
impl VK_AMD_shader_ballot for VkCore {}
impl VK_AMD_texture_gather_bias_lod for VkCore {}
impl VK_AMD_shader_info for VkCore {
	fn vkGetShaderInfoAMD(&self, device: VkDevice, pipeline: VkPipeline, shaderStage: VkShaderStageFlagBits, infoType: VkShaderInfoTypeAMD, pInfoSize: *mut size_t, pInfo: *mut c_void) -> Result<()> {
		convert_result("vkGetShaderInfoAMD", catch_unwind(||((self.vk_amd_shader_info.vk_get_shader_info_amd)(device, pipeline, shaderStage, infoType, pInfoSize, pInfo))))
	}
}
impl VK_AMD_shader_image_load_store_lod for VkCore {}
impl VK_NV_corner_sampled_image for VkCore {}
impl VK_IMG_format_pvrtc for VkCore {}
impl VK_NV_external_memory_capabilities for VkCore {
	fn vkGetPhysicalDeviceExternalImageFormatPropertiesNV(&self, physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, externalHandleType: VkExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *mut VkExternalImageFormatPropertiesNV) -> Result<()> {
		convert_result("vkGetPhysicalDeviceExternalImageFormatPropertiesNV", catch_unwind(||((self.vk_nv_external_memory_capabilities.vk_get_physical_device_external_image_format_properties_nv)(physicalDevice, format, type_, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties))))
	}
}
impl VK_NV_external_memory for VkCore {}
impl VK_EXT_validation_flags for VkCore {}
impl VK_EXT_shader_subgroup_ballot for VkCore {}
impl VK_EXT_shader_subgroup_vote for VkCore {}
impl VK_EXT_texture_compression_astc_hdr for VkCore {}
impl VK_EXT_astc_decode_mode for VkCore {}
impl VK_EXT_pipeline_robustness for VkCore {}
impl VK_EXT_conditional_rendering for VkCore {
	fn vkCmdBeginConditionalRenderingEXT(&self, commandBuffer: VkCommandBuffer, pConditionalRenderingBegin: *const VkConditionalRenderingBeginInfoEXT) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_conditional_rendering.vk_cmd_begin_conditional_rendering_ext)(commandBuffer, pConditionalRenderingBegin))))
	}
}
impl VK_NV_clip_space_w_scaling for VkCore {
	fn vkCmdSetViewportWScalingNV(&self, commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportWScalings: *const VkViewportWScalingNV) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_nv_clip_space_w_scaling.vk_cmd_set_viewport_wscaling_nv)(commandBuffer, firstViewport, viewportCount, pViewportWScalings))))
	}
}
impl VK_EXT_direct_mode_display for VkCore {
	fn vkReleaseDisplayEXT(&self, physicalDevice: VkPhysicalDevice, display: VkDisplayKHR) -> Result<()> {
		convert_result("vkReleaseDisplayEXT", catch_unwind(||((self.vk_ext_direct_mode_display.vk_release_display_ext)(physicalDevice, display))))
	}
}
impl VK_EXT_display_surface_counter for VkCore {
	fn vkGetPhysicalDeviceSurfaceCapabilities2EXT(&self, physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2EXT) -> Result<()> {
		convert_result("vkGetPhysicalDeviceSurfaceCapabilities2EXT", catch_unwind(||((self.vk_ext_display_surface_counter.vk_get_physical_device_surface_capabilities2_ext)(physicalDevice, surface, pSurfaceCapabilities))))
	}
}
impl VK_EXT_display_control for VkCore {
	fn vkDisplayPowerControlEXT(&self, device: VkDevice, display: VkDisplayKHR, pDisplayPowerInfo: *const VkDisplayPowerInfoEXT) -> Result<()> {
		convert_result("vkDisplayPowerControlEXT", catch_unwind(||((self.vk_ext_display_control.vk_display_power_control_ext)(device, display, pDisplayPowerInfo))))
	}
}
impl VK_GOOGLE_display_timing for VkCore {
	fn vkGetRefreshCycleDurationGOOGLE(&self, device: VkDevice, swapchain: VkSwapchainKHR, pDisplayTimingProperties: *mut VkRefreshCycleDurationGOOGLE) -> Result<()> {
		convert_result("vkGetRefreshCycleDurationGOOGLE", catch_unwind(||((self.vk_google_display_timing.vk_get_refresh_cycle_duration_google)(device, swapchain, pDisplayTimingProperties))))
	}
}
impl VK_NV_sample_mask_override_coverage for VkCore {}
impl VK_NV_geometry_shader_passthrough for VkCore {}
impl VK_NV_viewport_array2 for VkCore {}
impl VK_NVX_multiview_per_view_attributes for VkCore {}
impl VK_NV_viewport_swizzle for VkCore {}
impl VK_EXT_discard_rectangles for VkCore {
	fn vkCmdSetDiscardRectangleEXT(&self, commandBuffer: VkCommandBuffer, firstDiscardRectangle: u32, discardRectangleCount: u32, pDiscardRectangles: *const VkRect2D) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_discard_rectangles.vk_cmd_set_discard_rectangle_ext)(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles))))
	}
}
impl VK_EXT_conservative_rasterization for VkCore {}
impl VK_EXT_depth_clip_enable for VkCore {}
impl VK_EXT_swapchain_colorspace for VkCore {}
impl VK_EXT_hdr_metadata for VkCore {
	fn vkSetHdrMetadataEXT(&self, device: VkDevice, swapchainCount: u32, pSwapchains: *const VkSwapchainKHR, pMetadata: *const VkHdrMetadataEXT) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_hdr_metadata.vk_set_hdr_metadata_ext)(device, swapchainCount, pSwapchains, pMetadata))))
	}
}
impl VK_IMG_relaxed_line_rasterization for VkCore {}
impl VK_EXT_external_memory_dma_buf for VkCore {}
impl VK_EXT_queue_family_foreign for VkCore {}
impl VK_EXT_debug_utils for VkCore {
	fn vkSetDebugUtilsObjectNameEXT(&self, device: VkDevice, pNameInfo: *const VkDebugUtilsObjectNameInfoEXT) -> Result<()> {
		convert_result("vkSetDebugUtilsObjectNameEXT", catch_unwind(||((self.vk_ext_debug_utils.vk_set_debug_utils_object_name_ext)(device, pNameInfo))))
	}
}
impl VK_EXT_sampler_filter_minmax for VkCore {}
impl VK_AMD_gpu_shader_int16 for VkCore {}
impl VK_AMD_mixed_attachment_samples for VkCore {}
impl VK_AMD_shader_fragment_mask for VkCore {}
impl VK_EXT_inline_uniform_block for VkCore {}
impl VK_EXT_shader_stencil_export for VkCore {}
impl VK_EXT_sample_locations for VkCore {
	fn vkCmdSetSampleLocationsEXT(&self, commandBuffer: VkCommandBuffer, pSampleLocationsInfo: *const VkSampleLocationsInfoEXT) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_sample_locations.vk_cmd_set_sample_locations_ext)(commandBuffer, pSampleLocationsInfo))))
	}
}
impl VK_EXT_blend_operation_advanced for VkCore {}
impl VK_NV_fragment_coverage_to_color for VkCore {}
impl VK_NV_framebuffer_mixed_samples for VkCore {}
impl VK_NV_fill_rectangle for VkCore {}
impl VK_NV_shader_sm_builtins for VkCore {}
impl VK_EXT_post_depth_coverage for VkCore {}
impl VK_EXT_image_drm_format_modifier for VkCore {
	fn vkGetImageDrmFormatModifierPropertiesEXT(&self, device: VkDevice, image: VkImage, pProperties: *mut VkImageDrmFormatModifierPropertiesEXT) -> Result<()> {
		convert_result("vkGetImageDrmFormatModifierPropertiesEXT", catch_unwind(||((self.vk_ext_image_drm_format_modifier.vk_get_image_drm_format_modifier_properties_ext)(device, image, pProperties))))
	}
}
impl VK_EXT_validation_cache for VkCore {
	fn vkCreateValidationCacheEXT(&self, device: VkDevice, pCreateInfo: *const VkValidationCacheCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pValidationCache: *mut VkValidationCacheEXT) -> Result<()> {
		convert_result("vkCreateValidationCacheEXT", catch_unwind(||((self.vk_ext_validation_cache.vk_create_validation_cache_ext)(device, pCreateInfo, pAllocator, pValidationCache))))
	}
}
impl VK_EXT_descriptor_indexing for VkCore {}
impl VK_EXT_shader_viewport_index_layer for VkCore {}
impl VK_NV_shading_rate_image for VkCore {
	fn vkCmdBindShadingRateImageNV(&self, commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_nv_shading_rate_image.vk_cmd_bind_shading_rate_image_nv)(commandBuffer, imageView, imageLayout))))
	}
}
impl VK_NV_ray_tracing for VkCore {
	fn vkCreateAccelerationStructureNV(&self, device: VkDevice, pCreateInfo: *const VkAccelerationStructureCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pAccelerationStructure: *mut VkAccelerationStructureNV) -> Result<()> {
		convert_result("vkCreateAccelerationStructureNV", catch_unwind(||((self.vk_nv_ray_tracing.vk_create_acceleration_structure_nv)(device, pCreateInfo, pAllocator, pAccelerationStructure))))
	}
}
impl VK_NV_representative_fragment_test for VkCore {}
impl VK_EXT_filter_cubic for VkCore {}
impl VK_QCOM_render_pass_shader_resolve for VkCore {}
impl VK_EXT_global_priority for VkCore {}
impl VK_EXT_external_memory_host for VkCore {
	fn vkGetMemoryHostPointerPropertiesEXT(&self, device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHostPointer: *const c_void, pMemoryHostPointerProperties: *mut VkMemoryHostPointerPropertiesEXT) -> Result<()> {
		convert_result("vkGetMemoryHostPointerPropertiesEXT", catch_unwind(||((self.vk_ext_external_memory_host.vk_get_memory_host_pointer_properties_ext)(device, handleType, pHostPointer, pMemoryHostPointerProperties))))
	}
}
impl VK_AMD_buffer_marker for VkCore {
	fn vkCmdWriteBufferMarkerAMD(&self, commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_amd_buffer_marker.vk_cmd_write_buffer_marker_amd)(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker))))
	}
}
impl VK_AMD_pipeline_compiler_control for VkCore {}
impl VK_EXT_calibrated_timestamps for VkCore {
	fn vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(&self, physicalDevice: VkPhysicalDevice, pTimeDomainCount: *mut uint32_t, pTimeDomains: *mut VkTimeDomainKHR) -> Result<()> {
		convert_result("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT", catch_unwind(||((self.vk_ext_calibrated_timestamps.vk_get_physical_device_calibrateable_time_domains_ext)(physicalDevice, pTimeDomainCount, pTimeDomains))))
	}
}
impl VK_AMD_shader_core_properties for VkCore {}
impl VK_AMD_memory_overallocation_behavior for VkCore {}
impl VK_EXT_vertex_attribute_divisor for VkCore {}
impl VK_EXT_pipeline_creation_feedback for VkCore {}
impl VK_NV_shader_subgroup_partitioned for VkCore {}
impl VK_NV_compute_shader_derivatives for VkCore {}
impl VK_NV_mesh_shader for VkCore {
	fn vkCmdDrawMeshTasksNV(&self, commandBuffer: VkCommandBuffer, taskCount: u32, firstTask: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_nv_mesh_shader.vk_cmd_draw_mesh_tasks_nv)(commandBuffer, taskCount, firstTask))))
	}
}
impl VK_NV_fragment_shader_barycentric for VkCore {}
impl VK_NV_shader_image_footprint for VkCore {}
impl VK_NV_scissor_exclusive for VkCore {
	fn vkCmdSetExclusiveScissorEnableNV(&self, commandBuffer: VkCommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissorEnables: *const VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_nv_scissor_exclusive.vk_cmd_set_exclusive_scissor_enable_nv)(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables))))
	}
}
impl VK_NV_device_diagnostic_checkpoints for VkCore {
	fn vkCmdSetCheckpointNV(&self, commandBuffer: VkCommandBuffer, pCheckpointMarker: *const c_void) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_nv_device_diagnostic_checkpoints.vk_cmd_set_checkpoint_nv)(commandBuffer, pCheckpointMarker))))
	}
}
impl VK_INTEL_shader_integer_functions2 for VkCore {}
impl VK_INTEL_performance_query for VkCore {
	fn vkInitializePerformanceApiINTEL(&self, device: VkDevice, pInitializeInfo: *const VkInitializePerformanceApiInfoINTEL) -> Result<()> {
		convert_result("vkInitializePerformanceApiINTEL", catch_unwind(||((self.vk_intel_performance_query.vk_initialize_performance_api_intel)(device, pInitializeInfo))))
	}
}
impl VK_EXT_pci_bus_info for VkCore {}
impl VK_AMD_display_native_hdr for VkCore {
	fn vkSetLocalDimmingAMD(&self, device: VkDevice, swapChain: VkSwapchainKHR, localDimmingEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_amd_display_native_hdr.vk_set_local_dimming_amd)(device, swapChain, localDimmingEnable))))
	}
}
impl VK_EXT_fragment_density_map for VkCore {}
impl VK_EXT_scalar_block_layout for VkCore {}
impl VK_GOOGLE_hlsl_functionality1 for VkCore {}
impl VK_GOOGLE_decorate_string for VkCore {}
impl VK_EXT_subgroup_size_control for VkCore {}
impl VK_AMD_shader_core_properties2 for VkCore {}
impl VK_AMD_device_coherent_memory for VkCore {}
impl VK_EXT_shader_image_atomic_int64 for VkCore {}
impl VK_EXT_memory_budget for VkCore {}
impl VK_EXT_memory_priority for VkCore {}
impl VK_NV_dedicated_allocation_image_aliasing for VkCore {}
impl VK_EXT_buffer_device_address for VkCore {
	fn vkGetBufferDeviceAddressEXT(&self, device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> Result<VkDeviceAddress> {
		process_catch(catch_unwind(||((self.vk_ext_buffer_device_address.vk_get_buffer_device_address_ext)(device, pInfo))))
	}
}
impl VK_EXT_tooling_info for VkCore {
	fn vkGetPhysicalDeviceToolPropertiesEXT(&self, physicalDevice: VkPhysicalDevice, pToolCount: *mut uint32_t, pToolProperties: *mut VkPhysicalDeviceToolProperties) -> Result<()> {
		convert_result("vkGetPhysicalDeviceToolPropertiesEXT", catch_unwind(||((self.vk_ext_tooling_info.vk_get_physical_device_tool_properties_ext)(physicalDevice, pToolCount, pToolProperties))))
	}
}
impl VK_EXT_separate_stencil_usage for VkCore {}
impl VK_EXT_validation_features for VkCore {}
impl VK_NV_cooperative_matrix for VkCore {
	fn vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixPropertiesNV) -> Result<()> {
		convert_result("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", catch_unwind(||((self.vk_nv_cooperative_matrix.vk_get_physical_device_cooperative_matrix_properties_nv)(physicalDevice, pPropertyCount, pProperties))))
	}
}
impl VK_NV_coverage_reduction_mode for VkCore {
	fn vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(&self, physicalDevice: VkPhysicalDevice, pCombinationCount: *mut uint32_t, pCombinations: *mut VkFramebufferMixedSamplesCombinationNV) -> Result<()> {
		convert_result("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", catch_unwind(||((self.vk_nv_coverage_reduction_mode.vk_get_physical_device_supported_framebuffer_mixed_samples_combinations_nv)(physicalDevice, pCombinationCount, pCombinations))))
	}
}
impl VK_EXT_fragment_shader_interlock for VkCore {}
impl VK_EXT_ycbcr_image_arrays for VkCore {}
impl VK_EXT_provoking_vertex for VkCore {}
impl VK_EXT_headless_surface for VkCore {
	fn vkCreateHeadlessSurfaceEXT(&self, instance: VkInstance, pCreateInfo: *const VkHeadlessSurfaceCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR) -> Result<()> {
		convert_result("vkCreateHeadlessSurfaceEXT", catch_unwind(||((self.vk_ext_headless_surface.vk_create_headless_surface_ext)(instance, pCreateInfo, pAllocator, pSurface))))
	}
}
impl VK_EXT_line_rasterization for VkCore {
	fn vkCmdSetLineStippleEXT(&self, commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_line_rasterization.vk_cmd_set_line_stipple_ext)(commandBuffer, lineStippleFactor, lineStipplePattern))))
	}
}
impl VK_EXT_shader_atomic_float for VkCore {}
impl VK_EXT_host_query_reset for VkCore {
	fn vkResetQueryPoolEXT(&self, device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_host_query_reset.vk_reset_query_pool_ext)(device, queryPool, firstQuery, queryCount))))
	}
}
impl VK_EXT_index_type_uint8 for VkCore {}
impl VK_EXT_extended_dynamic_state for VkCore {
	fn vkCmdSetCullModeEXT(&self, commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_extended_dynamic_state.vk_cmd_set_cull_mode_ext)(commandBuffer, cullMode))))
	}
}
impl VK_EXT_host_image_copy for VkCore {
	fn vkCopyMemoryToImageEXT(&self, device: VkDevice, pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo) -> Result<()> {
		convert_result("vkCopyMemoryToImageEXT", catch_unwind(||((self.vk_ext_host_image_copy.vk_copy_memory_to_image_ext)(device, pCopyMemoryToImageInfo))))
	}
}
impl VK_EXT_map_memory_placed for VkCore {}
impl VK_EXT_shader_atomic_float2 for VkCore {}
impl VK_EXT_surface_maintenance1 for VkCore {}
impl VK_EXT_swapchain_maintenance1 for VkCore {
	fn vkReleaseSwapchainImagesEXT(&self, device: VkDevice, pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR) -> Result<()> {
		convert_result("vkReleaseSwapchainImagesEXT", catch_unwind(||((self.vk_ext_swapchain_maintenance1.vk_release_swapchain_images_ext)(device, pReleaseInfo))))
	}
}
impl VK_EXT_shader_demote_to_helper_invocation for VkCore {}
impl VK_NV_device_generated_commands for VkCore {
	fn vkGetGeneratedCommandsMemoryRequirementsNV(&self, device: VkDevice, pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoNV, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_nv_device_generated_commands.vk_get_generated_commands_memory_requirements_nv)(device, pInfo, pMemoryRequirements))))
	}
}
impl VK_NV_inherited_viewport_scissor for VkCore {}
impl VK_EXT_texel_buffer_alignment for VkCore {}
impl VK_QCOM_render_pass_transform for VkCore {}
impl VK_EXT_depth_bias_control for VkCore {
	fn vkCmdSetDepthBias2EXT(&self, commandBuffer: VkCommandBuffer, pDepthBiasInfo: *const VkDepthBiasInfoEXT) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_depth_bias_control.vk_cmd_set_depth_bias2_ext)(commandBuffer, pDepthBiasInfo))))
	}
}
impl VK_EXT_device_memory_report for VkCore {}
impl VK_EXT_acquire_drm_display for VkCore {
	fn vkAcquireDrmDisplayEXT(&self, physicalDevice: VkPhysicalDevice, drmFd: i32, display: VkDisplayKHR) -> Result<()> {
		convert_result("vkAcquireDrmDisplayEXT", catch_unwind(||((self.vk_ext_acquire_drm_display.vk_acquire_drm_display_ext)(physicalDevice, drmFd, display))))
	}
}
impl VK_EXT_robustness2 for VkCore {}
impl VK_EXT_custom_border_color for VkCore {}
impl VK_GOOGLE_user_type for VkCore {}
impl VK_NV_present_barrier for VkCore {}
impl VK_EXT_private_data for VkCore {
	fn vkCreatePrivateDataSlotEXT(&self, device: VkDevice, pCreateInfo: *const VkPrivateDataSlotCreateInfo, pAllocator: *const VkAllocationCallbacks, pPrivateDataSlot: *mut VkPrivateDataSlot) -> Result<()> {
		convert_result("vkCreatePrivateDataSlotEXT", catch_unwind(||((self.vk_ext_private_data.vk_create_private_data_slot_ext)(device, pCreateInfo, pAllocator, pPrivateDataSlot))))
	}
}
impl VK_EXT_pipeline_creation_cache_control for VkCore {}
impl VK_NV_device_diagnostics_config for VkCore {}
impl VK_QCOM_render_pass_store_ops for VkCore {}
impl VK_QCOM_tile_shading for VkCore {
	fn vkCmdDispatchTileQCOM(&self, commandBuffer: VkCommandBuffer, pDispatchTileInfo: *const VkDispatchTileInfoQCOM) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_qcom_tile_shading.vk_cmd_dispatch_tile_qcom)(commandBuffer, pDispatchTileInfo))))
	}
}
impl VK_NV_low_latency for VkCore {}
impl VK_EXT_descriptor_buffer for VkCore {
	fn vkGetDescriptorSetLayoutSizeEXT(&self, device: VkDevice, layout: VkDescriptorSetLayout, pLayoutSizeInBytes: *mut VkDeviceSize) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_descriptor_buffer.vk_get_descriptor_set_layout_size_ext)(device, layout, pLayoutSizeInBytes))))
	}
}
impl VK_EXT_graphics_pipeline_library for VkCore {}
impl VK_AMD_shader_early_and_late_fragment_tests for VkCore {}
impl VK_NV_fragment_shading_rate_enums for VkCore {
	fn vkCmdSetFragmentShadingRateEnumNV(&self, commandBuffer: VkCommandBuffer, shadingRate: VkFragmentShadingRateNV, combinerOps: &[VkFragmentShadingRateCombinerOpKHR; 2 as usize]) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_nv_fragment_shading_rate_enums.vk_cmd_set_fragment_shading_rate_enum_nv)(commandBuffer, shadingRate, combinerOps))))
	}
}
impl VK_NV_ray_tracing_motion_blur for VkCore {}
impl VK_EXT_ycbcr_2plane_444_formats for VkCore {}
impl VK_EXT_fragment_density_map2 for VkCore {}
impl VK_QCOM_rotated_copy_commands for VkCore {}
impl VK_EXT_image_robustness for VkCore {}
impl VK_EXT_image_compression_control for VkCore {}
impl VK_EXT_attachment_feedback_loop_layout for VkCore {}
impl VK_EXT_4444_formats for VkCore {}
impl VK_EXT_device_fault for VkCore {
	fn vkGetDeviceFaultInfoEXT(&self, device: VkDevice, pFaultCounts: *mut VkDeviceFaultCountsEXT, pFaultInfo: *mut VkDeviceFaultInfoEXT) -> Result<()> {
		convert_result("vkGetDeviceFaultInfoEXT", catch_unwind(||((self.vk_ext_device_fault.vk_get_device_fault_info_ext)(device, pFaultCounts, pFaultInfo))))
	}
}
impl VK_ARM_rasterization_order_attachment_access for VkCore {}
impl VK_EXT_rgba10x6_formats for VkCore {}
impl VK_VALVE_mutable_descriptor_type for VkCore {}
impl VK_EXT_vertex_input_dynamic_state for VkCore {
	fn vkCmdSetVertexInputEXT(&self, commandBuffer: VkCommandBuffer, vertexBindingDescriptionCount: u32, pVertexBindingDescriptions: *const VkVertexInputBindingDescription2EXT, vertexAttributeDescriptionCount: u32, pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription2EXT) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_vertex_input_dynamic_state.vk_cmd_set_vertex_input_ext)(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions))))
	}
}
impl VK_EXT_physical_device_drm for VkCore {}
impl VK_EXT_device_address_binding_report for VkCore {}
impl VK_EXT_depth_clip_control for VkCore {}
impl VK_EXT_primitive_topology_list_restart for VkCore {}
impl VK_EXT_present_mode_fifo_latest_ready for VkCore {}
impl VK_HUAWEI_subpass_shading for VkCore {
	fn vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(&self, device: VkDevice, renderpass: VkRenderPass, pMaxWorkgroupSize: *mut VkExtent2D) -> Result<()> {
		convert_result("vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI", catch_unwind(||((self.vk_huawei_subpass_shading.vk_get_device_subpass_shading_max_workgroup_size_huawei)(device, renderpass, pMaxWorkgroupSize))))
	}
}
impl VK_HUAWEI_invocation_mask for VkCore {
	fn vkCmdBindInvocationMaskHUAWEI(&self, commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_huawei_invocation_mask.vk_cmd_bind_invocation_mask_huawei)(commandBuffer, imageView, imageLayout))))
	}
}
impl VK_NV_external_memory_rdma for VkCore {
	fn vkGetMemoryRemoteAddressNV(&self, device: VkDevice, pMemoryGetRemoteAddressInfo: *const VkMemoryGetRemoteAddressInfoNV, pAddress: *mut VkRemoteAddressNV) -> Result<()> {
		convert_result("vkGetMemoryRemoteAddressNV", catch_unwind(||((self.vk_nv_external_memory_rdma.vk_get_memory_remote_address_nv)(device, pMemoryGetRemoteAddressInfo, pAddress))))
	}
}
impl VK_EXT_pipeline_properties for VkCore {
	fn vkGetPipelinePropertiesEXT(&self, device: VkDevice, pPipelineInfo: *const VkPipelineInfoEXT, pPipelineProperties: *mut VkBaseOutStructure) -> Result<()> {
		convert_result("vkGetPipelinePropertiesEXT", catch_unwind(||((self.vk_ext_pipeline_properties.vk_get_pipeline_properties_ext)(device, pPipelineInfo, pPipelineProperties))))
	}
}
impl VK_EXT_frame_boundary for VkCore {}
impl VK_EXT_multisampled_render_to_single_sampled for VkCore {}
impl VK_EXT_extended_dynamic_state2 for VkCore {
	fn vkCmdSetPatchControlPointsEXT(&self, commandBuffer: VkCommandBuffer, patchControlPoints: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_extended_dynamic_state2.vk_cmd_set_patch_control_points_ext)(commandBuffer, patchControlPoints))))
	}
}
impl VK_EXT_color_write_enable for VkCore {
	fn vkCmdSetColorWriteEnableEXT(&self, commandBuffer: VkCommandBuffer, attachmentCount: u32, pColorWriteEnables: *const VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_color_write_enable.vk_cmd_set_color_write_enable_ext)(commandBuffer, attachmentCount, pColorWriteEnables))))
	}
}
impl VK_EXT_primitives_generated_query for VkCore {}
impl VK_EXT_global_priority_query for VkCore {}
impl VK_EXT_image_view_min_lod for VkCore {}
impl VK_EXT_multi_draw for VkCore {
	fn vkCmdDrawMultiEXT(&self, commandBuffer: VkCommandBuffer, drawCount: u32, pVertexInfo: *const VkMultiDrawInfoEXT, instanceCount: u32, firstInstance: u32, stride: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_multi_draw.vk_cmd_draw_multi_ext)(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride))))
	}
}
impl VK_EXT_image_2d_view_of_3d for VkCore {}
impl VK_EXT_shader_tile_image for VkCore {}
impl VK_EXT_opacity_micromap for VkCore {
	fn vkCreateMicromapEXT(&self, device: VkDevice, pCreateInfo: *const VkMicromapCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pMicromap: *mut VkMicromapEXT) -> Result<()> {
		convert_result("vkCreateMicromapEXT", catch_unwind(||((self.vk_ext_opacity_micromap.vk_create_micromap_ext)(device, pCreateInfo, pAllocator, pMicromap))))
	}
}
impl VK_EXT_load_store_op_none for VkCore {}
impl VK_HUAWEI_cluster_culling_shader for VkCore {
	fn vkCmdDrawClusterHUAWEI(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_huawei_cluster_culling_shader.vk_cmd_draw_cluster_huawei)(commandBuffer, groupCountX, groupCountY, groupCountZ))))
	}
}
impl VK_EXT_border_color_swizzle for VkCore {}
impl VK_EXT_pageable_device_local_memory for VkCore {
	fn vkSetDeviceMemoryPriorityEXT(&self, device: VkDevice, memory: VkDeviceMemory, priority: f32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_pageable_device_local_memory.vk_set_device_memory_priority_ext)(device, memory, priority))))
	}
}
impl VK_ARM_shader_core_properties for VkCore {}
impl VK_ARM_scheduling_controls for VkCore {}
impl VK_EXT_image_sliced_view_of_3d for VkCore {}
impl VK_VALVE_descriptor_set_host_mapping for VkCore {
	fn vkGetDescriptorSetLayoutHostMappingInfoVALVE(&self, device: VkDevice, pBindingReference: *const VkDescriptorSetBindingReferenceVALVE, pHostMapping: *mut VkDescriptorSetLayoutHostMappingInfoVALVE) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_valve_descriptor_set_host_mapping.vk_get_descriptor_set_layout_host_mapping_info_valve)(device, pBindingReference, pHostMapping))))
	}
}
impl VK_EXT_depth_clamp_zero_one for VkCore {}
impl VK_EXT_non_seamless_cube_map for VkCore {}
impl VK_ARM_render_pass_striped for VkCore {}
impl VK_QCOM_fragment_density_map_offset for VkCore {}
impl VK_NV_copy_memory_indirect for VkCore {
	fn vkCmdCopyMemoryIndirectNV(&self, commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: u32, stride: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_nv_copy_memory_indirect.vk_cmd_copy_memory_indirect_nv)(commandBuffer, copyBufferAddress, copyCount, stride))))
	}
}
impl VK_NV_memory_decompression for VkCore {
	fn vkCmdDecompressMemoryNV(&self, commandBuffer: VkCommandBuffer, decompressRegionCount: u32, pDecompressMemoryRegions: *const VkDecompressMemoryRegionNV) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_nv_memory_decompression.vk_cmd_decompress_memory_nv)(commandBuffer, decompressRegionCount, pDecompressMemoryRegions))))
	}
}
impl VK_NV_device_generated_commands_compute for VkCore {
	fn vkGetPipelineIndirectMemoryRequirementsNV(&self, device: VkDevice, pCreateInfo: *const VkComputePipelineCreateInfo, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_nv_device_generated_commands_compute.vk_get_pipeline_indirect_memory_requirements_nv)(device, pCreateInfo, pMemoryRequirements))))
	}
}
impl VK_NV_ray_tracing_linear_swept_spheres for VkCore {}
impl VK_NV_linear_color_attachment for VkCore {}
impl VK_GOOGLE_surfaceless_query for VkCore {}
impl VK_EXT_image_compression_control_swapchain for VkCore {}
impl VK_QCOM_image_processing for VkCore {}
impl VK_EXT_nested_command_buffer for VkCore {}
impl VK_EXT_external_memory_acquire_unmodified for VkCore {}
impl VK_EXT_extended_dynamic_state3 for VkCore {
	fn vkCmdSetDepthClampEnableEXT(&self, commandBuffer: VkCommandBuffer, depthClampEnable: VkBool32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_extended_dynamic_state3.vk_cmd_set_depth_clamp_enable_ext)(commandBuffer, depthClampEnable))))
	}
}
impl VK_EXT_subpass_merge_feedback for VkCore {}
impl VK_LUNARG_direct_driver_loading for VkCore {}
impl VK_ARM_tensors for VkCore {
	fn vkCreateTensorARM(&self, device: VkDevice, pCreateInfo: *const VkTensorCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pTensor: *mut VkTensorARM) -> Result<()> {
		convert_result("vkCreateTensorARM", catch_unwind(||((self.vk_arm_tensors.vk_create_tensor_arm)(device, pCreateInfo, pAllocator, pTensor))))
	}
}
impl VK_EXT_shader_module_identifier for VkCore {
	fn vkGetShaderModuleIdentifierEXT(&self, device: VkDevice, shaderModule: VkShaderModule, pIdentifier: *mut VkShaderModuleIdentifierEXT) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_shader_module_identifier.vk_get_shader_module_identifier_ext)(device, shaderModule, pIdentifier))))
	}
}
impl VK_EXT_rasterization_order_attachment_access for VkCore {}
impl VK_NV_optical_flow for VkCore {
	fn vkGetPhysicalDeviceOpticalFlowImageFormatsNV(&self, physicalDevice: VkPhysicalDevice, pOpticalFlowImageFormatInfo: *const VkOpticalFlowImageFormatInfoNV, pFormatCount: *mut uint32_t, pImageFormatProperties: *mut VkOpticalFlowImageFormatPropertiesNV) -> Result<()> {
		convert_result("vkGetPhysicalDeviceOpticalFlowImageFormatsNV", catch_unwind(||((self.vk_nv_optical_flow.vk_get_physical_device_optical_flow_image_formats_nv)(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties))))
	}
}
impl VK_EXT_legacy_dithering for VkCore {}
impl VK_EXT_pipeline_protected_access for VkCore {}
impl VK_AMD_anti_lag for VkCore {
	fn vkAntiLagUpdateAMD(&self, device: VkDevice, pData: *const VkAntiLagDataAMD) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_amd_anti_lag.vk_anti_lag_update_amd)(device, pData))))
	}
}
impl VK_EXT_shader_object for VkCore {
	fn vkCreateShadersEXT(&self, device: VkDevice, createInfoCount: u32, pCreateInfos: *const VkShaderCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pShaders: *mut VkShaderEXT) -> Result<()> {
		convert_result("vkCreateShadersEXT", catch_unwind(||((self.vk_ext_shader_object.vk_create_shaders_ext)(device, createInfoCount, pCreateInfos, pAllocator, pShaders))))
	}
}
impl VK_QCOM_tile_properties for VkCore {
	fn vkGetFramebufferTilePropertiesQCOM(&self, device: VkDevice, framebuffer: VkFramebuffer, pPropertiesCount: *mut uint32_t, pProperties: *mut VkTilePropertiesQCOM) -> Result<()> {
		convert_result("vkGetFramebufferTilePropertiesQCOM", catch_unwind(||((self.vk_qcom_tile_properties.vk_get_framebuffer_tile_properties_qcom)(device, framebuffer, pPropertiesCount, pProperties))))
	}
}
impl VK_SEC_amigo_profiling for VkCore {}
impl VK_QCOM_multiview_per_view_viewports for VkCore {}
impl VK_NV_ray_tracing_invocation_reorder for VkCore {}
impl VK_NV_cooperative_vector for VkCore {
	fn vkGetPhysicalDeviceCooperativeVectorPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeVectorPropertiesNV) -> Result<()> {
		convert_result("vkGetPhysicalDeviceCooperativeVectorPropertiesNV", catch_unwind(||((self.vk_nv_cooperative_vector.vk_get_physical_device_cooperative_vector_properties_nv)(physicalDevice, pPropertyCount, pProperties))))
	}
}
impl VK_NV_extended_sparse_address_space for VkCore {}
impl VK_EXT_mutable_descriptor_type for VkCore {}
impl VK_EXT_legacy_vertex_attributes for VkCore {}
impl VK_EXT_layer_settings for VkCore {}
impl VK_ARM_shader_core_builtins for VkCore {}
impl VK_EXT_pipeline_library_group_handles for VkCore {}
impl VK_EXT_dynamic_rendering_unused_attachments for VkCore {}
impl VK_NV_low_latency2 for VkCore {
	fn vkSetLatencySleepModeNV(&self, device: VkDevice, swapchain: VkSwapchainKHR, pSleepModeInfo: *const VkLatencySleepModeInfoNV) -> Result<()> {
		convert_result("vkSetLatencySleepModeNV", catch_unwind(||((self.vk_nv_low_latency2.vk_set_latency_sleep_mode_nv)(device, swapchain, pSleepModeInfo))))
	}
}
impl VK_ARM_data_graph for VkCore {
	fn vkCreateDataGraphPipelinesARM(&self, device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *const VkDataGraphPipelineCreateInfoARM, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline) -> Result<()> {
		convert_result("vkCreateDataGraphPipelinesARM", catch_unwind(||((self.vk_arm_data_graph.vk_create_data_graph_pipelines_arm)(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines))))
	}
}
impl VK_QCOM_multiview_per_view_render_areas for VkCore {}
impl VK_NV_per_stage_descriptor_set for VkCore {}
impl VK_QCOM_image_processing2 for VkCore {}
impl VK_QCOM_filter_cubic_weights for VkCore {}
impl VK_QCOM_ycbcr_degamma for VkCore {}
impl VK_QCOM_filter_cubic_clamp for VkCore {}
impl VK_EXT_attachment_feedback_loop_dynamic_state for VkCore {
	fn vkCmdSetAttachmentFeedbackLoopEnableEXT(&self, commandBuffer: VkCommandBuffer, aspectMask: VkImageAspectFlags) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_attachment_feedback_loop_dynamic_state.vk_cmd_set_attachment_feedback_loop_enable_ext)(commandBuffer, aspectMask))))
	}
}
impl VK_MSFT_layered_driver for VkCore {}
impl VK_NV_descriptor_pool_overallocation for VkCore {}
impl VK_QCOM_tile_memory_heap for VkCore {
	fn vkCmdBindTileMemoryQCOM(&self, commandBuffer: VkCommandBuffer, pTileMemoryBindInfo: *const VkTileMemoryBindInfoQCOM) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_qcom_tile_memory_heap.vk_cmd_bind_tile_memory_qcom)(commandBuffer, pTileMemoryBindInfo))))
	}
}
impl VK_NV_display_stereo for VkCore {}
impl VK_NV_raw_access_chains for VkCore {}
impl VK_NV_external_compute_queue for VkCore {
	fn vkCreateExternalComputeQueueNV(&self, device: VkDevice, pCreateInfo: *const VkExternalComputeQueueCreateInfoNV, pAllocator: *const VkAllocationCallbacks, pExternalQueue: *mut VkExternalComputeQueueNV) -> Result<()> {
		convert_result("vkCreateExternalComputeQueueNV", catch_unwind(||((self.vk_nv_external_compute_queue.vk_create_external_compute_queue_nv)(device, pCreateInfo, pAllocator, pExternalQueue))))
	}
}
impl VK_NV_command_buffer_inheritance for VkCore {}
impl VK_NV_shader_atomic_float16_vector for VkCore {}
impl VK_EXT_shader_replicated_composites for VkCore {}
impl VK_EXT_shader_float8 for VkCore {}
impl VK_NV_ray_tracing_validation for VkCore {}
impl VK_NV_cluster_acceleration_structure for VkCore {
	fn vkGetClusterAccelerationStructureBuildSizesNV(&self, device: VkDevice, pInfo: *const VkClusterAccelerationStructureInputInfoNV, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_nv_cluster_acceleration_structure.vk_get_cluster_acceleration_structure_build_sizes_nv)(device, pInfo, pSizeInfo))))
	}
}
impl VK_NV_partitioned_acceleration_structure for VkCore {
	fn vkGetPartitionedAccelerationStructuresBuildSizesNV(&self, device: VkDevice, pInfo: *const VkPartitionedAccelerationStructureInstancesInputNV, pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_nv_partitioned_acceleration_structure.vk_get_partitioned_acceleration_structures_build_sizes_nv)(device, pInfo, pSizeInfo))))
	}
}
impl VK_EXT_device_generated_commands for VkCore {
	fn vkGetGeneratedCommandsMemoryRequirementsEXT(&self, device: VkDevice, pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoEXT, pMemoryRequirements: *mut VkMemoryRequirements2) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_device_generated_commands.vk_get_generated_commands_memory_requirements_ext)(device, pInfo, pMemoryRequirements))))
	}
}
impl VK_MESA_image_alignment_control for VkCore {}
impl VK_EXT_depth_clamp_control for VkCore {}
impl VK_HUAWEI_hdr_vivid for VkCore {}
impl VK_NV_cooperative_matrix2 for VkCore {
	fn vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(&self, physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t, pProperties: *mut VkCooperativeMatrixFlexibleDimensionsPropertiesNV) -> Result<()> {
		convert_result("vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV", catch_unwind(||((self.vk_nv_cooperative_matrix2.vk_get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv)(physicalDevice, pPropertyCount, pProperties))))
	}
}
impl VK_ARM_pipeline_opacity_micromap for VkCore {}
impl VK_EXT_vertex_attribute_robustness for VkCore {}
impl VK_ARM_format_pack for VkCore {}
impl VK_VALVE_fragment_density_map_layered for VkCore {}
impl VK_NV_present_metering for VkCore {}
impl VK_EXT_fragment_density_map_offset for VkCore {
	fn vkCmdEndRendering2EXT(&self, commandBuffer: VkCommandBuffer, pRenderingEndInfo: *const VkRenderingEndInfoEXT) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_fragment_density_map_offset.vk_cmd_end_rendering2_ext)(commandBuffer, pRenderingEndInfo))))
	}
}
impl VK_EXT_zero_initialize_device_memory for VkCore {}
impl VK_SEC_pipeline_cache_incremental_mode for VkCore {}
impl VK_KHR_acceleration_structure for VkCore {
	fn vkCreateAccelerationStructureKHR(&self, device: VkDevice, pCreateInfo: *const VkAccelerationStructureCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pAccelerationStructure: *mut VkAccelerationStructureKHR) -> Result<()> {
		convert_result("vkCreateAccelerationStructureKHR", catch_unwind(||((self.vk_khr_acceleration_structure.vk_create_acceleration_structure_khr)(device, pCreateInfo, pAllocator, pAccelerationStructure))))
	}
}
impl VK_KHR_ray_tracing_pipeline for VkCore {
	fn vkCmdTraceRaysKHR(&self, commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR, width: u32, height: u32, depth: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_khr_ray_tracing_pipeline.vk_cmd_trace_rays_khr)(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth))))
	}
}
impl VK_KHR_ray_query for VkCore {}
impl VK_EXT_mesh_shader for VkCore {
	fn vkCmdDrawMeshTasksEXT(&self, commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) -> Result<()> {
		process_catch(catch_unwind(||((self.vk_ext_mesh_shader.vk_cmd_draw_mesh_tasks_ext)(commandBuffer, groupCountX, groupCountY, groupCountZ))))
	}
}
impl VkCore {
	pub fn new(app_info: VkApplicationInfo, mut get_instance_proc_address: impl FnMut(VkInstance, &'static str) -> *const c_void) -> Self {
		let vkEnumerateInstanceExtensionProperties = get_instance_proc_address(null(), "vkEnumerateInstanceExtensionProperties");
		if vkEnumerateInstanceExtensionProperties == null() {
			panic_any(VkError::NullFunctionPointer("vkEnumerateInstanceExtensionProperties"));
		}
		let vkEnumerateInstanceExtensionProperties: PFN_vkEnumerateInstanceExtensionProperties = unsafe{transmute(vkEnumerateInstanceExtensionProperties)};
		let mut count: u32 = 0;
		let err = vkEnumerateInstanceExtensionProperties(null(), &mut count as *mut _, null_mut());
		if err != VkResult::VK_SUCCESS {
			panic!("Initialize Vulkan failed: couldn't get the number of the Vulkan extensions: {err:?}")
		}
		let mut extensions: Vec<VkExtensionProperties> = Vec::with_capacity(count as usize);
		unsafe {extensions.set_len(count as usize)};
		let err = vkEnumerateInstanceExtensionProperties(null(), &mut count as *mut _, extensions.as_mut_ptr());
		if err != VkResult::VK_SUCCESS {
			panic!("Initialize Vulkan failed: couldn't get the list of the Vulkan extensions: {err:?}")
		}
		let extensions: Vec<String> = extensions.into_iter().map(|prop|unsafe {CStr::from_ptr(prop.extensionName.as_ptr())}.to_string_lossy().to_string()).collect();
		let mut c_strings: Vec<CString> = Vec::with_capacity(extensions.len());
		for extension in extensions.iter() {
			c_strings.push(CString::new(&**extension).unwrap());
		}
		let mut ext_pointers: Vec<*const i8> = Vec::with_capacity(extensions.len());
		for (i, _) in extensions.iter().enumerate() {
			ext_pointers.push(c_strings[i].as_ptr());
		}
		let create_info = VkInstanceCreateInfo {
			sType: VkStructureType::VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
			pNext: null(),
			flags: 0,
			enabledLayerCount: 0,
			pApplicationInfo: &app_info,
			ppEnabledLayerNames: null(),
			enabledExtensionCount: count,
			ppEnabledExtensionNames: ext_pointers.as_ptr()
		};
		let vkCreateInstance = get_instance_proc_address(null(), "vkCreateInstance");
		if vkCreateInstance == null() {
			panic_any(VkError::NullFunctionPointer("vkCreateInstance"))
		}
		let vkCreateInstance: PFN_vkCreateInstance = unsafe{transmute(vkCreateInstance)};
		let mut instance: VkInstance = null();
		let result = vkCreateInstance(&create_info, null(), &mut instance);
		if result != VkResult::VK_SUCCESS {
			panic!("Initialize Vulkan failed: `vkCreateInstance()` failed: {result:?}")
		}
		
		Self {
			instance,
			extensions: extensions.into_iter().collect(),
			vk_version_1_0: Vulkan_VERSION_1_0::new(instance, &mut get_instance_proc_address),
			vk_version_1_1: Vulkan_VERSION_1_1::new(instance, &mut get_instance_proc_address),
			vk_version_1_2: Vulkan_VERSION_1_2::new(instance, &mut get_instance_proc_address),
			vk_version_1_3: Vulkan_VERSION_1_3::new(instance, &mut get_instance_proc_address),
			vk_version_1_4: Vulkan_VERSION_1_4::new(instance, &mut get_instance_proc_address),
			vk_khr_surface: Vulkan_KHR_surface::new(instance, &mut get_instance_proc_address),
			vk_khr_swapchain: Vulkan_KHR_swapchain::new(instance, &mut get_instance_proc_address),
			vk_khr_display: Vulkan_KHR_display::new(instance, &mut get_instance_proc_address),
			vk_khr_display_swapchain: Vulkan_KHR_display_swapchain::new(instance, &mut get_instance_proc_address),
			vk_khr_sampler_mirror_clamp_to_edge: Vulkan_KHR_sampler_mirror_clamp_to_edge::new(instance, &mut get_instance_proc_address),
			vk_khr_video_queue: Vulkan_KHR_video_queue::new(instance, &mut get_instance_proc_address),
			vk_khr_video_decode_queue: Vulkan_KHR_video_decode_queue::new(instance, &mut get_instance_proc_address),
			vk_khr_video_encode_h264: Vulkan_KHR_video_encode_h264::new(instance, &mut get_instance_proc_address),
			vulkan_video_codec_h264std: Vulkan_video_codec_h264std::new(instance, &mut get_instance_proc_address),
			vulkan_video_codecs_common: Vulkan_video_codecs_common::new(instance, &mut get_instance_proc_address),
			vulkan_video_codec_h264std_encode: Vulkan_video_codec_h264std_encode::new(instance, &mut get_instance_proc_address),
			vk_khr_video_encode_h265: Vulkan_KHR_video_encode_h265::new(instance, &mut get_instance_proc_address),
			vulkan_video_codec_h265std: Vulkan_video_codec_h265std::new(instance, &mut get_instance_proc_address),
			vulkan_video_codec_h265std_encode: Vulkan_video_codec_h265std_encode::new(instance, &mut get_instance_proc_address),
			vk_khr_video_decode_h264: Vulkan_KHR_video_decode_h264::new(instance, &mut get_instance_proc_address),
			vulkan_video_codec_h264std_decode: Vulkan_video_codec_h264std_decode::new(instance, &mut get_instance_proc_address),
			vk_khr_dynamic_rendering: Vulkan_KHR_dynamic_rendering::new(instance, &mut get_instance_proc_address),
			vk_khr_multiview: Vulkan_KHR_multiview::new(instance, &mut get_instance_proc_address),
			vk_khr_get_physical_device_properties2: Vulkan_KHR_get_physical_device_properties2::new(instance, &mut get_instance_proc_address),
			vk_khr_device_group: Vulkan_KHR_device_group::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_draw_parameters: Vulkan_KHR_shader_draw_parameters::new(instance, &mut get_instance_proc_address),
			vk_khr_maintenance1: Vulkan_KHR_maintenance1::new(instance, &mut get_instance_proc_address),
			vk_khr_device_group_creation: Vulkan_KHR_device_group_creation::new(instance, &mut get_instance_proc_address),
			vk_khr_external_memory_capabilities: Vulkan_KHR_external_memory_capabilities::new(instance, &mut get_instance_proc_address),
			vk_khr_external_memory: Vulkan_KHR_external_memory::new(instance, &mut get_instance_proc_address),
			vk_khr_external_memory_fd: Vulkan_KHR_external_memory_fd::new(instance, &mut get_instance_proc_address),
			vk_khr_external_semaphore_capabilities: Vulkan_KHR_external_semaphore_capabilities::new(instance, &mut get_instance_proc_address),
			vk_khr_external_semaphore: Vulkan_KHR_external_semaphore::new(instance, &mut get_instance_proc_address),
			vk_khr_external_semaphore_fd: Vulkan_KHR_external_semaphore_fd::new(instance, &mut get_instance_proc_address),
			vk_khr_push_descriptor: Vulkan_KHR_push_descriptor::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_float16_int8: Vulkan_KHR_shader_float16_int8::new(instance, &mut get_instance_proc_address),
			vk_khr_16bit_storage: Vulkan_KHR_16bit_storage::new(instance, &mut get_instance_proc_address),
			vk_khr_incremental_present: Vulkan_KHR_incremental_present::new(instance, &mut get_instance_proc_address),
			vk_khr_descriptor_update_template: Vulkan_KHR_descriptor_update_template::new(instance, &mut get_instance_proc_address),
			vk_khr_imageless_framebuffer: Vulkan_KHR_imageless_framebuffer::new(instance, &mut get_instance_proc_address),
			vk_khr_create_renderpass2: Vulkan_KHR_create_renderpass2::new(instance, &mut get_instance_proc_address),
			vk_khr_shared_presentable_image: Vulkan_KHR_shared_presentable_image::new(instance, &mut get_instance_proc_address),
			vk_khr_external_fence_capabilities: Vulkan_KHR_external_fence_capabilities::new(instance, &mut get_instance_proc_address),
			vk_khr_external_fence: Vulkan_KHR_external_fence::new(instance, &mut get_instance_proc_address),
			vk_khr_external_fence_fd: Vulkan_KHR_external_fence_fd::new(instance, &mut get_instance_proc_address),
			vk_khr_performance_query: Vulkan_KHR_performance_query::new(instance, &mut get_instance_proc_address),
			vk_khr_maintenance2: Vulkan_KHR_maintenance2::new(instance, &mut get_instance_proc_address),
			vk_khr_get_surface_capabilities2: Vulkan_KHR_get_surface_capabilities2::new(instance, &mut get_instance_proc_address),
			vk_khr_variable_pointers: Vulkan_KHR_variable_pointers::new(instance, &mut get_instance_proc_address),
			vk_khr_get_display_properties2: Vulkan_KHR_get_display_properties2::new(instance, &mut get_instance_proc_address),
			vk_khr_dedicated_allocation: Vulkan_KHR_dedicated_allocation::new(instance, &mut get_instance_proc_address),
			vk_khr_storage_buffer_storage_class: Vulkan_KHR_storage_buffer_storage_class::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_bfloat16: Vulkan_KHR_shader_bfloat16::new(instance, &mut get_instance_proc_address),
			vk_khr_relaxed_block_layout: Vulkan_KHR_relaxed_block_layout::new(instance, &mut get_instance_proc_address),
			vk_khr_get_memory_requirements2: Vulkan_KHR_get_memory_requirements2::new(instance, &mut get_instance_proc_address),
			vk_khr_image_format_list: Vulkan_KHR_image_format_list::new(instance, &mut get_instance_proc_address),
			vk_khr_sampler_ycbcr_conversion: Vulkan_KHR_sampler_ycbcr_conversion::new(instance, &mut get_instance_proc_address),
			vk_khr_bind_memory2: Vulkan_KHR_bind_memory2::new(instance, &mut get_instance_proc_address),
			vk_khr_maintenance3: Vulkan_KHR_maintenance3::new(instance, &mut get_instance_proc_address),
			vk_khr_draw_indirect_count: Vulkan_KHR_draw_indirect_count::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_subgroup_extended_types: Vulkan_KHR_shader_subgroup_extended_types::new(instance, &mut get_instance_proc_address),
			vk_khr_8bit_storage: Vulkan_KHR_8bit_storage::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_atomic_int64: Vulkan_KHR_shader_atomic_int64::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_clock: Vulkan_KHR_shader_clock::new(instance, &mut get_instance_proc_address),
			vk_khr_video_decode_h265: Vulkan_KHR_video_decode_h265::new(instance, &mut get_instance_proc_address),
			vulkan_video_codec_h265std_decode: Vulkan_video_codec_h265std_decode::new(instance, &mut get_instance_proc_address),
			vk_khr_global_priority: Vulkan_KHR_global_priority::new(instance, &mut get_instance_proc_address),
			vk_khr_driver_properties: Vulkan_KHR_driver_properties::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_float_controls: Vulkan_KHR_shader_float_controls::new(instance, &mut get_instance_proc_address),
			vk_khr_depth_stencil_resolve: Vulkan_KHR_depth_stencil_resolve::new(instance, &mut get_instance_proc_address),
			vk_khr_swapchain_mutable_format: Vulkan_KHR_swapchain_mutable_format::new(instance, &mut get_instance_proc_address),
			vk_khr_timeline_semaphore: Vulkan_KHR_timeline_semaphore::new(instance, &mut get_instance_proc_address),
			vk_khr_vulkan_memory_model: Vulkan_KHR_vulkan_memory_model::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_terminate_invocation: Vulkan_KHR_shader_terminate_invocation::new(instance, &mut get_instance_proc_address),
			vk_khr_fragment_shading_rate: Vulkan_KHR_fragment_shading_rate::new(instance, &mut get_instance_proc_address),
			vk_khr_dynamic_rendering_local_read: Vulkan_KHR_dynamic_rendering_local_read::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_quad_control: Vulkan_KHR_shader_quad_control::new(instance, &mut get_instance_proc_address),
			vk_khr_spirv_1_4: Vulkan_KHR_spirv_1_4::new(instance, &mut get_instance_proc_address),
			vk_khr_surface_protected_capabilities: Vulkan_KHR_surface_protected_capabilities::new(instance, &mut get_instance_proc_address),
			vk_khr_separate_depth_stencil_layouts: Vulkan_KHR_separate_depth_stencil_layouts::new(instance, &mut get_instance_proc_address),
			vk_khr_present_wait: Vulkan_KHR_present_wait::new(instance, &mut get_instance_proc_address),
			vk_khr_uniform_buffer_standard_layout: Vulkan_KHR_uniform_buffer_standard_layout::new(instance, &mut get_instance_proc_address),
			vk_khr_buffer_device_address: Vulkan_KHR_buffer_device_address::new(instance, &mut get_instance_proc_address),
			vk_khr_deferred_host_operations: Vulkan_KHR_deferred_host_operations::new(instance, &mut get_instance_proc_address),
			vk_khr_pipeline_executable_properties: Vulkan_KHR_pipeline_executable_properties::new(instance, &mut get_instance_proc_address),
			vk_khr_map_memory2: Vulkan_KHR_map_memory2::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_integer_dot_product: Vulkan_KHR_shader_integer_dot_product::new(instance, &mut get_instance_proc_address),
			vk_khr_pipeline_library: Vulkan_KHR_pipeline_library::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_non_semantic_info: Vulkan_KHR_shader_non_semantic_info::new(instance, &mut get_instance_proc_address),
			vk_khr_present_id: Vulkan_KHR_present_id::new(instance, &mut get_instance_proc_address),
			vk_khr_video_encode_queue: Vulkan_KHR_video_encode_queue::new(instance, &mut get_instance_proc_address),
			vk_khr_synchronization2: Vulkan_KHR_synchronization2::new(instance, &mut get_instance_proc_address),
			vk_khr_fragment_shader_barycentric: Vulkan_KHR_fragment_shader_barycentric::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_subgroup_uniform_control_flow: Vulkan_KHR_shader_subgroup_uniform_control_flow::new(instance, &mut get_instance_proc_address),
			vk_khr_zero_initialize_workgroup_memory: Vulkan_KHR_zero_initialize_workgroup_memory::new(instance, &mut get_instance_proc_address),
			vk_khr_workgroup_memory_explicit_layout: Vulkan_KHR_workgroup_memory_explicit_layout::new(instance, &mut get_instance_proc_address),
			vk_khr_copy_commands2: Vulkan_KHR_copy_commands2::new(instance, &mut get_instance_proc_address),
			vk_khr_format_feature_flags2: Vulkan_KHR_format_feature_flags2::new(instance, &mut get_instance_proc_address),
			vk_khr_ray_tracing_maintenance1: Vulkan_KHR_ray_tracing_maintenance1::new(instance, &mut get_instance_proc_address),
			vk_khr_portability_enumeration: Vulkan_KHR_portability_enumeration::new(instance, &mut get_instance_proc_address),
			vk_khr_maintenance4: Vulkan_KHR_maintenance4::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_subgroup_rotate: Vulkan_KHR_shader_subgroup_rotate::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_maximal_reconvergence: Vulkan_KHR_shader_maximal_reconvergence::new(instance, &mut get_instance_proc_address),
			vk_khr_maintenance5: Vulkan_KHR_maintenance5::new(instance, &mut get_instance_proc_address),
			vk_khr_present_id2: Vulkan_KHR_present_id2::new(instance, &mut get_instance_proc_address),
			vk_khr_present_wait2: Vulkan_KHR_present_wait2::new(instance, &mut get_instance_proc_address),
			vk_khr_ray_tracing_position_fetch: Vulkan_KHR_ray_tracing_position_fetch::new(instance, &mut get_instance_proc_address),
			vk_khr_pipeline_binary: Vulkan_KHR_pipeline_binary::new(instance, &mut get_instance_proc_address),
			vk_khr_surface_maintenance1: Vulkan_KHR_surface_maintenance1::new(instance, &mut get_instance_proc_address),
			vk_khr_swapchain_maintenance1: Vulkan_KHR_swapchain_maintenance1::new(instance, &mut get_instance_proc_address),
			vk_khr_cooperative_matrix: Vulkan_KHR_cooperative_matrix::new(instance, &mut get_instance_proc_address),
			vk_khr_compute_shader_derivatives: Vulkan_KHR_compute_shader_derivatives::new(instance, &mut get_instance_proc_address),
			vk_khr_video_decode_av1: Vulkan_KHR_video_decode_av1::new(instance, &mut get_instance_proc_address),
			vulkan_video_codec_av1std: Vulkan_video_codec_av1std::new(instance, &mut get_instance_proc_address),
			vulkan_video_codec_av1std_decode: Vulkan_video_codec_av1std_decode::new(instance, &mut get_instance_proc_address),
			vk_khr_video_encode_av1: Vulkan_KHR_video_encode_av1::new(instance, &mut get_instance_proc_address),
			vulkan_video_codec_av1std_encode: Vulkan_video_codec_av1std_encode::new(instance, &mut get_instance_proc_address),
			vk_khr_video_decode_vp9: Vulkan_KHR_video_decode_vp9::new(instance, &mut get_instance_proc_address),
			vulkan_video_codec_vp9std: Vulkan_video_codec_vp9std::new(instance, &mut get_instance_proc_address),
			vulkan_video_codec_vp9std_decode: Vulkan_video_codec_vp9std_decode::new(instance, &mut get_instance_proc_address),
			vk_khr_video_maintenance1: Vulkan_KHR_video_maintenance1::new(instance, &mut get_instance_proc_address),
			vk_khr_vertex_attribute_divisor: Vulkan_KHR_vertex_attribute_divisor::new(instance, &mut get_instance_proc_address),
			vk_khr_load_store_op_none: Vulkan_KHR_load_store_op_none::new(instance, &mut get_instance_proc_address),
			vk_khr_unified_image_layouts: Vulkan_KHR_unified_image_layouts::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_float_controls2: Vulkan_KHR_shader_float_controls2::new(instance, &mut get_instance_proc_address),
			vk_khr_index_type_uint8: Vulkan_KHR_index_type_uint8::new(instance, &mut get_instance_proc_address),
			vk_khr_line_rasterization: Vulkan_KHR_line_rasterization::new(instance, &mut get_instance_proc_address),
			vk_khr_calibrated_timestamps: Vulkan_KHR_calibrated_timestamps::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_expect_assume: Vulkan_KHR_shader_expect_assume::new(instance, &mut get_instance_proc_address),
			vk_khr_maintenance6: Vulkan_KHR_maintenance6::new(instance, &mut get_instance_proc_address),
			vk_khr_video_encode_intra_refresh: Vulkan_KHR_video_encode_intra_refresh::new(instance, &mut get_instance_proc_address),
			vk_khr_video_encode_quantization_map: Vulkan_KHR_video_encode_quantization_map::new(instance, &mut get_instance_proc_address),
			vk_khr_shader_relaxed_extended_instruction: Vulkan_KHR_shader_relaxed_extended_instruction::new(instance, &mut get_instance_proc_address),
			vk_khr_maintenance7: Vulkan_KHR_maintenance7::new(instance, &mut get_instance_proc_address),
			vk_khr_maintenance8: Vulkan_KHR_maintenance8::new(instance, &mut get_instance_proc_address),
			vk_khr_maintenance9: Vulkan_KHR_maintenance9::new(instance, &mut get_instance_proc_address),
			vk_khr_video_maintenance2: Vulkan_KHR_video_maintenance2::new(instance, &mut get_instance_proc_address),
			vk_khr_depth_clamp_zero_one: Vulkan_KHR_depth_clamp_zero_one::new(instance, &mut get_instance_proc_address),
			vk_khr_robustness2: Vulkan_KHR_robustness2::new(instance, &mut get_instance_proc_address),
			vk_khr_present_mode_fifo_latest_ready: Vulkan_KHR_present_mode_fifo_latest_ready::new(instance, &mut get_instance_proc_address),
			vk_ext_debug_report: Vulkan_EXT_debug_report::new(instance, &mut get_instance_proc_address),
			vk_nv_glsl_shader: Vulkan_NV_glsl_shader::new(instance, &mut get_instance_proc_address),
			vk_ext_depth_range_unrestricted: Vulkan_EXT_depth_range_unrestricted::new(instance, &mut get_instance_proc_address),
			vk_img_filter_cubic: Vulkan_IMG_filter_cubic::new(instance, &mut get_instance_proc_address),
			vk_amd_rasterization_order: Vulkan_AMD_rasterization_order::new(instance, &mut get_instance_proc_address),
			vk_amd_shader_trinary_minmax: Vulkan_AMD_shader_trinary_minmax::new(instance, &mut get_instance_proc_address),
			vk_amd_shader_explicit_vertex_parameter: Vulkan_AMD_shader_explicit_vertex_parameter::new(instance, &mut get_instance_proc_address),
			vk_ext_debug_marker: Vulkan_EXT_debug_marker::new(instance, &mut get_instance_proc_address),
			vk_amd_gcn_shader: Vulkan_AMD_gcn_shader::new(instance, &mut get_instance_proc_address),
			vk_nv_dedicated_allocation: Vulkan_NV_dedicated_allocation::new(instance, &mut get_instance_proc_address),
			vk_ext_transform_feedback: Vulkan_EXT_transform_feedback::new(instance, &mut get_instance_proc_address),
			vk_nvx_binary_import: Vulkan_NVX_binary_import::new(instance, &mut get_instance_proc_address),
			vk_nvx_image_view_handle: Vulkan_NVX_image_view_handle::new(instance, &mut get_instance_proc_address),
			vk_amd_draw_indirect_count: Vulkan_AMD_draw_indirect_count::new(instance, &mut get_instance_proc_address),
			vk_amd_negative_viewport_height: Vulkan_AMD_negative_viewport_height::new(instance, &mut get_instance_proc_address),
			vk_amd_gpu_shader_half_float: Vulkan_AMD_gpu_shader_half_float::new(instance, &mut get_instance_proc_address),
			vk_amd_shader_ballot: Vulkan_AMD_shader_ballot::new(instance, &mut get_instance_proc_address),
			vk_amd_texture_gather_bias_lod: Vulkan_AMD_texture_gather_bias_lod::new(instance, &mut get_instance_proc_address),
			vk_amd_shader_info: Vulkan_AMD_shader_info::new(instance, &mut get_instance_proc_address),
			vk_amd_shader_image_load_store_lod: Vulkan_AMD_shader_image_load_store_lod::new(instance, &mut get_instance_proc_address),
			vk_nv_corner_sampled_image: Vulkan_NV_corner_sampled_image::new(instance, &mut get_instance_proc_address),
			vk_img_format_pvrtc: Vulkan_IMG_format_pvrtc::new(instance, &mut get_instance_proc_address),
			vk_nv_external_memory_capabilities: Vulkan_NV_external_memory_capabilities::new(instance, &mut get_instance_proc_address),
			vk_nv_external_memory: Vulkan_NV_external_memory::new(instance, &mut get_instance_proc_address),
			vk_ext_validation_flags: Vulkan_EXT_validation_flags::new(instance, &mut get_instance_proc_address),
			vk_ext_shader_subgroup_ballot: Vulkan_EXT_shader_subgroup_ballot::new(instance, &mut get_instance_proc_address),
			vk_ext_shader_subgroup_vote: Vulkan_EXT_shader_subgroup_vote::new(instance, &mut get_instance_proc_address),
			vk_ext_texture_compression_astc_hdr: Vulkan_EXT_texture_compression_astc_hdr::new(instance, &mut get_instance_proc_address),
			vk_ext_astc_decode_mode: Vulkan_EXT_astc_decode_mode::new(instance, &mut get_instance_proc_address),
			vk_ext_pipeline_robustness: Vulkan_EXT_pipeline_robustness::new(instance, &mut get_instance_proc_address),
			vk_ext_conditional_rendering: Vulkan_EXT_conditional_rendering::new(instance, &mut get_instance_proc_address),
			vk_nv_clip_space_w_scaling: Vulkan_NV_clip_space_w_scaling::new(instance, &mut get_instance_proc_address),
			vk_ext_direct_mode_display: Vulkan_EXT_direct_mode_display::new(instance, &mut get_instance_proc_address),
			vk_ext_display_surface_counter: Vulkan_EXT_display_surface_counter::new(instance, &mut get_instance_proc_address),
			vk_ext_display_control: Vulkan_EXT_display_control::new(instance, &mut get_instance_proc_address),
			vk_google_display_timing: Vulkan_GOOGLE_display_timing::new(instance, &mut get_instance_proc_address),
			vk_nv_sample_mask_override_coverage: Vulkan_NV_sample_mask_override_coverage::new(instance, &mut get_instance_proc_address),
			vk_nv_geometry_shader_passthrough: Vulkan_NV_geometry_shader_passthrough::new(instance, &mut get_instance_proc_address),
			vk_nv_viewport_array2: Vulkan_NV_viewport_array2::new(instance, &mut get_instance_proc_address),
			vk_nvx_multiview_per_view_attributes: Vulkan_NVX_multiview_per_view_attributes::new(instance, &mut get_instance_proc_address),
			vk_nv_viewport_swizzle: Vulkan_NV_viewport_swizzle::new(instance, &mut get_instance_proc_address),
			vk_ext_discard_rectangles: Vulkan_EXT_discard_rectangles::new(instance, &mut get_instance_proc_address),
			vk_ext_conservative_rasterization: Vulkan_EXT_conservative_rasterization::new(instance, &mut get_instance_proc_address),
			vk_ext_depth_clip_enable: Vulkan_EXT_depth_clip_enable::new(instance, &mut get_instance_proc_address),
			vk_ext_swapchain_colorspace: Vulkan_EXT_swapchain_colorspace::new(instance, &mut get_instance_proc_address),
			vk_ext_hdr_metadata: Vulkan_EXT_hdr_metadata::new(instance, &mut get_instance_proc_address),
			vk_img_relaxed_line_rasterization: Vulkan_IMG_relaxed_line_rasterization::new(instance, &mut get_instance_proc_address),
			vk_ext_external_memory_dma_buf: Vulkan_EXT_external_memory_dma_buf::new(instance, &mut get_instance_proc_address),
			vk_ext_queue_family_foreign: Vulkan_EXT_queue_family_foreign::new(instance, &mut get_instance_proc_address),
			vk_ext_debug_utils: Vulkan_EXT_debug_utils::new(instance, &mut get_instance_proc_address),
			vk_ext_sampler_filter_minmax: Vulkan_EXT_sampler_filter_minmax::new(instance, &mut get_instance_proc_address),
			vk_amd_gpu_shader_int16: Vulkan_AMD_gpu_shader_int16::new(instance, &mut get_instance_proc_address),
			vk_amd_mixed_attachment_samples: Vulkan_AMD_mixed_attachment_samples::new(instance, &mut get_instance_proc_address),
			vk_amd_shader_fragment_mask: Vulkan_AMD_shader_fragment_mask::new(instance, &mut get_instance_proc_address),
			vk_ext_inline_uniform_block: Vulkan_EXT_inline_uniform_block::new(instance, &mut get_instance_proc_address),
			vk_ext_shader_stencil_export: Vulkan_EXT_shader_stencil_export::new(instance, &mut get_instance_proc_address),
			vk_ext_sample_locations: Vulkan_EXT_sample_locations::new(instance, &mut get_instance_proc_address),
			vk_ext_blend_operation_advanced: Vulkan_EXT_blend_operation_advanced::new(instance, &mut get_instance_proc_address),
			vk_nv_fragment_coverage_to_color: Vulkan_NV_fragment_coverage_to_color::new(instance, &mut get_instance_proc_address),
			vk_nv_framebuffer_mixed_samples: Vulkan_NV_framebuffer_mixed_samples::new(instance, &mut get_instance_proc_address),
			vk_nv_fill_rectangle: Vulkan_NV_fill_rectangle::new(instance, &mut get_instance_proc_address),
			vk_nv_shader_sm_builtins: Vulkan_NV_shader_sm_builtins::new(instance, &mut get_instance_proc_address),
			vk_ext_post_depth_coverage: Vulkan_EXT_post_depth_coverage::new(instance, &mut get_instance_proc_address),
			vk_ext_image_drm_format_modifier: Vulkan_EXT_image_drm_format_modifier::new(instance, &mut get_instance_proc_address),
			vk_ext_validation_cache: Vulkan_EXT_validation_cache::new(instance, &mut get_instance_proc_address),
			vk_ext_descriptor_indexing: Vulkan_EXT_descriptor_indexing::new(instance, &mut get_instance_proc_address),
			vk_ext_shader_viewport_index_layer: Vulkan_EXT_shader_viewport_index_layer::new(instance, &mut get_instance_proc_address),
			vk_nv_shading_rate_image: Vulkan_NV_shading_rate_image::new(instance, &mut get_instance_proc_address),
			vk_nv_ray_tracing: Vulkan_NV_ray_tracing::new(instance, &mut get_instance_proc_address),
			vk_nv_representative_fragment_test: Vulkan_NV_representative_fragment_test::new(instance, &mut get_instance_proc_address),
			vk_ext_filter_cubic: Vulkan_EXT_filter_cubic::new(instance, &mut get_instance_proc_address),
			vk_qcom_render_pass_shader_resolve: Vulkan_QCOM_render_pass_shader_resolve::new(instance, &mut get_instance_proc_address),
			vk_ext_global_priority: Vulkan_EXT_global_priority::new(instance, &mut get_instance_proc_address),
			vk_ext_external_memory_host: Vulkan_EXT_external_memory_host::new(instance, &mut get_instance_proc_address),
			vk_amd_buffer_marker: Vulkan_AMD_buffer_marker::new(instance, &mut get_instance_proc_address),
			vk_amd_pipeline_compiler_control: Vulkan_AMD_pipeline_compiler_control::new(instance, &mut get_instance_proc_address),
			vk_ext_calibrated_timestamps: Vulkan_EXT_calibrated_timestamps::new(instance, &mut get_instance_proc_address),
			vk_amd_shader_core_properties: Vulkan_AMD_shader_core_properties::new(instance, &mut get_instance_proc_address),
			vk_amd_memory_overallocation_behavior: Vulkan_AMD_memory_overallocation_behavior::new(instance, &mut get_instance_proc_address),
			vk_ext_vertex_attribute_divisor: Vulkan_EXT_vertex_attribute_divisor::new(instance, &mut get_instance_proc_address),
			vk_ext_pipeline_creation_feedback: Vulkan_EXT_pipeline_creation_feedback::new(instance, &mut get_instance_proc_address),
			vk_nv_shader_subgroup_partitioned: Vulkan_NV_shader_subgroup_partitioned::new(instance, &mut get_instance_proc_address),
			vk_nv_compute_shader_derivatives: Vulkan_NV_compute_shader_derivatives::new(instance, &mut get_instance_proc_address),
			vk_nv_mesh_shader: Vulkan_NV_mesh_shader::new(instance, &mut get_instance_proc_address),
			vk_nv_fragment_shader_barycentric: Vulkan_NV_fragment_shader_barycentric::new(instance, &mut get_instance_proc_address),
			vk_nv_shader_image_footprint: Vulkan_NV_shader_image_footprint::new(instance, &mut get_instance_proc_address),
			vk_nv_scissor_exclusive: Vulkan_NV_scissor_exclusive::new(instance, &mut get_instance_proc_address),
			vk_nv_device_diagnostic_checkpoints: Vulkan_NV_device_diagnostic_checkpoints::new(instance, &mut get_instance_proc_address),
			vk_intel_shader_integer_functions2: Vulkan_INTEL_shader_integer_functions2::new(instance, &mut get_instance_proc_address),
			vk_intel_performance_query: Vulkan_INTEL_performance_query::new(instance, &mut get_instance_proc_address),
			vk_ext_pci_bus_info: Vulkan_EXT_pci_bus_info::new(instance, &mut get_instance_proc_address),
			vk_amd_display_native_hdr: Vulkan_AMD_display_native_hdr::new(instance, &mut get_instance_proc_address),
			vk_ext_fragment_density_map: Vulkan_EXT_fragment_density_map::new(instance, &mut get_instance_proc_address),
			vk_ext_scalar_block_layout: Vulkan_EXT_scalar_block_layout::new(instance, &mut get_instance_proc_address),
			vk_google_hlsl_functionality1: Vulkan_GOOGLE_hlsl_functionality1::new(instance, &mut get_instance_proc_address),
			vk_google_decorate_string: Vulkan_GOOGLE_decorate_string::new(instance, &mut get_instance_proc_address),
			vk_ext_subgroup_size_control: Vulkan_EXT_subgroup_size_control::new(instance, &mut get_instance_proc_address),
			vk_amd_shader_core_properties2: Vulkan_AMD_shader_core_properties2::new(instance, &mut get_instance_proc_address),
			vk_amd_device_coherent_memory: Vulkan_AMD_device_coherent_memory::new(instance, &mut get_instance_proc_address),
			vk_ext_shader_image_atomic_int64: Vulkan_EXT_shader_image_atomic_int64::new(instance, &mut get_instance_proc_address),
			vk_ext_memory_budget: Vulkan_EXT_memory_budget::new(instance, &mut get_instance_proc_address),
			vk_ext_memory_priority: Vulkan_EXT_memory_priority::new(instance, &mut get_instance_proc_address),
			vk_nv_dedicated_allocation_image_aliasing: Vulkan_NV_dedicated_allocation_image_aliasing::new(instance, &mut get_instance_proc_address),
			vk_ext_buffer_device_address: Vulkan_EXT_buffer_device_address::new(instance, &mut get_instance_proc_address),
			vk_ext_tooling_info: Vulkan_EXT_tooling_info::new(instance, &mut get_instance_proc_address),
			vk_ext_separate_stencil_usage: Vulkan_EXT_separate_stencil_usage::new(instance, &mut get_instance_proc_address),
			vk_ext_validation_features: Vulkan_EXT_validation_features::new(instance, &mut get_instance_proc_address),
			vk_nv_cooperative_matrix: Vulkan_NV_cooperative_matrix::new(instance, &mut get_instance_proc_address),
			vk_nv_coverage_reduction_mode: Vulkan_NV_coverage_reduction_mode::new(instance, &mut get_instance_proc_address),
			vk_ext_fragment_shader_interlock: Vulkan_EXT_fragment_shader_interlock::new(instance, &mut get_instance_proc_address),
			vk_ext_ycbcr_image_arrays: Vulkan_EXT_ycbcr_image_arrays::new(instance, &mut get_instance_proc_address),
			vk_ext_provoking_vertex: Vulkan_EXT_provoking_vertex::new(instance, &mut get_instance_proc_address),
			vk_ext_headless_surface: Vulkan_EXT_headless_surface::new(instance, &mut get_instance_proc_address),
			vk_ext_line_rasterization: Vulkan_EXT_line_rasterization::new(instance, &mut get_instance_proc_address),
			vk_ext_shader_atomic_float: Vulkan_EXT_shader_atomic_float::new(instance, &mut get_instance_proc_address),
			vk_ext_host_query_reset: Vulkan_EXT_host_query_reset::new(instance, &mut get_instance_proc_address),
			vk_ext_index_type_uint8: Vulkan_EXT_index_type_uint8::new(instance, &mut get_instance_proc_address),
			vk_ext_extended_dynamic_state: Vulkan_EXT_extended_dynamic_state::new(instance, &mut get_instance_proc_address),
			vk_ext_host_image_copy: Vulkan_EXT_host_image_copy::new(instance, &mut get_instance_proc_address),
			vk_ext_map_memory_placed: Vulkan_EXT_map_memory_placed::new(instance, &mut get_instance_proc_address),
			vk_ext_shader_atomic_float2: Vulkan_EXT_shader_atomic_float2::new(instance, &mut get_instance_proc_address),
			vk_ext_surface_maintenance1: Vulkan_EXT_surface_maintenance1::new(instance, &mut get_instance_proc_address),
			vk_ext_swapchain_maintenance1: Vulkan_EXT_swapchain_maintenance1::new(instance, &mut get_instance_proc_address),
			vk_ext_shader_demote_to_helper_invocation: Vulkan_EXT_shader_demote_to_helper_invocation::new(instance, &mut get_instance_proc_address),
			vk_nv_device_generated_commands: Vulkan_NV_device_generated_commands::new(instance, &mut get_instance_proc_address),
			vk_nv_inherited_viewport_scissor: Vulkan_NV_inherited_viewport_scissor::new(instance, &mut get_instance_proc_address),
			vk_ext_texel_buffer_alignment: Vulkan_EXT_texel_buffer_alignment::new(instance, &mut get_instance_proc_address),
			vk_qcom_render_pass_transform: Vulkan_QCOM_render_pass_transform::new(instance, &mut get_instance_proc_address),
			vk_ext_depth_bias_control: Vulkan_EXT_depth_bias_control::new(instance, &mut get_instance_proc_address),
			vk_ext_device_memory_report: Vulkan_EXT_device_memory_report::new(instance, &mut get_instance_proc_address),
			vk_ext_acquire_drm_display: Vulkan_EXT_acquire_drm_display::new(instance, &mut get_instance_proc_address),
			vk_ext_robustness2: Vulkan_EXT_robustness2::new(instance, &mut get_instance_proc_address),
			vk_ext_custom_border_color: Vulkan_EXT_custom_border_color::new(instance, &mut get_instance_proc_address),
			vk_google_user_type: Vulkan_GOOGLE_user_type::new(instance, &mut get_instance_proc_address),
			vk_nv_present_barrier: Vulkan_NV_present_barrier::new(instance, &mut get_instance_proc_address),
			vk_ext_private_data: Vulkan_EXT_private_data::new(instance, &mut get_instance_proc_address),
			vk_ext_pipeline_creation_cache_control: Vulkan_EXT_pipeline_creation_cache_control::new(instance, &mut get_instance_proc_address),
			vk_nv_device_diagnostics_config: Vulkan_NV_device_diagnostics_config::new(instance, &mut get_instance_proc_address),
			vk_qcom_render_pass_store_ops: Vulkan_QCOM_render_pass_store_ops::new(instance, &mut get_instance_proc_address),
			vk_qcom_tile_shading: Vulkan_QCOM_tile_shading::new(instance, &mut get_instance_proc_address),
			vk_nv_low_latency: Vulkan_NV_low_latency::new(instance, &mut get_instance_proc_address),
			vk_ext_descriptor_buffer: Vulkan_EXT_descriptor_buffer::new(instance, &mut get_instance_proc_address),
			vk_ext_graphics_pipeline_library: Vulkan_EXT_graphics_pipeline_library::new(instance, &mut get_instance_proc_address),
			vk_amd_shader_early_and_late_fragment_tests: Vulkan_AMD_shader_early_and_late_fragment_tests::new(instance, &mut get_instance_proc_address),
			vk_nv_fragment_shading_rate_enums: Vulkan_NV_fragment_shading_rate_enums::new(instance, &mut get_instance_proc_address),
			vk_nv_ray_tracing_motion_blur: Vulkan_NV_ray_tracing_motion_blur::new(instance, &mut get_instance_proc_address),
			vk_ext_ycbcr_2plane_444_formats: Vulkan_EXT_ycbcr_2plane_444_formats::new(instance, &mut get_instance_proc_address),
			vk_ext_fragment_density_map2: Vulkan_EXT_fragment_density_map2::new(instance, &mut get_instance_proc_address),
			vk_qcom_rotated_copy_commands: Vulkan_QCOM_rotated_copy_commands::new(instance, &mut get_instance_proc_address),
			vk_ext_image_robustness: Vulkan_EXT_image_robustness::new(instance, &mut get_instance_proc_address),
			vk_ext_image_compression_control: Vulkan_EXT_image_compression_control::new(instance, &mut get_instance_proc_address),
			vk_ext_attachment_feedback_loop_layout: Vulkan_EXT_attachment_feedback_loop_layout::new(instance, &mut get_instance_proc_address),
			vk_ext_4444_formats: Vulkan_EXT_4444_formats::new(instance, &mut get_instance_proc_address),
			vk_ext_device_fault: Vulkan_EXT_device_fault::new(instance, &mut get_instance_proc_address),
			vk_arm_rasterization_order_attachment_access: Vulkan_ARM_rasterization_order_attachment_access::new(instance, &mut get_instance_proc_address),
			vk_ext_rgba10x6_formats: Vulkan_EXT_rgba10x6_formats::new(instance, &mut get_instance_proc_address),
			vk_valve_mutable_descriptor_type: Vulkan_VALVE_mutable_descriptor_type::new(instance, &mut get_instance_proc_address),
			vk_ext_vertex_input_dynamic_state: Vulkan_EXT_vertex_input_dynamic_state::new(instance, &mut get_instance_proc_address),
			vk_ext_physical_device_drm: Vulkan_EXT_physical_device_drm::new(instance, &mut get_instance_proc_address),
			vk_ext_device_address_binding_report: Vulkan_EXT_device_address_binding_report::new(instance, &mut get_instance_proc_address),
			vk_ext_depth_clip_control: Vulkan_EXT_depth_clip_control::new(instance, &mut get_instance_proc_address),
			vk_ext_primitive_topology_list_restart: Vulkan_EXT_primitive_topology_list_restart::new(instance, &mut get_instance_proc_address),
			vk_ext_present_mode_fifo_latest_ready: Vulkan_EXT_present_mode_fifo_latest_ready::new(instance, &mut get_instance_proc_address),
			vk_huawei_subpass_shading: Vulkan_HUAWEI_subpass_shading::new(instance, &mut get_instance_proc_address),
			vk_huawei_invocation_mask: Vulkan_HUAWEI_invocation_mask::new(instance, &mut get_instance_proc_address),
			vk_nv_external_memory_rdma: Vulkan_NV_external_memory_rdma::new(instance, &mut get_instance_proc_address),
			vk_ext_pipeline_properties: Vulkan_EXT_pipeline_properties::new(instance, &mut get_instance_proc_address),
			vk_ext_frame_boundary: Vulkan_EXT_frame_boundary::new(instance, &mut get_instance_proc_address),
			vk_ext_multisampled_render_to_single_sampled: Vulkan_EXT_multisampled_render_to_single_sampled::new(instance, &mut get_instance_proc_address),
			vk_ext_extended_dynamic_state2: Vulkan_EXT_extended_dynamic_state2::new(instance, &mut get_instance_proc_address),
			vk_ext_color_write_enable: Vulkan_EXT_color_write_enable::new(instance, &mut get_instance_proc_address),
			vk_ext_primitives_generated_query: Vulkan_EXT_primitives_generated_query::new(instance, &mut get_instance_proc_address),
			vk_ext_global_priority_query: Vulkan_EXT_global_priority_query::new(instance, &mut get_instance_proc_address),
			vk_ext_image_view_min_lod: Vulkan_EXT_image_view_min_lod::new(instance, &mut get_instance_proc_address),
			vk_ext_multi_draw: Vulkan_EXT_multi_draw::new(instance, &mut get_instance_proc_address),
			vk_ext_image_2d_view_of_3d: Vulkan_EXT_image_2d_view_of_3d::new(instance, &mut get_instance_proc_address),
			vk_ext_shader_tile_image: Vulkan_EXT_shader_tile_image::new(instance, &mut get_instance_proc_address),
			vk_ext_opacity_micromap: Vulkan_EXT_opacity_micromap::new(instance, &mut get_instance_proc_address),
			vk_ext_load_store_op_none: Vulkan_EXT_load_store_op_none::new(instance, &mut get_instance_proc_address),
			vk_huawei_cluster_culling_shader: Vulkan_HUAWEI_cluster_culling_shader::new(instance, &mut get_instance_proc_address),
			vk_ext_border_color_swizzle: Vulkan_EXT_border_color_swizzle::new(instance, &mut get_instance_proc_address),
			vk_ext_pageable_device_local_memory: Vulkan_EXT_pageable_device_local_memory::new(instance, &mut get_instance_proc_address),
			vk_arm_shader_core_properties: Vulkan_ARM_shader_core_properties::new(instance, &mut get_instance_proc_address),
			vk_arm_scheduling_controls: Vulkan_ARM_scheduling_controls::new(instance, &mut get_instance_proc_address),
			vk_ext_image_sliced_view_of_3d: Vulkan_EXT_image_sliced_view_of_3d::new(instance, &mut get_instance_proc_address),
			vk_valve_descriptor_set_host_mapping: Vulkan_VALVE_descriptor_set_host_mapping::new(instance, &mut get_instance_proc_address),
			vk_ext_depth_clamp_zero_one: Vulkan_EXT_depth_clamp_zero_one::new(instance, &mut get_instance_proc_address),
			vk_ext_non_seamless_cube_map: Vulkan_EXT_non_seamless_cube_map::new(instance, &mut get_instance_proc_address),
			vk_arm_render_pass_striped: Vulkan_ARM_render_pass_striped::new(instance, &mut get_instance_proc_address),
			vk_qcom_fragment_density_map_offset: Vulkan_QCOM_fragment_density_map_offset::new(instance, &mut get_instance_proc_address),
			vk_nv_copy_memory_indirect: Vulkan_NV_copy_memory_indirect::new(instance, &mut get_instance_proc_address),
			vk_nv_memory_decompression: Vulkan_NV_memory_decompression::new(instance, &mut get_instance_proc_address),
			vk_nv_device_generated_commands_compute: Vulkan_NV_device_generated_commands_compute::new(instance, &mut get_instance_proc_address),
			vk_nv_ray_tracing_linear_swept_spheres: Vulkan_NV_ray_tracing_linear_swept_spheres::new(instance, &mut get_instance_proc_address),
			vk_nv_linear_color_attachment: Vulkan_NV_linear_color_attachment::new(instance, &mut get_instance_proc_address),
			vk_google_surfaceless_query: Vulkan_GOOGLE_surfaceless_query::new(instance, &mut get_instance_proc_address),
			vk_ext_image_compression_control_swapchain: Vulkan_EXT_image_compression_control_swapchain::new(instance, &mut get_instance_proc_address),
			vk_qcom_image_processing: Vulkan_QCOM_image_processing::new(instance, &mut get_instance_proc_address),
			vk_ext_nested_command_buffer: Vulkan_EXT_nested_command_buffer::new(instance, &mut get_instance_proc_address),
			vk_ext_external_memory_acquire_unmodified: Vulkan_EXT_external_memory_acquire_unmodified::new(instance, &mut get_instance_proc_address),
			vk_ext_extended_dynamic_state3: Vulkan_EXT_extended_dynamic_state3::new(instance, &mut get_instance_proc_address),
			vk_ext_subpass_merge_feedback: Vulkan_EXT_subpass_merge_feedback::new(instance, &mut get_instance_proc_address),
			vk_lunarg_direct_driver_loading: Vulkan_LUNARG_direct_driver_loading::new(instance, &mut get_instance_proc_address),
			vk_arm_tensors: Vulkan_ARM_tensors::new(instance, &mut get_instance_proc_address),
			vk_ext_shader_module_identifier: Vulkan_EXT_shader_module_identifier::new(instance, &mut get_instance_proc_address),
			vk_ext_rasterization_order_attachment_access: Vulkan_EXT_rasterization_order_attachment_access::new(instance, &mut get_instance_proc_address),
			vk_nv_optical_flow: Vulkan_NV_optical_flow::new(instance, &mut get_instance_proc_address),
			vk_ext_legacy_dithering: Vulkan_EXT_legacy_dithering::new(instance, &mut get_instance_proc_address),
			vk_ext_pipeline_protected_access: Vulkan_EXT_pipeline_protected_access::new(instance, &mut get_instance_proc_address),
			vk_amd_anti_lag: Vulkan_AMD_anti_lag::new(instance, &mut get_instance_proc_address),
			vk_ext_shader_object: Vulkan_EXT_shader_object::new(instance, &mut get_instance_proc_address),
			vk_qcom_tile_properties: Vulkan_QCOM_tile_properties::new(instance, &mut get_instance_proc_address),
			vk_sec_amigo_profiling: Vulkan_SEC_amigo_profiling::new(instance, &mut get_instance_proc_address),
			vk_qcom_multiview_per_view_viewports: Vulkan_QCOM_multiview_per_view_viewports::new(instance, &mut get_instance_proc_address),
			vk_nv_ray_tracing_invocation_reorder: Vulkan_NV_ray_tracing_invocation_reorder::new(instance, &mut get_instance_proc_address),
			vk_nv_cooperative_vector: Vulkan_NV_cooperative_vector::new(instance, &mut get_instance_proc_address),
			vk_nv_extended_sparse_address_space: Vulkan_NV_extended_sparse_address_space::new(instance, &mut get_instance_proc_address),
			vk_ext_mutable_descriptor_type: Vulkan_EXT_mutable_descriptor_type::new(instance, &mut get_instance_proc_address),
			vk_ext_legacy_vertex_attributes: Vulkan_EXT_legacy_vertex_attributes::new(instance, &mut get_instance_proc_address),
			vk_ext_layer_settings: Vulkan_EXT_layer_settings::new(instance, &mut get_instance_proc_address),
			vk_arm_shader_core_builtins: Vulkan_ARM_shader_core_builtins::new(instance, &mut get_instance_proc_address),
			vk_ext_pipeline_library_group_handles: Vulkan_EXT_pipeline_library_group_handles::new(instance, &mut get_instance_proc_address),
			vk_ext_dynamic_rendering_unused_attachments: Vulkan_EXT_dynamic_rendering_unused_attachments::new(instance, &mut get_instance_proc_address),
			vk_nv_low_latency2: Vulkan_NV_low_latency2::new(instance, &mut get_instance_proc_address),
			vk_arm_data_graph: Vulkan_ARM_data_graph::new(instance, &mut get_instance_proc_address),
			vk_qcom_multiview_per_view_render_areas: Vulkan_QCOM_multiview_per_view_render_areas::new(instance, &mut get_instance_proc_address),
			vk_nv_per_stage_descriptor_set: Vulkan_NV_per_stage_descriptor_set::new(instance, &mut get_instance_proc_address),
			vk_qcom_image_processing2: Vulkan_QCOM_image_processing2::new(instance, &mut get_instance_proc_address),
			vk_qcom_filter_cubic_weights: Vulkan_QCOM_filter_cubic_weights::new(instance, &mut get_instance_proc_address),
			vk_qcom_ycbcr_degamma: Vulkan_QCOM_ycbcr_degamma::new(instance, &mut get_instance_proc_address),
			vk_qcom_filter_cubic_clamp: Vulkan_QCOM_filter_cubic_clamp::new(instance, &mut get_instance_proc_address),
			vk_ext_attachment_feedback_loop_dynamic_state: Vulkan_EXT_attachment_feedback_loop_dynamic_state::new(instance, &mut get_instance_proc_address),
			vk_msft_layered_driver: Vulkan_MSFT_layered_driver::new(instance, &mut get_instance_proc_address),
			vk_nv_descriptor_pool_overallocation: Vulkan_NV_descriptor_pool_overallocation::new(instance, &mut get_instance_proc_address),
			vk_qcom_tile_memory_heap: Vulkan_QCOM_tile_memory_heap::new(instance, &mut get_instance_proc_address),
			vk_nv_display_stereo: Vulkan_NV_display_stereo::new(instance, &mut get_instance_proc_address),
			vk_nv_raw_access_chains: Vulkan_NV_raw_access_chains::new(instance, &mut get_instance_proc_address),
			vk_nv_external_compute_queue: Vulkan_NV_external_compute_queue::new(instance, &mut get_instance_proc_address),
			vk_nv_command_buffer_inheritance: Vulkan_NV_command_buffer_inheritance::new(instance, &mut get_instance_proc_address),
			vk_nv_shader_atomic_float16_vector: Vulkan_NV_shader_atomic_float16_vector::new(instance, &mut get_instance_proc_address),
			vk_ext_shader_replicated_composites: Vulkan_EXT_shader_replicated_composites::new(instance, &mut get_instance_proc_address),
			vk_ext_shader_float8: Vulkan_EXT_shader_float8::new(instance, &mut get_instance_proc_address),
			vk_nv_ray_tracing_validation: Vulkan_NV_ray_tracing_validation::new(instance, &mut get_instance_proc_address),
			vk_nv_cluster_acceleration_structure: Vulkan_NV_cluster_acceleration_structure::new(instance, &mut get_instance_proc_address),
			vk_nv_partitioned_acceleration_structure: Vulkan_NV_partitioned_acceleration_structure::new(instance, &mut get_instance_proc_address),
			vk_ext_device_generated_commands: Vulkan_EXT_device_generated_commands::new(instance, &mut get_instance_proc_address),
			vk_mesa_image_alignment_control: Vulkan_MESA_image_alignment_control::new(instance, &mut get_instance_proc_address),
			vk_ext_depth_clamp_control: Vulkan_EXT_depth_clamp_control::new(instance, &mut get_instance_proc_address),
			vk_huawei_hdr_vivid: Vulkan_HUAWEI_hdr_vivid::new(instance, &mut get_instance_proc_address),
			vk_nv_cooperative_matrix2: Vulkan_NV_cooperative_matrix2::new(instance, &mut get_instance_proc_address),
			vk_arm_pipeline_opacity_micromap: Vulkan_ARM_pipeline_opacity_micromap::new(instance, &mut get_instance_proc_address),
			vk_ext_vertex_attribute_robustness: Vulkan_EXT_vertex_attribute_robustness::new(instance, &mut get_instance_proc_address),
			vk_arm_format_pack: Vulkan_ARM_format_pack::new(instance, &mut get_instance_proc_address),
			vk_valve_fragment_density_map_layered: Vulkan_VALVE_fragment_density_map_layered::new(instance, &mut get_instance_proc_address),
			vk_nv_present_metering: Vulkan_NV_present_metering::new(instance, &mut get_instance_proc_address),
			vk_ext_fragment_density_map_offset: Vulkan_EXT_fragment_density_map_offset::new(instance, &mut get_instance_proc_address),
			vk_ext_zero_initialize_device_memory: Vulkan_EXT_zero_initialize_device_memory::new(instance, &mut get_instance_proc_address),
			vk_sec_pipeline_cache_incremental_mode: Vulkan_SEC_pipeline_cache_incremental_mode::new(instance, &mut get_instance_proc_address),
			vk_khr_acceleration_structure: Vulkan_KHR_acceleration_structure::new(instance, &mut get_instance_proc_address),
			vk_khr_ray_tracing_pipeline: Vulkan_KHR_ray_tracing_pipeline::new(instance, &mut get_instance_proc_address),
			vk_khr_ray_query: Vulkan_KHR_ray_query::new(instance, &mut get_instance_proc_address),
			vk_ext_mesh_shader: Vulkan_EXT_mesh_shader::new(instance, &mut get_instance_proc_address),
		}
	}
}

impl Drop for VkCore {
	fn drop(&mut self) {
		self.vkDestroyInstance(self.instance, null()).unwrap();
	}
}

